--- 
title: "An√°lises Ecol√≥gicas no R"
author: "Fernando Rodrigues da Silva, Thiago Gon√ßalves-Souza, Gustavo Brant Paterno, Diogo Borges Provete, Maur√≠cio Humberto Vancine"
description: "Este livro oferece uma introdu√ß√£o compreensiva aos m√©todos estat√≠sticos mais utilizados em Ecologia."
date: "`r Sys.Date()`"
cover-image: img/capa.jpeg
site: bookdown::bookdown_site
url: 'https://analises-ecologicas.netlify.app/'
bibliography: ["all_references.bib"]
biblio-style: "apalike"
link-citations: true
---
```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Bem-vindos {.unnumbered}

[![analises ecologicas](img/capa.jpeg){.cover width="250"}](https://analises-ecologicas.netlify.app/) Essa √© a p√°gina online do livro **An√°lises Ecol√≥gicas no R**. Este livro oferece uma introdu√ß√£o compreensiva aos m√©todos estat√≠sticos mais utilizados em Ecologia. 

A vers√£o online est√° dispon√≠vel **gratuitamente** e o c√≥digo fonte necess√°rio para reproduzir todo o conte√∫do do livro est√° depositado no [Github](https://github.com/paternogbc/livro_aer). 


Este livro foi escrito em [Rmarkdown](https://rmarkdown.rstudio.com/) e compilado utilizando o pacote [bookdown](https://bookdown.org/). 

## Como contribuir? {.unnumbered}

Para contribuir com o livro √© necess√°rio que voc√™ se cadastre no [Github](https://github.com/).
Caso encontre erros no livro ou tenha sugest√µes para melhorar o seu conte√∫do, abra uma [chamado](https://github.com/paternogbc/livro_aer/issues/new) no reposit√≥rio e descreva o problema encontrado ou apresente suas sugest√µes. Caso encontre errors de digita√ß√£o, voc√™ pode corrigir clicando em "Edite esta p√°gina" na barra lateral direita. Depois de corrigir o erro, submeta um "pull request" pelo Github. Sua contribui√ß√£o √© muito bem-vinda. 

## Licen√ßa {.unnumbered}

A vers√£o online deste livro ser√° sempre **gratuita** e distribu√≠da sob a lice√ßa [XXX]().

*** 

A p√°gina online do livro est√° hospedada pela plataforma [Netlify](https://www.netlify.com/).

<a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg"/></a>


\newpage

# Pref√°cio {-}

\newpage

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Sobre os autores {-}

**Fernando Rodrigues da Silva**

```{r echo=FALSE, out.width="40%"}
knitr::include_graphics(path = "img/autores_fernando.jpeg")
```

Piadista descomedido de Barueri/SP, pai da √Åria, companheiro da Winter, respons√°vel pela Filomena (gata), Z√© (gato), Cenoura (cachorra) e Chica (cachorra), admirador de botecos, viagens, mato, cerveja, poker, basquete e prosa com os amigos. Formado em Ci√™ncias Biol√≥gicas na UNESP-Assis e com mestrado e doutorado em Biologia Animal pela UNESP-S√£o Jos√© do Rio Preto. Realizou doutorado sandu√≠che na SUNY ‚Äì College of Environmental Science and Forest. Atualmente √© Professor Associado II no Departamento de Ci√™ncias Ambientais, UFSCAR-Sorocaba e trabalha na linha de pesquisa de ecologia de comunidades, metacomunidades, macroecologia, biogeografia e hist√≥ria natural de anf√≠bios. 

Site: http://fernandoecologia.wix.com/fernandorodrigues

**Thiago Gon√ßalves-Souza**

Capixaba de Cachoeiro do Itapemirim/ES, pai do Lucas, companheiro da Nat√°lia, praticante de Muay Thai, Boxe e da arte de provar cervejas. Formado em Ci√™ncias Biol√≥gicas na Escola Superior S√£o Francisco de Assis/ES e com mestrado e doutorado em Biologia Animal pela UNESP-S√£o Jos√© do Rio Preto. Realizou doutorado sandu√≠che na University of Guelph (Canad√°) e p√≥s-doutorado na UNICAMP. Atualmente √© Professor Adjunto III no Departamento de Biologia da Universidade Federal Rural de Pernambuco, trabalhando nas linhas de pesquisa de ecologia de comunidades, ecologia funcional, macroecologia e metacomunidades.

Site: https://thiagocalvesouza.wixsite.com/ecofun

**Gustavo Brant Paterno**

```{r echo=FALSE, out.width="40%"}
knitr::include_graphics(path = "img/autores_gustavo.png")
```

Compositor de cantigas e violeiro, nascido em Ribeir√£o Preto/SP, pai do Rud√° e da Maria Flor, e apaixonado por Mila. Admira profundamente a incr√≠vel diversidade da vida na Terra. Gosta de trilha, m√∫sica, skate, surf, fotografia de estrelas e programa√ß√£o. √â Ec√≥logo com muito orgulho pela forma√ß√£o na UFRN/Natal, com mestrado e doutorado em Ecologia pela mesma universidade. Realizou sandu√≠che na Macquarie University (Austr√°lia). Possui grande interesse em Ci√™ncia aberta e software livre e √© embaixador do projeto Open Science Framework (OSF). Atualmente √© pesquisador de p√≥s-doutorado na Faculty of Forest Sciences and Forest Ecology da Universidade de Gottingen (Alemanha). Atua na interface entre ecologia evolutiva, biodiversidade-funcionamento de ecossistemas e ecologia da restaura√ß√£o.

Site: https://gustavopaterno.netlify.app/

**Diogo Borges Provete**

```{r echo=FALSE, out.width="40%"}
knitr::include_graphics(path = "img/autores_diogo.png")
```

Capixaba da gema, nascido em Bom Jesus do Norte/ES (na verdade registrado nessa cidade e nascido em Bom Jesus do Itabapoana/RJ do outro lado da ponte, porque no ES n√£o tinha hospital :D ), pai orgulhoso da Manuela e esposo apaixonado da Lilian. Apreciador das boas Ale Belgas e Inglesas e vinhos Chilenos e Brasileiros. J√° fui nadador, jogador de futebol, e um p√©ssimo jogador de Xadrez. Dizem que gosto de livros e HQs. Graduado em Ci√™ncias Biol√≥gicas na Universidade Federal de Alfenas-MG, com mestrado em Biologia Animal na UNESP-S√£o Jos√© do Rio Preto e Doutorado em Ecologia e Evolu√ß√£o na Universidade Federal de Goi√°s. Atualmente √© Professor Adjunto I na Universidade Federal de Mato Grosso do Sul. Meu programa de pesquisa tenta integrar evolu√ß√£o fenot√≠pica e processos micro- e macroevolutivos para entender padr√µes de distribui√ß√£o de esp√©cies em escala de metacomunidades, especialmente em ambientes de √°gua doce.

Site: http://diogoprovete.weebly.com

**Maur√≠cio Humberto Vancine**

Caipira do interior de Socorro/SP, pai do Dudu, companheiro da Japa, amante de softwares livres, GNU/Linux, m√∫sica, livros, games, uma boa cerveja, al√©m de um dedo de cacha√ßa e uma boa prosa. Mais recentemente tenta n√£o levar muitos tombos ao aprender a andar de skate depois dos 30. Graduado em Ecologia e mestre em Zoologia, ambos pela UNESP-Rio Claro. Atualmente √© Doutorando no PPG de Ecologia, Evolu√ß√£o e Biodiversidade da UNESP-Rio Claro e atua na linha de pesquisa de Ecologia Espacial, Ecologia da Paisagem, Modelagem Ecol√≥gica e Ecologia de Anf√≠bios.

Site: https://mauriciovancine.github.io/

<!--chapter:end:00_autores.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Revisores e colaboradores {-}

Expressamos nossos sinceros agradecimentos aos pesquisadores, alunos e colegas indicados abaixo, pelo imprescind√≠vel trabalho de avalia√ß√£o, revis√£o e cr√≠tica do conte√∫do deste livro.

- **Andr√© Padial** - Setor de Ci√™ncias Biol√≥gicas, Universidade Federal do Paran√°, Curitiba, Paran√°

- **Adriano Sanches Melo** - Instituto de Bioci√™ncias, Universidade Federal do Rio Grande do Sul (UFRGS), campus do Vale, Porto Alegre, Rio Grande do Sul

- **Beatriz Milz** - Programa de P√≥s-Gradua√ß√£o em Ci√™ncia Ambiental, Instituto de Energia e Ambiente, Universidade de S√£o Paulo (PROCAM/IEE/USP), S√£o Paulo, S√£o Paulo

- **Felipe Sodr√© Mendes Barros** - Departamento de Geografia, Instituto Superior Antonio Ruiz de Montoya, Instituto Misionero de Biodiversidad - IMiBio, Ambiental Analytics, Misiones, Argentina

- **Ingrid da Silva Lima** -  Programa de Etnobiologia e Conserva√ß√£o da Natureza (PPGEtno), Universidade Federal Rural de Pernambuco (UFRPE), Recife, Pernambuco

- **Maur√≠cio Cetra** - Departamento de Ci√™ncias Ambientais, Universidade Federal de S√£o Carlos (UFSCar), campus Sorocaba, S√£o Paulo

- **Marcos Rafael Severgnini** - Programa de P√≥s Gradua√ß√£o em Ecologia e Conserva√ß√£o, Universidade Federal de Mato Grosso do Sul, Campo Grande, Mato Grosso do Sul

- **Marcos Robalinho Lima** - Departamento de Biologia Animal e Plantas, Universidade Estadual de Londrina, Londrina, Paran√°

- **Michel Varaj√£o Garey** - Instituto Latino Americano de Ci√™ncias da Vida e da Natureza (ILACVN), Universidade Federal da Integra√ß√£o Latino-Americana (UNILA), Foz do Igua√ßu, Paran√°

- **Paulo Mateus Martins Sobrinho** - Programa de Etnobiologia e Conserva√ß√£o da Natureza (PPGEtno), Universidade Federal Rural de Pernambuco (UFRPE), Recife, Pernambuco

- **Paulo S√©rgio Monteiro Ferreira** - Secretaria do Estado da Educa√ß√£o da Para√≠ba, Para√≠ba

- **Pedro Henrique Albuquerque Sena** - Centro de Pesquisas Ambientais do Nordeste (Cepan), Recife, Pernambuco

- **Reginaldo Augusto Farias de Gusm√£o** - Programa de Etnobiologia e Conserva√ß√£o da Natureza (PPGEtno), Universidade Federal Rural de Pernambuco (UFRPE), Recife, Pernambuco

- **Victor Satoru Saito** - Departamento de Ci√™ncias Ambientais, Universidade Federal de S√£o Carlos (UFSCar), campus S√£o Carlos, S√£o Paulo

<!--chapter:end:00_agradecimentos_revisores.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Introdu√ß√£o {#cap1}

## Hist√≥rico deste livro

Este livro foi estruturado a partir da apostila elaborada pelos pesquisadores Diogo B. Provete, Fernando R. da Silva e Thiago Gon√ßalves-Souza para ministrar o curso *Estat√≠stica aplicada √† ecologia usando o R* no PPG em Biologia Animal da UNESP de S√£o Jos√© Rio Preto/SP, em abril de 2011. Os tr√™s pesquisadores eram ent√£o alunos do PPG em Biologia Animal quando elaboraram o material disponibilizado na apostila [Estat√≠stica aplicada √† ecologia usando o R](https://cran.r-project.org/doc/contrib/Provete-Estatistica_aplicada.pdf). A proposta de transformar a apostila em livro sempre foi um t√≥pico recorrente desde 2011, e concretizado agora, um pouco mais de 10 anos depois.

Neste per√≠odo, Diogo, Fernando e Thiago foram contratados pela Universidade Federal de Mato Grosso do Sul, Universidade Federal de S√£o Carlos campus Sorocaba, e Universidade Federal Rural de Pernambuco, respectivamente. Nestes anos eles ofertaram diferentes vers√µes do curso *Estat√≠stica aplicada √† ecologia usando o R* para alunos de gradua√ß√£o e p√≥s-gradua√ß√£o em diferentes institui√ß√µes do Brasil. A possibilidade da oferta destes novos cursos fortaleceu a ideia de trasformar a apostila em um livro com base nas experi√™ncias dos pesquisadores em sala de aula.

Considerando que novas abordagens ecol√≥gicas v√™m sendo descritas e criadas a uma taxa elevada nos √∫ltimos anos, era de se esperar que as informa√ß√µes dispon√≠veis na apostila estivessem defasadas ap√≥s uma d√©cada. Por este motivo, Diogo, Fernando e Thiago convidaram outros dois pesquisadores, Gustavo B. Paterno da Georg-August-University of G√∂ttingen e Maur√≠cio H. Vancine do PPG em Ecologia, Evolu√ß√£o e Biodiversidade da UNESP de Rio Claro/SP, que s√£o refer√™ncias no uso de estat√≠stica em ecologia usando o R. Com o time completo, passaram mais de um ano realizando reuni√µes, compartilhando scripts e pagando cerveja para os coautores por cap√≠tulos atrasados at√© chegarem nesta primeira vers√£o do livro.

## Objetivo deste livro

Nossa proposta com este livro √© tra√ßar o melhor caminho, pelo menos do nosso ponto de vista, entre quest√µes ecol√≥gicas e os m√©todos estat√≠sticos mais robustos para test√°-las. Guiar seus passos nesse caminho (nem sempre linear) necessita que voc√™ utilize um requisito b√°sico: o de se esfor√ßar para caminhar. O nosso esfor√ßo, em contrapartida, ser√° o de indicar as melhores dire√ß√µes para que voc√™ adquira certa independ√™ncia em an√°lises ecol√≥gicas. Um dos nossos objetivos √© mostrar que o conhecimento de teorias ecol√≥gicas e a formula√ß√£o de quest√µes apropriadas s√£o o primeiro passo na caminhada rumo √† compreens√£o da l√≥gica estat√≠stica. N√£o deixe que a estat√≠stica se torne a "pedra no seu caminho". Em nossa opini√£o, programas com ambiente de programa√ß√£o favorecem o entendimento da l√≥gica estat√≠stica, uma vez que cada passo (lembre-se de que voc√™ est√° caminhando em uma estrada desconhecida e cheia de pedras) precisa ser coordenado, ou seja, as linhas de c√≥digo (detalhes abaixo) precisam ser compreendidas para que voc√™ teste suas hip√≥teses. No entanto, tome cuidado ao copiar deliberadamente scripts sem entender cada um dos passos da an√°lise ou gr√°fico realizado.

A primeira parte deste livro pretende utilizar uma estrat√©gia que facilita a escolha do teste estat√≠stico apropriado, por meio da sele√ß√£o de quest√µes/hip√≥teses claras e da liga√ß√£o dessas hip√≥teses com a teoria e o m√©todo (veja Figura \@ref(fig:fig-statistical-thinking) no Cap√≠tulo \@ref(cap2)). Enfatizamos que √© fundamental ter em mente aonde se quer chegar, para poder escolher o que deve ser feito. Posteriormente √† escolha de suas quest√µes, √© necess√°rio transferir o contexto ecol√≥gico para um contexto meramente estat√≠stico (hip√≥tese nula/alternativa). A partir da defini√ß√£o de uma hip√≥tese nula, partiremos para a aplica√ß√£o de cada teste estat√≠stico (de modelos lineares generalizados √† an√°lises multivariadas) utilizando a linguagem R.

Antes de detalhar cada an√°lise estat√≠stica, apresentaremos o funcionamento b√°sico da utiliza√ß√£o da linguagem R e os tipos de distribui√ß√£o estat√≠stica que s√£o essenciais para a compreens√£o dos testes estat√≠sticos. Para isso, organizamos um esquema que chamamos de "estrutura l√≥gica" que facilita a compreens√£o dos passos necess√°rios para testar suas hip√≥teses (veja Figura \@ref(fig:fig-statistical-thinking) no Cap√≠tulo \@ref(cap2)) [@albuquerque_going_2019].

## O que voc√™ n√£o encontrar√° neste livro

Aprofundamento te√≥rico, detalhes matem√°ticos e explica√ß√£o dos algoritmos s√£o informa√ß√µes que infelizmente n√£o ser√£o abordadas neste livro. O foco aqui √© a explica√ß√£o de como cada teste funciona (teoria e procedimentos matem√°ticos b√°sicos) e sua aplica√ß√£o em testes ecol√≥gicos usando scripts na linguagem R. 
## Livros que recomendamos para aprofundamento te√≥rico

Recomendamos aos leitores (as) que consultem os livros a seguir caso desejem maior aprofundamente te√≥rico e pr√°tico:

 - *Hands-On Programming with R* (2014) Garrett Grolemund
 
Esse livro √© para quem quer se aprofundar e aprender a programar em R, com exemplos pr√°ticos. Nas palavras do autor, ele disse que escreveu o livro para n√£o programadores, com o intuito de fornecer uma introdu√ß√£o amig√°vel √† linguagem R. Nele, √© apresentado como carregar dados, montar e desmontar objetos de dados, navegar no sistema de ambiente do R, escrever fun√ß√µes e usar as ferramentas de programa√ß√£o do R para a solu√ß√£o de problemas pr√°ticos de ci√™ncia de dados. O livro est√° dispon√≠vel nesse [link](https://rstudio-education.github.io/hopr/index.html).
 
 - *R for Data Science: Import, Tidy, Transform, Visualize, and Model Data* (2017) Hadley Wickham & Garrett Grolemund
 
Tamb√©m conhecido como R4DS, esse livro √© uma das primeiras refer√™ncias sobre tidyverse e de Ci√™ncia de Dados no R. O livro aborda as principais etapas de importa√ß√£o, convers√£o, explora√ß√£o e modelagem de dados e comunica√ß√£o dos resultados. Ele apresenta uma compreens√£o do ciclo da ci√™ncia de dados, juntamente com as ferramentas b√°sicas necess√°rias para gerenciar os detalhes sobre cada etapa do ciclo. Cada se√ß√£o do livro √© combinada com exerc√≠cios para ajudar na fixa√ß√£o do conte√∫do. Os principais t√≥picos s√£o: i) transformar conjuntos de dados em um formato conveniente para an√°lise, ii) programa√ß√£o com ferramentas poderosas do R para resolver problemas de dados com maior clareza e facilidade, iii) examinar os dados, gerar hip√≥teses e test√°-las rapidamente, iv) gerar modelos que forne√ßam um resumo dos dados e que capture "sinais" no conjunto de dados, e v) aprendar R Markdown para integrar texto, c√≥digo e resultados. O livro est√° dispon√≠vel nesse [link](https://r4ds.had.co.nz/).
 
 - *Geocomputation with R* (2020) Robin Lovelace, Jakub Nowosad & Jannes Muenchow
 
Lan√ßado em 2020, esse livro tornou-se rapidamente a principal refer√™ncia sobre manipula√ß√£o, visualiza√ß√£o, an√°lise e modelagem de dados geoespaciais no R. O livro √© dividido em tr√™s partes: i) fundamentos, ii) extens√µes e iii) aplica√ß√µes. A parte um √© voltada para a fundamenta√ß√£o dos dados geogr√°ficos no R, descrevendo a natureza dos conjuntos de dados espaciais e m√©todos para manipul√°-los, assim como a importa√ß√£o/exporta√ß√£o de dados geogr√°ficos e a transforma√ß√£o de sistemas de refer√™ncia de coordenadas. A Parte II representa m√©todos que se baseiam nessas funda√ß√µes, abrange a cria√ß√£o de mapas avan√ßados (incluindo mapeamento da web), "pontes" para GIS, compartilhamento de c√≥digo reproduz√≠vel e como fazer valida√ß√£o cruzada na presen√ßa de autocorrela√ß√£o espacial. A Parte III aplica o conhecimento adquirido para resolver problemas do mundo real, incluindo representa√ß√£o e modelagem de sistemas de transporte, localiza√ß√£o ideal para lojas ou servi√ßos e modelagem ecol√≥gica. Os exerc√≠cios no final de cada cap√≠tulo fornecem as habilidades necess√°rias para lidar com uma s√©rie de problemas geoespaciais. As solu√ß√µes para cada cap√≠tulo e materiais complementares est√£o dispon√≠veis nesse [link](https://geocompr.github.io/geocompkg/articles/) e o livro nesse [link](https://geocompr.robinlovelace.net/).

- *A primer of ecological statistics, 2nd edition* (2012) Nicholas J. Gotelli & Aaron M. Ellison

O cap. 7 deste livro tr√°s um apanhado geral sobre desenhos amostrais voltados para experimenta√ß√£o e os dois √∫ltimos cap√≠tulos s√£o uma introdu√ß√£o √† estat√≠stica multivariada. Existe uma tradu√ß√£o para o portugu√™s da primeira edi√ß√£o, chamada "Princ√≠pios de Estat√≠stica em Ecologia" que saiu pela ed ArtMed em 2010. Este √© um excelente refer√™ncia para quem quer come√ßar a estudar estat√≠stica b√°sica, especialmente com aplica√ß√µes em ecologia.

- *Experimental Design and Data Analysis for Biologists* (2002) Gerry P. Quinn & Michael J. Keough

Outro execelente livro introdut√≥rio sobre estat√≠stica com exemplos pr√°ticos para ecologia e um dos preferidos dos autores deste livro aqui. Ele aborda os modelos lineares mais comuns vistos em disciplinas de bioestat√≠stica, tais como regress√£o e ANOVA, mas tamb√©m traz uma boa introdu√ß√£o sobre GLMs e m√©todos mais modernos de an√°lise de dados. Mas o mais importante, a l√≥gica de ensino dos m√©todos segue muito o que preconizamos neste livro e n√£o podemos recomend√°-lo o bastante para quem est√° come√ßando a estudar estat√≠stica.

- *The R book, 2nd edition * (2012) Michael J. Crawley

Livro que vai do b√°sico ao avan√ßado, tem informa√ß√µes sobre linguagem R, estat√≠stica univariada, multivariada e modelagem. Relativamente f√°cil de compreender. Cap√≠tulos trazem fun√ß√µes para cria√ß√£o e manipula√ß√£o de gr√°ficos passoa-passo.

- *Numerical ecology, 3rd English edition* (2012) Pierre Legendre & Louis Legendre

Este √© o manual te√≥rico essencial e leitura obrigat√≥ria para entender mais a fundo qualquer an√°lise multivariada. Esta nova edi√ß√£o traz um cap√≠tulo novo sobre an√°lises multiescalares em ecologia de comunidade, com exemplos de aplica√ß√£o de Moran Eigenvector Maps (MEMs).

- *Biological Diversity: Frontiers in Measurement and Assessment (2012)* Anne E. Magurran & Brian J. McGill

Livro editado com v√°rios cap√≠tulos sobre medidas tradicionais e alternativas de biodiversidade. Tamb√©m atualiza medidas de estimativa de diversidade, uma revis√£o sobre diversidade funcional e filogen√©tica. Esse √© uma boa porta de entrada para entender os aspectos te√≥ricos e meandros da an√°lise de dados de biodiversidade.

- *Mixed effects models and extensions in ecology with R* (2009) Alain F. Zuur, Elena N. Ieno, Neil Walker, Anatoly A. Saveliev, Graham M.  Smith

Este continua sendo a melhor introdu√ß√£o para modelos lineares generalizados (e de efeito misto), modelos de m√≠nimos quadrados generalizados, Modelos Aditivos Generalizados para bi√≥logos e ec√≥logos. O livro cont√©m v√°rios cap√≠tulos em que o funcionamento dos modelos √© explicada de maneira bastante atraente, mantendo a matem√°tica no m√≠nimo. Todos os exemplos s√£o com dados reais produzidor por ec√≥logos. Este √© um bom livro intermedi√°rio para quem quer se aprofundar nas an√°lises mais modernas feitas em ecologia. Sugerimos a leitura depois de Quinn & Keough e Gotelli & Ellison. 

Recomendamos ainda para o amadurecimento em an√°lises ecol√≥gicas as seguintes leituras: @manly_randomization_1991, @pinheiro_mixed-effects_2000, @scheiner_design_2001, @burnham_pvalues_2014,  @venables_modern_2002, @zar_biostatistical_2010, @zuur_analysing_2007, @zuur_protocol_2009, @crawley_r_2012, @james_introduction_2013, @fox_ecological_2015, @thioulouse_multivariate_2018 e @touchon_applied_2021.


## Por que usar o R?

Os criadores do R o chamam de uma linguagem e ambiente de programa√ß√£o estat√≠stica e gr√°fica [@venables_modern_2002]. A linguagem R tamb√©m √© chamada de programa√ß√£o "orientada ao objeto" (*object oriented programming*), o que significa que utilizar o R envolve basicamente a cria√ß√£o e manipula√ß√£o de objetos em um terminal, em que o usu√°rio tem de dizer exatamente o que deseja que o programa execute, ao inv√©s de simplesmente clicar em bot√µes. E vem da√≠ uma das grandes vantagens em se usar o R: o usu√°rio tem total controle sobre o que est√° acontecendo e tamb√©m tem de compreender o que deseja antes de executar uma an√°lise. Al√©m disso, o R permite integra√ß√£o com outros programas escritos em Fortran, C++, Python e Java, permitindo que os usu√°rios possam aplicar novas metodologias sem ter que aprender novas linguagens.

Na p√°gina pessoal do Prof. Nicolas J. Gotelli ([link](http://www.uvm.edu/~ngotelli/GradAdvice.html)) existem v√°rios conselhos para um estudante iniciante de ecologia. Dentre esses conselhos, o Prof. Gotelli menciona que o dom√≠nio de uma linguagem de programa√ß√£o √© uma das habilidades mais importantes, porque d√° liberdade ao ec√≥logo para executar tarefas que v√£o al√©m daquelas dispon√≠veis em pacotes estat√≠sticos comerciais. Al√©m disso, a maioria das novas an√°lises propostas nos mais reconhecidos peri√≥dicos em ecologia normalmente s√£o implementadas na linguagem R, e os autores geralmente incluem o c√≥digo fonte no material suplementar dos artigos, tornando a an√°lise acess√≠vel e reprodut√≠vel. A partir do momento que essas an√°lises ficam dispon√≠veis (seja por c√≥digo fornecido pelo autor ou por implementa√ß√£o em pacotes pr√©-existentes), √© mais simples entendermos a l√≥gica de an√°lises complexas, especialmente as multivariadas, utilizando nossos pr√≥prios dados, realizando-as passo a passo. Sem a utiliza√ß√£o do R, normalmente temos que contatar os autores que nem sempre s√£o t√£o acess√≠veis.

Especificamente em Ecologia, o uso da linguagem R para an√°lise de dados cresceu enormemente nas duas √∫ltimas d√©cadas. Em um artigo de revis√£o, Lai et al. [-@lai_evaluating_2019] analisaram mais de 60.000 artigos revisados por pares publicados em 30 peri√≥dicos de Ecologia durante um per√≠odo de 10 anos. O n√∫mero de estudos usando R aumentou linearmente de 11,4% em 2008 para 58,0% em 2017, e os 10 principais pacotes utilizados e ordenados por maior frequ√™ncia de uso foram: `lme4`, `vegan`, `nlme`, `ape`, `MuMIn`, `MASS`, `mgcv`, `ade4`, `multcomp` e `car`. Os autores afirmam que a crescente popularidade do R promoveu a ci√™ncia aberta na pesquisa ecol√≥gica,  melhorando a reprodutibilidade das an√°lises e o fluxo de trabalho, principalmente quando scripts e c√≥digos foram inclu√≠dos e compartilhados nos artigos. Eles finalizam dizendo que a partir dos resultados encontrados, a linguagem R √© um componente significativo das an√°lises no campo da Ecologia.

Uma √∫ltima vantagem √© que por ser um software livre, a cita√ß√£o do R em artigos √© permitida e at√© aconselh√°vel. Para saber como citar o R, digite `citation()` na linha de comando. Para citar um pacote espec√≠fico, digite `citation()` com o nome do pacote entre aspas dentro dos par√™nteses. Mais detalhes sobre cita√ß√µes podem ser vistos no Cap√≠tulo \@ref(cap4). Neste ponto, esperamos ter convencido voc√™ leitor(a), de que aprender a utilizar o R tem in√∫meras vantagens. Entretanto, provavelmente vai ser dif√≠cil no come√ßo, mas continue e perceber√° que o investimento vai valer √† pena no futuro.

## Indo al√©m da linguagem de progra√ß√£o para a Ecologia

Um ponto em comum em que todos os autores deste livro concordaram em conversas durante sua estrutura√ß√£o, foi a dificuldade que todos tivemos quando est√°vamos aprendendo a linguagem:

1.  Como transcrever os objetivos (manipula√ß√£o de dados, an√°lises e gr√°ficos) em linguagem R
2.  Como interpretar os resultados das an√°lises estat√≠sticas do R para os objetivos ecol√≥gicos

Num primeiro momento, quando estamos aprendendo a linguagem R √© muito desafiador pensar em como estruturar nossos c√≥digos para que eles fa√ßam o que precisamos: importar dados, selecionar linhas ou colunas, qual pacote ou fun√ß√£o usar para uma certa an√°lise ou como fazer um gr√°fico que nas nossas anota√ß√µes s√£o simples, mas no c√≥digo parece imposs√≠vel. Bem, n√£o h√° um caminho f√°cil nesse sentido e ele depende muito da experi√™ncia e familiaridade adquirida com o tempo de uso da linguagem, assim como outra l√≠ngua qualquer, como ingl√™s ou espanhol. Entretanto, uma dica pode ajudar: estruture seus c√≥digos antes de partir para o R. Por exemplo, escreva um papel os pontos que deseja executar em seus c√≥digos, como se estivesse explicando para algu√©m os passos que precisa para realizar as tarefas. Depois disso, transcreva para o script (arquivo onde os c√≥digos s√£o escritos, mas n√£o se preocupe, iremos explicar esse conceito no Cap√≠tulo \@ref(cap4)) esses pontos em formato de texto. Por fim, traduza isso em linguagem R. Pode parecer massante e cansativo no come√ßo, mas isso o ajudar√° a ter maior dom√≠nio da linguagem, sendo que esse passo se tornar√° desnecess√°rio quando se adquire bastante experi√™ncia.

Uma vez que esta barreira inicial foi transposta e voc√™ conseguiu obter os primeiros resultados de suas an√°lises com valores de estat√≠sticas, par√¢metros estimados, valores de p e R¬≤, gr√°ficos, e etc., como interpretamos √† luz da teoria ecol√≥gica? Esse ponto √© talvez um dos mais complicados. Com o tempo, ter um valor final de uma estat√≠stica ou gr√°fico √† partir da linaguagem R √© relativamente simples, mas o que esse valor ou gr√°fico significam para nossa hip√≥tese ecol√≥gica √© o ponto mais complexo. Essa dificuldade por ser por inexperi√™ncia te√≥rica (ainda n√£o lemos muito sobre um aspecto ecol√≥gico) ou inexperi√™ncia cient√≠fica (ainda temos dificuldade para expandir nossos argumentos de forma indutiva). Destacamos esse ponto porque ele √© fundamental no processo cient√≠fico e talvez seja o principal aspecto que diferencia os cientistas de outros profissionais: sua capacidade de entendimento dos padr√µes √† partir dos processos e mecanismos atrelados. Nesse ponto, quase sempre recorremos aos nossos orientadores ou colegas mais experientes para nos ajudar, mas √© natural e faz parte do processo de aprendizado de uso da linguagem R junto √† Ecologia como Ci√™ncia. Entretanto, contrapomos a import√¢ncia dessa extrapola√ß√£o para n√£o nos tornarmos apenas especialistas em linguagem R sem a fundamental capacidade de entendimento do sistema ecol√≥gico que estamos estudando.

## Como usar este livro

Os conte√∫dos apresentados em cada cap√≠tulo s√£o independentes entre si. Portanto, voc√™ pode utilizar este livro de duas formas. A primeira √© seguir uma ordem sequencial (cap√≠tulos 1, 2, 3, ...) que recomendamos, principalmente, para as pessoas que n√£o possuem familiaridade com a linguagem R. A segunda forma, √© selecionar o cap√≠tulo que cont√©m a an√°lise de seu interesse e mudar de um cap√≠tulo para outro sem seguir a sequ√™ncia apresentada no livro.

Com exce√ß√£o dos cap√≠tulos 2, 3, 4, 5, 6 e 15, os outros cap√≠tulos foram elaborados seguindo a mesma estrutura, contendo uma descri√ß√£o da an√°lise estat√≠stica (aspectos te√≥ricos) e exemplos relacionados com quest√µes ec√≥logicas que podem ser respondidas por esta an√°lise e exerc√≠cios. Todos os exemplos s√£o compostos por: i) uma descri√ß√£o dos dados utilizados, ii) pergunta e predi√ß√£o do trabalho, iii) descri√ß√£o das vari√°veis resposta(s) e preditora(s), e iv) descri√ß√£o e explica√ß√£o das linhas de c√≥digo do R necess√°rias para realiza√ß√£o das an√°lises. A maioria dos exemplos utilizados s√£o baseados em dados reais que j√° foram publicados em artigos cient√≠ficos ou s√£o dados coletados por um dos autores deste livro. N√≥s recomendamos que primeiro voc√™ utilize estes exemplos para se familiarizar com as an√°lises e a formata√ß√£o das linhas e colunas das planilhas. Em seguida, fa√ßa os exerc√≠cios propostos no final de cada cap√≠tulo, e por fim, utilize seus pr√≥prios dados para realizar as an√°lises. Esta √© a melhor maneira de se familiarizar com as linhas de c√≥digo do R.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Muitas das m√©tricas ou √≠ndices apresentados neste livro n√£o foram traduzidas para o portugu√™s, porque seus acr√¥nimos s√£o cl√°ssicos e bem estabelecidos na literatura ecol√≥gica. Nestes casos, consideramos que a tradu√ß√£o poderia confundir as pessoas que est√£o come√ßando a se familiarizar com a literatura espec√≠fica. Al√©m disso, optamos por manter a vers√£o padr√£o em alguns gr√°ficos utilizados nos cap√≠tulos 7 e 15, principalmente aqueles gr√°ficos que s√£o "output" de an√°lises como, por exemplo, visualiza√ß√£o de normalidade de res√≠duos, homogeneidade de vari√¢ncias, entre outros. Em geral, essese gr√°ficos s√£o usados no processo de decis√£o de algum passo da an√°lise e n√£o possuem qualidade de publica√ß√£o. Como o usu√°rio vai obter o mesmo gr√°fico quando replicar as an√°lises propostas aqui ou suas pr√≥prias an√°lises, julgamos ser mais did√°tico manter a vers√£o original, em ingl√™s.
:::

Real√ßamos que n√£o estamos abordando todas as possibilidades dispon√≠veis, e existem muito outros pacotes e fun√ß√µes no R que realizam as mesmas an√°lises. Contudo, esperamos que o conte√∫do apresentado permita que os leitores(as) adquiram independ√™ncia e seguran√ßa para que possam caminhar sozinhos(as) na explora√ß√£o de novos pacotes e fun√ß√µes para responderem suas perguntas biol√≥gicas e ecol√≥gicas.

## Como ensinar e aprender com esse livro

Uma forma bastante interessante de aprender ou aprofundar seu conhecimento sobre um tema √© a partir de grupos de estudo. Aproveitando as din√¢micas de estudos que os pr√≥prios autores fizeram em seus laborat√≥rios (seja como discente ou professor), sugerimos abaixo alguns formatos que podem ser usados por um grupo de discentes (sem a presen√ßa de um orientador) ou pelo laborat√≥rio. √â importante ressaltar que esses formatos n√£o s√£o os √∫nicos que podem ser testados. O leitor pode juntar ideias de diferentes propostas ou mesmo usar parte das propostas e inserir suas pr√≥prias ideias, tendo como base as caracter√≠sticas do grupo que ir√° se reunir. 

### Em laborat√≥rios ou grupos de pesquisa

**L√≠der aleat√≥rio**

Cada cap√≠tulo √© sorteado para um integrante do grupo que ficar√° respons√°vel por estudar, apresentar e enviar outros materiais que julgar necess√°rio. Neste formato, existem duas possibilidades interessantes. A primeira √© de um grupo de estudantes que √© iniciante em determinado tema (e.g., an√°lise multivariada) e, desse modo, todos integrantes ser√£o estimulados a participarem do processo de ensino e de aprendizagem. O segundo ponto interessante √© para grupos heterog√™neos onde pessoas diferentes possuem dom√≠nio de diferentes ferramentas. Neste caso, √© importante que mesmo que determinado integrante seja especialista na an√°lise X, ele poder√° aleatoriamente ter que aprender e ensinar a an√°lise Y. Como resultado, espera-se que os grupos de estudo neste formato tenham ampla discuss√£o, uma vez que integrantes com baixo, m√©dio ou alto conhecimento em determinada an√°lise ser√£o tanto professores como aprendizes.  

**L√≠der especialista I (discentes como l√≠deres)**

Cada cap√≠tulo √© liderado pelo ‚Äúmaior especialista‚Äù naquele determinado assunto, que ficar√° respons√°vel por organizar toda din√¢mica do grupo. O ideal √© que especialistas distintos liderem a discuss√£o de diferentes cap√≠tulos, para que todos os membros do grupo sejam l√≠deres em no m√≠nimo um cap√≠tulo. 

**L√≠der especialista II (orientador ou p√≥s-doc)**

O orientador (ou p√≥s-doc ou ambos) selecionam os cap√≠tulos sobre o assunto de interesse (ou todos os cap√≠tulos do livro) e se re√∫ne regularmente para discuss√£o com discentes. Al√©m da leitura dos cap√≠tulos, o l√≠der pode enviar atividades extras ou desafios para estimular que os discentes leiam o conte√∫do e tamb√©m executem comandos no R. Por exemplo, em cada cap√≠tulo, o desafio pode ser criar hip√≥teses sobre um tema de estudo, gerar dados fict√≠cios (ou usar dados reais dispon√≠veis) e analisar os dados com determinado teste estat√≠stico no R. 
L√≠der especialista I ou II integrando com teoria (espec√≠fico para cap√≠tulos 8 a 15):
Esta proposta expande o L√≠der especialista I uma vez que n√£o estar√° focada somente na an√°lise estat√≠stica apresentada no livro. Al√©m de inserir este componente anal√≠tico, o l√≠der ir√° apresentar o arcabou√ßo te√≥rico ecol√≥gico que √© geralmente usado em estudos que utilizaram determinada an√°lise. Por exemplo, o cap√≠tulo que apresenta regress√£o linear seria combinado com a teoria de biogeografia de ilhas para entender a rela√ß√£o esp√©cies-√°rea. Desse modo, n√£o seria apresentado somente as especificidades da regress√£o linear, mas tamb√©m a teoria de biogeografia de ilhas.

### Em disciplinas da gradua√ß√£o ou p√≥s-gradua√ß√£o

**Atividade em grupo em sala invertida**

O professor pode sortear diferentes grupos que ficar√£o respons√°veis por cada cap√≠tulo do livro (a depender do conte√∫do da disciplina). Cada componente do grupo pode ficar respons√°vel por diferentes partes do cap√≠tulo. Por exemplo, se a disciplina for de gr√°ficos, um discente pode discutir a estrutura das fun√ß√µes do pacote ggplot2, outro discente pode apresentar a conex√£o entre tipos de vari√°veis e gr√°ficos, enquanto um terceiro discente se responsabiliza por executar os comandos dos gr√°ficos no R. As atividades devem ser realizadas e apresentadas antes da aula te√≥rica/pr√°tica sobre aquela tem√°tica, e o docente ficar√° respons√°vel por mediar as apresenta√ß√µes e discuss√µes.   

**Sala convencional**

O professor pode usar o livro como material did√°tico seguindo o conte√∫do de acordo com a disciplina em quest√£o, seja ela da linguagem R, de an√°lises univariadas, multivariadas ou espaciais. Al√©m disso, o professor pode fornecer dados para os discentes (ou estimular que discentes usem os pr√≥prios dados) e replicar gr√°ficos e an√°lises usando os scripts fornecidos no livro.

<!--chapter:end:01_introducao.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Voltando ao b√°sico: como dominar a arte de fazer perguntas cientificamente relevantes {#cap2}

*Cap√≠tulo originalmente publicado por Gon√ßalves-Souza, Provete, Garey, da Silva & Albuquerque [-@albuquerque_going_2019], in Methods and Techniques in Ethnobiology and Ethnoecology (publica√ß√£o autorizada por Springer, licen√ßa 5230220198680).*

## Introdu√ß√£o

> *Aquele que ama a pr√°tica sem teoria √© como um marinheiro que embarca em um barco sem um leme e uma b√∫ssola e nunca sabe onde pode atracar - Leonardo da Vinci.*

Qual √© a sua pergunta? Talvez esta seja a frase que pesquisadores mais jovens ouvem quando come√ßam suas atividades cient√≠ficas. Apesar de aparentemente simples, responder a esta pergunta se torna um dos maiores desafios da forma√ß√£o cient√≠fica. Seja na pesquisa quantitativa ou qualitativa, todo processo de busca de conhecimento parte de uma quest√£o/problema formulada pelo pesquisador no in√≠cio desse processo. Esta quest√£o guiar√° o pesquisador em todas as etapas da pesquisa. No caso espec√≠fico de pesquisa quantitativa, a quest√£o √© a porta de entrada de uma das formas mais poderosas de pensar cientificamente: o m√©todo hipot√©tico-dedutivo (MHD) definido por Karl Popper [-@popper_logic_1959]. Este cap√≠tulo prop√µe uma maneira de pensar sobre hip√≥teses (geradas dentro do MHD) para melhorar o pensamento estat√≠stico usando um fluxograma que relaciona vari√°veis por liga√ß√µes causais. Al√©m disso, argumentamos que voc√™ pode facilmente usar fluxogramas para: i) identificar vari√°veis relevantes e como elas afetam umas √†s outras; ii) melhorar (quando necess√°rio) o desenho experimental/observacional; iii) facilitar a escolha de an√°lises estat√≠sticas; e iv) melhorar a interpreta√ß√£o e comunica√ß√£o dos dados e an√°lises.

## Perguntas devem preceder as an√°lises estat√≠sticas

### Um besti√°rio[^perguntas_ecologia-1] para o teste de hip√≥teses (Voc√™ est√° fazendo a pergunta certa?)

[^perguntas_ecologia-1]: O besti√°rio √© uma literatura do S√©culo XII que descrevia animais (reais ou imagin√°rios) com uma vis√£o divertida e fantasiosa. Parte da interpreta√ß√£o continha li√ß√µes de moral dos monges cat√≥licos que escreviam e ilustravam os besti√°rios. Longe de ser uma li√ß√£o de moral ou mesmo uma descri√ß√£o fantasiosa, usamos o termo besti√°rio neste livro para expressar o que h√° de mais importante e fant√°stico (na vis√£o dos autores) para fazer um bom teste de hip√≥teses.

A maioria dos alunos e professores de ci√™ncias biol√≥gicas possuem avers√£o √† palavra "estat√≠stica". N√£o surpreendentemente, enquanto a maioria das disciplinas acad√™micas que comp√µem o "STEM" (termo em ingl√™s para aglomerar *Ci√™ncia, Tecnologia, Engenharia e Matem√°tica*) t√™m uma s√≥lida forma√ß√£o estat√≠stica durante a gradua√ß√£o, cursos de ci√™ncias biol√≥gicas t√™m um curr√≠culo fraco ao integrar o pensamento estat√≠stico dentro de um contexto biol√≥gico [@metz_teaching_2008]. Esses cursos t√™m sido frequentemente ministrados sem qualquer abordagem pr√°tica para integrar os alunos em uma plataforma de solu√ß√£o de problemas [@horgan_teaching_1999]. Infelizmente, a Etnobiologia, Ecologia e Conserva√ß√£o (daqui em diante EEC) n√£o s√£o exce√ß√µes. Talvez mais importante, uma grande preocupa√ß√£o durante o treinamento estat√≠stico de estudantes de EEC √© a necessidade de trabalhar com problemas complexos e multidimensionais que exigem solu√ß√µes anal√≠ticas ainda mais complicadas para um p√∫blico sem experi√™ncia em estat√≠stica e matem√°tica. Por este motivo, muitos pesquisadores consideram a estat√≠stica como a parte mais problem√°tica de sua pesquisa cient√≠fica. Argumentamos neste cap√≠tulo que a dificuldade de usar estat√≠stica em EEC est√° associada √† aus√™ncia de uma plataforma de solu√ß√£o de problemas gerando hip√≥teses claras que s√£o derivadas de uma teoria. No entanto, concordamos que h√° um grande desafio em algumas disciplinas como a Etnobiologia para integrar esta abordagem direcionada por hip√≥teses, uma vez que foi introduzida apenas recentemente [veja @phillips_useful_1993; @albuquerque_five_2009]. Devido √† falta de uma plataforma de solu√ß√£o de problemas, frequentemente percebemos que alunos/pesquisadores na EEC geralmente t√™m dificuldades de responder perguntas b√°sicas para uma pesquisa cient√≠fica, tais como:

1.  Qual √© a principal teoria ou racioc√≠nio l√≥gico do seu estudo?
2.  Qual √© a quest√£o principal do seu estudo?
3.  Qual √© a sua hip√≥tese? Quais s√£o suas predi√ß√µes?
4.  Qual √© a unidade amostral, vari√°vel independente e dependente do seu trabalho? Existe alguma covari√°vel?
5.  Qual √© o grupo controle?

Como selecionar qualquer teste estat√≠stico sem responder a essas cinco perguntas? A estrutura estat√≠stica frequentista fornece uma maneira de ir progressivamente suportando ou falseando uma hip√≥tese [@neyman__problem_1933; @popper_logic_1959]. A decis√£o de rejeitar uma hip√≥tese nula √© feita usando um valor de probabilidade (geralmente P \< 0,05) calculado pela compara√ß√£o de eventos observados com observa√ß√µes repetidas obtidas a partir de uma distribui√ß√£o nula.

Agora, vamos ensinar atrav√©s de um exemplo e apresentar um "guia para o pensamento estat√≠stico" que conecta alguns elementos essenciais para executar qualquer an√°lise multivariada (ou univariada) (Fig. \@ref(fig:fig-statistical-thinking). Primeiro, imagine que voc√™ observou os seguintes fen√¥menos na natureza: i) "indiv√≠duos de uma popula√ß√£o tradicional selecionar algumas plantas para fins m√©dicos" e ii) "manchas monodominantes da √°rvore *Prosopis juliflora*, uma esp√©cie invasora em v√°rias regi√µes". Do lado da etnobiologia, para entender como e porque o conhecimento tradicional √© constru√≠do, existe uma teoria ou hip√≥tese (por exemplo, hip√≥tese de apar√™ncia: @goncalves_most_2016) explicando os principais processos que ditam a sele√ß√£o da planta (Fig. \@ref(fig:fig-statistical-thinking)a). Ent√£o, voc√™ pode fazer uma ou mais perguntas relacionadas √†quele fen√¥meno observado (Fig. \@ref(fig:fig-statistical-thinking)b). Por exemplo, como a urbaniza√ß√£o afeta o conhecimento das pessoas sobre o uso de plantas medicinais em diferentes biomas? Do lado ecol√≥gico/conserva√ß√£o, para entender por que esp√©cies introduzidas afetam as esp√©cies nativas locais, voc√™ precisa entender as teorias do nicho ecol√≥gico e evolutiva [@macdougall_plant_2009; @saul_eco-evolutionary_2015]. Voc√™ pode perguntar, por exemplo, como as plantas ex√≥ticas afetam a estrutura de comunidades de plantas nativas? Quest√µes complexas ou vagas dificultam a constru√ß√£o do fluxograma de pesquisa (ver descri√ß√£o abaixo) e a sele√ß√£o de testes estat√≠sticos. Em vez disso, uma pergunta √∫til deve indicar as vari√°veis relevantes do seu estudo, como as independentes e dependentes, covari√°veis, unidade amostral e a escala espacial de interesse (Fig. \@ref(fig:fig-statistical-thinking)b). No exemplo etnobiol√≥gico fornecido, a urbaniza√ß√£o e o conhecimento das pessoas s√£o as vari√°veis independentes e dependentes, respectivamente. Al√©m disso, este estudo tem uma escala ampla, pois compara biomas diferentes. A pr√≥xima etapa √© construir a hip√≥tese biol√≥gica (Fig. \@ref(fig:fig-statistical-thinking)c), que indicar√° a associa√ß√£o entre vari√°veis independentes e dependentes. No exemplo etnobiol√≥gico, a hip√≥tese √© que i) "a urbaniza√ß√£o afeta o conhecimento das pessoas sobre o uso de plantas medicinais", enquanto a hip√≥tese ecol√≥gica √© que ii) "esp√©cies ex√≥ticas afetam a estrutura de comunidades de plantas nativas". Observe que isso √© muito semelhante √† quest√£o principal. Mas voc√™ pode ter m√∫ltiplas hip√≥teses [@platt_strong_1964] derivado de uma teoria. Depois de selecionar a hip√≥tese biol√≥gica (ou cient√≠fica), √© hora de pensar sobre a deriva√ß√£o l√≥gica da hip√≥tese, que √© chamada de predi√ß√£o ou previs√£o (Fig. \@ref(fig:fig-statistical-thinking)d). Os padr√µes preditos s√£o uma etapa muito importante, pois ap√≥s defini-los voc√™ pode operacionalizar suas vari√°veis e visualizar seus dados. Por exemplo, a vari√°vel te√≥rica "Urbaniza√ß√£o" pode ser medida como "grau de urbaniza√ß√£o ao longo das √°reas urbanas, periurbanas e rurais" e "conhecimento das pessoas" como "o n√∫mero e tipo de esp√©cies de plantas √∫teis usadas para diferentes doen√ßas". Assim, a predi√ß√£o √© que o grau de urbaniza√ß√£o diminua o n√∫mero e tipo de esp√©cies de plantas conhecidas utilizadas para fins medicinais. No exemplo ecol√≥gico, a vari√°vel "esp√©cies ex√≥ticas" pode ser medida como "a densidade da planta ex√≥tica *Prosopis juliflora*" e "Estrutura da comunidade" como "riqueza e composi√ß√£o de esp√©cies nativas". Depois de operacionalizar o seu trabalho √† luz do m√©todo hipot√©tico-dedutivo (HDM), o pr√≥ximo passo √© "pensar estatisticamente" sobre a hip√≥tese biol√≥gica formulada (ver Figura \@ref(fig:fig-statistical-thinking)e, f).

```{r fig-statistical-thinking, fig.align='center', fig.cap="Um guia para o pensamento estat√≠stico combinando o m√©todo hipot√©tico-dedutivo (a -- d, i) e estat√≠stica frequentista (e -- i). Veja tamb√©m a Fig. 1 em Underwood 1997, Fig. 1 em [@ford_scientific_2004] e Fig. 1.3 em [@legendre_numerical_2012].", out.width="70%", echo=FALSE}
knitr::include_graphics("img/cap02_fig01.png")
```

Ent√£o, voc√™ precisa definir as hip√≥tese estat√≠stica nula (H<sub>0</sub>) e a alternativa (H<sub>1</sub>). Duas "hip√≥teses estat√≠sticas" diferentes podem ser derivadas de uma hip√≥tese biol√≥gica (Fig. \@ref(fig:fig-statistical-thinking)e). Portanto, n√≥s usamos o termo "hip√≥tese estat√≠stica" entre aspas, porque as chamadas hip√≥teses estat√≠sticas s√£o predi√ß√µes *sensu stricto*, e muitas vezes confundem jovens estudantes. A hip√≥tese estat√≠stica nula representa uma aus√™ncia de relac√£o entre as vari√°veis independentes e dependentes. Depois de definir a hip√≥tese estat√≠stica nula, voc√™ pode derivar uma ou v√°rias hip√≥teses estat√≠sticas alternativas, que demonstram a(s) associa√ß√£o(√µes) esperada(s) entre suas vari√°veis (Fig. \@ref(fig:fig-statistical-thinking)e). Em nosso exemplo, a hip√≥tese nula √© que "o grau de urbaniza√ß√£o n√£o afeta o n√∫mero de esp√©cies de plantas √∫teis conhecidas pela popula√ß√£o local". Por sua vez, a hip√≥tese alternativa √© que "o grau de urbaniza√ß√£o afeta o n√∫mero de esp√©cies de plantas √∫teis conhecidas pela popula√ß√£o local". Depois de operacionalizar suas vari√°veis e definir o valor nulo e hip√≥teses alternativas, √© hora de visualizar o resultado esperado (Fig. \@ref(fig:fig-box), Caixa 1) e escolher um m√©todo estat√≠stico adequado. Por exemplo, se voc√™ deseja comparar a diferen√ßa na composi√ß√£o de plantas √∫teis entre √°reas urbanas, periurbanas e rurais, voc√™ pode executar uma PERMANOVA [@albuquerque_multidimensional_2019] que usa uma estat√≠stica de teste chamada *pseudo-F*. Ent√£o, voc√™ deve escolher o limite de probabilidade (o valor P) do teste estat√≠stico para decidir se a hip√≥tese nula deve ou n√£o deve ser rejeitada [@gotelli_primer_2012]. Se voc√™ encontrar um P \< 0,05, voc√™ deve rejeitar a hip√≥tese estat√≠stica nula (urbaniza√ß√£o n√£o afeta o n√∫mero e a composi√ß√£o das plantas). Por outro lado, um P \> 0,05 indica que voc√™ n√£o pode rejeitar a hip√≥tese nula estat√≠stica. Assim, a estat√≠stica do teste e o valor P representam a √∫ltima parte do teste de hip√≥tese estat√≠stica, que √© a decis√£o e conclus√µes apropriadas que ser√£o usadas para retroalimentar a teoria principal (Figura \@ref(fig:fig-statistical-thinking)g -- i). Generalizando seus resultados e falseando (ou n√£o) suas hip√≥teses, o estudo busca refinar a constru√ß√£o conceitual da teoria, que muda constantemente [Fig. 1i, @ford_scientific_2004]. No entanto, h√° um ponto cr√≠tico nesta √∫ltima frase, porque a signific√¢ncia estat√≠stica n√£o significa necessariamente relev√¢ncia biol√≥gica [ver discuss√£o em Gotelli e Ellison [-@gotelli_primer_2012] e Mart√≠nez-Abra√≠n [-@martinez-abrain_statistical_2008]. Nas palavras de Ford [-@ford_scientific_2004]: "as estat√≠sticas s√£o usadas para iluminar o problema, e n√£o para apoiar uma posi√ß√£o". Al√©m disso, o procedimento de teste de hip√≥tese tem alguma incerteza, que pode influenciar resultados "falso-positivos" (erro tipo 1) e "falso-negativos" (erro tipo 2) [@whitlock_analysis_2015]. Para simplificar, n√£o discutiremos em detalhes os pr√≥s e contras da estat√≠stica frequentista, bem como m√©todos alternativos (por exemplo, Bayesiano e M√°xima Verossimilhan√ßa), e quest√µes filos√≥ficas relativas ao "valor P" [para uma discuss√£o sobre esses t√≥picos, consulte o f√≥rum em @ellison_p_2014].

> **Caixa 1. Tipo de vari√°veis e visualiza√ß√£o de dados**. Conforme descrito na Se√ß√£o 2.3, o fluxograma √© essencial para conectar vari√°veis relevantes para a pesquisa. Para aproveitar ao m√°ximo esta abordagem, voc√™ pode desenhar suas pr√≥prias predi√ß√µes gr√°ficas para te ajudar a pensar sobre diferentes possibilidades anal√≠ticas. Aqui, n√≥s fornecemos uma descri√ß√£o completa dos tipos de vari√°veis que voc√™ deve saber antes de executar qualquer an√°lise estat√≠stica e representar seus resultados. Al√©m disso, mostramos uma breve galeria (Fig. \@ref(fig:fig-box)) com exemplos de boas pr√°ticas em visualiza√ß√£o de dados [Fig. \@ref(fig:fig-research-flowchart)b, veja tamb√©m figuras em @albuquerque_multidimensional_2019]. Al√©m de conectar diferentes vari√°veis no fluxograma, voc√™ deve distinguir o tipo de vari√°vel. Primeiro voc√™ deve identificar as vari√°veis independentes (tamb√©m conhecidos como explicativas ou preditoras) e dependentes (tamb√©m conhecidas como resposta). A vari√°vel independente √© aquela (ou aquelas) que prev√™ ou afeta a vari√°vel resposta (por exemplo, a fertilidade do solo √© a vari√°vel independente capaz de afetar a abund√¢ncia de uma esp√©cie de planta focal, a vari√°vel dependente). Al√©m disso, uma covari√°vel √© uma vari√°vel cont√≠nua que pode afetar tanto a vari√°vel resposta quanto a independente (ou ambos), mas geralmente n√£o √© do interesse do pesquisador. Depois de definir as vari√°veis relevantes, conectando-as no fluxograma, √© hora de diferenciar seu tipo: i) quantitativa ou cont√≠nua, e ii) categ√≥rica ou qualitativa (Fig. \@ref(fig:fig-box), Caixa 1). O tipo de vari√°vel ir√° definir que tipo de figura voc√™ pode selecionar. Por exemplo, se voc√™ est√° comparando duas vari√°veis cont√≠nuas ou uma vari√°vel cont√≠nua e uma bin√°ria, a melhor maneira de visualiz√°-los (Fig. \@ref(fig:fig-box)) √© um gr√°fico de dispers√£o (Fig. \@ref(fig:fig-box)). A linha representa os valores preditos pelo modelo estat√≠stico usado (por exemplo, linear ou log√≠stico). Se voc√™ est√° interessado em comparar a gama de diferentes atributos (ou a descri√ß√£o de qualquer vari√°vel num√©rica) entre as vari√°veis categ√≥ricas (por exemplo, esp√©cies ou popula√ß√µes locais), um gr√°fico de halteres (do ingl√™s Dumbbell plot) √© uma boa op√ß√£o (Fig. \@ref(fig:fig-box)). Histogramas tamb√©m podem ser usados para mostrar a distribui√ß√£o de duas vari√°veis cont√≠nuas de dois grupos ou fatores (Fig. \@ref(fig:fig-box)). No entanto, se voc√™ quiser testar o efeito de uma vari√°vel categ√≥rica independente (como em um desenho de ANOVA) sobre uma vari√°vel dependente, boxplots (Fig. \@ref(fig:fig-box)) ou gr√°ficos de violino podem resumir essas rela√ß√µes de maneira elegante. Conjuntos de dados multivariados, por sua vez, podem ser visualizados com ordena√ß√£o (Fig. \@ref(fig:fig-box)) ou gr√°ficos de agrupamento (n√£o mostrados). Existe um site abrangente apresentando v√°rias maneiras de visualizar dados chamado [datavizproject](https://www.datavizproject.com).

```{r fig-box, fig.align='center', fig.cap="(A) Tipos de vari√°veis e (B) visualiza√ß√£o de dados para representar a rela√ß√£o entre vari√°veis independentes e dependentes ou covari√°veis.", out.width="100%", echo=FALSE}
knitr::include_graphics("img/cap02_fig02.png")
```

## Fluxograma: Conectando vari√°veis para melhorar o desenho experimental e as an√°lises estat√≠sticas

McIntosh e Pontius [-@mcintosh_science_2017] afirmaram que o pensamento estat√≠stico (representado na Fig. \@ref(fig:fig-statistical-thinking) inclui quatro etapas importantes: i) quais perguntas voc√™ investigaria (Se√ß√£o 2.4), ii) como e onde coletar os dados [@ruxton_experimental_2016], iii) quais fatores devem ser considerados e como eles afetam suas vari√°veis de interesse (e como elas afetam umas √†s outras), e iv) qual an√°lise estat√≠stica voc√™ deve usar e como interpretar e comunicar os resultados (Se√ß√£o 2.4). No entanto, a etapa (3) deve ser feita antes de coletar os dados. Por exemplo, se voc√™ est√° interessado na investiga√ß√£o dos benef√≠cios das matas ciliares para as esp√©cies nativas de peixes, quais vari√°veis devem ser inclu√≠das no estudo? Se voc√™ escolher rios com e sem mata ciliar como √∫nica vari√°vel preditora, seu projeto de amostragem ir√° omitir outras vari√°veis de confus√£o, como ordem do rio e carbono org√¢nico do solo a montante. Vellend [-@vellend_theory_2016] nomeou este problema como o "problema de tr√™s caixas" [ver tamb√©m @ruxton_experimental_2016], que se refere √† limita√ß√£o em inferir que X (vari√°vel independente) causa varia√ß√£o em Y (vari√°vel depende) quando outras vari√°veis criam ou ampliam a correla√ß√£o entre X e Y [ver Fig. 2 em @ruxton_experimental_2016]. Uma ferramenta √∫til para compreender a rela√ß√£o entre todas as vari√°veis relevantes do seu estudo √© um fluxograma. No "fluxograma de pesquisa" [ver tamb√©m @magnusson_statistics_2004] proposto aqui, vari√°veis dependentes (tamb√©m conhecidas como resposta) e independentes (ou preditora), bem como covari√°veis s√£o representadas como caixas (com formas distintas: Fig. \@ref(fig:fig-research-flowchart)). Al√©m disso, voc√™ pode usar uma seta para representar uma (poss√≠vel) via causal indicando for√ßa e sinal (positivo ou negativo) da vari√°vel preditora na vari√°vel dependente (Fig. \@ref(fig:fig-research-flowchart)). Ao fazer isso, voc√™ pode melhorar o desenho experimental ou observacional incluindo ou controlando vari√°veis de confus√£o o que, por sua vez, pode ajudar a separar a contribui√ß√£o relativa de diferentes vari√°veis preditoras em seu sistema. Mais importante, fazer conex√µes entre vari√°veis melhora sua capacidade de visualizar o "Quadro geral" de sua pesquisa, o que pode afetar seu experimento, an√°lise estat√≠stica e revis√£o da literatura. Na verdade, Arlidge et al. [-@arlidge_using_2017] argumentam que fluxogramas facilitam a constru√ß√£o de narrativas, melhorando: i) a defini√ß√£o de m√∫ltiplas hip√≥teses, ii) coleta, interpreta√ß√£o e dissemina√ß√£o de dados e iii) a comunica√ß√£o do conte√∫do do estudo. Voc√™ tamb√©m pode ler os livros de Magnusson et al. [-@magnusson_statistics_2004] para entender mais como usar fluxogramas para auxiliar an√°lises estat√≠sticas e Ford [-@ford_scientific_2004] que recomenda o uso de uma abordagem anal√≠tica para fomentar o desenvolvimento da pesquisa. Al√©m disso, o fluxograma de pesquisa pode ser usado como uma ferramenta forte para contemplar os conselhos de Ford [-@ford_scientific_2004], que foram: i) definir a pergunta da pesquisa, ii) definir a teoria a ser usada, iii) definir a t√©cnica de investiga√ß√£o (por exemplo, experimento, observa√ß√£o de campo), iv) definir as medi√ß√µes, v) definir como fazer infer√™ncia, e vi) interpretar, generalizar,e sintetizar a partir de dados que, por sua vez, s√£o usados para refinar a teoria e modificar (quando necess√°rio) quest√µes futuras (Fig. \@ref(fig:fig-statistical-thinking)).

```{r fig-research-flowchart, fig.align='center', fig.cap='Exemplo de como usar um fluxograma para melhorar o entendimento do sistema estudado. A pergunta te√≥rica "Qual √© o impacto da invas√£o na comunidade nativa e nas propriedades do ecossistema?" pode gerar duas predi√ß√µes: i) a planta ex√≥tica *Prosopis juliflora* reduz a diversidade beta de comunidades de plantas nativas, e ii) *Prosopis juliflora* modifica a composi√ß√£o das comunidades de plantas e reduz o estoque de carbono e as taxas de decomposi√ß√£o. Ap√≥s selecionar suas predi√ß√µes, voc√™ pode construir um fluxograma conectando as vari√°veis relevantes e as associa√ß√µes entre elas. Al√©m disso, voc√™ pode usar as informa√ß√µes na **Caixa 1** para identificar que tipo de vari√°vel voc√™ ir√° coletar e quais figuras podem ser usadas (b).', out.width="100%", echo=FALSE}
knitr::include_graphics("img/cap02_fig03.png")
```

## Quest√µes fundamentais em etnobiologia, ecologia e conserva√ß√£o

> *As teorias s√£o generaliza√ß√µes. As teorias cont√™m perguntas. Para algumas teorias, as perguntas s√£o expl√≠citas e representam o que a teoria pretende explicar. Para outras, as quest√µes s√£o impl√≠citas e se relacionam com a quantidade e tipo de generaliza√ß√£o, dada a escolha de m√©todos e exemplos usados por pesquisadores na constru√ß√£o da teoria. As teorias mudam continuamente, √† medida que exce√ß√µes s√£o encontradas √†s suas generaliza√ß√µes e como quest√µes impl√≠citas sobre m√©todo e op√ß√µes de estudos s√£o expostas. - E. David Ford [-@ford_scientific_2004]*

Como argumentamos antes, uma quest√£o relevante e test√°vel precede as an√°lises estat√≠sticas. Assim, apresentamos a seguir 12 quest√µes que podem estimular pesquisas futuras na ECC. Observe, no entanto, que n√£o queremos dizer que eles s√£o as √∫nicas quest√µes relevantes a serem testadas na EEC - ver, por exemplo, Sutherland et al. [-@sutherland_identification_2013] para uma avalia√ß√£o completa da pesquisa de ponta em Ecologia; e Caixa 6.1 em Pickett et al. [-@pickett_ecological_2007][^perguntas_ecologia-2]. Especificamente, essas quest√µes s√£o muito amplas e podem ser desenvolvidas em perguntas, hip√≥teses e predi√ß√µes mais restritas. Depois de cada quest√£o te√≥rica, apresentamos um estudo que testou essas hip√≥teses bem como as vari√°veis relevantes que podem estimular estudos futuros.

[^perguntas_ecologia-2]: Ap√≥s a publica√ß√£o original deste cap√≠tulo, Ulysses Albuquerque e colaboradores publicaram artigo sugerindo quest√µes fundamentais em Etnobiologia: Albuquerque et al. 2019, Acta Bot. Bras. 33, 2.

(a) **Como o uso da terra afeta a manuten√ß√£o da biodiversidade e a distribui√ß√£o de esp√©cies em diferentes escalas espaciais?**

*Exemplo*: V√°rios estudos em diferentes ecossistemas e escalas investigaram como o uso da terra afeta a biodiversidade. No entanto, destacamos um estudo comparando os efeitos globais do uso da terra (por exemplo, densidade populacional humana, paisagem para usos humanos, tempo desde a convers√£o da floresta) em esp√©cies terrestres (por exemplo, mudan√ßa l√≠quida na riqueza local, dissimilaridade composicional m√©dia) [@newbold_global_2015].

(b) **Qual √© o impacto da invas√£o bi√≥tica nas comunidades nativas e propriedades do ecossistema?**

*Exemplo*: Investigar como o estabelecimento de esp√©cies ex√≥ticas afetam a riqueza de esp√©cies do receptor, comunidades nativas, bem como isso afeta a entrega do servi√ßos ecossit√™micos. Estudos anteriores controlaram a presen√ßa de esp√©cies invasoras ou registros hist√≥ricos comparados (estudos observacionais) dessas esp√©cies e como elas impactam a biodiversidade. Al√©m disso, h√° algum esfor√ßo em compreender os preditores de invasibilidade (por exemplo, produto interno bruto de regi√µes, densidade populacional humana, litoral continental e ilhas) [@dawson_global_2017].

(c) **Como o decl√≠nio do predador de topo afeta a entrega de servi√ßos ecossist√™micos?**

*Exemplo*: Investigar como a remo√ß√£o de grandes carn√≠voros afeta o fornecimento de servi√ßos ecossist√™micos, como o sequestro de carbono, doen√ßas e controle de danos √†s colheitas. Estudos anteriores investigaram esta quest√£o controlando a presen√ßa de predadores de topo ou comparando registros hist√≥ricos (estudo observacionais) de esp√©cies e v√°rios preditores (por exemplo, perda e fragmenta√ß√£o de habitat, conflito entre humanos e esp√©cies ca√ßadas, utiliza√ß√£o para a medicina tradicional e superexplora√ß√£o de presas) [@ripple_status_2014].

(d) **Como a acidifica√ß√£o dos oceanos afeta a produtividade prim√°ria e teias alimentares em ecossistemas marinhos?**

*Exemplo*: Estudos recentes testaram os efeitos individuais e interativos da acidifica√ß√£o e do aquecimento do oceano nas intera√ß√µes tr√≥ficas em uma teia alimentar. A acidifica√ß√£o e o aquecimento foram manipulados pela mudan√ßa dos n√≠veis de CO<sub>2</sub> e temperatura, respectivamente. Estudos anteriores demonstraram que eleva√ß√£o de CO<sub>2</sub> e temperatura aumentou a produtividade prim√°ria e afetou a for√ßa do controle de cima para baixo exercido por predadores [@goldenberg_boosted_2017].

(e) **Como podemos reconciliar as necessidades da sociedade por recursos naturais com conserva√ß√£o da Natureza?**

*Exemplo*: Existe uma literatura crescente usando abordagens de paisagem para melhorar a gest√£o da terra para reconciliar conserva√ß√£o e desenvolvimento econ√¥mico. Os estudos possuem diversos objetivos, mas em geral eles usaram o engajamento das partes interessadas, apoio institucional, estruturas eficazes de governan√ßa como vari√°veis preditoras e melhorias ambientais (por exemplo, conserva√ß√£o do solo e da √°gua, cobertura vegetal) e socioecon√¥micas (renda, capital social, sa√∫de p√∫blica, emprego) como vari√°veis dependentes [@reed_have_2017].

(f) **Qual √© o papel das √°reas protegidas (UCs) para a manuten√ß√£o da biodiversidade e dos servi√ßos ecossist√™micos?**

*Exemplo*: Houve um trabalho consider√°vel na √∫ltima d√©cada comparando a efic√°cia das UCs para a conserva√ß√£o da biodiversidade. Embora esta quest√£o n√£o esteja completamente separada da quest√£o anterior, o desenho dos estudos √© relativamente distinto. Em geral, os pesquisadores contrastam o n√∫mero de esp√©cies e o fornecimento de servi√ßos ecossist√™micos (por exemplo, reten√ß√£o de √°gua e solo, sequestro de carbono) entre √°reas legalmente protegidas (UCs) e n√£o protegidas [@xu_strengthening_2017].

(g) **Como integrar o conhecimento cient√≠fico e das pessoas locais para mitigar os impactos negativos das mudan√ßas clim√°ticas e do uso da terra na biodiversidade?**

*Exemplo*: Eventos clim√°ticos extremos podem ter forte impacto sobre rendimento agr√≠cola e produ√ß√£o de alimentos. Autores recentes t√™m argumentado que esse efeito pode ser mais forte para os pequenos agricultores. Estudos futuros podem investigar como a precipita√ß√£o e a temperatura afetam o rendimento agr√≠cola e como os agricultores tradicionais ou ind√≠genas lidam com esse impacto negativo. Sistemas de agricultura tradicional t√™m menor eros√£o do solo e emiss√µes de N<sub>2</sub>O / CO<sub>2</sub> do que as monoculturas e, portanto, podem ser vistos como uma atividade de mitiga√ß√£o vi√°vel em um mundo em constante mudan√ßa [@niggli_low_2009; @altieri_adaptation_2017].

(h) **Como as mudan√ßas clim√°ticas afetam a resili√™ncia e estrat√©gias adaptativas em sistemas socioecol√≥gicos?**

*Exemplo*: A mudan√ßa do clima altera tanto a pesca quanto a agricultura em todo o mundo, o que por sua vez obriga os humanos a mudar suas estrat√©gias de cultivo. Estudos recentes t√™m argumentado que a agricultura em alguns pa√≠ses enfrentar√° riscos com as mudan√ßas clim√°ticas. Esses estudos comparam diferentes sistemas de produ√ß√£o, de agricultura convencional a outros tipos empregados por popula√ß√µes locais. Por exemplo, h√° uma forte conex√£o entre i) esp√©cies amea√ßadas e sobrepesca, ii) √≠ndice de desenvolvimento humano (IDH) e depend√™ncia m√©dia da pesca e aquicultura. Al√©m disso, h√° evid√™ncias de que a biodiversidade pode amortecer os impactos das mudan√ßas clim√°ticas aumentando a resili√™ncia da terra [@niggli_low_2009; @altieri_adaptation_2017; @blanchard_linked_2017]. Uma abordagem interessante √© investigar como as popula√ß√µes locais lidam com esses desafios em termos de percep√ß√µes e comportamento.

(i) **Como a invas√£o biol√≥gica afeta espacial e temporalmente a estrutura e funcionalidade dos sistemas s√≥cio-ecol√≥gicos?**

*Exemplo*: Muitos estudos demonstraram que esp√©cies invasoras t√™m consequ√™ncias biol√≥gicas, econ√¥micas e sociais negativas. Aqui, da mesma forma que a pergunta B, os pesquisadores controlaram a presen√ßa de esp√©cies invasoras ou utilizaram registros hist√≥ricos. No entanto, trabalhos recentes quantificam n√£o apenas a riqueza e composi√ß√£o de esp√©cies nativas, mas tamb√©m atributos funcionais de animais/vegetais que afetam diretamente o fornecimento de servi√ßos ecossist√™micos como abastecimento (comida, √°gua), regula√ß√£o (clima, controle de inunda√ß√µes), suporte (ciclagem de nutrientes, forma√ß√£o do solo) e cultural (ecoturismo, patrim√¥nio cultural) [@chaffin_biological_2016]. Mas, esp√©cies invasoras podem provocar efeitos positivos no sistema s√≥cio-ecol√≥gico aumentando a disponibilidade de recursos naturais, impactando como as pessoas gerenciam e usam a biodiversidade local.

(j) **Qual √© a rela√ß√£o entre as diversidades filogen√©tica e taxon√¥mica com a diversidade biocultural?**

*Exemplo*: Estudos recentes mostraram que existe um padr√£o filogen√©tico e taxon√¥mico nos recursos que as pessoas incorporam em seus sistemas s√≥cio-ecol√≥gicos, especialmente em plantas medicinais. Existe uma tend√™ncia para as pessoas, em diferentes partes do mundo, para usar plantas pr√≥ximas filogeneticamente para os mesmos prop√≥sitos. Aqui, os pesquisadores podem testar o quanto isso afeta a diversidade de pr√°ticas em um sistema s√≥cio-ecol√≥gico considerando o ambiente, bem como sua estrutura e fun√ß√µes [@saslis-lagoudakis_phylogenies_2012; @saslis-lagoudakis_evolution_2014].

(k) **Quais vari√°veis ambientais e s√≥cio-pol√≠ticas mudam a estrutura e funcionalidade dos sistemas s√≥cio-ecol√≥gicos tropicais?**

*Exemplo*: Testar a influ√™ncia das mudan√ßas ambientais afetadas pela esp√©cie humana (por exemplo, fogo, explora√ß√£o madeireira, aquecimento) em esp√©cies-chave e, consequentemente, como esse efeito em cascata pode afetar outras esp√©cies e servi√ßos ecossist√™micos (por exemplo, armazenamento de carbono, ciclo da √°gua e din√¢mica do fogo) [@lindenmayer_hidden_2018].

(l) **Os atributos das esp√©cies influenciam como as popula√ß√µes locais distinguem plantas ou animais √∫teis e n√£o-√∫teis?**

*Exemplo*: Investigar se a popula√ß√£o local possui prefer√™ncia ao selecionar esp√©cies de animais ou plantas. Voc√™ pode avaliar se grupos diferentes (por exemplo, turistas) ou popula√ß√µes locais (por exemplo, pescadores) selecionam esp√©cies com base em atributos das esp√©cies. Estudos recentes t√™m mostrado uma liga√ß√£o potencial entre planta (por exemplo, cor, folha, flora√ß√£o) e p√°ssaro (por exemplo, cor, vocaliza√ß√£o) e alguns servi√ßos culturais do ecossistema, como est√©tica, recreativa e espiritual/religiosa [@goodness_exploring_2016].

Como voc√™ notou, as quest√µes eram mais te√≥ricas e, consequentemente, voc√™ pode derivar predi√ß√µes test√°veis (usando vari√°veis) a partir delas (Figuras \@ref(fig:fig-statistical-thinking), \@ref(fig:fig-research-flowchart)). Por exemplo, da quest√£o *"Como o uso da terra afeta a manuten√ß√£o da biodiversidade e distribui√ß√£o de esp√©cies em diferentes escalas?"* podemos derivar duas predi√ß√µes diferentes: i) densidade populacional (vari√°vel operacional de uso da terra) muda a composi√ß√£o de esp√©cies e reduz a riqueza de esp√©cies na escala da paisagem [predi√ß√£o derivada da hip√≥tese da homogeneiza√ß√£o bi√≥tica: @solar_how_2015]; ii) a composi√ß√£o dos atributos funcionais das plantas √© diferente em remanescentes florestais com diferentes matrizes (cana-de-a√ß√∫car, gado, cidade, etc.).

## Considera√ß√µes Finais

> *Conte-me seus segredos*\
> *E fa√ßa-me suas perguntas*\
> *Oh, vamos voltar para o in√≠cio*\
> *Correndo em c√≠rculos, perseguindo caudas*\
> *Cabe√ßas em uma ci√™ncia √† parte*\
> *Ningu√©m disse que seria f√°cil*\
> *(...) Desfazendo enigmas*\
> *Quest√µes da ci√™ncia, ci√™ncia e progresso*\
> *- O Cientista, Coldplay*

Este √© um trecho de uma m√∫sica da banda brit√¢nica de rock Coldplay, do √°lbum de 2002 *A Rush of Blood to the Head*. A letra √© uma compara√ß√£o incr√≠vel entre a ci√™ncia e os altos e baixos de um relacionamento fadado ao fracasso. A banda traz uma mensagem surpreendentemente clara de que como cientistas, n√≥s dever√≠amos frequentemente fazer perguntas, voltar ao in√≠cio ap√≥s descobrir que est√°vamos errados (ou n√£o) e que corremos em c√≠rculos tentando melhorar nosso conhecimento. A banda descreveu de uma forma t√£o precisa o qu√£o c√≠clico (mas n√£o repetitivo) √© o m√©todo cient√≠fico. Como disse a can√ß√£o: n√£o √© f√°cil, mas aprender como fazer boas perguntas √© um passo essencial para a consolida√ß√£o do conhecimento. Ao incluir o teste de hip√≥tese no EEC, podemos ser mais precisos. Definitivamente, isso n√£o significa que a ci√™ncia descritiva seja in√∫til. Ao contr√°rio, o desenvolvimento da ECC e principalmente da Etnobiologia, foi constru√≠do sobre uma linha de frente descritiva, o que significa que foi valioso para a funda√ß√£o da Etnobiologia como disciplina consolidada [@ethnobiology_working_group_intellectual_2003; @stepp_advances_2005]. No entanto, estudos recentes defendem que a etnobiologia deve dialogar com disciplinas com maior respaldo te√≥rico, como ecologia e biologia evolutiva para melhorar a pesquisa sobre biodiversidade [@albuquerque_what_2017]. Por sua vez, incorporando o conhecimento local em ecologia e evolu√ß√£o ir√° certamente refinar seu pr√≥prio desenvolvimento, que em √∫ltima an√°lise beneficia a conserva√ß√£o biol√≥gica [@saslis-lagoudakis_ethnobiology_2013]. Al√©m disso, h√° uma necessidade urgente de formar jovens pesquisadores em filosofia e metodologia da ci√™ncia, bem como comunica√ß√£o e produ√ß√£o cient√≠fica [@albuquerque_how_2013]. Como coment√°rio final, acreditamos que a forma√ß√£o dos alunos em EEC precisa de uma reavalia√ß√£o que necessariamente volta aos conceitos e m√©todos b√°sicos. Assim, os pesquisadores podem combinar o m√©todo hipot√©tico-dedutivo com pensamento estat√≠stico usando um fluxograma de pesquisa para ir al√©m da descri√ß√£o b√°sica.


<!--chapter:end:02_perguntas_ecologia.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Pr√©-requisitos {#cap3}

## Introdu√ß√£o

O objetivo deste cap√≠tulo √© informar como fazer a instala√ß√£o dos Programas R e RStudio, al√©m de descrever os pacotes e dados necess√°rios para reproduzir os exemplos do livro.

## Instala√ß√£o do R

Abaixo descrevemos os sete passos necess√°rios para a instala√ß√£o do programa R no seu computador (Figura \@ref(fig:fig-r-instalacao)):

1.  Para come√ßarmos a trabalhar com o R √© necess√°rio baix√°-lo na p√°gina do R Project. Ent√£o, acesse esse [http://www.r-project.org](http://www.r-project.org)
2.  Clique no link **download R**
3.  Na p√°gina *CRAN Mirros (Comprehensive R Archive Network)*, escolha uma das p√°ginas espelho do Brasil mais pr√≥xima de voc√™ para baixar o programa
4.  Escolha agora o sistema operacional do seu computador (passos adicionais existem para diferentes distribui√ß√µes Linux ou MacOS). Aqui faremos o exemplo com o Windows
5.  Clique em **base** para finalmente chegar √† p√°gina de download com a vers√£o mais recente do R
6.  Clique no arquivo **Download R (vers√£o mais recente) for Windows** que ser√° instalado no seu computador
7.  Abra o arquivo que foi baixado no seu computador e siga os passos indicados para finalizar a instala√ß√£o do programa R

```{r fig-r-instalacao, echo=FALSE, fig.cap="Esquema ilustrativo demonstrando os passos necess√°rios para instala√ß√£o do programa R no computador. Fonte das figuras: imagem [computador](https://pt.wikipedia.org/wiki/Computador_pessoal) e imagem da [lupa](https://openclipart.org/detail/185356/magnifier)."}
knitr::include_graphics(path = "img/cap03_fig01.png")
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para o Sistema Operacional (SO) Windows, alguns pacotes s√£o dependentes da instala√ß√£o separada do [Rtools40](https://cran.rstudio.com/bin/windows/Rtools/). Da mesma forma, GNU/Linux e MacOS tamb√©m possuem depend√™ncias de outras bibliotecas para pacotes espec√≠ficos, mas que n√£o abordaremos aqui. Essas informa√ß√µes de depend√™ncia geralmente s√£o retornadas como erros ou voc√™ pode procurar ajuda em f√≥rum espec√≠ficos.
:::

## Instala√ß√£o do RStudio

O RStudio possui algumas caracter√≠sticas que o tornam popular: v√°rias janelas de visualiza√ß√£o, marca√ß√£o e preenchimento autom√°tico do script, integra√ß√£o com controle de vers√£o, dentre outras funcionalidades.

Abaixo descrevemos os cinco passos necess√°rios para a instala√ß√£o do RStudio no seu computador (Figura \@ref(fig:fig-rstudio-instalacao)):

1.  Para fazer o download do RStudio, acessamos o [site](https://www.rstudio.com/)
2.  Clique em **download**
3.  Escolha a vers√£o gratuita
4.  Escolha o instalador com base no seu sistema operacional
5.  Abra o arquivo que foi baixado no seu computador e siga os passos indicados para finalizar a instala√ß√£o do programa RStudio

```{r fig-rstudio-instalacao, echo=FALSE, fig.cap="Esquema ilustrativo demonstrando os passos necess√°rios para instala√ß√£o do programa RStudio no computador. Fonte das figuras: imagem [computador](https://pt.wikipedia.org/wiki/Computador_pessoal) e imagem da [lupa](https://openclipart.org/detail/185356/magnifier)."}
knitr::include_graphics(path = "img/cap03_fig02.png")
```

## Vers√£o do R

Todas os c√≥digos, pacotes e an√°lises disponibilizados no livro foram realizos no Programa R vers√£o 4.1.2 (10-12-2021).

## Pacotes

Descrevemos no Cap√≠tulo \@ref(cap4) o que s√£o e como instalar os pacotes para realizar as an√°lises estat√≠sticas no R.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Criamos o pacote `ecodados` que cont√©m todas as informa√ß√µes e dados utilizados neste livro. Assim, recomendamos que voc√™ instale e carregue este pacote no in√≠cio de cada cap√≠tulo para ter acesso aos dados necess√°rios para executar as fun√ß√µes no R.
:::

Abaixo, listamos todos os pacotes utilizados no livro. Voc√™ pode instalar os pacotes agora ou esperar para instal√°-los quando ler o Cap√≠tulo \@ref(cap4) e entender o que s√£o as fun√ß√µes `install.packages()`, `library()` e `install_github()`. Para fazer a instala√ß√£o, voc√™ vai precisar estar conectado √† internet.

```{r eval=FALSE}
install.packages(c("ade4", "adespatial", "ape", "bbmle", "betapart", "BiodiversityR", "car", "cati", "datasauRus", "devtools", "DHARMa", "dplyr", "emmeans", "factoextra", "FactoMineR", "fasterize", "FD", "forcats", "geobr", "GGally", "ggExtra", "ggforce", "ggplot2", "ggpubr", "ggrepel", "ggspatial", "glmmTMB", "grid", "gridExtra", "here", "hillR", "iNEXT", "janitor", "kableExtra", "knitr", "labdsv", "lattice", "leaflet", "lmtest", "lsmeans", "lubridate", "mapview", "MASS", "MuMIn", "nlme", "ordinal", "palmerpenguins", "performance", "pez", "phyloregion", "phytools", "picante", "piecewiseSEM", "purrr", "pvclust", "raster", "readr", "reshape2", "rgdal" , "Rmisc", "rnaturalearth", "RVAideMemoire", "sciplot", "sf", "sidrar", "sjPlot", "spData", "spdep", "stringr", "SYNCSA", "tibble", "tidyr", "tidyverse", "tmap", "tmaptools", "TPD", "vegan", "viridis", "visdat", "mvabund", "rdist", "udunits2"), dependencies = TRUE)
```

Diferente dos pacotes anteriores que s√£o baixados do CRAN, alguns pacotes s√£o baixados do GitHub dos pesquisadores respons√°veis pelos pacotes. [GitHub](https://github.com/) √© um reposit√≥rio remoto de c√≥digos que permite controle de vers√£o, muito utilizado por desenvolvedores e programadores. Nestes casos, precisamos carregar o pacote `devtools` para acessar a fun√ß√£o `install_github`. Durante as instala√ß√µes deste pacotes, algumas vezes o R ir√° pedir para voc√™ digitar um n√∫mero indicando os pacotes que voc√™ deseja fazer update. Neste caso, digite 1 para indicar que ele deve atualizar os pacotes dependenste antes de instalar os pacotes requeridos.

```{r eval=FALSE}
library(devtools) 
install_github("paternogbc/ecodados")
install_github("mwpennell/geiger-v2")
install_github("fawda123/ggord")
install_github("jinyizju/V.PhyloMaker")
```

## Dados

A maioria dos exemplos utilizados s√£o baseados em dados reais que j√° foram publicados em artigos cient√≠ficos ou s√£o dados coletados por um dos autores deste livro. Em alguns casos, os dados foram simulados para facilitar a interpreta√ß√£o dos resultados de algumas an√°lises estat√≠sticas. Todos os dados, publicados ou simulados, est√£o dispon√≠veis no pacote [`ecodados`](https://paternogbc.github.io/ecodados/). Al√©m disso, em cada cap√≠tulo fazemos uma breve descri√ß√£o dos dados para facilitar a compreens√£o sobre o que √© vari√°vel resposta ou preditora, como essas vari√°veis est√£o relacionadas com as perguntas e predi√ß√µes do exemplo.

<!--chapter:end:03_pre_requisitos.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Introdu√ß√£o ao R {#cap4}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r eval=FALSE}
## Pacotes
library(ecodados)

## Dados necess√°rios
intror_anfibios_locais <- ecodados::intror_anfibios_locais
```

## Contextualiza√ß√£o

O objetivo deste cap√≠tulo √© apresentar os aspectos b√°sicos da linguagem R para a realiza√ß√£o dos principais passos para a manipula√ß√£o, visualiza√ß√£o e an√°lise de dados. Abordaremos aqui as quest√µes b√°sicas sobre a linguagem R, como: i) R e RStudio, ii) funcionamento da linguagem, iii) estrutura e manipula√ß√£o de objetos, iv) exerc√≠cios e v) principais livros e material para se aprofundar nos seus estudos.

Todo processo de aprendizagem torna-se mais efetivo quando a teoria √© combinada com a pr√°tica. Assim, recomendamos fortemente que voc√™, leitor(a) acompanhe os c√≥digos e exerc√≠cios deste livro, ao mesmo tempo que os executa em seu computador e n√£o s√≥ os leia passivamente. Al√©m disso, se voc√™ tiver seus pr√≥prios dados √© muito importante tentar executar e/ou replicar as an√°lises e/ou gr√°ficos. Por motivos de espa√ßo, n√£o abordaremos todas as quest√µes relacionadas ao uso da linguagem R neste cap√≠tulo. Logo, aconselhamos que voc√™ consulte o material sugerido no final do cap√≠tulo para se aprofundar.

Este cap√≠tulo, na maioria das vezes, pode desestimular as pessoas que est√£o iniciando, uma vez que o mesmo n√£o apresenta os c√≥digos para realizar as an√°lises estat√≠sticas. Contudo, ele √© essencial para o entendimento e interpreta√ß√£o do que est√° sendo informado nas linhas de c√≥digo, al√©m de facilitar a manipula√ß√£o dos dados antes de realizar as an√°lises estat√≠sticas. Voc√™ perceber√° que n√£o usar√° este cap√≠tulo para fazer as an√°lises, mas voltar√° aqui diversas vezes para relembrar qual √© o c√≥digo ou o que significa determinada express√£o ou fun√ß√£o usada nos pr√≥ximos cap√≠tulos.

## R e RStudio

Com o R, √© poss√≠vel manipular, analisar e visualizar dados, al√©m de escrever desde pequenas linhas de c√≥digos at√© programas inteiros. O R √© a vers√£o em c√≥digo aberto de uma linguagem de programa√ß√£o  chamada de S, criada por John M. Chambers (Stanford University, CA, EUA) nos anos 1980 no Bell Labs, que contou com tr√™s vers√µes: Old S (1976-1987), New S (1988-1997) e S4 (1998), utilizada na IDE S-PLUS (1988-2008). Essa linguagem tornou-se bastante popular e v√°rios produtos comerciais que a usam ainda est√£o dispon√≠veis, como o SAS.

No final dos anos 1990, Robert Gentleman e Ross Ihaka (ambos da Universidade de Auckland, Nova Zel√¢ndia), iniciaram o desenvolvimento da vers√£o livre da linguagem S, a linguagem R, com o seguinte hist√≥rico: Desenvolvimento (1997-2000), Vers√£o 1 (2000-2004), Vers√£o 2 (2004-2013), Vers√£o 3 (2013-2020) e Vers√£o 4 (2020). Para mais detalhes do hist√≥rico de desenvolvimento das linguagens S e R, consultar Wickham [-@wickham2013]. Atualmente a linguagem R √© mantida por uma rede de colaboradores denominada *R Core Team*. A origem do nome R √© desconhecida, mas reza a lenda que ao lan√ßarem o nome da linguagem os autores se valeram da letra que vinha antes do S, uma vez que a linguagem R foi baseada nela e utilizaram a letra "R". Outra hist√≥ria conta que pelo fato do nome dos dois autores iniciarem por "R", batizaram a linguagem com essa letra, vai saber.

Um aspecto digno de nota √© que a linguagem R √© uma linguagem de programa√ß√£o interpretada, assim como o [Python](https://www.python.org/), mas contr√°ria a outras linguagens como C e Java, que s√£o compiladas. Isso a faz ser mais f√°cil de ser utilizada, pois processa linhas de c√≥digo e as transforma em linguagem de m√°quina (c√≥digo bin√°rio que o computador efetivamente l√™), apesar desse fato diminuir a velocidade de processamento.

Para come√ßarmos a trabalhar com o R √© necess√°rio baix√°-lo na p√°gina do **R Project**. Os detalhes de instala√ß√£o s√£o apresentados no Cap√≠tulo \@ref(cap3). Reserve algum tempo para explorar esta p√°gina do R-Project. Existem v√°rios [livros](http://www.r-project.org/doc/bib/R-books.html) dedicados a diversos assuntos baseados no R. Al√©m disso, est√£o dispon√≠veis [manuais](http://cran.r-project.org/manuals.html) em [diversas l√≠nguas](http://cran.r-project.org/other-docs.html) para serem baixados gratuitamente.

Como o R √© um software livre, n√£o existe a possibilidade de o usu√°rio entrar em contato com um servi√ßo de suporte de usu√°rios, muito comuns em softwares pagos. Ao inv√©s disso, existem v√°rias listas de e-mails que fornecem suporte √† [comunidade de usu√°rios](http://www.r-project.org/mail.html). N√≥s, particularmente, recomendamos o ingresso nas seguintes listas: R-help, R-sig-ecolog, [R-br](http://www.leg.ufpr.br/doku.php/software:rbr) e [discourse.curso-r](https://discourse.curso-r.com/). Este √∫ltimo re√∫ne um grupo de pessoas usu√°rias brasileiras do programa R.

Apesar de podermos utilizar o R com o IDE (Ambiente de Desenvolvimento Integrado - *Integrated Development Environment*) RGui que vem com a instala√ß√£o da linguagem R para usu√°rios Windows (Figura \@ref(fig:fig-rgui)) ou no pr√≥prio terminal para usu√°rios Linux e MacOS, existem alguns IDEs espec√≠ficos para facilitar nosso uso dessa linguagem.

```{r fig-rgui, echo=FALSE, fig.cap="Interface do RGui. Os n√∫meros indicam: (1) R Script, (2) R Console, e (3) R Graphics."}
knitr::include_graphics("img/cap04_fig01.png")
```

Dessa forma, n√≥s que escrevemos este livro utilizamos o IDE RStudio e assumimos que voc√™ que est√° lendo far√° o mesmo.

O RStudio permite diversas personaliza√ß√µes, grande parte delas contidas em `Tools > Global options`. Incentivamos as leitoras e leitores a "fu√ßar" com certa dose de cuidado, nas op√ß√µes para personaliza√ß√£o. Dentre essas mudan√ßas, destacamos duas:

1. `Tools > Global options > Appearance > Editor theme`: para escolher um tema para seu RStudio
1. `Tools > Global options > Code > [X] Soft-wrap R source files`: com essa op√ß√£o habilitada, quando escrevemos coment√°rios longos ou mudamos a largura da janela que estamos trabalhando, todo o texto e o c√≥digo se ajustam a janela automaticamente
1. `Tools > Global options > Code > Display > [X Show Margis] e Margin column (80)`: com essa op√ß√£o habilitada e para esse valor (80), uma linha vertical ir√° aparecer no script marcando 80 caracteres, um comprimento m√°ximo recomendado para padroniza√ß√£o dos scripts

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para evitar poss√≠veis erros √© importante instalar primeiro o software da linguagem R e depois o IDE RStudio.
:::

## Funcionamento da linguagem R

Nesta se√ß√£o, veremos os principais conceitos para entender como a linguagem R funciona ou como geralmente utilizamos o IDE RStudio no dia a dia, para executar nossas rotinas utilizando a linguagem R. Veremos ent√£o: i) console, ii) script, iii) operadores, iv) objetos, v) fun√ß√µes, vi) pacotes, vii) ajuda (*help*), viii) ambiente (*environment/workspace*), ix) cita√ß√µes e x) principais erros.

Antes de iniciarmos o uso do R pelo RStudio √© fundamental entendermos alguns pontos sobre as janelas e o funcionamento delas no RStudio (Figura \@ref(fig:fig-rstudio)).

```{r fig-rstudio, echo=FALSE, fig.cap="Interface do RStudio. Os n√∫meros indicam: (1) janela com abas de Script, R Markdown, dentre outras; (2) janela com abas de Console, Terminal e Jobs; (3) janela com abas de Environment, History, Conections e Tutorial; e (4) janela com abas de Files, Plots, Packages, Help e Viewer."}
knitr::include_graphics("img/cap04_fig02.png")
```

Detalhando algumas dessas janelas e abas, temos:

-   **Console**: painel onde os c√≥digos s√£o rodados e vemos as sa√≠das
-   **Editor/Script**: painel onde escrevemos nossos c√≥digos em R, R Markdown ou outro formato
-   **Environment**: painel com todos os objetos criados na sess√£o
-   **History**: painel com o hist√≥rico dos c√≥digos rodados
-   **Files**: painel que mostra os arquivos no diret√≥rio de trabalho
-   **Plots**: painel onde os gr√°ficos s√£o apresentados
-   **Packages**: painel que lista os pacotes
-   **Help**: painel onde a documenta√ß√£o das fun√ß√µes √© exibida

No RStudio, alguns atalhos s√£o fundamentais para aumentar nossa produtividade:

-   **F1**: abre o painel de *Help* quando digitado em cima de uma fun√ß√£o
-   **Ctrl + Enter**: roda a linha de c√≥digo selecionada no script
-   **Ctrl + Shift + N**: abre um novo script
-   **Ctrl + S**: salva um script
-   **Ctrl + Z**: desfaz uma opera√ß√£o
-   **Ctrl + Shift + Z**: refaz uma opera√ß√£o
-   **Alt + -**: insere um sinal de atribui√ß√£o (<-)
-   **Ctrl + Shift + M**: insere um operador pipe (%>%)
-   **Ctrl + Shift + C**: comenta uma linha no script - insere um (#)
-   **Ctrl + I**: indenta (recuo inicial das linhas) as linhas
-   **Ctrl + Shift + A**: reformata o c√≥digo
-   **Ctrl + Shift + R**: insere uma sess√£o (# ----------------------)
-   **Ctrl + Shift + H**: abre uma janela para selecionar o diret√≥rio de trabalho
-   **Ctrl + Shift + F10**: reinicia o console
-   **Ctrl + L**: limpa os c√≥digos do console
-   **Alt + Shift + K**: abre uma janela com todos os atalhos dispon√≠veis

### Console

O console √© onde a vers√£o da linguagem R instalada √© carregada para executar os c√≥digos da linguagem R (Figura \@ref(fig:fig-rstudio) janela 2). Na janela do console aparecer√° o s√≠mbolo `>`, seguido de uma barra vertical `|` que fica piscando (cursor), onde digitaremos ou enviaremos nossos c√≥digos do script. Podemos fazer um pequeno exerc√≠cio: vamos digitar `10 + 2`, seguido da tecla `Enter` para que essa opera√ß√£o seja executada.

```{r}
10 + 2
```

O resultado retorna o valor `12`, precedido de um valor entre colchetes. Esses colchetes demonstram a posi√ß√£o do elemento numa sequ√™ncia de valores. Se fizermos essa outra opera√ß√£o `1:42`, o R vai criar uma sequ√™ncia unit√°ria de valores de 1 a 42. A depender da largura da janela do console, vai aparecer um n√∫mero diferente entre colchetes indicando sua posi√ß√£o na sequ√™ncia: antes do n√∫mero 1 vai aparecer o `[1]`, depois quando a sequ√™ncia for quebrada, vai aparecer o n√∫mero correspondente da posi√ß√£o do elemento, por exemplo, `[37]`.

```{r}
1:42
```

Podemos ver o hist√≥rico dos c√≥digos executados no console na aba **History** (Figura \@ref(fig:fig-rstudio) janela 3).

### Scripts

Scripts s√£o arquivos de texto simples, criados com a extens√£o (termina√ß√£o) `.R` (Figura \@ref(fig:fig-rstudio) janela 1). Para criar um script, basta ir em `File > New File > R Script`, ou clicando no √≠cone com uma folha branca e um c√≠rculo verde com um sinal de `+`, logo abaixo de `File`, ou ainda usando o atalho `Ctrl + Shift + N`.

Uma vez escrito os c√≥digos no script podemos rodar esses c√≥digos de duas formas: i) todo o script de uma vez, clicando em **Source** ou usando o atalho `Ctrl + Shift + Enter`; ou ii) apenas a linha onde o cursor estiver posicionado, independente de sua posi√ß√£o naquela linha, clicando em **Run** ou usando o atalho `Ctrl + Enter`.

Devemos sempre salvar nossos scripts, tomando por via de regra: primeiro criar o arquivo e depois ir salvando nesse mesmo arquivo a cada passo de desenvolvimento das an√°lises (n√£o √© raro o RStudio fechar sozinho e voc√™ perder algum tempo de trabalho). H√° diversos motivos para criar um script: continuar o desenvolvimento desse script em outro momento ou em outro computador, preservar trabalhos passados, ou ainda compartilhar seus c√≥digos com outras pessoas. Para criar ou salvar um script basta ir em `File > Save`, escolher um diret√≥rio e nome para o script e salv√°-lo. Podemos ainda utilizar o atalho `Ctrl + S`.

Em rela√ß√£o aos scripts, h√° ainda os coment√°rios, representados pelos s√≠mbolos `#` (hash), `#'` (hash-linha) e `#>` (hash-maior). A diferen√ßa entre eles √© que para o segundo e terceiro, quando precionamos a tecla `Enter` o coment√°rio `#'` e `#>` s√£o inseridos automaticamente na linha seguinte. Linhas de c√≥digos do script contendo coment√°rios em seu in√≠cio n√£o s√£o lidos pelo console do R. Se o coment√°rio estiver no final da linha, essa linha de c√≥digo ainda ser√° lida. Os coment√°rios s√£o utilizados geralmente para: i) descrever informa√ß√µes sobre dados ou fun√ß√µes e/ou ii) suprimir linhas de c√≥digo. 

√â interessante ter no in√≠cio de cada script um cabe√ßalho identificando o objetivo ou an√°lise, autor e data para facilitar o compartilhamento e reprodutibilidade. Os coment√°rios podem ser inseridos ou retirados das linhas com o atalho: `Ctrl + Shift + C`.

```{r}
#' ---
#' T√≠tulo: Cap√≠tulo 04 - Introdu√ß√£o ao R
#' Autor: Maur√≠cio Vancine
#' Data: 11-11-2021
#' ---
```

Al√©m disso, podemos usar coment√°rios para adicionar informa√ß√µes sobre os c√≥digos.

```{r}
## Coment√°rios
# O R n√£o l√™ a linha do c√≥digo depois do # (hash).
42 # Essas palavras n√£o s√£o executadas, apenas o 42, a resposta para quest√£o fundamental da vida, o universo e tudo mais.
```

Por fim, outro ponto fundamental √© ter boas pr√°ticas de estilo de c√≥digo. Quanto mais organizado e padronizado estiver seus scripts, mais f√°cil de entend√™-los e de procurar poss√≠veis erros. Existem dois guias de boas pr√°ticas para adequar seus scripts: [Hadley Wickham](http://adv-r.had.co.nz/Style.html) e [Google](https://google.github.io/styleguide/Rguide.xml).

Ainda em rela√ß√£o aos scripts, temos os *Code Snippets* (Fragmentos de c√≥digo), que s√£o macros de texto usadas para inserir rapidamente fragmentos comuns de c√≥digo. Por exemplo, o snippet `fun` insere uma defini√ß√£o de fun√ß√£o R. Para mais detalhes, ler o artigo do RStudio: [link](https://support.rstudio.com/hc/en-us/articles/204463668-Code-Snippets).

```{r eval=FALSE}
# fun {snippet}
fun
name <- function(variables) {
    
}
```

Uma aplica√ß√£o bem interessante dos *Code Snippets* no script √© o `ts`. Basta digitar esse c√≥digo e em seguida completar um a tecla `Tab` para inserir rapidamente a data e hor√°rio atuais no script em forma de coment√°rio.

```{r}
# ts {snippet}
# Thu Nov 11 18:19:26 2021 ------------------------------
```

### Operadores

No R, podemos agrupar os operadores em cinco tipos: aritm√©ticos, relacionais, l√≥gicos, atribui√ß√£o e diversos. Grande parte deles s√£o descritos na Tabela \@ref(tab:tab-operadores).

```{r tab-operadores, echo=FALSE}
 knitr::kable(data.frame(Operador = c("+", "-", "*", "/", "%%", "%/%", "^ ou **", ">", "<", ">=", "<=", "==", "!=", "!", "&", "|", "&&", "||", "<- ou =", "<<-", "->", "->>", ":", "%in%", "%*%", "%>%", "|>", "%--%"),
 Tipo = c(
  rep("Aritm√©tico", 7),
  rep("Relacional", 6),
  rep("L√≥gico", 5),
  rep("Atribui√ß√£o", 4),
  rep("Diversos", 6)), 
 Descri√ß√£o = c(
  "Adi√ß√£o", "Subtra√ß√£o", "Multiplica√ß√£o", "Divis√£o", "Resto da divis√£o", "Divis√£o inteira", "Expoente",
  "Maior", "Menor", "Maior ou igual", "Menor ou igual", "Igualdade", "Diferen√ßa",
  "L√≥gico N√ÉO", "L√≥gico elementar E", "L√≥gico elementar OU", "L√≥gico E", "L√≥gico OU", 
  "Atribui√ß√£o √† esquerda", "Super atribui√ß√£o √† esquerda", "Atribui√ß√£o √† direita", "Super atribui√ß√£o √† direita",
  "Sequ√™ncia unit√°ria", "Elementos que pertencem a um vetor", "Multiplicar matriz com sua transposta", "Pipe (pacote magrittr)", "Pipe (R base nativo)", "Intervalo de datas (pacote lubridate)")),
 align = "c",
 caption = "Principais operadores no R.")
```

Como exemplo, podemos fazer opera√ß√µes simples usando os operadores aritm√©ticos.

```{r}
## Opera√ß√µes aritm√©ticas
10 + 2 # adi√ß√£o
10 * 2 # multiplica√ß√£o
```

Precisamos ficar atentos √† prioridade dos operadores aritm√©ticos: 

> **`PRIORIT√ÅRIO`** `()` > `^` > `* ou /` > `+ ou -` **`N√ÉO PRIORIT√ÅRIO`**

Veja no exemplo abaixo como o uso dos par√™nteses muda o resultado.

```{r}
## Sem especificar a ordem
# Segue a ordem dos operadores.
1 * 2 + 2 / 2 ^ 2

## Especificando a ordem
# Segue a ordem dos parenteses.
((1 * 2) + (2 / 2)) ^ 2
```

### Objetos

Objetos s√£o palavras √†s quais s√£o atribu√≠dos dados. A atribui√ß√£o possibilita a manipula√ß√£o de dados ou armazenar os resultados de an√°lises. Utilizaremos os s√≠mbolos `<` (menor), seguido de `-` (menos), sem espa√ßo, dessa forma `<-`. Tamb√©m podemos utilizar o s√≠mbolo de igual (`=`), mas n√£o recomendamos, por n√£o fazer parte das boas pr√°ticas de escrita de c√≥digos em R. Podemos inserir essa combina√ß√£o de s√≠mbolos com o atalho `Alt + -`. Para demonstrar, vamos atribuir o valor `10` √† palavra `obj_10`, e chamar esse objeto novamente para verificar seu conte√∫do.

```{r}
## Atribui√ß√£o - s√≠mbolo (<-)
obj_10 <- 10
obj_10
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Recomendamos sempre verificar o conte√∫do dos objetos chamando-os novamente para confirmar se a atribui√ß√£o foi realizada corretamente e se o conte√∫do corresponde √† opera√ß√£o realizada.
:::

Todos os objetos criados numa sess√£o do R ficam listados na aba **Environment** (Figura \@ref(fig:fig-rstudio) janela 3). Al√©m disso, o RStudio possui a fun√ß√£o *autocomplete*, ou seja, podemos digitar as primeiras letras de um objeto (ou fun√ß√£o) e em seguida apertar `Tab` para que o RStudio liste tudo que come√ßar com essas letras.

Dois pontos importantes sobre atribui√ß√µes: primeiro, o R sobrescreve os valores dos objetos com o mesmo nome, deixando o objeto com o valor da √∫ltima atribui√ß√£o.

```{r}
## Sobrescreve o valor dos objetos
obj <- 100
obj

## O objeto 'obj' agora vale 2
obj <- 2
obj
```

Segundo, o R tem limita√ß√µes ao nomear objetos:

-   nome de objetos s√≥ podem come√ßar por letras (`a-z` ou `A-Z`) ou pontos (`.`)
-   nome de objetos s√≥ podem conter letras (`a-z` ou `A-Z`), n√∫meros (`0-9`), underscores (`_`) ou pontos (`.`)
-   R √© *case-sensitive*, i.e., ele reconhece letras mai√∫sculas como diferentes de letras min√∫scula. Assim, um objeto chamado "resposta" √© diferente do objeto "RESPOSTA"
-   devemos evitar acentos ou cedilha (`√ß`) para facilitar a memoriza√ß√£o dos objetos e tamb√©m para evitar erros de codifica√ß√£o (*encoding*) de caracteres
-   nome de objetos n√£o podem ser iguais a nomes especiais, reservados para programa√ß√£o (`break`, `else`, `FALSE`, `for`, `function`, `if`, `Inf`, `NA`, `NaN`, `next`, `repeat`, `return`, `TRUE`, `while`)

Podemos ainda utilizar objetos para fazer opera√ß√µes e criar objetos. Isso pode parecer um pouco confuso para os iniciantes, mas √© fundamental aprender essa l√≥gica para passar para os pr√≥ximos passos.

```{r}
## Definir dois objetos
va1 <- 10
va2 <- 2

## Opera√ß√µes com objetos e atribuic√£o
adi <- va1 + va2
adi
```

### Fun√ß√µes

Fun√ß√µes s√£o c√≥digos preparados para realizar uma tarefa espec√≠fica de modo simples. Outra forma de entender uma fun√ß√£o √©: c√≥digos que realizam opera√ß√µes em argumentos. Devemos retomar ao conceito do ensino m√©dio de fun√ß√µes: os dados de entrada s√£o argumentos e a fun√ß√£o realiz√° alguma opera√ß√£o para modificar esses dados de entrada. A estrutura de uma fun√ß√£o √© muito similar √† sintaxe usada em planilhas eletr√¥nicas, sendo composta por:

> nome_da_fun√ß√£o(argumento1, argumento2, ...)

1.  **Nome da fun√ß√£o**: remete ao que ela faz
2.  **Par√™nteses**: limitam a fun√ß√£o
3.  **Argumentos**: valores, par√¢metros ou express√µes onde a fun√ß√£o atuar√°
4.  **V√≠rgulas**: separam os argumentos

Os argumentos de uma fun√ß√£o podem ser de dois tipos:

1.  **Valores ou objetos**: a fun√ß√£o alterar√° os valores em si ou os valores atribu√≠dos aos objetos
2.  **Par√¢metros**: valores fixos que informam um m√©todo ou a realiza√ß√£o de uma opera√ß√£o. Informa-se o nome desse argumento, seguido de "=" e um n√∫mero, texto ou TRUE ou FALSE

Alguns exemplos de argumentos como valores ou objetos.

```{r}
## Fun√ß√µes - argumentos como valores
sum(10, 2)

## Fun√ß√µes - argumentos como objetos
sum(va1, va2)
```

Vamos ver agora alguns exemplos de argumentos usados como par√¢metros. Note que apesar do valor do argumento ser o mesmo (10), seu efeito no resultado da fun√ß√£o `rep()`` muda drasticamente. Aqui tamb√©m √© importante destacar um ponto: i) podemos informar os argumentos sequencialmente, sem explicitar seus nomes, ou ii) independente da ordem, mas explicitando seus nomes. Entretanto, como no exemplo abaixo, devemos informar o nome do argumento (i.e., par√¢metro), para que seu efeito seja o que desejamos.

```{r}
## Fun√ß√µes - argumentos como par√¢metros
## Repeti√ß√£o - repete todos os elementos
rep(x = 1:5, times = 10)

## Repeti√ß√£o - repete cada um dos elementos
rep(x = 1:5, each = 10)
```

Um ponto fundamental e que deve ser entendido nesse ponto, √© o fluxo de atribui√ß√µes do resultado da opera√ß√£o de fun√ß√µes a novos objetos. No desenvolvimento de qualquer script na linguagem R, grande parte da estrutura do mesmo ser√° dessa forma: atribui√ß√£o de dados a objetos > opera√ß√µes com fun√ß√µes > atribui√ß√£o dos resultados a novos objetos > opera√ß√µes com fun√ß√µes desses novos objetos > atribui√ß√£o dos resultados a novos objetos. Ao entender esse funcionamento, come√ßamos a entender como devemos pensar na organiza√ß√£o do nosso script para montar as an√°lises que precisamos.

```{r}
## Atribuic√£o dos resultados
## Repeti√ß√£o
rep_times <- rep(1:5, times = 10)
rep_times

## Somar e atribuir
rep_times_soma <- sum(rep_times)
rep_times_soma

## Raiz e atribuir
rep_times_soma_raiz <- sqrt(rep_times_soma)
rep_times_soma_raiz
```

Por fim, √© fundamental tamb√©m entender a origem das fun√ß√µes que usamos no R. Todas as fun√ß√µes s√£o advindas de pacotes. Esses pacotes possuem duas origens.

1.  pacotes j√° instalados por padr√£o e que s√£o carregados quando abrimos o R (*R Base*)
2.  pacotes que instalamos e carregamos com fun√ß√µes

### Pacotes

Pacotes s√£o conjuntos extras de fun√ß√µes para executar tarefas espec√≠ficas, al√©m dos pacotes instalados no *R Base*. Existe literalmente milhares de pacotes (~19,000 enquanto escrever esse livro) para as mais diversas tarefas: estat√≠stica, ecologia, geografia, sensoriamento remoto, econometria, ci√™ncias sociais, gr√°ficos, *machine learning*, etc. Podemos verificar este vasto conjunto de pacotes pelo [link](https://cran.r-project.org/web/packages/available_packages_by_name.html) que lista por nome os pacotes oficiais, ou seja, que passaram pelo crivo do **CRAN**. Existem ainda muito mais pacotes em desenvolvimento, geralmente disponibilizados em reposit√≥rios do **GitHub** ou **GitLab**.

Podemos listar esses pacotes dispon√≠veis no **CRAN** com esse c√≥digo.

```{r}
## N√∫mero atual de pacotes no CRAN
nrow(available.packages())
```

Primeiramente, com uma sess√£o do R sem carregar nenhum pacote extra, podemos verificar pacotes carregados pelo *R Base* utilizando a fun√ß√£o `search()`.

```{r eval=FALSE}
## Verificar pacotes carregados
search()
```

Podemos ainda verificar todos pacotes instalados em nosso computador com a fun√ß√£o `library()`.

```{r eval=FALSE}
## Verificar pacotes instalados
library()
```

No R, quando tratamos de pacotes, devemos destacar a diferen√ßa de dois conceitos: instalar um pacote e carregar um pacote. A instala√ß√£o de pacotes possui algumas caracter√≠sticas:

-   Instala-se um pacote apenas uma vez
-   Precisamos estar conectados √† internet
-   O nome do pacote precisa estar entre aspas na fun√ß√£o de instala√ß√£o
-   Fun√ß√£o (CRAN): `install.packages()`

Vamos instalar o pacote `vegan` diretamente do CRAN, que possui fun√ß√µes para realizar uma s√©rie de an√°lise em ecologia (veja mais no Cap√≠tulo \@ref(cap10)). Para isso, podemos ir em `Tools > Install Packages...`, ou ir na aba **Packages** (Figura \@ref(fig:fig-rstudio) janela 4), procurar o pacote e simplesmente clicar em "Install". Podemos ainda utilizar a fun√ß√£o `install.packages()`.

```{r eval=FALSE}
## Instalar pacotes
install.packages("vegan")
```

Podemos conferir em que diret√≥rios um pacote ser√° instalado com a fun√ß√£o `.libPaths()`.

```{r}
## Diret√≥rios de intala√ß√£o dos pacotes
.libPaths()
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Uma vez instalado um pacote, n√£o h√° necessidade de instal√°-lo novamente. Entretanto, todas √†s vezes que iniciarmos uma sess√£o no R, precisamos carregar os pacotes com as fun√ß√µes que precisamos utilizar.
:::

O carregamento de pacotes possui algumas caracter√≠sticas:

-   Carrega-se o pacote toda vez que se abre uma nova sess√£o do R
-   N√£o precisamos estar conectados √† internet
-   O nome do pacote n√£o precisa estar entre aspas na fun√ß√£o de carregamento
-   Fun√ß√µes: `library()` ou `require()`

Vamos carregar o pacote `vegan` que instalamos anteriormente. Podemos ir na aba **Packages** (Figura \@ref(fig:fig-rstudio) janela 4) e assinalar o pacote que queremos carregar ou utilizar a fun√ß√£o `library()`.

```{r message=TRUE}
## Carregar pacotes
library(vegan)
```

Como dissemos, alguns pacotes em desenvolvimento encontram-se dispon√≠veis em reposit√≥rios do [GitHub](https://github.com/), [GitLab](https://gitlab.com) e [Bioconductor](https://www.bioconductor.org/). Para instalar pacotes do GitHub, por exemplo, precisamos instalar e carregar o pacote `devtools`.

```{r eval=FALSE}
## Instalar pacote devtools
install.packages("devtools")

## Carregar pacote devtools
library(devtools)
```

Uma vez instalado e carregado esse pacote, podemos instalar o pacote do GitHub, utilizando a fun√ß√£o `devtools::install_github()`. Precisamos atentar para usar essa forma "nome_usuario/nome_repositorio", retirados do link do reposit√≥rio de interesse. Como exemplo, podemos instalar o pacote `ecodados` do reposit√≥rio do GitHub [paternogbc/ecodados](https://github.com/paternogbc/ecodados) e depois utilizar a fun√ß√£o `library()` para carreg√°-lo.

```{r eval=FALSE}
## Instalar pacote do github
devtools::install_github("paternogbc/ecodados")

## Carregar pacote do github
library("ecodados")
```

Pode ser que em algumas circunst√¢ncias iremos precisar instalar pacotes com vers√µes espec√≠ficas para algumas an√°lises. A forma mais simples de fazer isso √© instalar um pacote a partir de um arquivo compactado `.tar.gz`. Para isso podemos ir √† base do CRAN e realizar o download: <https://cran.r-project.org/src/contrib/Archive/>. Para exemplificar, vamos instalar o pacote `vegan 2.4.0`.

```{r eval=FALSE}
## Download do arquivo .tar.gz
download.file(url = "https://cran.r-project.org/src/contrib/Archive/vegan/vegan_2.4-0.tar.gz",
              destfile = "vegan_2.4-0.tar.gz", mode = "auto")

## Instalar o pacote vegan 2.4.0
install.packages("vegan_2.4-0.tar.gz", repos = NULL, type = "source")
```

Podemos ver a descri√ß√£o de um pacote com a fun√ß√£o `packageDescription()`.

```{r}
## Descri√ß√£o de um pacote
packageDescription("vegan")
```

A maioria dos pacotes possui conjuntos de dados que podem ser acessados pela fun√ß√£o `data()`. Esses conjuntos de dados podem ser usados para testar as fun√ß√µes do pacote. Se estiver com d√∫vida na maneira como voc√™ deve preparar a planilha para realizar uma an√°lise espec√≠fica, entre na Ajuda (*Help*) da fun√ß√£o e veja os conjuntos de dados que est√£o no exemplo desta fun√ß√£o. Como exemplo, vamos carregar os dados `dune` do pacote `vegan`, que s√£o dados de observa√ß√µes de 30 esp√©cies vegetais em 20 locais.

```{r}
## Carregar dados de um pacote
library(vegan)
data(dune)
dune[1:6, 1:6]
```

Se por algum motivo precisarmos desinstalar um pacote, podemos utilizar a fun√ß√£o `remove.packages()`. J√° para descarregar um pacote de uma sess√£o do R, podemos usar a fun√ß√£o `detach()`.

```{r eval=FALSE}
## Desinstalar um pacote
remove.packages("vegan")

## Descarregar um pacote
detach("package:vegan", unload = TRUE)
```

E um √∫ltimo ponto fundamental sobre pacotes, diz respeito √† atualiza√ß√£o dos mesmos. Os pacotes s√£o atualizados com frequ√™ncia, e infelizmente (ou felizmente, pois as atualiza√ß√µes podem oferecer algumas quebras entre pacotes), n√£o se atualizam sozinhos. Muitas vezes, a instala√ß√£o de um pacote pode depender da vers√£o dos pacotes dependentes, e geralmente uma janela com diversas op√ß√µes num√©ricas se abre perguntando se voc√™ quer que todos os pacotes dependentes sejam atualizados. Podemos ir na aba **Packages** (Figura \@ref(fig:fig-rstudio) janela 4) e clicar em "Update" ou usar a fun√ß√£o `update.packages(checkBuilt = TRUE, ask = FALSE)` para atualiz√°-los, entretanto, essa √© uma fun√ß√£o que costuma demorar muito para terminar de ser executada.

```{r eval=FALSE}
## Atualiza√ß√£o dos pacotes
update.packages(checkBuilt = TRUE, ask = FALSE)
```

Para fazer a atualiza√ß√£o dos pacotes instalados pelo GitHub, recomendamos o uso do pacote [`dtupdate`](https://github.com/hrbrmstr/dtupdate).

```{r eval = FALSE}
## Atualiza√ß√£o dos pacotes instalados pelo GitHub
dtupdate::github_update(auto.install = TRUE, ask = FALSE)
```

Destacamos e incentivamos ainda uma pr√°tica que achamos interessante para aumentar a reprodutibilidade de nossos c√≥digos e scripts: a de chamar as fun√ß√µes de pacotes carregados dessa forma `pacote::fun√ß√£o()`. Com o uso dessa pr√°tica, deixamos claro o pacote em que a fun√ß√£o est√° implementada. Esta pr√°tica √© importante por que com frequ√™ncia pacotes diferentes criam fun√ß√µes com mesmo nome, mas com caracter√≠sticas internas (argumentos) diferentes. Assim, n√£o expressar o pacote de interesse pode gerar erros na execu√ß√£o de suas an√°lises. Destacamos aqui o exemplo de como instalar pacotes do GitHub do pacote `devtools`.

```{r eval=FALSE}
## Pacote seguido da fun√ß√£o implementada daquele pacote
devtools::install_github()
```

### Ajuda (*Help*)

Um importante passo para melhorar a usabilidade e ter mais familiaridade com a linguagem R √© aprender a usar a ajuda (*help*) de cada fun√ß√£o. Para tanto, podemos utilizar a fun√ß√£o `help()` ou o operador `?`, depois de ter carregado o pacote, para abrir uma nova aba (Figura \@ref(fig:fig-rstudio) janela 4) que possui diversas informa√ß√µes sobre a fun√ß√£o de interesse. O arquivo de ajuda do R possui geralmente nove ou dez t√≥picos, que nos auxiliam muito no entendimento dos dados de entrada, argumentos e que opera√ß√µes est√£o sendo realizadas. Abaixo descrever esses t√≥picos:

-   **Description**: resumo da fun√ß√£o
-   **Usage**: como utilizar a fun√ß√£o e quais os seus argumentos
-   **Arguments**: detalha os argumentos e como os mesmos devem ser especificados
-   **Details**: detalhes importantes para se usar a fun√ß√£o
-   **Value**: mostra como interpretar a sa√≠da (*output*) da fun√ß√£o (os resultados)
-   **Note**: notas gerais sobre a fun√ß√£o
-   **Authors**: autores da fun√ß√£o
-   **References**: refer√™ncias bibliogr√°ficas para os m√©todos usados para constru√ß√£o da fun√ß√£o
-   **See also**: fun√ß√µes relacionadas
-   **Examples**: exemplos do uso da fun√ß√£o. √Äs vezes pode ser √∫til copiar esse trecho e colar no R para ver como funciona e como usar a fun√ß√£o.

Vamos realizar um exemplo, buscando o `help` da fun√ß√£o `aov()`, que realiza uma an√°lise de vari√¢ncia (veja detalhes no Cap√≠tulo \@ref(cap8)).

```{r eval=FALSE}
## Ajuda
help(aov)
?aov
```

Al√©m das fun√ß√µes, podemos buscar detalhes de um pacote espec√≠fico, para uma p√°gina simples do `help` utilizando a fun√ß√£o `help()` ou o operador `?`. Entretanto, para uma op√ß√£o que ofere√ßa uma descri√ß√£o detalhada e um √≠ndice de todas as fun√ß√µes do pacote, podemos utilizar a fun√ß√£o `library()`, mas agora utilizando o argumento `help`, indicando o pacote de interesse entre aspas.

```{r eval=FALSE}
## Ajuda do pacote
help(vegan)
?vegan

## Help detalhado
library(help = "vegan")
```

Podemos ainda procurar o nome de uma fun√ß√£o para realizar uma an√°lise espec√≠fica utilizando a fun√ß√£o `help.search()` com o termo que queremos em ingl√™s e entre aspas.

```{r eval=FALSE}
## Procurar por fun√ß√µes que realizam modelos lineares
help.search("linear models")
```

Outra ferramenta de busca √© a p√°gina [rseek](http://www.rseek.org), na qual √© poss√≠vel buscar por um termo n√£o s√≥ nos pacotes do R, mas tamb√©m em listas de emails, manuais, p√°ginas na internet e livros sobre o programa.

### Ambiente (*Environment*)

O ambiente *Environment* como vimos √© onde os objetos criados s√£o armazenados. √â fundamental entender que um objeto √© uma aloca√ß√£o de um pequeno espa√ßo na mem√≥ria RAM do nosso computador, onde o R armazenar√° um valor ou o resultado de uma fun√ß√£o, utilizando o nome dos objetos que definimos na atribui√ß√£o. Sendo assim, se fizermos uma atribui√ß√£o de um objeto maior que o tamanho da mem√≥ria RAM do nosso computador, esse objeto n√£o ser√° alocado, e a atribui√ß√£o n√£o funcionar√°, retornando um erro. Existem op√ß√µes para contornar esse tipo de limita√ß√£o, mas n√£o a abordaremos aqui. Entretanto, podemos utilizar a fun√ß√£o `object.size()` para saber quanto espa√ßo nosso objeto criado est√° alocando de mem√≥ria RAM.

```{r}
## Tamanho de um objeto
object.size(adi)
```

Podemos listar todos os objetos criados com a fun√ß√£o `ls()` ou `objects()`.

```{r eval=FALSE}
## Listar todos os objetos
ls()
```

Podemos ainda remover todos os objetos criados com a fun√ß√£o `rm()` ou `remove()`. Ou ainda fazer uma fun√ß√£o composta para remover todos os objetos do *Environment*.

```{r}
## Remover um objeto
rm(adi)

## Remover todos os objetos criados
rm(list = ls())
```

Quando usamos a fun√ß√£o `ls()` agora, nenhum objeto √© listado.

```{r}
## Listar todos os objetos
ls()
```

Toda a vez que fechamos o R os objetos criados s√£o apagados do **Environment**. Dessa forma, em algumas ocasi√µes, por exemplo, an√°lises estat√≠sticas que demoram um grande tempo para serem realizadas, pode ser interessante exportar alguns ou todos os objetos criados. 

Para salvar todos os objetos, ou seja, todo o *Workspace*, podemos ir em `Session -> Save Workspace As...` e escolher o nome do arquivo do *Workspace*, por exemplo, "meu_workspace.RData". Podemos ainda utilizar fun√ß√µes para essas tarefas. A fun√ß√£o `save.image()` salva todo *Workspace* com a extens√£o `.RData`.

```{r eval=FALSE}
## Salvar todo o workspace
save.image(file = "meu_workspace.RData")
```

Depois disso, podemos fechar o RStudio tranquilamente e quando formos trabalhar novamente, podemos carregar os objetos criados indo em `Session -> Load Workspace...` ou utilizando a fun√ß√£o `load()`.

```{r eval=FALSE}
## Carregar todo o workspace
load("meu_workspace.RData")
```

Entretanto, em algumas ocasi√µes, n√£o precisamos salvar todos os objetos. Dessa forma, podemos salvar apenas alguns objetos espec√≠ficos usando a fun√ß√£o `save()`, tamb√©m com a extens√£o `.RData`.

```{r eval=FALSE}
## Salvar apenas um objeto
save(obj1, file = "meu_obj.RData")

## Salvar apenas um objeto
save(obj1, obj2, file = "meus_objs.RData")

## Carregar os objetos
load("meus_objs.RData")
```

Ou ainda podemos salvar apenas um objeto com a extens√£o `.rds`. Para isso, usamos as fun√ß√µes `saveRDS()` e `readRDS()`, para exportar e importar esses dados, respectivamente. √â importante ressaltar que nesse formato `.rds`, apenas um objeto √© salvo por arquivo criado e que para que o objeto seja criado no *Workspace* do R, ele precisa ser lido e atribu√≠do √† um objeto.

```{r eval=FALSE}
## Salvar um objeto para um arquivo
saveRDS(obj, file = "meu_obj.rds")

## Carregar esse objeto
obj <- readRDS(file = "meu_obj.rds")
```

### Cita√ß√µes

Ao utilizar o R para realizar alguma an√°lise em nossos estudos, √© fundamental a cita√ß√£o do mesmo. Para saber como citar o R em artigos, existe uma fun√ß√£o denominada `citation()`, que prov√™ um formato gen√©rico de cita√ß√£o e um BibTeX para arquivos LaTeX e R Markdown.

```{r}
## Cita√ß√£o do R
citation()
```

No resultado dessa fun√ß√£o, h√° uma mensagem muito interessante: "See also 'citation("pkgname")' for citing R packages.". Dessa forma, aconselhamos, sempre que poss√≠vel, claro, citar tamb√©m os pacotes utilizados nas an√°lises para dar os devidos cr√©ditos aos desenvolvedores e desenvolvedoras das fun√ß√µes implementadas nos pacotes. Como exemplo, vamos ver como fica a cita√ß√£o do pacote `vegan`.

```{r}
## Cita√ß√£o do pacote vegan
citation("vegan")
```

Podemos ainda utilizar a fun√ß√£o `write_bib()` do pacote `knitr` para exportar a cita√ß√£o do pacote no formato `.bib`.

```{r eval=FALSE}
## Exportar uma cita√ß√£o em formato .bib
knitr::write_bib("vegan", file = "vegan_ex.bib")
```

### Principais erros de iniciantes

Errar quando est√° come√ßando a usar o R √© muito comum e faz parte do aprendizado. Entretanto, os erros nunca devem ser encarados como uma forma de desest√≠mulo, mas sim como um desafio para continuar tentando. Todos n√≥s, autores desse livro, e provavelmente usu√°rios mais ou menos experientes, j√° passaram por um momento em que se quer desistir de tudo. Jovem aprendiz de R, a √∫nica diferen√ßa entre voc√™ que est√° iniciando agora e n√≥s que usamos h√° mais tempo s√£o as horas a mais de uso (e √≥dio). O que temos a mais √© experi√™ncia para olhar o erro, l√™-lo e conseguir interpretar o que est√° errado e saber buscar ajuda.

Dessa forma, o ponto mais importante de quem est√° iniciando √© ter paci√™ncia, calma, bom humor, ler e entender as mensagens de erros. Recomendamos uma pr√°tica que pode ajudar: caso n√£o esteja conseguindo resolver alguma parte do seu c√≥digo, deixe ele de lado um tempo, descance, fa√ßa uma caminhada, tome um banho, converse com seus animais de estima√ß√£o ou plantas, tenha um pato de borracha ou outro objeto inanimado (um dos autores tem um sapinho de madeira), explique esse c√≥digo para esse pato (processo conhecido como [Debug com Pato de Borracha](https://pt.wikipedia.org/wiki/Debug_com_Pato_de_Borracha)), logo a solu√ß√£o deve aparecer.

Listaremos aqui o que consideramos os principais erros dos iniciantes no R.

**1. Esquecer de completar uma fun√ß√£o ou bloco de c√≥digos**

Esquecer de completar uma fun√ß√£o ou bloco de c√≥digos √© algo bem comum. Geralmente esquecemos de fechar aspas `""` ou par√™nteses `()`, mas geralmente o R nos informa isso, indicando um s√≠mbolo de `+` no console. Se voc√™ cometeu esse erro, lembre-se de apertar a tecla esc do seu computador clicando antes com o cursor do mouse no console do R.

```{r error=TRUE}
sum(1, 2
  +
```

**2. Esquecer de v√≠rgulas dentro de fun√ß√µes**

Outro erro bastante comum √© esquecer de acrescentar a v√≠rgula `,` para separar argumentos dentro de uma fun√ß√£o, principalmente se estamos compondo v√°rias fun√ß√µes acopladas, i.e., uma fun√ß√£o dentro da outra.

```{r error=TRUE}
sum(1 2)
```

**3. Chamar um objeto pelo nome errado**

Pode parecer simples, mas esse √© de longe o erro mais comum que pessoas iniciantes comentem. Quando temos um script longo, √© de se esperar que tenhamos atribu√≠do diversos objetos e em algum momento atribu√≠mos um nome do qual n√£o lembramos. Dessa forma, quando chamamos o objeto ele n√£o existe e o console informa um erro. Entretanto, esse tipo de erro pode ser facilmente identificado, como o exemplo abaixo.

```{r error=TRUE}
obj <- 10
OBJ
```

**4. Esquecer de carregar um pacote**

Esse tamb√©m √© um erro recorrente, mesmo para usu√°rios mais experientes. Em scripts de an√°lises complexas, que requerem v√°rios pacotes, geralmente esquecemos de um ou outro pacote. A melhor forma de evitar esse tipo de erro √© listar os pacotes que vamos precisar usar logo no in√≠cio do script.

```{r echo=FALSE}
detach("package:vegan", unload = TRUE, force = TRUE)
```

```{r error=TRUE}
## Carregar dados
data(dune)

## Fun√ß√£o do pacote vegan
decostand(dune[1:6, 1:6], "hell")
```

Geralmente a mensagem de erro ser√° de que a fun√ß√£o n√£o foi encontrada ou algo nesse sentido. Carregando o pacote, esse erro √© contornado.

```{r}
## Carregar o pacote
library(vegan)

## Carregar dados
data(dune)

## Fun√ß√£o do pacote vegan
decostand(dune[1:6, 1:6], "hell")
```

**5. Usar o nome da fun√ß√£o de forma err√¥nea**

Esse erro n√£o √© t√£o comum, mas pode ser inc√¥modo √†s vezes. Algumas fun√ß√µes possuem nomes no padr√£o "Camel Case", i.e., com letras mai√∫sculas no meio do nome da fun√ß√£o. Isso √†s vezes pode confundir, ou ainda, as fun√ß√µes podem ou n√£o ser separadas com `.`, como `row.names()` e `rownames()`. No Cap√≠tulo \@ref(cap5) sobre *tidyverse*, veremos que houve uma tentativa de padroniza√ß√£o nos nomes das fun√ß√µes para "Snake Case", i.e, todas as fun√ß√µes possuem letras min√∫sculas, com palavras separadas por *underscore* `_`.

```{r error=TRUE}
## Soma das colunas
colsums(dune)
```

```{r}
## Soma das colunas
colSums(dune)
```

**6. Atentar para o diret√≥rio correto**

Muitas vezes o erro √© simplesmente porque o usu√°rio(a) n√£o definiu o diret√≥rio correto onde est√° o arquivo a ser importado ou exportado. Por isso √© fundamental sempre verificar se o diret√≥rio foi definido corretamente, geralmente usando as fun√ß√µes `dir()` ou `list.files()` para listar no console a lista de arquivos no diret√≥rio. Podemos ainda usar o argumento `pattern` para listar arquivos por um padr√£o textual.

```{r eval=FALSE}
## Listar os arquivos do diret√≥rio definido
dir()
list.files()

## Listar os arquivos do diret√≥rio definido por um padr√£o
dir(pattern = ".csv")
```

Al√©m disso, √© fundamental ressaltar a import√¢ncia de verificar se o nome do arquivo que importaremos foi digitado corretamente, atentando-se tamb√©m para a extens√£o: `.csv`, `.txt`, `.xlsx`, etc.

## Estrutura e manipula√ß√£o de objetos

O conhecimento sobre a estrutura e manipula√ß√£o de objetos √© fundamental para ter dom√≠nio e entendimento do funcionamento da linguagem R. Nesta se√ß√£o, trataremos da estrutura e manipula√ß√£o de dados no R, no que ficou conhecido como modo *R Base*, em contrapartida ao *tidyverse*, t√≥pico tratado no Cap√≠tulo \@ref(cap5). Abordaremos aqui temas chaves, como: i) atributos de objetos, ii) manipula√ß√£o de objetos unidimensionais e multidimensionais, iii) valores faltantes e especiais, iv) diret√≥rio de trabalho e v) importar, conferir e exportar dados tabulares.

### Atributo dos objetos

Quando fazemos atribui√ß√µes de dados no R (`<-`), os objetos gerados possuem tr√™s caracter√≠sticas.

1.  **Nome**: palavra que o R reconhece os dados atribu√≠dos
2.  **Conte√∫do**: dados em si
3.  **Atributos**: modos (*natureza*) e estruturas (*organiza√ß√£o*) dos elementos

Vamos explorar mais a fundo os **modos** e **estruturas** dos objetos. Vale ressaltar que isso √© uma simplifica√ß√£o, pois h√° muitas classes de objetos, como fun√ß√µes e sa√≠das de fun√ß√µes que possuem outros atributos.

Podemos verificar os atributos dos objetos com a fun√ß√£o `attributes()`.

```{r}
## Atributos
attributes(dune)
```

**Modo dos objetos**

A depender da natureza dos elementos que comp√µem os dados e que foram atribu√≠dos aos objetos, esses objetos podem ser, de forma simples um dos cinco modos: num√©rico do tipo inteiro (*integer*), num√©rico do tipo flutuante (*double*), texto (*character*), l√≥gico (*logical*) ou complexo (*complex*).

A atribui√ß√£o de n√∫meros no R podem gerar dois tipos de modos: integer para n√∫meros inteiros e double para n√∫meros flutuantes ou com decimais.

```{r}
## Num√©rico double
obj_numerico_double <- 1

## Modo
mode(obj_numerico_double)

## Tipo
typeof(obj_numerico_double)
```

A t√≠tulo de praticidade, ambos s√£o incorporados como o modo numeric, com o tipo double, a menos que especifiquemos que seja inteiro com a letra `L` depois do n√∫mero, representando a palavra *Larger*, geralmente usando para armazenar n√∫meros muito grandes.

```{r}
## Num√©rico integer
obj_numerico_inteiro <- 1L

## Modo
mode(obj_numerico_inteiro)

## Tipo
typeof(obj_numerico_inteiro)
```

Al√©m de n√∫meros, podemos atribuir textos, utilizando para isso aspas `""`.

```{r}
## Caracter ou string
obj_caracter <- "a" # atencao para as aspas

## Modo
mode(obj_caracter)
```

Em algumas situa√ß√µes, precisamos indicar a ocorr√™ncia ou n√£o de um evento ou uma opera√ß√£o. Para isso, utilizamos as palavras reservadas (`TRUE` e `FALSE`), chamadas de vari√°veis booleanas, pois assumem apenas duas possibilidades: falso (0) ou verdadeiro (1). Devemos nos ater para o fato dessas palavras serem escritas com letras mai√∫sculas e sem aspas.

```{r}
## L√≥gico
obj_logico <- TRUE # maiusculas e sem aspas

## Modo
mode(obj_logico)
```

Por fim, existe um modo pouco utilizado que cria n√∫meros complexos (raiz de n√∫meros negativos).

```{r}
## Complexo
obj_complexo <- 1+1i

## Modo
mode(obj_complexo)
```

Podemos verificar o modo dos objetos ou fazer a convers√£o entre esses modos com diversas fun√ß√µes.

```{r eval=FALSE}
## Verificar o modo dos objetos
is.numeric()
is.integer()
is.character()
is.logical()
is.complex()

## Convers√µes entre modos
as.numeric()
as.integer()
as.character()
as.logical()
as.complex()

## Exemplo
num <- 1:5
num
class(num)

fac <- as.factor(num)
fac
class(fac)
```

**Estrutura dos objetos**

Uma vez entendido a natureza dos modos dos elementos dos objetos no R, podemos passar para o passo seguinte e entender como esses elementos s√£o estruturados dentro dos objetos.

Essa estrutura√ß√£o ir√° nos contar sobre a organiza√ß√£o dos elementos, com rela√ß√£o aos modos e dimensionalidade da disposi√ß√£o dos elementos (Figura \@ref(fig:fig-r-estruturas)). De modo bem simples, os elementos podem ser estruturados em cinco tipos:

1.  **Vetores e fatores**: homog√™neo (*um modo*) e unidimensional (*uma dimens√£o*). Um tipo especial de vetor s√£o os fatores, usados para designar vari√°veis categ√≥ricas
2.  **Matrizes**: homog√™neo (*um modo*) e bidimensional (*duas dimens√µes*)
3.  **Arrays**: homog√™neo (*um modo*) e multidimensional (*mais de duas dimens√µes*)
4.  **Data frames**: heterog√™neo (*mais de um modo*) e bidimensional (*duas dimens√µes*)
5.  **Listas**: heterog√™neo (*mais de um modo*) e unidimensional (*uma dimens√£o*)

```{r fig-r-estruturas, echo=FALSE, fig.cap="Estruturas de dados mais comuns no R: vetores, matrizes, arrays, listas e data frames. Adaptado de: [@grolemund2014]."}
knitr::include_graphics("img/cap04_fig03.png")
```

**Vetor**

Vetores representam o encadeamento de elementos numa sequ√™ncia unidimensional. No Cap√≠tulo \@ref(cap2) na Figura \@ref(fig:fig-box), vimos o conceito de vari√°vel aleat√≥ria e seus tipos. No R, essas vari√°veis podem ser operacionalizadas como vetores. Dessa forma, essa estrutura de dados pode ser traduzida como medidas de uma vari√°vel num√©rica (discretas ou cont√≠nuas), vari√°vel bin√°ria (booleana - TRUE e FALSE) ou descri√ß√£o (informa√ß√µes em texto).

H√° diversas formas de se criar um vetor no R:

1.  Concatenando elementos com a fun√ß√£o `c()`
2.  Criando sequ√™ncias unit√°rias `:` ou com a fun√ß√£o `seq()`
3.  Criando repeti√ß√µes com a fun√ß√£o `rep()`
4.  "Colar" palavras com uma sequ√™ncia num√©rica com a fun√ß√£o `paste()` ou `paste0()`
5.  Amostrando aleatoriamente elementos com a fun√ß√£o `sample()`

```{r}
## Concatenar elementos num√©ricos
concatenar <- c(15, 18, 20, 22, 18)
concatenar

## Sequ√™ncia unit√°ria (x1:x2)
sequencia <- 1:10
sequencia

## Sequ√™ncia com diferentes espa√ßamentos 
sequencia_esp <- seq(from = 0, to = 100, by = 10) 
sequencia_esp

## Repeti√ß√£o
repeticao <- rep(x = c(TRUE, FALSE), times = 5)
repeticao

## Cola palavra e sequ√™ncia num√©rica
colar <- paste("amostra", 1:5)
colar

## Amostragem aleat√≥ria
amostragem <- sample(x = 1:100, size = 10)
amostragem
```

Como os vetores s√£o homog√™neos, i.e., s√≥ comportam um modo, quando combinamos mais de um modo no mesmo objeto ocorre uma domin√¢ncia de modos. Existe, dessa forma, uma **coer√ß√£o** dos elementos combinados para que todos fiquem iguais. Essa domin√¢ncia segue essa ordem:

> **`DOMINANTE`** character > double > integer > logical **`RECESSIVO`**

Al√©m disso, podemos utilizar as convers√µes listadas anteriormente para alterar os modos. Vamos exemplificar combinando os vetores criados anteriormente e convertendo-os.

```{r}
## Coer√ß√£o
c(colar, amostragem)

## Convers√£o
as.numeric(repeticao)
```

**Fator**

O fator representa medidas de uma vari√°vel categ√≥rica, podendo ser nominal ou ordinal. √â fundamental destacar que fatores no R devem ser entendidos como um vetor de **integer**, i.e., ele √© composto por n√∫meros inteiros representando os n√≠veis da vari√°vel categ√≥rica.

Para criar um fator no R usamos uma fun√ß√£o espec√≠fica `factor()`, na qual podemos especificar os **n√≠veis** com o argumento `level`, ou fazemos uma convers√£o usando a fun√ß√£o `as.factor()`. Trabalhar com fatores no *R Base* n√£o √© das tarefas mais agrad√°veis, sendo assim, no Cap√≠tulo \@ref(cap5) usamos a vers√£o *tidyverse* usando o pacote `forcats`. Destacamos ainda a exist√™ncia de fatores nominais para vari√°veis categ√≥ricas nominais e fatores ordinais para vari√°veis categ√≥ricas ordinais, quando h√° ordenamento entre os n√≠veis, como dias da semana ou classes de altura.

```{r}
## Fator nominal
fator_nominal <- factor(x = sample(x = c("floresta", "pastagem", "cerrado"), 
                                   size = 20, replace = TRUE),
                        levels = c("floresta", "pastagem", "cerrado"))
fator_nominal

## Fator ordinal
fator_ordinal <- factor(x = sample(x = c("baixa", "media", "alta"), 
                                   size = 20, replace = TRUE),
                        levels = c("baixa", "media", "alta"), ordered = TRUE)
fator_ordinal

## Convers√£o
fator <- as.factor(x = sample(x = c("floresta", "pastagem", "cerrado"), 
                              size = 20, replace = TRUE))
fator
```

**Matriz**

A matriz representa dados no formato de tabela, com linhas e colunas. As linhas geralmente representam unidades amostrais (locais, transectos, parcelas) e as colunas representam vari√°veis num√©ricas (discretas ou cont√≠nuas), vari√°veis bin√°rias (TRUE ou FALSE) ou descri√ß√µes (informa√ß√µes em texto).

Podemos criar matrizes no R de duas formas. A primeira delas dispondo elementos de um vetor em um certo n√∫mero de linhas e colunas com a fun√ß√£o `matrix()`, podendo preencher essa matriz com os elementos do vetor por linhas ou por colunas alterando o argumento `byrow`.

```{r}
## Vetor
ve <- 1:12

## Matrix - preenchimento por linhas - horizontal
ma_row <- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE)
ma_row

## Matrix - preenchimento por colunas - vertical
ma_col <- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE)
ma_col
```

A segundo forma, podemos combinar vetores, utilizando a fun√ß√£o `rbind()` para combinar vetores por linha, i.e., um vetor embaixo do outro, e `cbind()` para combinar vetores por coluna, i.e., um vetor ao lado do outro.

```{r}
## Criar dois vetores
vec_1 <- c(1, 2, 3)
vec_2 <- c(4, 5, 6)

## Combinar por linhas - vertical - um embaixo do outro
ma_rbind <- rbind(vec_1, vec_2)
ma_rbind

## Combinar por colunas - horizontal - um ao lado do outro
ma_cbind <- cbind(vec_1, vec_2)
ma_cbind
```

**Array**

O array representa combina√ß√£o de tabelas, com linhas, colunas e dimens√µes. Essa combina√ß√£o pode ser feita em m√∫ltiplas dimens√µes, mas apesar disso, geralmente √© mais comum o uso em Ecologia para tr√™s dimens√µes, por exemplo: linhas (unidades amostrais), colunas (esp√©cies) e dimens√£o (tempo). Isso gera um "cubo m√°gico" ou "cartas de um baralho", onde podemos comparar, nesse caso, comunidades ao longo do tempo. Al√©m disso, arrays tamb√©m s√£o muito comuns em morfometria geom√©trica ou sensoriamento remoto.

Podemos criar arrays no R dispondo elementos de um vetor em um certo n√∫mero de linhas, colunas e dimens√µes com a fun√ß√£o `array()`. Em nosso exemplo, vamos compor cinco comunidades de cinco esp√©cies ao longo de tr√™s per√≠odos.

```{r}
## Array
ar <- array(data = sample(x = c(0, 1), size = 75, rep = TRUE), 
            dim = c(5, 5, 3))
ar
```

**Data frame**

O data frame tamb√©m representa dados no formato de tabela, com linhas e colunas, muito semelhante √† matriz. Mas diferentemente das matrizes, os data frames comportam mais de um modo em suas colunas. Dessa forma, as linhas do data frame ainda representam unidades amostrais (locais, transectos, parcelas), mas as colunas agora podem representar descri√ß√µes (informa√ß√µes em texto), vari√°veis num√©ricas (discretas ou cont√≠nuas), vari√°veis bin√°rias (TRUE ou FALSE) e vari√°veis categ√≥ricas (nominais ou ordinais).

A forma mais simples de se criar data frames no R √© atrav√©s da combina√ß√£o de vetores. Essa combina√ß√£o √© feita com a fun√ß√£o `data.frame()` e ocorre de forma horizontal, semelhante √† fun√ß√£o `cbind()`. Sendo assim, todos os vetores precisam ter o mesmo n√∫mero de elementos, ou seja, o mesmo comprimento. Podemos ainda nomear as colunas de cada vetor. Outra forma, seria converter uma matriz em um data frame, utilizando a fun√ß√£o `as.data.frame()`.

```{r}
## Criar tr√™s vetores
vec_ch <- c("sp1", "sp2", "sp3")
vec_nu <- c(4, 5, 6)
vec_fa <- factor(c("campo", "floresta", "floresta"))

## Data frame - combinar por colunas - horizontal - um ao lado do outro
df <- data.frame(vec_ch, vec_nu, vec_fa)

df

## Data frame - nomear as colunas
df <- data.frame(especies = vec_ch, 
                 abundancia = vec_nu, 
                 vegetacao = vec_fa)
df

## Data frame - converter uma matriz
ma <- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE)
ma

df_ma <- as.data.frame(ma)
df_ma
```

**Lista**

A lista √© um tipo especial de vetor que aceita objetos como elementos. Ela √© a estrutura de dados utilizada para agrupar objetos, e √© geralmente a sa√≠da de muitas fun√ß√µes.

Podemos criar listas atrav√©s da fun√ß√£o `list()`. Essa fun√ß√£o funciona de forma semelhante √† fun√ß√£o `c()` para a cria√ß√£o de vetores, mas agora estamos concatenando objetos. Podemos ainda nomear os elementos (objetos) que estamos combinando.

Um ponto interessante para entender data frames, √© que eles s√£o listas, em que todos os elementos (colunas) possuem o mesmo n√∫mero de elementos, ou seja, mesmo comprimento.

```{r}
## Lista
lista <- list(rep(1, 20), # vector
              factor(1, 1), # factor
              cbind(c(1, 2), c(1, 2))) # matrix
lista

## Lista - nomear os elementos
lista_nome <- list(vector = rep(1, 20), # vector
              factor = factor(1, 1), # factor
              matrix = cbind(c(1, 2), c(1, 2))) # matrix
lista_nome
```

**Fun√ß√µes**

Uma √∫ltima estrutura de objetos criados no R s√£o as fun√ß√µes. Elas s√£o objetos criados pelo usu√°rio e reutilizados para fazer opera√ß√µes espec√≠ficas. A cria√ß√£o de fun√ß√µes geralmente √© um t√≥pico tratado num segundo momento, quando o usu√°rio de R adquire certo conhecimento da linguagem. Aqui abordaremos apenas seu funcionamento b√°sico, diferenciando sua estrutura para entendimento e sua diferencia√ß√£o das demais estruturas. 

Vamos criar uma fun√ß√£o simples que retorna a multiplica√ß√£o de dois termos. Criaremos a fun√ß√£o com o nome `multi`, √† qual ser√° atribu√≠da uma fun√ß√£o com o nome `function()`, com dois argumentos `x` e `y`. Depois disso abrimos chaves `{}`, que √© onde iremos incluir nosso bloco de c√≥digo. Nosso bloco de c√≥digo √© composto por duas linhas, a primeira contendo a opera√ß√£o de multiplica√ß√£o dos argumento com a atribui√ß√£o ao objeto `mu` e a sugunda contendo a fun√ß√£o `return()` para retornar o valor da multiplica√ß√£o.

```{r}
## Criar uma fun√ß√£o
multi <- function(x, y){
  
  mu <- (x * y)
  return(mu)
 
}
multi

## Uso da fun√ß√£o
multi(42, 23)
```

### Manipula√ß√£o de objetos unidimensionais

Vamos agora explorar formas de manipular elementos de objetos unidimensionais, ou seja, vetores, fatores e listas.

A primeira forma de manipula√ß√£o √© atrav√©s da **indexa√ß√£o**, utilizando os operadores `[]`. Com a indexa√ß√£o podemos acessar elementos de vetores e fatores por sua posi√ß√£o. Utilizaremos n√∫meros, sequ√™ncia de n√∫meros ou opera√ß√µes booleanas para retornar partes dos vetores ou fatores. Podemos ainda retirar elementos dessas estruturas com o operador aritm√©tico `-`.

No exemplo a seguir, iremos fixar o ponto de partida da amostragem da fun√ß√£o `sample()`, utilizando a fun√ß√£o `set.seed(42)` (usamos 42 porque √© a resposta para a vida, o universo e tudo mais - O Guia do Mochileiro das Gal√°xias, mas poderia ser outro n√∫mero qualquer). Isso permite que o resultado da amostragem aleat√≥ria seja igual em diferentes computadores.

```{r}
## Fixar a amostragem
set.seed(42)

## Amostrar 10 elementos de uma sequ√™ncia
ve <- sample(x = seq(0, 2, .05), size = 10)
ve

## Seleciona o quinto elemento
ve[5]

## Seleciona os elementos de 1 a 5
ve[1:5]

## Retira o decimo elemento
ve[-10]

## Retira os elementos 2 a 9
ve[-(2:9)]
```

Podemos ainda fazer uma sele√ß√£o condicional do vetor. Ao utilizarmos operadores relacionais, teremos como resposta um vetor l√≥gico. Esse vetor l√≥gico pode ser utilizado dentro da indexa√ß√£o para sele√ß√£o de elementos.

```{r}
## Quais valores sao maiores que 1?
ve > 1

## Selecionar os valores acima de 1 no vetor ve
ve[ve > 1]
```

Al√©m da indexa√ß√£o, temos algumas fun√ß√µes que nos auxiliam em algumas opera√ß√µes com objetos unidimensionais, listadas na Tabela \@ref(tab:tab-tab-funcoes-conf-uni).

```{r tab-tab-funcoes-conf-uni, echo=FALSE}
knitr::kable(data.frame(
 Fun√ß√£o = c(
  "`max()`",
  "`min()`", 
  "`range()`", 
  "`length()`", 
  "`sum()`",
  "`cumsum()`",
  "`prod()`",
  "`sqrt()`",
  "`abs()`",
  "`exp()`",
  "`log()`",
  "`log1p()`",
  "`log2()`", 
  "`log10()`",
  "`mean()`", 
  "`mean.weighted()`",
  "`var()`",
  "`sd()`", 
  "`mediam()`",
  "`quantile()`", 
  "`quarters()`",
  "`IQR()`", 
  "`round()`",
  "`sort()`",
  "`order()`",
  "`rev()`",
  "`unique()`",
  "`summary()`", 
  "`cut()`",
  "`pretty()`",
  "`scale()`", 
  "`sub()`",
  "`grep()`",
  "`any()`", 
  "`all()`",
  "`which()`",
  "`subset()`", 
  "`ifelse()`"),
 Descri√ß√£o = c(
  "Valor m√°ximo", 
  "Valor m√≠nimo", 
  "Amplitude", 
  "Comprimento",
  "Soma", 
  "Soma cumulativa", 
  "Produto",
  "Raiz quadrada",
  "Valor absoluto",
  "Expoente",
  "Logaritmo natural", 
  "Logaritmo natural mais 1 *log(x + 1)*", 
  "Logaritmo base 2", 
  "Logaritmo base 10", 
  "M√©dia", 
  "M√©dia ponderada", 
  "Vari√¢ncia", 
  "Desvio Padr√£o",
  "Mediana", 
  "Quantil", 
  "Quartil", 
  "Amplitude interquartil", 
  "Arredondamento", 
  "Ordena√ß√£o",
  "Posi√ß√£o ordenada",
  "Reverso",
  "√önicos",
  "Resumo estat√≠stico", 
  "Divide vari√°vel cont√≠nua em fator",
  "Divide vari√°vel cont√≠nua em intervalos",
  "Padroniza√ß√£o e centraliza√ß√£o", 
  "Substitui caracteres", 
  "Posi√ß√£o de caracteres", 
  "Algum valor?", 
  "Todos os valores?", 
  "Quais valores?",
  "Subconjunto", 
  "Opera√ß√£o condicional")),
 align = "c",
 caption = "Fun√ß√µes para verifica√ß√£o e resumo de dados unidimensionais.")
```

Para listas, tamb√©m podemos usar a indexa√ß√£o `[]` para acessar ou retirar elementos.

```{r}
## Lista
li <- list(elem1 = 1, elem2 = 2, elem3 = 3)

## Acessar o primeiro elemento
li[1]

## Retirar o primeiro elemento
li[-1]
```

Podemos ainda usar a indexa√ß√£o dupla `[[]]` para acessar os valores desses elementos.

```{r}
## Acessar o valor do primeiro elemento
li[[1]]

## Acessar o valor do segundo elemento
li[[2]]
```

Para listas nomeadas, podemos ainda utilizar o operador `$` para acessar elementos pelo seu nome.

```{r}
## Acessar o primeiro elemento
li$elem1
```

E ainda podemos utilizar fun√ß√µes para medir o comprimento dessa lista, listar os nomes dos elementos ou ainda renomear os elementos: `length()` e `names()`.

```{r}
## Comprimento
length(li)

## Nomes
names(li)

## Renomear
names(li) <- paste0("elemento0", 1:3)
li
```

### Manipula√ß√£o de objetos multidimensionais

Da mesma forma que para objetos unidimensionais, podemos manipular elementos de objetos multidimensionais, ou seja, matrizes, data frames e arrays.

Novamente, a primeira forma de manipula√ß√£o √© atrav√©s da indexa√ß√£o, utilizando os operadores `[]`. Com a indexa√ß√£o podemos acessar elementos de matrizes, data frames e arrays por sua posi√ß√£o. Podemos ainda retirar elementos dessas estruturas com o operador aritm√©tico `-`.

Entretanto, agora temos mais de uma dimens√£o na estrutura√ß√£o dos elementos dentro dos objetos. Assim, utilizamos n√∫meros, sequ√™ncia de n√∫meros ou opera√ß√£o booleanas para retornar partes desses objetos, mas as dimens√µes t√™m de ser explicitadas e separadas por **v√≠rgulas** para acessar linhas e colunas. Essa indexa√ß√£o funciona para matrizes e data frames. Para arrays, especificamos tamb√©m as dimens√µes, tamb√©m separadas por v√≠rgulas para acessar essas dimens√µes.

```{r}
## Matriz
ma <- matrix(1:12, 4, 3)
ma

## Indexa√ß√£o
ma[3, ] # linha 3
ma[, 2] # coluna 2
ma[1, 2] # elemento da linha 1 e coluna 2
ma[1, 1:2] # elementos da linha 1 e coluna 1 e 2
ma[1, c(1, 3)] # elementos da linha 1 e coluna 1 e 3
ma[-1, ] # retirar a linha 1
ma[, -3] # retirar a coluna 3
```

Para data frames, al√©m de utilizar n√∫meros e/ou sequ√™ncias de n√∫meros dentro do operador `[]` simples, podemos utilizar o operador `[[]]` duplo para retornar apenas os valores de uma linha ou uma coluna. Se as colunas estiverem nomeadas, podemos utilizar o nome da coluna de interesse entre aspas dentro dos operadores `[]` (retornar coluna) e `[[]]` (retornar apenas os valores), assim como ainda podemos utilizar o operador `$` para data frames. Essas √∫ltimas opera√ß√µes retornam um vetor, para o qual podemos fazer opera√ß√µes de vetores ou ainda atualizar o valor dessa coluna selecionada ou adicionar outra coluna.

```{r}
## Criar tr√™s vetores
sp <- paste("sp", 1:10, sep = "")
abu <- 1:10
flo <- factor(rep(c("campo", "floresta"), each = 5))

## data frame
df <- data.frame(sp, abu, flo)
df

## [] - n√∫meros
df[, 1]

## [] - nome das colunas - retorna coluna
df["flo"]

## [[]] - nome das colunas - retorna apenas os valores
df[["flo"]]

## $ funciona apenas para data frame 
df$sp

## Opera√ß√£o de vetors
length(df$abu)

## Converter colunas
df$abu <- as.character(df$abu)
mode(df$abu)

## Adicionar ou mudar colunas
set.seed(42)
df$abu2 <- sample(x = 0:1, size = nrow(df), rep = TRUE)
df
```

Podemos ainda fazer sele√ß√µes condicionais para retornar linhas com valores que temos interesse, semelhante ao uso de filtro de uma planilha eletr√¥nica.

```{r}
## Selecionar linhas de uma matriz ou data frame 
df[df$abu > 4, ]

df[df$flo == "floresta", ]
```

Al√©m disso, h√° uma s√©rie de fun√ß√µes para confer√™ncia e manipula√ß√£o de dados que listamos na Tabela \@ref(tab:tab-funcoes-conf-multi).

```{r tab-funcoes-conf-multi, echo=FALSE}
knitr::kable(data.frame(
 Fun√ß√£o = c(
  "`head()`", 
  "`tail()`", 
  "`nrow()`", 
  "`ncol()`", 
  "`dim()`", 
  "`rownames()`",
  "`colnames()`", 
  "`str()`", 
  "`summary()`", 
  "`rowSums()`", 
  "`colSums()`", 
  "`rowMeans()`", 
  "`colMeans()`", 
  "`table()`",
  "`t()`"),
 Descri√ß√£o = c(
   "Mostra as primeiras 6 linhas", 
   "Mostra as √∫ltimas 6 linhas", 
   "Mostra o n√∫mero de linhas", 
   "Mostra o n√∫mero de colunas", 
   "Mostra o n√∫mero de linhas e de colunas", 
   "Mostra os nomes das linhas (locais)",
   "Mostra os nomes das colunas (vari√°veis)", 
   "Mostra as classes de cada coluna (estrutura)", 
   "Mostra um resumo dos valores de cada coluna", 
   "Calcula a soma das linhas (horizontal)",
   "Calcula a soma das colunas (vertical)", 
   "Calcula a m√©dia das linhas (horizontal)",
   "Calcula a m√©dia das colunas (vertical)",
   "Tabula√ß√£o cruzada",
   "Matriz ou data frame transposto")),
 align = "c",
 caption = "Fun√ß√µes para verifica√ß√£o e resumo de dados multidimensionais.")
```

### Valores faltantes e especiais

Valores faltantes e especiais s√£o valores reservados que representam dados faltantes, indefini√ß√µes matem√°ticas, infinitos e objetos nulos.

1.  **NA (*Not Available*)**: significa dado faltante ou indispon√≠vel
2.  **NaN (*Not a Number*)**: representa indefini√ß√µes matem√°ticas
3.  **Inf (*Infinito*)**: √© um n√∫mero muito grande ou um limite matem√°tico
4.  **NULL *(Nulo*)**: representa um objeto nulo, sendo √∫til para preenchimento em aplica√ß√µes de programa√ß√£o

```{r}
## Data frame com elemento NA
df <- data.frame(var1 = c(1, 4, 2, NA), var2 = c(1, 4, 5, 2))
df

## Resposta booleana para elementos NA
is.na(df)

## Algum elemento √© NA?
any(is.na(df))

## Remover as linhas com NAs
df_sem_na <- na.omit(df)
df_sem_na

## Substituir NAs por 0
df[is.na(df)] <- 0
df

## Desconsiderar os NAs em fun√ß√µes com o argumento rm.na = TRUE
sum(1, 2, 3, 4, NA, na.rm = TRUE)

## NaN - not a number
0/0
log(-1)

## Limite matem√°tico
1/0

## N√∫mero grande
10^310

## Objeto nulo
nulo <- NULL
nulo
```

### Diret√≥rio de trabalho

O diret√≥rio de trabalho √© o endere√ßo da pasta (ou diret√≥rio) de onde o R importar√° ou exportar nossos dados.

Podemos utilizar o pr√≥prio RStudio para tal tarefa, indo em `Session > Set Work Directory > Choose Directory...` ou simplesmente utilizar o atalho `Ctrl + Shift + H`.

Podemos ainda utilizar fun√ß√µes do R para definir o diret√≥rio. Para tanto, podemos navegar com o aplicativo de gerenciador de arquivos (e.g., Windows Explorer) at√© nosso diret√≥rio de interesse e copiar o endere√ßo na barra superior. Voltamos para o R e colamos esse endere√ßo entre aspas como um argumento da fun√ß√£o `setwd()`. √â fundamental destacar que em no Windows √© necess√°rio inverter as barras (`\` por `/` ou duplicar elas `\\`).

Aconselhamos ainda utilizar as fun√ß√µes `getwd()` para retornar o diret√≥rio definido na sess√£o do R, assim como as fun√ß√µes `dir()` ou `list.files()` para listagem dos arquivos no diret√≥rio, ambas medidas de confer√™ncia do diret√≥rio correto.

```{r eval=FALSE}
## Definir o diret√≥rio de trabalho
setwd("/home/mude/data/github/livro_r_ecologia/dados")

## Verificar o diret√≥rio
getwd()

## Listar os arquivos no diret√≥rio
dir()
list.files()
```

Outra forma de definir o diret√≥rio √© digitar a tecla `tab` dentro da fun√ß√£o `setwd("tab")`. Quando apertamos a `tab` dentro das aspas conseguimos selecionar o diret√≥rio manualmente, pois abre-se uma lista de diret√≥rio que podemos ir selecionando at√© chegar no diret√≥rio de interesse.

```{r eval=FALSE}
## Mudar o diret√≥rio com a tecla tab
setwd("`tab`")
```

### Importar dados

Uma das opera√ß√µes mais corriqueiras do R, antes de realizar alguma an√°lise ou plotar um gr√°fico, √© a de importar dados que foram tabulados numa planilha eletr√¥nica e salvos no formato .csv, .txt ou .xlsx. Ao importar esse tipo de dado para o R, o formato que o mesmo assume, se nenhum par√¢metro for especificado, √© o da classe `data frame`, prevendo que a planilha de dados possua colunas com diferentes modos.

Existem diversas formas de importar dados para o R. Podemos importar utilizando o RStudio, indo na janela **Environment** (Figura \@ref(fig:fig-rstudio) janela 3) e clicar em "Importar Dataset".

Entretanto, aconselhamos o uso de fun√ß√µes que fiquem salvas em um script para aumentar a reprodutibilidade do mesmo. Dessa forma, as tr√™s principais fun√ß√µes para importar os arquivos nos tr√™s principais extens√µes (.csv, .txt ou .xlsx) s√£o, respectivamente: `read.csv()`, `read.table()` e `openxlsx::read.xlsx()`, sendo o √∫ltimo do pacote `openxlsx`.

Para exemplificar como importar dados no R, vamos usar os dados de comunidades de anf√≠bios da Mata Atl√¢ntica [@vancine2018]. Faremos o download diretamente do site da fonte dos dados.

Vamos antes escolher um diret√≥rio de trabalho com a fun√ß√£o `setwd()`, e em seguida criar um diret√≥rio com a fun√ß√£o `dir.create()` chamado "dados". Em seguida, vamos mudar nosso diret√≥rio para essa pasta e criar mais um diret√≥rio chamado "tabelas", e por fim, definir esse diret√≥rio para que o conte√∫do do download seja armazenado ali.

```{r eval=FALSE}
## Escolher um diret√≥rio
setwd("/home/mude/data/github/livro_aer")

## Criar um diret√≥rio 'dados'
dir.create("dados")

## Escolher diret√≥rio 'dados'
setwd("dados")

## Criar um diret√≥rio 'tabelas'
dir.create("tabelas")

## Escolher diret√≥rio 'tabelas'
setwd("tabelas")
```

Agora podemos fazer o download do arquivo `.zip` e extrair as tabelas usando a fun√ß√£o `unzip()` nesse mesmo diret√≥rio.

```{r eval=FALSE}
## Download
download.file(url = "https://esajournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fecy.2392&file=ecy2392-sup-0001-DataS1.zip",
              destfile = "atlantic_amphibians.zip", mode = "auto")

## Unzip
unzip(zipfile = "atlantic_amphibians.zip")
```

Agora podemos importar a tabela de dados com a fun√ß√£o `read.csv()`, atribuindo ao objeto `intror_anfibios_locais`. Devemos atentar para o argumento `encoding`, que selecionamos aqui como `latin1` para corrigir um erro de caracteres, que o autor dos dados cometeu quando publicou esse data paper. Geralmente n√£o precisamos especificar esse tipo de informa√ß√£o, mas caso depois de importar os dados e na confer√™ncia, os caracteres como acento estiverem desformatados, procure especificar no argumento `encoding` um padr√£o para corrigir esse erro.

```{r}
## Importar a tabela de locais
intror_anfibios_locais <- read.csv("dados/tabelas/ATLANTIC_AMPHIBIANS_sites.csv", encoding = "latin1")
```

Esse arquivo foi criado com separador de decimais sendo `.` e separador de colunas sendo `,`. Caso tivesse sido criado com separador de decimais sendo `,` e separador de colunas sendo `;`, usar√≠amos a fun√ß√£o `read.csv2()`.

Para outros formatos, basta usar as outras fun√ß√µes apresentadas, atentando-se para os argumentos espec√≠ficos de cada fun√ß√£o.

Outra forma de importar dados, principalmente quando n√£o sabemos exatamente o nome do arquivo e tamb√©m para evitar erros de digita√ß√£o, √© utilizar a tecla `tab` dentro das aspas da fun√ß√£o de importa√ß√£o. Dessa forma, conseguimos ter acesso aos arquivos do nosso diret√≥rio e temos a possibilidade de selecion√°-los sem erros de digita√ß√£o.

```{r eval=FALSE}
## Importar usando a tecla tab
intror_anfibios_locais <- read.csv("`tab`")
intror_anfibios_locais
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r}
## Importar os dados pelo pacote ecodados
intror_anfibios_locais <- ecodados::intror_anfibios_locais
head(intror_anfibios_locais)
```

### Confer√™ncia dos dados importados

Uma vez importados os dados para o R, geralmente antes de iniciarmos qualquer manipula√ß√£o, visualiza√ß√£o ou an√°lise de dados, fazemos a confer√™ncia desses dados. Para isso, podemos utilizar as fun√ß√µes listadas na Tabela \@ref(tab:tab-funcoes-conf-multi).

Dentre todas essas fun√ß√µes de verifica√ß√£o, destacamos a import√¢ncia destas fun√ß√µes apresentadas abaixo para saber se as vari√°veis foram importadas e interpretadas corretamente e reconhecer erros de digita√ß√£o, por exemplo.

```{r}
## Primeiras linhas
head(intror_anfibios_locais)

## √öltimas linhas
tail(intror_anfibios_locais)

## N√∫mero de linhas e colunas
nrow(intror_anfibios_locais)
ncol(intror_anfibios_locais)
dim(intror_anfibios_locais)
```

```{r eval=FALSE}
## Nome das linhas e colunas
rownames(intror_anfibios_locais)
colnames(intror_anfibios_locais)

## Estrutura dos dados
str(intror_anfibios_locais)

## Resumo dos dados
summary(intror_anfibios_locais)

## Verificar NAs
any(is.na(intror_anfibios_locais))
which(is.na(intror_anfibios_locais))

## Remover as linhas com NAs
intror_anfibios_locais_na <- na.omit(intror_anfibios_locais)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A fun√ß√£o `na.omit()` retira a **linha inteira** que possui algum `NA`, inclusive as colunas que possuem dados que voc√™ n√£o tem interesse em excluir. Dessa forma, tenha em mente quais dados voc√™ realmente quer remover da sua tabela.
:::

Al√©m das fun√ß√µes apresentadas, recomendamos olhar os seguintes pacotes que ajudam na confer√™ncia dos dados importados: [`Hmisc`](https://cran.r-project.org/web/packages/Hmisc/index.html), [`skimr`](https://cran.r-project.org/web/packages/skimr.html) e [`inspectDF`](https://alastairrushworth.github.io/inspectdf).

### Exportar dados

Uma vez realizado as opera√ß√µes de manipula√ß√£o ou tendo dados que foram analisados e armazenados num objeto no formato de data frame ou matriz, podemos exportar esses dados do R para o diret√≥rio que definimos anteriormente.

Para tanto, podemos utilizar fun√ß√µes de escrita de dados, como `write.csv()`, `write.table()` e `openxlsx::write.xlsx()`. Dois pontos s√£o fundamentais: i) o nome do arquivo tem de estar entre aspas e no final dele deve constar a extens√£o que pretendemos que o arquivo tenha, e ii) √© interessante utilizar os argumentos **row.names = FALSE** e **quote=FALSE**, para que o arquivo escrito n√£o tenha o nome das linhas ou aspas em todas as c√©lulas, respectivamente.

```{r eval=FALSE}
## Exportar dados na extens√£o .csv
write.csv(intror_anfibios_locais_na, "ATLANTIC_AMPHIBIAN_sites_na.csv", 
          row.names = FALSE, quote = FALSE)

## Exportar dados na extens√£o .txt
write.table(intror_anfibios_locais_na, "ATLANTIC_AMPHIBIAN_sites_na.txt", 
            row.names = FALSE, quote = FALSE)

## Exportar dados na extens√£o .xlsx
openxlsx::write.xlsx(intror_anfibios_locais_na, "ATLANTIC_AMPHIBIAN_sites_na.xlsx", 
                     row.names = FALSE, quote = FALSE)
```

## Para se aprofundar

Listamos a seguir livros e links com material que recomendamos para seguir com sua aprendizagem em R Base.

### Livros

Recomendamos aos interessados os livros: i) Crawley [-@crawley_r_2012] The R Book, ii) Davies [-@davies_book_2016] The Book of R: A First Course in Programming and Statistics, iii) Gillespie e Lovelace [-@gillespie_efficient_2017] Efficient R programming, iv) Holmes e Huber [-@holmes_modern_2019] Modern Statistics for Modern Biology, v) Irizarry e Love [-@irizarry_data_2017] Data Analysis for the Life Sciences with R, vi) James e colaboradores [-@james_introduction_2013] An Introduction to Statistical Learning: with Applications in R, vii) Kabacoff [-@kabacoff_r_2011] R in Action: Data analysis and graphics with R, viii) Matloff [-@matloff_art_2011] The Art of R Programming: A Tour of Statistical Software Design, ix) Long e Teetor [-@long_r_2019] R Cookbook e x) Wickham [-@wickham_advanced_2019] Advanced R.

### Links
Existem centenas de ferramentas online para aprender e explorar o R. Dentre elas, indicamos os seguintes links (em portugu√™s e ingl√™s):  

**Introdu√ß√£o ao R**

- [An Introduction to R - Douglas A, Roos D, Mancini F, Couto A, Lusseau D](https://intro2r.com/)
- [A (very) shortintroduction to R - Paul Torfs & Claudia Brauer](https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf)
- [R for Beginners - Emmanuel Paradis](https://rbasicsworkshop.weebly.com/uploads/1/8/6/0/18603232/paradis_2005_r-forbeginners.pdf)

**Ci√™ncia de dados**
- [Ci√™ncia de Dados em R - Curso-R](https://livro.curso-r.com/)
- [Data Science for Ecologists and Environmental Scientists - Coding Club](https://ourcodingclub.github.io/course)


**Estat√≠stica**
- [Estat√≠stica Computacional com R - Mayer F. P., Bonat W. H., Zeviani W. M., Krainski E. T., Ribeiro Jr. P. J](http://cursos.leg.ufpr.br/ecr/index.html)
- [Data Analysis and Visualization in R for Ecologists - Data Carpentry](https://datacarpentry.org/R-ecology-lesson/index.html)

**Miscel√¢nea**

- [Materiais sobre R - Beatriz Milz](https://materiais-estudo-r.netlify.app/)
- [R resources (free courses, books, tutorials, & cheat sheets) - Paul van der Laken](https://paulvanderlaken.com/2017/08/10/r-resources-cheatsheets-tutorials-books)


## Exerc√≠cios

**4.1**
Use o R para verificar o resultado da opera√ß√£o `7 + 7 √∑ 7 + 7 x 7 - 7`.

**4.2**
Verifique atrav√©s do R se `3x2¬≥` √© maior que `2x3¬≤`.

**4.3**
Crie dois objetos (qualquer nome) com os valores 100 e 300. Multiplique esses objetos (fun√ß√£o `prod()`) e atribuam ao objeto `mult`. Fa√ßa o logaritmo natural (fun√ß√£o `log()`) do objeto `mult` e atribuam ao objeto `ln`.

**4.4**
Quantos pacotes existem no CRAN nesse momento? Execute essa combina√ß√£o no Console: `nrow(available.packages(repos = "http://cran.r-project.org"))`.

**4.5**
Instale o pacote `tidyverse` do CRAN.

**4.6**
Escolha n√∫meros para jogar na mega-sena usando o R, nomeando o objeto como `mega`. Lembrando: s√£o 6 valores de 1 a 60 e atribuam a um objeto.

**4.7**
Crie um fator chamado `tr`, com dois n√≠veis ("cont" e "trat") para descrever 100 locais de amostragem, 50 de cada tratamento. O fator deve ser dessa forma `cont, cont, cont, ...., cont, trat, trat, ...., trat`.

**4.8**
Crie uma matriz chamada `ma`, resultante da disposi√ß√£o de um vetor composto por 1000 valores aleat√≥rios entre 0 e 10. A matriz deve conter 100 linhas e ser disposta por colunas.

**4.9**
Crie um data frame chamado `df`, resultante da composi√ß√£o desses vetores:

-   `id: 1:50`
-   `sp: sp01, sp02, ..., sp49, sp50`
-   `ab: 50 valores aleat√≥rios entre 0 a 5`

**4.10**
Crie uma lista com os objetos criados anteriormente: `mega`, `tr`, `ma` e `df`.

**4.11**
Selecione os elementos √≠mpares do objeto `tr` e atribua ao objeto `tr_impar`.

**4.12**
Selecione as linhas com ids pares do objeto `df` e atribua ao objeto `df_ids_par`.

**4.13**
Fa√ßa uma amostragem de 10 linhas do objeto `df` e atribua ao objeto `df_amos10`.

**4.14**
Amostre 10 linhas do objeto `ma`, mas utilizando as linhas amostradas do `df_amos10` e atribua ao objeto `ma_amos10`.

**4.15**
Una as colunas dos objetos `df_amos10` e `ma_amos10` e atribua ao  objeto `dados_amos10`.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-4---introdu%C3%A7%C3%A3o-ao-r.html).

<!--chapter:end:04_introducao_r.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Tidyverse {#cap5}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r eval=FALSE}
## Pacotes
library(tidyverse)
library(here)
library(ggplot2)
library(purrr)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(forcats)
library(palmerpenguins)
library(lubridate)

## Dados
penguins <- palmerpenguins::penguins
penguins_raw <- palmerpenguins::penguins_raw
tidy_anfibios_locais <- ecodados::tidy_anfibios_locais
```

## Contextualiza√ß√£o

Como todo idioma, a linguagem R vem passando por transforma√ß√µes nos √∫ltimos anos. Grande parte dessas mudan√ßas est√£o dentro do paradigma de Ci√™ncia de Dados (*Data Science*), uma nova √°rea de conhecimento que vem se moldando a partir do desenvolvimento da sociedade em torno da era digital e da grande quantidade de dados gerados e dispon√≠veis pela internet, de onde adv√©m os pilares das inova√ß√µes tecnol√≥gicas: *Big Data*, *Machine Learning* e *Internet of Things*. A grande necessidade de computa√ß√£o para desenvolver esse novo paradigma colocaram o [R](https://www.r-project.org/) e o [python](https://www.python.org/) como as principais linguagens de programa√ß√£o frente a esses novos desafios. Apesar de n√£o serem as √∫nicas ferramentas utilizadas para esse prop√≥sito, elas rapidamente se tornaram uma das melhores escolhas, dado v√°rios fatores como: ser de c√≥digo-aberto e gratuitas, possu√≠r grandes comunidades contribuidoras, ser linguagens de interpreta√ß√£o (orientadas a objeto) e relativamente f√°ceis de serem aprendidas e aplicadas.

Essas mudan√ßas e expan√ß√µes na utiliza√ß√£o da linguagem R para a Ci√™ncia de Dados come√ßaram a ser implementadas principalmente devido a um pesquisador: [Hadley Wickham](http://hadley.nz/), que iniciou sua contribui√ß√£o √† comunidade R com o desenvolvimento do j√° consagrado pacote `ggplot2` [@wickham2016] para a composi√ß√£o de gr√°ficos no R (ver mais no Cap√≠tulo \@ref(cap6)), baseado na gram√°tica de gr√°ficos [@wilkinson2005]. Depois disso, Wickham dedicou-se ao desenvolvimento do pensamento de uma nova abordagem dentro da manipula√ß√£o de dados, denominada **Tidy Data** (Dados organizados) [@wickham2014], na qual focou na limpeza e organiza√ß√£o dos mesmos. A ideia postula que dados est√£o `tidy` quando: i) vari√°veis est√£o nas colunas, ii) observa√ß√µes est√£o nas linhas e iii) valores est√£o nas c√©lulas, sendo que para esse √∫ltimo, n√£o deve haver mais de um valor por c√©lula (Figura \@ref(fig:fig-r-dados-tidy)).

A partir dessas ideias, o [*tidyverse*](https://www.tidyverse.org/) foi operacionalizado no R como uma cole√ß√£o de pacotes que atuam no fluxo de trabalho comum da ci√™ncia de dados: importa√ß√£o, manipula√ß√£o, explora√ß√£o, visualiza√ß√£o, an√°lise e comunica√ß√£o de dados e an√°lises [@tidyverse2019] (Figura \@ref(fig:fig-r-tidyverse)). O principal objetivo do *tidyverse* √© aproximar a linguagem para melhorar a intera√ß√£o entre ser humano e computador sobre dados, de modo que os pacotes compartilham uma filosofia de design de alto n√≠vel e gram√°tica, al√©m da estrutura de dados de baixo n√≠vel [@tidyverse2019]. As principais leituras sobre o tema no R s√£o os artigos "Tidy Data" [@wickham2014] e "Welcome to the Tidyverse" [@tidyverse2019], e o livro ["R for Data Science"](https://r4ds.had.co.nz/) [@wickham2017], al√©m do [Tidyverse](https://www.tidyverse.org/) que possui muito mais informa√ß√µes.

```{r fig-r-tidyverse, echo=FALSE, fig.cap="Modelo das ferramentas necess√°rias em um projeto t√≠pico de ci√™ncia de dados: importar, organizar, entender (transformar, visualizar, modelar) e comunicar, envolto √† essas ferramentas est√° a programa√ß√£o. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig01.png")
```

## *tidyverse*

Uma vez instalado e carregado, o pacote `tidyverse` disponibiliza um conjunto de ferramentas atrav√©s de v√°rios pacotes. Esses pacotes compartilham uma filosofia de design, gram√°tica e estruturas. Podemos entender o *tidyverse* como um "dialeto novo" para a linguagem R, onde *tidy* quer dizer organizado, arrumado, ordenado, e *verse* √© universo. A seguir, listamos os principais pacotes e suas funcionalidades.

- [`readr`](https://readr.tidyverse.org/): importa dados tabulares (e.g. `.csv` e `.txt`)
- [`tibble`](https://tibble.tidyverse.org/): implementa a classe `tibble`
- [`tidyr`](https://tidyr.tidyverse.org/): transforma√ß√£o de dados para `tidy`
- [`dplyr`](https://dplyr.tidyverse.org/): manipula√ß√£o de dados
- [`stringr`](https://github.com/tidyverse/stringr): manipula√ß√£o de caracteres
- [`forcats`](https://github.com/hadley/forcats): manipula√ß√£o de fatores
- [`ggplot2`](https://ggplot2.tidyverse.org/): possibilita a visualiza√ß√£o de dados
- [`purrr`](https://purrr.tidyverse.org/): disponibiliza ferramentas para programa√ß√£o funcional

Al√©m dos pacotes principais, fazemos tamb√©m men√ß√£o a outros pacotes que est√£o dentro dessa abordagem e que trataremos ainda neste cap√≠tulo, em outro momento do livro, ou que voc√™ leitor(a) deve se familiarizar. Alguns pacotes comp√µem o tidyverse outros s√£o mais gerais, entretanto, todos est√£o envolvidos de alguma forma com ci√™ncia de dados.

- [`readxl`](https://readxl.tidyverse.org/) e [`writexl`](https://cran.r-project.org/package=writexl): importa e exporta dados tabulares (.xlsx)
- [`janitor`](http://sfirke.github.io/janitor/): examinar e limpar dados sujos
- [`DBI`](https://github.com/rstats-db/DBI): interface de banco de dados R
- [`haven`](https://github.com/tidyverse/haven): importa e exporta dados do SPSS, Stata e SAS
- [`httr`](https://github.com/r-lib/httr): ferramentas para trabalhar com URLs e HTTP
- [`rvest`](https://github.com/tidyverse/rvest): coletar facilmente (raspe) p√°ginas da web
- [`xml2`](https://github.com/r-lib/xml2): trabalhar com arquivos XML
- [`jsonlite`](https://github.com/jeroen/jsonlite): um analisador e gerador JSON simples e robusto para R
- [`hms`](https://github.com/rstats-db/hms): hora do dia
- [`lubridate`](https://github.com/tidyverse/lubridate): facilita o tratamento de datas
- [`magrittr`](https://magrittr.tidyverse.org/): prov√™ os operadores pipe (`%>%`, `%$%`, `%<>%`)
- [`glue`](https://github.com/tidyverse/glue): facilita combinar dados e caracteres
- [`rmarkdown`](https://rmarkdown.rstudio.com/): cria documentos de an√°lise din√¢mica que combinam c√≥digo, sa√≠da renderizada (como figuras) e texto
- [`knitr`](https://yihui.org/knitr/): projetado para ser um mecanismo transparente para gera√ß√£o de relat√≥rios din√¢micos com R
- [`shiny`](https://shiny.rstudio.com/): framework de aplicativo Web para R
- [`flexdashboard`](https://rmarkdown.rstudio.com/flexdashboard/): pain√©is interativos para R
- [`here`](https://here.r-lib.org/): facilita a defini√ß√£o de diret√≥rios
- [`usethis`](https://usethis.r-lib.org/): automatiza tarefas durante a configura√ß√£o e desenvolvimento de projetos (Git, 'GitHub' e Projetos RStudio)
- [`data.table`](https://rdatatable.gitlab.io/data.table/): pacote que fornece uma vers√£o de alto desempenho do `data.frame` (importar, manipular e expotar)
- [`reticulate`](https://rstudio.github.io/reticulate/): pacote que fornece ferramentas para integrar Python e R
- [`sparklyr`](https://spark.rstudio.com/): interface R para Apache Spark
- [`broom`](https://github.com/tidymodels/broom): converte objetos estat√≠sticos em tibbles organizados
- [`modelr`](https://github.com/tidyverse/modelr): fun√ß√µes de modelagem que funcionam com o pipe
- [`tidymodels`](https://www.tidymodels.org/): cole√ß√£o de pacotes para modelagem e aprendizado de m√°quina usando os princ√≠pios do tidyverse

Destacamos a grande expans√£o e aplicabilidade dos pacotes [rmarkdown](https://rmarkdown.rstudio.com/), [knitr](https://yihui.org/knitr/) e [bookdown](https://bookdown.org/), que permitiram a escrita desse livro usando essas ferramentas e linguagem de marca√ß√£o, chamada [Markdown](https://daringfireball.net/projects/markdown/).

Para instalar os principais pacotes que integram o *tidyverse* podemos instalar o pacote `tidyverse`.

```{r eval=FALSE}
## Instalar o pacote tidyverse
install.packages("tidyverse")
```

Quando carregamos o pacote `tidyverse` podemos notar uma mensagem indicando quais pacotes foram carregados, suas respectivas vers√µes e os conflitos com outros pacotes.

```{r message=TRUE}
## Carregar o pacote tidyverse
library(tidyverse)
```

Podemos ainda listar todos os pacotes do *tidyverse* com a fun√ß√£o `tidyverse::tidyverse_packages()`.

```{r}
## Listar todos os pacotes do tidyverse 
tidyverse::tidyverse_packages()
```

Tamb√©m podemos verificar se os pacotes est√£o atualizados, sen√£o, podemos atualiz√°-los com a fun√ß√£o `tidyverse::tidyverse_update()`.

```{r eval=FALSE}
## Verificar e atualizar os pacotes do tidyverse 
tidyverse::tidyverse_update(repos = "http://cran.us.r-project.org")
```

Todas as fun√ß√µes dos pacotes tidyverse usam **fonte min√∫scula** e **`_` (*underscore*)** para separar os nomes internos das fun√ß√µes, seguindo a mesma sintaxe do Python ("Snake Case"). Neste sentido de padroniza√ß√£o, √© importante destacar ainda que existe um guia pr√≥prio para que os scripts sigam a recomenda√ß√£o de padroniza√ß√£o, o [The tidyverse style guide](https://style.tidyverse.org/), criado pelo pr√≥prio Hadley Wickham. Para pessoas que desenvolvem fun√ß√µes e pacotes existe o [Tidyverse design guide](https://design.tidyverse.org/) criado pelo *Tidyverse team*.

```{r eval=FALSE}
## Fun√ß√µes no formato snake case
read_csv()
read_tsv()
as_tibble()
left_join()
group_by()
```

Por fim, para evitar poss√≠veis conflitos de fun√ß√µes com o mesmo nome entre pacotes, recomendamos fortemente o h√°bito de usar as fun√ß√µes precedidas do operador `::` e o respectivo pacote. Assim, garante-se que a fun√ß√£o utilizada √© referente ao pacote daquela fun√ß√£o. Segue um exemplo com as fun√ß√µes apresentadas anteriormente.

```{r eval=FALSE}
## Fun√ß√µes seguidas de seus respectivos pacotes
readr::read_csv()
readr::read_tsv()
tibble::as_tibble()
dplyr::left_join()
dplyr::group_by()
```

Seguindo essas ideias do novo paradigma da **Ci√™ncia de Dados**, outro conjunto de pacotes foi desenvolvido, chamado de [`tidymodels`](https://www.tidymodels.org/) que atuam no fluxo de trabalho da an√°lise de dados em ci√™ncia de dados: separa√ß√£o e reamostragem, pr√©-processamento, ajuste de modelos e m√©tricas de performasse de ajustes. Por raz√µes de espa√ßo e especificidade, n√£o entraremos em detalhes desses pacotes.

Seguindo a estrutura da Figura \@ref(fig:fig-r-tidyverse), iremos ver nos itens das pr√≥ximas se√ß√µes como esses passos s√£o realizados com fun√ß√µes de cada pacote.

## here

Dentro do fluxo de trabalho do tidyverse, devemos sempre trabalhar com **Projetos do RStudio**. Junto com o projeto, tamb√©m podemos fazer uso do pacote `here`. Ele permite construir caminhos para os arquivos do projeto de forma mais simples e com maior reprodutibilidade.

Esse pacote cobre o ponto de mudarmos o diret√≥rio de trabalho que discutimos no cap√≠tulo \@ref(cap4), dado que muitas vezes mudar o diret√≥rio com a fun√ß√£o `setwd()` tende a ser demorado e tedioso, principalmente quando se trata de um script em que v√°rias pessoas est√£o trabalhando em diferentes computadores e sistemas operacionais. Al√©m disso, ele elimina a quest√£o da fragilidade dos scripts, pois geralmente um script est√° com os diret√≥rios conectados exatamente a um lugar e a um momento. Por fim, ele tamb√©m simplifica o trabalho com subdiret√≥rios, facilitando importar ou exportar arquivos para subpastas.

Seu uso √© relativamente simples: uma vez criado e aberto o RStudio pelo Projeto do RStudio, o diret√≥rio automaticamente √© definido para o diret√≥rio do projeto. Depois disso, podemos usar a fun√ß√£o `here::here()` para definir os subdiret√≥rios onde est√£o os dados. O exemplo da aplica√ß√£o fica para a se√ß√£o seguinte, quando iremos de fato importar um arquivo tabular para o R. Logo abaixo, mostramos como instalar e carregar o pacote `here`.

```{r eval=FALSE}
## Instalar
install.packages("here")

## Carregar
library(here)
```

## readr, readxl e writexl

Dado que possu√≠mos um conjunto de dados e que geralmente esse conjunto de dados estar√° no formato tabular com umas das extens√µes: .csv, .txt ou .xlsx, usaremos o pacote `readr` ou `readxl` para importar esses dados para o R. Esses pacotes leem e escrevem grandes arquivos de forma mais r√°pida, al√©m de fornecerem medidores de progresso de importa√ß√£o e exporta√ß√£o, e imprimir a informa√ß√£o dos modos das colunas no momento da importa√ß√£o. Outro ponto bastante positivo √© que tamb√©m classificam automaticamente o modo dos dados de cada coluna, i.e., se uma coluna possui dados num√©ricos ou apenas texto, essa informa√ß√£o ser√° considerada para classificar o modo da coluna toda. A classe do objeto atribu√≠do quando lido por esses pacotes √© automaticamente um `tibble`, que veremos melhor na se√ß√£o seguinte. Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://readr.tidyverse.org/reference/index.html) do pacote.

Usamos as fun√ß√µes `readr::read_csv()` e `readr::write_csv()` para importar e exportar arquivos .csv do R, respectivamente. Para dados com a extens√£o .txt, podemos utilizar as fun√ß√µes `readr::read_tsv()` ou ainda `readr::read_delim()`. Para arquivos tabulares com a extens√£o .xlsx, temos de instalar e carregar dois pacotes adicionais: `readxl` e `writexl`, dos quais usaremos as fun√ß√µes `readxl::read_excel()`, `readxl::read_xlsx()` ou `readxl::read_xls()` para importar dados, atentado para o fato de podermos indicar a aba com os dados com o argumento `sheet`, e `writexl::write_xlsx()` para exportar.

Se o arquivo .csv foi criado com separador de decimais sendo `.` e separador de colunas sendo `,`, usamos as fun√ß√µes listadas acima normalmente. Caso seja criado com separador de decimais sendo `,` e separador de colunas sendo `;`, devemos usar a fun√ß√£o `readr::read_csv2()` para importar e `readr::write_csv2()` para exportar nesse formato, que √© mais comum no Brasil.

Para exemplificar como essas fun√ß√µes funcionam, vamos importar novamente os dados de comunidades de anf√≠bios da Mata Atl√¢ntica [@vancine2018], que fizemos o download no Cap√≠tulo \@ref(cap4). Estamos usando a fun√ß√£o `readr::read_csv()`, indicando os diret√≥rios com a fun√ß√£o `here::here()`, e a classe do arquivo √© `tibble`. Devemos atentar para o argumento `locale = readr::locale(encoding = "latin1")`,que selecionamos aqui como `latin1` para corrigir um erro de caracteres, que o autor dos dados cometeu quando publicou esse data paper.

```{r message=TRUE}
## Importar locais
tidy_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    locale = readr::locale(encoding = "latin1")
)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
tidy_anfibios_locais <- ecodados::tidy_anfibios_locais
head(tidy_anfibios_locais)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [11 Data import](https://r4ds.had.co.nz/data-import.html) de Wickham & Grolemund [-@wickham2017].

## tibble

O `tibble` (`tbl_sf`) √© uma vers√£o aprimorada do data frame (`data.frame`). Ele √© a classe aconselhada para que as fun√ß√µes do tidyverse funcionem melhor sobre conjuntos de dados tabulares importados para o R.

Geralmente, quando utilizamos fun√ß√µes tidyverse para importar dados para o R, √© essa classe que os dados adquirem depois de serem importados. Al√©m da importa√ß√£o de dados, podemos criar um tibble no R usando a fun√ß√£o `tibble::tibble()`, semelhante ao uso da fun√ß√£o `data.frame()`. Podemos ainda converter um `data.frame` para um `tibble` usando a fun√ß√£o `tibble::as_tibble()`. Entretanto, em alguns momentos precisaremos da classe `data.frame` para algumas fun√ß√µes espec√≠ficas, e podemos converter um `tibble` para `data.frame` usando a fun√ß√£o `tibble::as_data_frame()`.

Existem duas diferen√ßas principais no uso do `tibble` e do `data.frame`: impress√£o e subconjunto. Objetos da classe `tibbles` possuem um m√©todo de impress√£o que mostra a contagem do n√∫mero de linhas e colunas, e apenas as primeiras 10 linhas e todas as colunas que cabem na tela no console, al√©m dos modos ou tipos das colunas. Dessa forma, cada coluna ou vari√°vel, pode ser do modo numbers (`int` ou `dbl`), character (`chr`), logical (`lgl`), factor (`fctr`), date + time (`dttm`) e date (`date`), al√©m de outras [in√∫meras possibilidades](https://tibble.tidyverse.org/articles/types.html).

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://tibble.tidyverse.org/reference/index.html) do pacote.

```{r}
## Tibble - impress√£o
tidy_anfibios_locais
```

Para o subconjunto, como vimos no Cap√≠tulo \@ref(cap4), para selecionar colunas e linhas de objetos bidimensionais podemos utilizar os operadores `[]` ou `[[]]`, associado com n√∫meros separados por v√≠rgulas ou o nome da coluna entre aspas, e o operador `$` para extrair uma coluna pelo seu nome. Comparando um `data.frame` a um `tibble`, o √∫ltimo √© mais r√≠gido na sele√ß√£o das colunas: eles nunca fazem correspond√™ncia parcial e geram um aviso se a coluna que voc√™ est√° tentando acessar n√£o existir.

```{r, error=TRUE, warning=TRUE}
## Tibble - subconjunto
tidy_anfibios_locais$ref
```

Por fim, podemos "espiar" os dados utilizando a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral de n√∫mero de linhas, colunas, e conte√∫do de todas as colunas. Essa √© fun√ß√£o *tidyverse* da fun√ß√£o R Base `str()`.

```{r}
## Espiar os dados
tibble::glimpse(tidy_anfibios_locais[, 1:10])
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [10 Tibbles](https://r4ds.had.co.nz/tibbles.html) de Wickham & Grolemund [-@wickham2017].

## magrittr (pipe - %>%)

O operador pipe `%>%` permite o encadeamento de v√°rias fun√ß√µes, eliminando a necessidade de criar objetos para armazenar resultados intermedi√°rios. Dessa forma, pipes s√£o uma ferramenta poderosa para expressar uma sequ√™ncia de m√∫ltiplas opera√ß√µes.

O operador pipe `%>%` vem do pacote `magrittr`, entretanto, todos os pacotes no tidyverse automaticamente tornam o pipe dispon√≠vel. Essa fun√ß√£o torna os c√≥digos em R mais simples, pois realizamos m√∫ltiplas opera√ß√µes em uma √∫nica linha. Ele captura o resultado de uma declara√ß√£o e o torna a primeira entrada da pr√≥xima declara√ß√£o, ent√£o podemos pensar como "EM SEGUIDA FA√áA" ao final de cada linha de c√≥digo.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://maggritr.tidyverse.org/reference/index.html) do pacote.

A principal vantagem do uso dos pipes √© facilitar a depura√ß√£o (*debugging* - achar erros) nos c√≥digos, porque seu uso torna a linguagem R mais pr√≥xima do que falamos e pensamos, uma vez que evita o uso de fun√ß√µes dentro de fun√ß√µes (fun√ß√µes compostas, lembra-se do fog e gof do ensino m√©dio? Evitamos eles aqui tamb√©m).

Digitar `%>%` √© um pouco chato, dessa forma, existe um atalho para sua inser√ß√£o nos scripts: `Ctrl + Shift + M`.

Para deixar esse t√≥pico menos estranho a quem possa ver essa opera√ß√£o pela primeira vez, vamos fazer alguns exemplos.

```{r}
## Base R - sem pipe
sqrt(sum(1:100))

## Tidyverse - com pipe
1:100 %>% 
    sum() %>% 
    sqrt()
```

Essas opera√ß√µes ainda est√£o simples, vamos torn√°-las mais complexas com v√°rias fun√ß√µes compostas. √â nesses casos que a propriedade organizacional do uso do pipe emerge: podemos facilmente ver o encadeamento de opera√ß√µes, onde cada fun√ß√£o √© disposta numa linha. Apenas um adendo: a fun√ß√£o `set.seed()` que fixa a amostragem de fun√ß√µes que geram valores aleat√≥rios, como √© o caso da fun√ß√£o `rpois()`.

```{r}
## Fixar amostragem
set.seed(42)

## Base R - sem pipe
ve <- sum(sqrt(sin(log10(rpois(100, 10)))))
ve

## Fixar amostragem
set.seed(42)

## Tidyverse - com pipe
ve <- rpois(100, 10) %>% 
    log10() %>%
    sin() %>% 
    sqrt() %>% 
    sum()
ve
```

O uso do pipe vai se tornar especialmente √∫til quando seguirmos para os pacotes das pr√≥ximas duas se√ß√µes: `tidyr` e `dplyr`. Com esses pacotes faremos opera√ß√µes em linhas e colunas de nossos dados tabulares, ent√£o podemos encadear uma s√©rie de fun√ß√µes para manipula√ß√£o, limpeza e an√°lise de dados.

H√° ainda tr√™s outras varia√ß√µes do pipe que podem ser √∫teis em alguns momentos, mas que para funcionar precisam que o pacote `magrittr` esteja carregado:

- `%T>%`: retorna o lado esquerdo em vez do lado direito da opera√ß√£o
- `%$%`: "explode" as vari√°veis em um quadro de dados
- `%<>%`: permite atribui√ß√£o usando pipes

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [18 Pipes](https://r4ds.had.co.nz/pipes.html) de Wickham & Grolemund [-@wickham2017].

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A partir da vers√£o do R 4.1+ (18/05/2021), o operador pipe se tornou nativo do R. Entretanto, o operador foi atualizado para `|>`, podendo ser inserido com o mesmo atalho `Ctrl + Shift + M`, mas necessitando uma mudan√ßa de op√ß√£o em `Tools > Global Options > Code > [x] Use native pipe operator, |> (requires R 4.1+)`, necessitando que o RStudio esteja numa vers√£o igual ou superior a 1.4.17+.
:::

## tidyr

Os conjuntos de dados `tidy` (organizados) s√£o mais f√°ceis de manipular, modelar e visualizar. Um conjunto de dados est√° no formato `tidy` ou n√£o, dependendo de como linhas, colunas e c√©lulas s√£o combinadas com observa√ß√µes, vari√°veis e valores. Nos dados tidy, as vari√°veis est√£o nas colunas, observa√ß√µes est√£o nas linhas e valores est√£o nas c√©lulas, sendo que para esse √∫ltimo, n√£o deve haver mais de um valor por c√©lula (Figura \@ref(fig:fig-r-dados-tidy)).

1. Cada vari√°vel em uma coluna
2. Cada observa√ß√£o em uma linha
3. Cada valor como uma c√©lula

```{r fig-r-dados-tidy, echo=FALSE, fig.cap="As tr√™s regras que tornam um conjunto de dados *tidy*. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig02.png")
```

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://tidyr.tidyverse.org/reference/index.html) do pacote.

Para realizar diversas transforma√ß√µes nos dados, a fim de ajust√°-los ao formato `tidy` existe uma s√©rie de fun√ß√µes para: unir colunas, separar colunas, lidar com valores faltantes (`NA`), transformar a base de dados de formato longo para largo (ou vice-e-versa), al√©m de outras [fun√ß√µes espec√≠ficas](https://tidyr.tidyverse.org/reference/index.html).

- `unite()`: junta dados de m√∫ltiplas colunas em uma coluna
- `separate()`: separa caracteres em m√∫ltiplas colunas
- `separate_rows()`: separa caracteres em m√∫ltiplas colunas e linhas
- `drop_na()`: retira linhas com `NA` do conjunto de dados
- `replace_na()`: substitui `NA` do conjunto de dados
- `pivot_wider()`: transforma um conjunto de dados longo (*long*) para largo (*wide*)
- `pivot_longer()`: transforma um conjunto de dados largo (*wide*) para longo (*long*)

### palmerpenguins

Para exemplificar o funcionamento dessas fun√ß√µes, usaremos os dados de medidas de pinguins chamados [*palmerpenguins*](https://allisonhorst.github.io/palmerpenguins), dispon√≠veis no pacote `palmerpenguins`.

```{r eval=FALSE}
## Instalar o pacote
install.packages("palmerpenguins")
```

Esses dados foram coletados e disponibilizados pela [Dra. Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) e pela [Palmer Station, Antarctica LTER](https://pal.lternet.edu/), membro da Long Term Ecological Research Network.

O pacote `palmerpenguins` cont√©m dois conjuntos de dados. Um √© chamado de `penguins` e √© uma vers√£o simplificada dos dados brutos. O segundo conjunto de dados √© `penguins_raw` e cont√©m todas as vari√°veis e nomes originais baixados. Ambos os conjuntos de dados cont√™m dados para 344 pinguins, de tr√™s esp√©cies diferentes, coletados em tr√™s ilhas no arquip√©lago de Palmer, na Ant√°rtica. Destacamos tamb√©m a vers√£o traduzida desses dados para o portugu√™s, dispon√≠vel no pacote [`dados`](https://cienciadedatos.github.io/dados/).

Vamos utilizar principalmente o conjunto de dados `penguins_raw`, que √© a vers√£o dos dados brutos.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

Podemos ainda vericar os dados, pedindo uma ajuda de cada um dos objetos.

```{r eval=FALSE}
## Ajuda dos dados
?penguins
?penguins_raw
```

### glimpse()

Primeiramente, vamos observar os dados e utilizar a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral dos dados.

```{r}
## Visualizar os dados
penguins_raw

## Espiar os dados
dplyr::glimpse(penguins_raw)
```

### unite()

Primeiramente, vamos exemplificar como juntar e separar colunas. Vamos utilizar a fun√ß√£o `tidyr::unite()` para unir as colunas. H√° diversos par√¢metros para alterar como esta fun√ß√£o funciona, entretanto, √© importante destacar tr√™s deles: `col` nome da coluna que vai receber as colunas unidas, `sep` indicando o caracter separador das colunas unidas, e `remove` para uma resposta l√≥gica se as colunas unidas s√£o removidas ou n√£o. Vamos unir as colunas "Region" e "Island" na nova coluna "region_island".

```{r}
## Unir colunas
penguins_raw_unir <- tidyr::unite(data = penguins_raw, 
                                  col = "region_island",
                                  Region:Island, 
                                  sep = ", ",
                                  remove = FALSE)
head(penguins_raw_unir[, c("Region", "Island", "region_island")])
```

### separate()

De forma contr√°ria, podemos utilizar as fun√ß√µes `tidyr::separate()` e `tidyr::separate_rows()` para separar elementos de uma coluna em mais colunas. Respectivamente, a primeira fun√ß√£o separa uma coluna em novas colunas conforme a separa√ß√£o, e a segunda fun√ß√£o separa uma coluna, distribuindo os elementos nas linhas. Novamente, h√° diversos par√¢metros para mudar o comportamento dessas fun√ß√µes, mas destacaremos aqui quatro deles: `col` coluna a ser separada, `into` os nomes das novas colunas, `sep` indicando o caractere separador das colunas, e `remove` para uma resposta l√≥gica se as colunas separadas s√£o removidas ou n√£o. Vamos separar a coluna "Stage" nas colunas "stage" e "egg_stage".

```{r}
## Separar colunas
penguins_raw_separar <- tidyr::separate(data = penguins_raw, 
                                        col = Stage,
                                        into = c("stage", "egg_stage"), 
                                        sep = ", ",
                                        remove = FALSE)
head(penguins_raw_separar[, c("Stage", "stage", "egg_stage")])

## Separar colunas em novas linhas
penguins_raw_separar_linhas <- tidyr::separate_rows(data = penguins_raw,
                                                    Stage,
                                                    sep = ", ")
head(penguins_raw_separar_linhas[, c("studyName", "Sample Number", "Species", 
                                     "Region", "Island", "Stage")])
```

### drop_na() e replace_na()

*Valores faltantes* (`NA`) √© um tipo especial de elemento que discutimos no Cap√≠tulo \@ref(cap4) e s√£o relativamente comuns em conjuntos de dados. Em Base R, vimos algumas formas de lidar com esse tipo de elemento. No formato `tidyverse`, existem tamb√©m v√°rias formas de lidar com eles, mas aqui focaremos nas fun√ß√µes `tidyr::drop_na()` e `tidyr::replace_na()`, para retirar linhas e substituir esses valores, respectivamente.

```{r, cache=TRUE}
## Remover todas as linhas com NAs
penguins_raw_todas_na <- tidyr::drop_na(data = penguins_raw)
head(penguins_raw_todas_na)

## Remover linhas de colunas espec√≠ficas com NAs
penguins_raw_colunas_na <- tidyr::drop_na(data = penguins_raw,
                                          any_of("Comments"))
head(penguins_raw_colunas_na[, "Comments"])

## Substituir NAs por outro valor
penguins_raw_subs_na <- tidyr::replace_na(data = penguins_raw,
                                          list(Comments = "Unknown"))
head(penguins_raw_subs_na[, "Comments"])
```

### pivot_longer() e pivot_wider()

Por fim, trataremos da pivotagem ou remodelagem de dados. Veremos como mudar o formato do nosso conjunto de dados de longo (*long*) para largo (*wide*) e vice-versa. Primeiramente, vamos ver como partir de um dados longo (*long*) e criar um dados largo (*wide*). Essa √© uma opera√ß√£o semelhante √† "Tabela Din√¢mica" das planilhas eletr√¥nicas. Consiste em usar uma coluna para distribuir seus valores em outras colunas, de modo que os valores dos elementos s√£o preenchidos corretamente, reduzindo assim o n√∫mero de linhas e aumentando o n√∫mero de colunas. Essa opera√ß√£o √© bastante comum em Ecologia de Comunidades, quando queremos transformar uma lista de esp√©cies em uma matriz de comunidades, com v√°rias esp√©cies nas colunas. Para realizar essa opera√ß√£o, usarmos a fun√ß√£o `tidyr::pivot_wider()`. Dos diversos par√¢metros que podem compor essa fun√ß√£o, dois deles s√£o fundamentais: `names_from` que indica a coluna de onde os nomes ser√£o usados e `values_from` a coluna com os valores.

```{r}
## Selecionar colunas
penguins_raw_sel_col <- penguins_raw[, c(2, 3, 13)]
head(penguins_raw_sel_col)

## Pivotar para largo
penguins_raw_pivot_wider <- tidyr::pivot_wider(data = penguins_raw_sel_col, 
                                               names_from = Species, 
                                               values_from = `Body Mass (g)`)
head(penguins_raw_pivot_wider)
```

De modo oposto, podemos partir de um conjunto de dados largo (*wide*), ou seja, com v√°rias colunas, e queremos que essas colunas preencham uma √∫nica coluna, e que os valores antes espalhados nessas v√°rias colunas sejam adicionados um embaixo do outro, numa √∫nica coluna, no formato longo (*long*). Para essa opera√ß√£o, podemos utilizar a fun√ß√£o `tidyr::pivot_longer()`. Novamente, dos diversos par√¢metros que podem compor essa fun√ß√£o, tr√™s deles s√£o fundamentais: `cols` indicando as colunas que ser√£o usadas para serem pivotadas, `names_to` que indica a coluna de onde os nomes ser√£o usados e `values_to` a coluna com os valores.

```{r}
## Selecionar colunas
penguins_raw_sel_col <- penguins_raw[, c(2, 3, 10:13)]
head(penguins_raw_sel_col)

## Pivotar para largo
penguins_raw_pivot_longer <- tidyr::pivot_longer(data = penguins_raw_sel_col, 
                                                 cols = `Culmen Length (mm)`:`Body Mass (g)`,
                                                 names_to = "medidas", 
                                                 values_to = "valores")
head(penguins_raw_pivot_longer)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo 12 [Tidy data](https://r4ds.had.co.nz/tidy-data.html) de Wickham & Grolemund [-@wickham2017].

## dplyr

O `dplyr` √© um pacote que facilita a manipula√ß√£o de dados, com uma gram√°tica simples e flex√≠vel (por exemplo, como filtragem, reordenamento, sele√ß√£o, entre outras). Ele foi constru√≠do com o intuito de obter uma forma mais r√°pida e expressiva de manipular dados tabulares. O `tibble` √© a vers√£o de data frame mais conveniente para se usar com pacote `dplyr`.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://dplyr.tidyverse.org/reference/index.html) do pacote.

### Gram√°tica

Sua gram√°tica simples cont√©m fun√ß√µes verbais para manipula√ß√£o de dados, baseada em:

-   Verbos: `mutate()`, `select()`, `filter()`, `arrange()`, `summarise()`, `slice()`, `rename()`, etc.
-   Replica√ß√£o: `across()`, `if_any()`, `if_all()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, etc.
-   Agrupamento: `group_by()` e `ungroup()`
-   Jun√ß√µes: `inner_join()`, `full_join()`, `left_join()`, `right_join()`, etc.
-   Combina√ß√µes: `bind_rows()` e `bind_cols()`
-   Resumos, contagem e sele√ß√£o: `n()`, `n_distinct()`, `first()`, `last()`, `nth()`, etc.

Existe uma s√©rie de fun√ß√µes para realizar a manipula√ß√£o dos dados, com diversas finalidades: manipula√ß√£o de uma tabela, manipula√ß√£o de duas tabelas, replica√ß√£o, agrupamento, fun√ß√µes de vetores, al√©m de muitas outras [fun√ß√µes espec√≠ficas](https://dplyr.tidyverse.org/reference/index.html).

-   `relocate()`: muda a ordem das colunas
-   `rename()`: muda o nome das colunas
-   `select()`: seleciona colunas pelo nome ou posi√ß√£o
-   `pull()`: seleciona uma coluna como vetor
-   `mutate()`: adiciona novas colunas ou resultados em colunas existentes
-   `arrange()`: reordena as linhas com base nos valores de colunas
-   `filter()`: seleciona linhas com base em valores de colunas
-   `slice()`: seleciona linhas de diferente formas
-   `distinct()`: remove linhas com valores repetidos com base nos valores de colunas
-   `count()`: conta observa√ß√µes para um grupo
-   `group_by()`: agrupa linhas pelos valores das colunas
-   `summarise()`: resume os dados atrav√©s de fun√ß√µes considerando valores das colunas
-   `*_join()`: fun√ß√µes que juntam dados de duas tabelas atrav√©s de uma coluna chave

### Sintaxe

As fun√ß√µes do `dplyr` podem seguir uma mesma sintaxe: o `tibble` ser√° sempre o primeiro argumento dessas fun√ß√µes, seguido de um operador pipe (`%>%`) e pelo nome da fun√ß√£o que ir√° fazer a manipula√ß√£o nesses dados. Isso permite o encadeamento de v√°rias opera√ß√µes consecutivas mantendo a estrutura do dado original e acrescentando mudan√ßas num encadeamento l√≥gico.

Sendo assim, as fun√ß√µes verbais n√£o precisam modificar necessariamente o tibble original, sendo que as opera√ß√µes de manipula√ß√µes podem e devem ser atribu√≠das a um novo objeto.

```{r eval=FALSE}
## Sintaxe
tb_dplyr <- tb %>% 
    funcao_verbal1(argumento1, argumento2, ...) %>% 
    funcao_verbal2(argumento1, argumento2, ...) %>% 
    funcao_verbal3(argumento1, argumento2, ...)
```

Al√©m de `data.frames` e `tibbles`, a manipula√ß√£o pelo formato `dplyr` torna o trabalho com outros formatos de classes e dados acess√≠veis e eficientes como `data.table`, SQL e Apache Spark, para os quais existem pacotes espec√≠ficos.

-   [*dtplyr*](https://dtplyr.tidyverse.org/): manipular conjuntos de dados `data.table`
-   [*dbplyr*](https://dbplyr.tidyverse.org/): manipular conjuntos de dados SQL
-   [*sparklyr*](https://spark.rstudio.com/): manipular conjuntos de dados no Apache Spark

### palmerpenguins

Para nossos exemplos, vamos utilizar novamente os dados de pinguins [*palmerpenguins*](https://allisonhorst.github.io/palmerpenguins). Esses dados est√£o dispon√≠veis no pacote `palmerpenguins`. Vamos utilizar principalmente o conjunto de dados `penguins`, que √© a vers√£o simplificada dos dados brutos `penguins_raw`.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

### relocate()

Primeiramente, vamos reordenar as colunas com a fun√ß√£o `dplyr::relocate()`, onde simplesmente listamos as colunas que queremos mudar de posi√ß√£o e para onde elas devem ir. Para esse √∫ltimo passo h√° dois argumentos: `.before` que indica a coluna onde a coluna realocada deve se mover antes, e o argumento `.after` indicando onde deve se mover depois. Ambos podem ser informados com os nomes ou posi√ß√µes dessas colunas com n√∫meros.

```{r}
## Reordenar colunas - nome
penguins_relocate_col <- penguins %>% 
    dplyr::relocate(sex, year, .after = island)
head(penguins_relocate_col)

## Reordenar colunas - posi√ß√£o
penguins_relocate_ncol <- penguins %>% 
    dplyr::relocate(sex, year, .after = 2)
head(penguins_relocate_ncol)
```

### rename()

Podemos renomear colunas facilmente com a fun√ß√£o `dplyr::rename()`, onde primeiramente informamos o nome que queremos que a coluna tenha, seguido do operador `=` e a coluna do nosso dado ("nova_coluna = antiga_coluna"). Tamb√©m podemos utilizar a fun√ß√£o `dplyr::rename_with()`, que faz a mudan√ßa do nome em m√∫ltiplas colunas, que pode depender ou n√£o de resultados booleanos.

```{r}
## Renomear as colunas
penguins_rename <- penguins %>% 
    dplyr::rename(bill_length = bill_length_mm,
                  bill_depth = bill_depth_mm,
                  flipper_length = flipper_length_mm,
                  body_mass = body_mass_g)
head(penguins_rename)

## mudar o nome de todas as colunas
penguins_rename_with <- penguins %>% 
    dplyr::rename_with(toupper)
head(penguins_rename_with)
```

### select()

Outra opera√ß√£o bastante usual dentro da manipula√ß√£o de dados tabulares √© a sele√ß√£o de colunas. Podemos fazer essa opera√ß√£o com a fun√ß√£o `dplyr::select()`, que seleciona colunas pelo nome ou pela sua posi√ß√£o. Aqui h√° uma s√©rie de possibilidades de sele√ß√£o de colunas, desde utilizar operadores como `:` para selecionar intervalos de colunas, `!` para tomar o complemento (todas menos as listadas), al√©m de fun√ß√µes como `dplyr::starts_with()`, `dplyr::ends_with()`, `dplyr::contains()` para procurar colunas com um padr√£o de texto do nome da coluna.

```{r}
## Selecionar colunas por posi√ß√£o
penguins_select_position <- penguins %>% 
    dplyr::select(3:6)
head(penguins_select_position)

## Selecionar colunas por nomes
penguins_select_names <- penguins %>% 
    dplyr::select(bill_length_mm:body_mass_g)
head(penguins_select_names)

## Selecionar colunas por padr√£o
penguins_select_contains <- penguins %>% 
    dplyr::select(contains("_mm"))
head(penguins_select_contains)
```

### pull()

Quando usamos a fun√ß√£o `dplyr::select()`, mesmo que para apenas uma coluna, o retorno da fun√ß√£o √© sempre um `tibble`. Caso precisemos que essa coluna se torne um vetor dentro do encadeamento dos `pipes`, usamos a fun√ß√£o `dplyr::pull()`, que extrai uma √∫nica coluna como vetor.

```{r}
## Coluna como vetor
penguins_select_pull <- penguins %>% 
    dplyr::pull(bill_length_mm)
head(penguins_select_pull, 15)
```

### mutate()

Uma das opera√ß√µes mais √∫teis dentre as opera√ß√µes para colunas √© adicionar ou atualizar os valores de colunas. Para essa opera√ß√£o, usaremos a fun√ß√£o `dplyr::mutate()`. Podemos ainda usar os argumentos `.before` e `.after` para indicar onde a nova coluna deve ficar, al√©m do par√¢metro `.keep` com diversas possibilidades de manter colunas depois de usar a fun√ß√£o `dplyr::mutate()`. Por fim, √© fundamental destacar o uso das fun√ß√µes de replica√ß√£o: `dplyr::across()`, `dplyr::if_any()` e `dplyr::if_all()`, para os quais a fun√ß√£o far√° altera√ß√µes em m√∫ltiplas colunas de uma vez, dependendo de resultados booleanos.

```{r}
## Adicionar colunas
penguins_mutate <- penguins %>% 
    dplyr::mutate(body_mass_kg = body_mass_g/1e3, .before = sex)
head(penguins_mutate)

## Modificar v√°rias colunas
penguins_mutate_across <- penguins %>% 
    dplyr::mutate(across(where(is.factor), as.character))
head(penguins_mutate_across)
```

### arrange()

Al√©m de opera√ß√µes em colunas, podemos fazer opera√ß√µes em linhas. Vamos come√ßar com a reordena√ß√£o das linhas com base nos valores das colunas. Para essa opera√ß√£o, usamos a fun√ß√£o `dplyr::arrange()`. Podemos reordenar por uma ou mais colunas de forma crescente ou decrescente usando a fun√ß√£o `desc()` ou o operador `-` antes da coluna de interesse. Da mesma forma que na fun√ß√£o `dplyr::mutate()`, podemos usar as fun√ß√µes de replica√ß√£o para ordenar as linhas para v√°rias colunas de uma vez, dependendo de resultados booleanos.

```{r}
## Reordenar linhas - crescente
penguins_arrange <- penguins %>% 
    dplyr::arrange(body_mass_g)
head(penguins_arrange)

## Reordenar linhas - decrescente
penguins_arrange_desc <- penguins %>% 
    dplyr::arrange(desc(body_mass_g))
head(penguins_arrange_desc)

## Reordenar linhas - decrescente
penguins_arrange_desc_m <- penguins %>% 
    dplyr::arrange(-body_mass_g)
head(penguins_arrange_desc_m)

## Reordenar linhas - multiplas colunas
penguins_arrange_across <- penguins %>% 
    dplyr::arrange(across(where(is.numeric)))
head(penguins_arrange_across)
```

### filter()

Uma das principais e mais usuais opera√ß√µes que podemos realizar em linhas √© a sele√ß√£o de linhas atrav√©s do filtro por valores de uma ou mais colunas, utilizando a fun√ß√£o `dplyr::filter()`. Para realizar os filtros utilizaremos grande parte dos operadores relacionais e l√≥gicos que listamos na Tabela \@ref(tab:tab-operadores) no Cap√≠tulo \@ref(cap4), especialmente os l√≥gicos para combina√ß√µes de filtros em mais de uma coluna. Al√©m desses operadores, podemos utilizar a fun√ß√£o `is.na()` para filtros em elementos faltantes, e as fun√ß√µes `dplyr::between()` e `dplyr::near()` para filtros entre valores, e para valores pr√≥ximos com certa toler√¢ncia, respectivamente. Por fim, podemos usar as fun√ß√µes de replica√ß√£o para filtro das linhas para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Filtrar linhas
penguins_filter <- penguins %>% 
    dplyr::filter(species == "Adelie")
head(penguins_filter)

## Filtrar linhas
penguins_filter_two <- penguins %>% 
    dplyr::filter(species == "Adelie" & sex == "female")
head(penguins_filter_two)

## Filtrar linhas
penguins_filter_in <- penguins %>% 
    dplyr::filter(species %in% c("Adelie", "Gentoo"),
                  sex == "female")
head(penguins_filter_in)

## Filtrar linhas - NA
penguins_filter_na <- penguins %>% 
    dplyr::filter(!is.na(sex) == TRUE)
head(penguins_filter_na)

## Filtrar linhas - intervalos
penguins_filter_between <- penguins %>% 
    dplyr::filter(between(body_mass_g, 3000, 4000))
head(penguins_filter_between)

## Filtrar linhas por v√°rias colunas
penguins_filter_if <- penguins %>% 
    dplyr::filter(if_all(where(is.integer), ~ . > 200))
head(penguins_filter_if)
```

### slice()

Al√©m da sele√ß√£o de linhas por filtros, podemos fazer a sele√ß√£o das linhas por intervalos, indicando quais linhas desejamos, usando a fun√ß√£o `dplyr::slice()`, e informando o argumento `n` para o n√∫mero da linha ou intervalo das linhas. Essa fun√ß√£o possui varia√ß√µes no sufixo muito interessantes: `dplyr::slice_head()` e `dplyr::slice_tail()` seleciona as primeiras e √∫ltimas linhas, `dplyr::slice_min()` e `dplyr::slice_max()` seleciona linhas com os maiores e menores valores de uma coluna, e `dplyr::slice_sample()` seleciona linhas aleatoriamente.

```{r}
## Seleciona linhas
penguins_slice <- penguins %>% 
    dplyr::slice(n = c(1, 3, 300:n()))
head(penguins_slice)

## Seleciona linhas - head
penguins_slice_head <- penguins %>% 
    dplyr::slice_head(n = 5)
head(penguins_slice_head)

## Seleciona linhas - max
penguins_slice_max <- penguins %>% 
    dplyr::slice_max(body_mass_g, n = 5)
head(penguins_slice_max)

## Seleciona linhas - sample
penguins_slice_sample <- penguins %>% 
    dplyr::slice_sample(n = 30)
head(penguins_slice_sample)
```

### distinct()

A √∫ltima opera√ß√£o que apresentaremos para linhas √© a retirada de linhas com valores repetidos com base nos valores de uma ou mais colunas, utilizando a fun√ß√£o `dplyr::distinct()`. Essa fun√ß√£o por padr√£o retorna apenas a(s) coluna(s) utilizada(s) para retirar as linhas com valores repetidos, sendo necess√°rio acrescentar o argumento `.keep_all = TRUE` para retornar todas as colunas. Por fim, podemos usar as fun√ß√µes de replica√ß√£o para retirar linhas com valores repetidos para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Retirar linhas com valores repetidos
penguins_distinct <- penguins %>% 
    dplyr::distinct(body_mass_g)
head(penguins_distinct)

## Retirar linhas com valores repetidos - manter as outras colunas
penguins_distinct_keep_all <- penguins %>% 
    dplyr::distinct(body_mass_g, .keep_all = TRUE)
head(penguins_distinct_keep_all)

## Retirar linhas com valores repetidos para v√°rias colunas
penguins_distinct_keep_all_across <- penguins %>% 
    dplyr::distinct(across(where(is.integer)), .keep_all = TRUE)
head(penguins_distinct_keep_all_across)
```

### count()

Agora entraremos no assunto de resumo das observa√ß√µes. Podemos fazer contagens resumos dos nossos dados, utilizando para isso a fun√ß√£o `dplyr::count()`. Essa fun√ß√£o contar√° valores de uma ou mais colunas, geralmente para vari√°veis categ√≥ricas, semelhante √† fun√ß√£o Base R `table()`, mas num contexto *tidyverse*.

```{r}
## Contagens de valores para uma coluna
penguins_count <- penguins %>% 
    dplyr::count(species)
penguins_count

## Contagens de valores para mais de uma coluna
penguins_count_two <- penguins %>% 
    dplyr::count(species, island)
penguins_count_two
```

### group_by()

Uma grande parte das opera√ß√µes feitas nos dados s√£o realizadas em grupos definidos por valores de colunas com dados categ√≥ricas. A fun√ß√£o `dplyr::group_by()` transforma um `tibble` em um `tibble grouped`, onde as opera√ß√µes s√£o realizadas "por grupo". Essa fun√ß√£o √© utilizada geralmente junto com a fun√ß√£o `dplyr::summarise()`, que veremos logo em seguida. O agrupamento n√£o altera a apar√™ncia dos dados (al√©m de informar como est√£o agrupados). A fun√ß√£o `dplyr::ungroup()` remove o agrupamento. Podemos ainda usar fun√ß√µes de replica√ß√£o para fazer os agrupamentos para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Agrupamento
penguins_group_by <- penguins %>% 
    dplyr::group_by(species)
head(penguins_group_by)

## Agrupamento de v√°rias colunas
penguins_group_by_across <- penguins %>% 
    dplyr::group_by(across(where(is.factor)))
head(penguins_group_by_across)
```

### summarise()

Como dissemos, muitas vezes queremos resumir nossos dados, principalmente para ter uma no√ß√£o geral das vari√°veis (colunas) ou mesmo come√ßar a an√°lise explorat√≥ria resumindo vari√°veis cont√≠nuas por grupos de vari√°veis categ√≥ricas. Dessa forma, ao utilizar a fun√ß√£o `dplyr::summarise()` teremos um novo `tibble` com os dados resumidos, que √© a agrega√ß√£o ou resumo dos dados atrav√©s de fun√ß√µes. Da mesma forma que outras fun√ß√µes, podemos usar fun√ß√µes de replica√ß√£o para resumir valores para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Resumo
penguins_summarise <- penguins %>% 
    dplyr::group_by(species) %>% 
    dplyr::summarize(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),
                     body_mass_g_sd = sd(body_mass_g, na.rm = TRUE))
penguins_summarise

## Resumo para v√°rias colunas
penguins_summarise_across <- penguins %>% 
    dplyr::group_by(species) %>% 
    dplyr::summarize(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
penguins_summarise_across
```

### bind_rows() e bind_cols()

Muitas vezes teremos de combinar duas ou mais tabelas de dados. Podemos utilizar as fun√ß√µes Base R `rbind()` e `cbind()`, como vimos no Cap√≠tulo \@ref(cap4). Entretanto, pode ser interessante avan√ßar para as fun√ß√µes `dplyr::bind_rows()` e `dplyr::bind_cols()` do formato *tidyverse*. A ideia √© muito semelhante: a primeira fun√ß√£o combina dados por linhas e a segunda por colunas. Entretanto, h√° algumas vantagens no uso dessas fun√ß√µes, como a identifica√ß√£o das linhas pelo argumento `.id` para a primeira fun√ß√£o, e a confer√™ncia do nome das colunas pelo argumento `.name_repair` para a segunda fun√ß√£o.

```{r}
## Selecionar as linhas para dois tibbles
penguins_01 <- dplyr::slice(penguins, 1:5)
penguins_02 <- dplyr::slice(penguins, 51:55)

## Combinar as linhas
penguins_bind_rows <- dplyr::bind_rows(penguins_01, penguins_02, .id = "id")
head(penguins_bind_rows)

## Combinar as colunas
penguins_bind_cols <- dplyr::bind_cols(penguins_01, penguins_02, .name_repair = "unique")
head(penguins_bind_cols)
```

### *_join()

Finalmente, veremos o √∫ltimo conjunto de fun√ß√µes do pacote `dplyr`, a jun√ß√£o de tabelas. Nessa opera√ß√£o, fazemos a combina√ß√£o de pares de conjunto de dados tabulares por uma ou mais colunas chaves. H√° dois tipos de jun√ß√µes: jun√ß√£o de modifica√ß√£o e jun√ß√£o de filtragem. A jun√ß√£o de modifica√ß√£o primeiro combina as observa√ß√µes por suas chaves e, em seguida, copia as vari√°veis (colunas) de uma tabela para a outra. √â fundamental destacar a import√¢ncia da coluna chave, que √© indicada pelo argumento `by`. Essa coluna deve conter elementos que sejam comuns √†s duas tabelas para que haja a combina√ß√£o dos elementos.

Existem quatro tipos de jun√ß√µes de modifica√ß√µes, que s√£o realizadas pelas fun√ß√µes: `dplyr::inner_join()`, `dplyr::left_join()`, `dplyr::full_join()` e `dplyr::right_join()`, e que podem ser representadas na Figura \@ref(fig:fig-r-join).

```{r fig-r-join, echo=FALSE, fig.cap="Diferentes tipos de joins, representados com um diagrama de Venn. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig03.png")
```

Considerando a nomenclatura de duas tabelas de dados por `x` e `y`, temos:

-   `inner_join(x, y)`: mant√©m apenas as observa√ß√µes em `x` e em `y`
-   `left_join(x, y)`: mant√©m todas as observa√ß√µes em `x`
-   `right_join(x, y)`: mant√©m todas as observa√ß√µes em `y`
-   `full_join(x, y)`: mant√©m todas as observa√ß√µes em `x` e em `y`

Aqui, vamos demostrar apenas a fun√ß√£o `dplyr::left_join()`, combinando um `tibble` de coordenadas geogr√°ficas das ilhas com o conjunto de dados do penguins.

```{r}
## Adicionar uma coluna chave de ids
penguin_islands <- tibble(
    island = c("Torgersen", "Biscoe", "Dream", "Alpha"),
    longitude = c(-64.083333, -63.775636, -64.233333, -63),
    latitude = c(-64.766667, -64.818569, -64.733333, -64.316667))

## Jun√ß√£o - left
penguins_left_join <- dplyr::left_join(penguins, penguin_islands, by = "island")
head(penguins_left_join)
```

J√° o segundo tipo de jun√ß√£o, a jun√ß√£o de filtragem combina as observa√ß√µes da mesma maneira que as jun√ß√µes de modifica√ß√£o, mas afetam as observa√ß√µes (linhas), n√£o as vari√°veis (colunas). Existem dois tipos.

-   `semi_join(x, y)`: mant√©m todas as observa√ß√µes em `x` que t√™m uma correspond√™ncia em `y`
-   `anti_join(x, y)`: elimina todas as observa√ß√µes em `x` que t√™m uma correspond√™ncia em `y`

De forma geral, *semi-joins* s√£o √∫teis para corresponder tabelas de resumo filtradas de volta √†s linhas originais, removendo as linhas que n√£o estavam antes do join. J√° *anti-joins* s√£o √∫teis para diagnosticar incompatibilidades de jun√ß√£o, por exemplo, ao verificar os elementos que n√£o combinam entre duas tabelas de dados.

### Opera√ß√µes de conjuntos e compara√ß√£o de dados

Temos ainda opera√ß√µes de conjuntos e compara√ß√£o de dados.

-   `union(x, y)`: retorna todas as linhas que aparecem em `x`, `y` ou mais dos conjuntos de dados
-   `interesect(x, y)`: retorna apenas as linhas que aparecem em `x` e em `y`
-   `setdiff(x, y)`: retorna as linhas que aparecem `x`, mas n√£o em `y`
-   `setequal(x, y)`: retorna se `x` e `y` s√£o iguais e quais suas diferen√ßas

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [13 Relational data](https://r4ds.had.co.nz/relational-data.html) de Wickham & Grolemund [-@wickham2017].

## stringr

O pacote `stringr` fornece um conjunto de fun√ß√µes para a manipula√ß√£o de caracteres ou strings. O pacote concentra-se nas fun√ß√µes de manipula√ß√£o mais importantes e comumente usadas. Para fun√ß√µes mais espec√≠ficas, recomenda-se usar o pacote `stringi`, que fornece um conjunto mais abrangente de fun√ß√µes. As fun√ß√µes do `stringr` podem ser agrupadas em algumas opera√ß√µes para tarefas espec√≠ficas como i) correspond√™ncia de padr√µes, ii)retirar e acrescentar espa√ßos em branco, iii) mudar mai√∫sculas e min√∫sculas, al√©m de muitas outras opera√ß√µes com caracteres.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://stringr.tidyverse.org/reference/index.html) do pacote.

Demonstraremos algumas fun√ß√µes para algumas opera√ß√µes mais comuns, utilizando um vetor de um elemento, com o string "penguins".

Podemos explorar o comprimento de strings com a fun√ß√£o `stringr::str_length()`.

```{r}
## Comprimento
stringr::str_length(string = "penguins")
```

Extrair um string por sua posi√ß√£o usando a fun√ß√£o `stringr::str_sub()` ou por um padr√£o com `stringr::str_extract()`.

```{r}
## Extrair pela posi√ß√£o
stringr::str_sub(string = "penguins", end = 3)

## Extrair por padr√£o
stringr::str_extract(string = "penguins", pattern = "p")
```

Substituir strings por outros strings com `stringr::str_replace()`.

```{r}
## Substituir
stringr::str_replace(string = "penguins", pattern = "i", replacement = "y")
```

Separar strings por um padr√£o com a fun√ß√£o `stringr::str_split()`.

```{r}
## Separar
stringr::str_split(string = "p-e-n-g-u-i-n-s", pattern = "-", simplify = TRUE)
```

Inserir espa√ßos em brancos pela esquerda, direita ou ambos com a fun√ß√£o `stringr::str_pad()`.

```{r}
## Inserir espacos em branco
stringr::str_pad(string = "penguins", width = 10, side = "left")
stringr::str_pad(string = "penguins", width = 10, side = "right")
stringr::str_pad(string = "penguins", width = 10, side = "both")
```

Tamb√©m podemos remover espa√ßos em branco da esquerda, direita ou ambos, utilizando `stringr::str_trim()`.

```{r}
## Remover espacos em branco
stringr::str_trim(string = " penguins ", side = "left")
stringr::str_trim(string = " penguins ", side = "right")
stringr::str_trim(string = " penguins ", side = "both")
```

Podemos tamb√©m alterar min√∫sculas e mai√∫sculas em diferentes posi√ß√µes do string, com v√°rias fun√ß√µes.

```{r}
## Alterar min√∫sculas e mai√∫sculas
stringr::str_to_lower(string = "Penguins")
stringr::str_to_upper(string = "penguins")
stringr::str_to_sentence(string = "penGuins")
stringr::str_to_title(string = "penGuins")
```

Podemos ainda ordenar os elementos de um vetor por ordem alfab√©tica de forma crescente ou decrescente, usando `stringr::str_sort()`.

```{r}
## Ordenar
stringr::str_sort(x = letters)
stringr::str_sort(x = letters, dec = TRUE)
```

Podemos ainda utilizar essas fun√ß√µes em complemento com o pacote `dplyr`, para alterar os strings de colunas ou nome das colunas.

```{r}
## Alterar valores das colunas
penguins_stringr_valores <- penguins %>% 
    dplyr::mutate(species = stringr::str_to_lower(species))

## Alterar nome das colunas
penguins_stringr_nomes <- penguins %>% 
    dplyr::rename_with(stringr::str_to_title)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [14 Strings](https://r4ds.had.co.nz/strings.html) de Wickham & Grolemund [-@wickham2017].

## forcats

O pacote `forcats` fornece um conjunto de ferramentas √∫teis para facilitar a manipula√ß√£o de fatores. Como dito no Cap√≠tulo \@ref(cap4), usamos fatores geralmente quando temos dados categ√≥ricos, que s√£o vari√°veis que possuem um conjunto de valores fixos e conhecidos. As fun√ß√µes s√£o utilizadas principalmente para: i) mudar a ordem dos n√≠veis, ii) mudar os valores dos n√≠veis, iii) adicionar e remover n√≠veis, iv) combinar m√∫ltiplos n√≠veis, al√©m de outras opera√ß√µes.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://forcats.tidyverse.org/reference/index.html) do pacote.

Vamos utilizar ainda os dados `penguins` e `penguins_raw` para exemplificar o uso do pacote `forcats`.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

Primeiramente, vamos converter dados de string para fator, utilizando a fun√ß√£o `forcats::as_factor()`.

```{r}
## String
forcats::as_factor(penguins_raw$Species) %>% head()
```

Podemos facilmente mudar o nome dos n√≠veis utilizando a fun√ß√£o `forcats::fct_recode()`.

```{r}
## Mudar o nome dos n√≠veis
forcats::fct_recode(penguins$species, a = "Adelie", c = "Chinstrap", g = "Gentoo") %>% head()
```

Para inverter os n√≠veis, usamos a fun√ß√£o `forcats::fct_rev()`.

```{r}
## Inverter os n√≠veis
forcats::fct_rev(penguins$species) %>% head()
```

Uma opera√ß√£o muito comum com fatores √© mudar a ordem dos n√≠veis. Quando precisamos especificar a ordem dos n√≠veis, podemos fazer essa opera√ß√£o manualmente com a fun√ß√£o `forcats::fct_relevel()`.

```{r}
## Especificar a ordem dos n√≠veis
forcats::fct_relevel(penguins$species, "Chinstrap", "Gentoo", "Adelie") %>% head()
```

Como vimos, a reordena√ß√£o dos n√≠veis pode ser feita manualmente. Mas existem outras formas autom√°ticas de reordena√ß√£o seguindo algumas regras, para as quais existem fun√ß√µes espec√≠ficas.

-   `forcats::fct_inorder()`: pela ordem em que aparecem pela primeira vez
-   `forcats::fct_infreq()`: por n√∫mero de observa√ß√µes com cada n√≠vel (decrescente, i.e., o maior primeiro)
-   `forcats::fct_inseq()`: pelo valor num√©rico do n√≠vel

```{r}
## N√≠veis pela ordem em que aparecem
forcats::fct_inorder(penguins$species) %>% head()

## Ordem (decrescente) de frequ√™ncia
forcats::fct_infreq(penguins$species) %>% head()
```

Por fim, podemos fazer a agrega√ß√£o de n√≠veis raros em um n√≠vel utilizando a fun√ß√£o `forcats::fct_lump()`.

```{r}
## Agrega√ß√£o de n√≠veis raros em um n√≠vel
forcats::fct_lump(penguins$species) %>% head()
```

Podemos ainda utilizar essas fun√ß√µes em complemento com o pacote `dplyr` para fazer manipula√ß√µes de fatores nas colunas de `tibbles`.

```{r}
## Transformar v√°rias colunas em fator
penguins_raw_multi_factor <- penguins_raw %>% 
    dplyr::mutate(across(where(is.character), forcats::as_factor))
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [15 Factors](https://r4ds.had.co.nz/factors.html) de Wickham & Grolemund [-@wickham2017].

## lubridate

O pacote `lubridate` fornece um conjunto de fun√ß√µes para a manipula√ß√£o de dados de data e hor√°rio. Dessa forma, esse pacote facilita a manipula√ß√£o dessa classe de dado no R, pois geralmente esses dados n√£o s√£o intuitivos e mudam dependendo do tipo de objeto de data e hor√°rio. Al√©m disso, os m√©todos que usam datas e hor√°rios devem levar em considera√ß√£o fusos hor√°rios, anos bissextos, hor√°rios de ver√£o, al√©m de outras particularidades. Existem diversas fun√ß√µes nesse pacote, sendo as mesmas focadas em: i) transforma√ß√µes de data/hor√°rio, ii) componentes, iii) arredondamentos, iv) dura√ß√µes, v) per√≠odos, vi) intervalos, al√©m de muitas outras fun√ß√µes espec√≠ficas.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://lubridate.tidyverse.org/reference/index.html) do pacote.

Apesar de estar inserido no escopo do *tidyverse*, este pacote n√£o √© carregado com os demais, requisitando seu carregamento solo.

```{r}
## Carregar
library(lubridate)
```

Existem tr√™s tipos de dados data/hor√°rio:

- **Data**: tempo em dias, meses e anos `<date>`
- **Hor√°rio**: tempo dentro de um dia `<time>`
- **Data-hor√°rio**: tempo em um instante (data mais tempo) `<dttm>`

Para trabalhar exclusivamente com hor√°rios, podemos utilizar o pacote `hms`.

√â fundamental tamb√©m destacar que algumas letras ter√£o um significado temporal, sendo abrevia√ß√µes de diferentes per√≠odos em ingl√™s: **y**ear (ano), **m**onth (m√™s), **w**eak (semana), **d**ay (dia), **h**our (hora), **m**inute (minuto), e **s**econd (segundo).

Para acessar a informa√ß√£o da data e hor√°rios atuais podemos utilizar as fun√ß√µes `lubridate::today()` e `lubridate::now()`.

```{r}
## Extrair a data nesse instante
lubridate::today()

## Extrair a data e tempo nesse instante
lubridate::now()
```

Al√©m dessas informa√ß√µes instant√¢neas, existem tr√™s maneiras de criar um dado de data/hor√°rio.

-   De um string
-   De componentes individuais de data e hor√°rio
-   De um objeto de data/hor√°rio existente

Os dados de data/hor√°rio geralmente est√£o no formato de strings. Podemos transformar os dados especificando a ordem dos seus componentes, ou seja, a ordem em que ano, m√™s e dia aparecem no string, usando as letras `y` (ano), `m` (m√™s) e `d` (dia) na mesma ordem, por exemplo, `lubridate::dmy()`.

```{r}
## Strings e n√∫meros para datas
lubridate::dmy("03-03-2021")
```

Essas fun√ß√µes tamb√©m aceitam n√∫meros sem aspas, al√©m de serem muito vers√°teis e funcionarem em outros diversos formatos.

```{r, eval=FALSE}
## Strings e n√∫meros para datas
lubridate::dmy("03-Mar-2021")
lubridate::dmy(03032021)
lubridate::dmy("03032021")
lubridate::dmy("03/03/2021")
lubridate::dmy("03.03.2021")
```

Al√©m da data, podemos especificar hor√°rios atrelados a essas datas. Para criar uma data com hor√°rio adicionamos um underscore (`_`) e `h` (hora), `m` (minuto) e `s` (segundo) ao nome da fun√ß√£o, al√©m do argumento `tz` para especificar o *fuso hor√°rio* (tema tratado mais adiante nessa se√ß√£o).

```{r}
## Especificar hor√°rios e fuso hor√°rio
lubridate::dmy_h("03-03-2021 13")
lubridate::dmy_hm("03-03-2021 13:32")
lubridate::dmy_hms("03-03-2021 13:32:01")
lubridate::dmy_hms("03-03-2021 13:32:01", tz = "America/Sao_Paulo")
```

Podemos ainda ter componentes individuais de data/hor√°rio em m√∫ltiplas colunas. Para realizar essa transforma√ß√£o, podemos usar as fun√ß√µes `lubridate::make_date()` e `lubridate::make_datetime()`.

```{r}
## Dados com componentes individuais
dados <- tibble::tibble(
    ano = c(2021, 2021, 2021),
    mes = c(1, 2, 3),
    dia = c(12, 20, 31),
    hora = c(2, 14, 18), 
    minuto = c(2, 44, 55))

## Data de componentes individuais
dados %>% 
    dplyr::mutate(data = lubridate::make_datetime(ano, mes, dia, hora, minuto))
```

Por fim, podemo criar datas modificando entre data/hor√°rio e data, utilizando as fun√ß√µes `lubridate::as_datetime()` e `lubridate::as_date()`.

```{r}
## Data para data-hor√°rio
lubridate::as_datetime(today())

## Data-hor√°rio para data
lubridate::as_date(now())
```

Uma vez que entendemos como podemos criar dados de data/hor√°rio, podemos explorar fun√ß√µes para acessar e definir componentes individuais. Para essa tarefa existe uma grande quantidade de fun√ß√µes para acessar de partes espec√≠ficas de datas e hor√°rios.

-   `year()`: acessa o ano
-   `month()`: acessa o m√™s
-   `month()`: acessa o dia
-   `yday()`: acessa o dia do ano
-   `mday()`: acessa o dia do m√™s
-   `wday()`: acessa o dia da semana
-   `hour()`: acessa as horas
-   `minute()`: acessa os minutos
-   `second()`: acessa os segundos

```{r}
## Extrair
lubridate::year(now())
lubridate::month(now())
lubridate::month(now(), label = TRUE)
lubridate::day(now())
lubridate::wday(now())
lubridate::wday(now(), label = TRUE)
lubridate::second(now())
```

Al√©m de acessar componentes de datas e hor√°rios, podemos usar essas fun√ß√µes para fazer a inclus√£o de informa√ß√µes de datas e hor√°rios.

```{r}
## Data
data <- dmy_hms("04-03-2021 01:04:56")

## Incluir
lubridate::year(data) <- 2020
lubridate::month(data) <- 01
lubridate::hour(data) <- 13
```

Mais convenientemente, podemos utilizar a fun√ß√£o `update()` para alterar v√°rios valores de uma vez.

```{r}
## Incluir v√°rios valores
update(data, year = 2020, month = 1, mday = 1, hour = 1)
```

Muitas vezes precisamos fazer opera√ß√µes com datas, como a aritm√©tica: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o. Para tanto, √© preciso entender tr√™s classes importantes que representam intervalos de tempo.

-   **Dura√ß√µes**: representam um n√∫mero exato de segundos
-   **Per√≠odos**: representam unidades humanas como semanas e meses
-   **Intervalos**: representam um ponto inicial e final

Quando fazemos uma subtra√ß√£o de datas, criamos um objeto da classe `difftime`. Essa classe pode ser um pouco complicada de trabalhar, ent√£o dentro do *lubridate* usamos fun√ß√µes que convertem essa classe em dura√ß√£o, da classe `Duration`. As dura√ß√µes sempre registram o intervalo de tempo em segundos, com alguma unidade de tempo maior entre par√™nteses. H√° uma s√©rie de fun√ß√µes para tratar dessa classe.

-   `duration()`: cria data em dura√ß√£o
-   `as.duration()`: converte datas em dura√ß√£o
-   `dyears()`: dura√ß√£o de anos
-   `dmonths()`: dura√ß√£o de meses
-   `dweeks()`: dura√ß√£o de semanas
-   `ddays()`: dura√ß√£o de dias
-   `dhours()`: dura√ß√£o de horas
-   `dminutes()`: dura√ß√£o de minutos
-   `dseconds()`: dura√ß√£o de segundos

```{r}
## Subtra√ß√£o de datas
tempo_estudando_r <- lubridate::today() - lubridate::dmy("30-11-2011")

## Convers√£o para dura√ß√£o
tempo_estudando_r_dur <- lubridate::as.duration(tempo_estudando_r)

## Criando dura√ß√µes
lubridate::duration(90, "seconds")
lubridate::duration(1.5, "minutes")
lubridate::duration(1, "days")

## Transforma√ß√£o da dura√ß√£o
lubridate::dseconds(100)
lubridate::dminutes(100)
lubridate::dhours(100)
lubridate::ddays(100)
lubridate::dweeks(100)
lubridate::dyears(100)
```

Podemos ainda utilizar as dura√ß√µes para fazer opera√ß√µes aritm√©ticas com datas como adi√ß√£o, subtra√ß√£o e multiplica√ß√£o.

```{r}
## Somando dura√ß√µes a datas
lubridate::today() + lubridate::ddays(1)

## Subtraindo dura√ß√µes de datas
lubridate::today() - lubridate::dyears(1)

## Multiplicando dura√ß√µes
2 * dyears(2)
```

Al√©m das dura√ß√µes, podemos usar per√≠odos, que s√£o extens√µes de tempo n√£o fixados em segundos como as dura√ß√µes, mas flex√≠veis, com o tempo em dias, semanas, meses ou anos, permitindo uma interpreta√ß√£o mais intuitiva das datas. Novamente, h√° uma s√©rie de fun√ß√µes para realizar essas opera√ß√µes.

-   `period()`: cria data em per√≠odo
-   `as.period()`: converte datas em per√≠odo
-   `seconds()`: per√≠odo em segundos
-   `minutes()`: per√≠odo em minutos
-   `hours()`: per√≠odo em horas
-   `days()`: per√≠odo em dias
-   `weeks()`: per√≠odo em semanas
-   `months()`: per√≠odo em meses
-   `years()`: per√≠odo em anos

```{r}
## Criando per√≠odos
period(c(90, 5), c("second", "minute"))
period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))

## Transforma√ß√£o de per√≠odos
lubridate::seconds(100)
lubridate::minutes(100)
lubridate::hours(100)
lubridate::days(100)
lubridate::weeks(100)
lubridate::years(100)
```

Al√©m disso, podemos fazer opera√ß√µes com os per√≠odos, somando e subtraindo.

```{r}
## Somando datas
lubridate::today() + lubridate::weeks(10)

## Subtraindo datas
lubridate::today() - lubridate::weeks(10)

## Criando datas recorrentes
lubridate::today() + lubridate::weeks(0:10)
```

Por fim, intervalos s√£o per√≠odos de tempo limitados por duas datas, possuindo uma dura√ß√£o com um ponto de partida, que o faz preciso para determinar uma dura√ß√£o. Intervalos s√£o objetos da classe `Interval`. Da mesma forma que para dura√ß√£o e per√≠odos, h√° uma s√©rie de fun√ß√µes para realizar essas opera√ß√µes.

-   `interval()`: cria data em intervalo
-   `%--%`: cria data em intervalo
-   `as.interval()`: converte datas em intervalo
-   `int_start()`: acessa ou atribui data inicial de um intervalo
-   `int_end()`: acessa ou atribui data final de um intervalo
-   `int_length()`: comprimento de um intervalo em segundos
-   `int_flip()`: inverte a ordem da data de in√≠cio e da data de t√©rmino em um intervalo
-   `int_shift()`: desloca as datas de in√≠cio e t√©rmino de um intervalo
-   `int_aligns()`: testa se dois intervalos compartilham um ponto final
-   `int_standardize()`: garante que todos os intervalos sejam positivos
-   `int_diff()`: retorna os intervalos que ocorrem entre os elementos de data/hor√°rio
-   `int_overlaps()`: testa se dois intervalos se sobrep√µem
-   `%within%`: testa se o primeiro intervalo est√° contido no segundo

```{r}
## Criando duas datas - in√≠cio de estudos do R e nascimento do meu filho
r_inicio <- lubridate::dmy("30-11-2011")
filho_nascimento <- lubridate::dmy("26-09-2013")
r_hoje <- lubridate::today()

## Criando intervalos - interval
r_intervalo <- lubridate::interval(r_inicio, r_hoje)

## Criando intervalos - interval %--%
filho_intervalo <- filho_nascimento %--% lubridate::today()

## Opera√ß√µes com intervalos
lubridate::int_start(r_intervalo)
lubridate::int_end(r_intervalo)
lubridate::int_length(r_intervalo)
lubridate::int_flip(r_intervalo)
lubridate::int_shift(r_intervalo, duration(days = 30))
```

Uma opera√ß√£o de destaque √© verificar a sobreposi√ß√£o entre dois intervalos.

```{r}
## Verificar sobreposi√ß√£o - int_overlaps
lubridate::int_overlaps(r_intervalo, filho_intervalo)

## Verificar se intervalo est√° contido
r_intervalo %within% filho_intervalo
filho_intervalo %within% r_intervalo
```

Podemos ainda calcular quantos per√≠odos existem dentro de um intervalo, utilizando as opera√ß√µes de `/` e `%/%`.

```{r}
## Per√≠odos dentro de um intervalo - anos
r_intervalo / lubridate::years()
r_intervalo %/% lubridate::years()

## Per√≠odos dentro de um intervalo - dias e semandas
filho_intervalo / lubridate::days()
filho_intervalo / lubridate::weeks()
```

Ainda podemos fazer transforma√ß√µes dos dados para per√≠odos e ter todas as unidades de data e tempo que o intervalo compreende.

```{r}
## Tempo total estudando R
lubridate::as.period(r_intervalo)

## Idade do meu filho
lubridate::as.period(filho_intervalo)
```

Por fim, fusos hor√°rios tendem a ser um fator complicador quando precisamos analisar informa√ß√µes instant√¢neas de tempo (hor√°rio) de outras partes do planeta, ou mesmo fazer convers√µes dos hor√°rios. No `lubridate` h√° fun√ß√µes para ajudar nesse sentido. Para isso, podemos utilizar a fun√ß√£o `lubridate::with_tz()` e no argumento `tzone` informar o fuso hor√°rio para a transforma√ß√£o do hor√°rio.

Podemos descobrir o fuso hor√°rio que o R est√° considerando com a fun√ß√£o `Sys.timezone()`.

```{r}
## Fuso hor√°rio no R
Sys.timezone()
```

No R h√° uma listagem dos nomes dos fusos hor√°rios que podemos utilizar no argumento `tzone` para diferentes fusos hor√°rios.

```{r}
## Verificar os fuso hor√°rios
length(OlsonNames())
head(OlsonNames())
```

Podemos nos perguntar que horas s√£o em outra parte do globo ou fazer as convers√µes facilmente no *lubridate*.

```{r}
## Que horas s√£o em...
lubridate::with_tz(lubridate::now(), tzone = "America/Sao_Paulo")
lubridate::with_tz(lubridate::now(), tzone = "GMT")
lubridate::with_tz(lubridate::now(), tzone = "Europe/Berlin")

## Altera o fuso sem mudar a hora
lubridate::force_tz(lubridate::now(), tzone = "GMT")
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [16 Dates and times](https://r4ds.had.co.nz/dates-and-times.html) de Wickham & Grolemund [-@wickham2017].

## purrr

O pacote `purrr` implementa a *Programa√ß√£o Funcional* no R, fornecendo um conjunto completo e consistente de ferramentas para trabalhar com fun√ß√µes e vetores. A programa√ß√£o funcional √© um assunto bastante extenso, sendo mais conhecido no R pela fam√≠lia de fun√ß√µes `purrr::map()`, que permite substituir muitos *loops for* por um c√≥digo mais sucinto e f√°cil de ler. N√£o focaremos aqui nas outras fun√ß√µes, pois esse √© um assunto extremamente extenso.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://purrr.tidyverse.org/reference/index.html) do pacote.

Um *loop for* pode ser entendido como uma itera√ß√£o: um bloco de c√≥digos √© repetido mudando um contador de uma lista de possibilidades. Vamos exemplificar com uma itera√ß√£o bem simples, onde imprimiremos no console os valores de 1 a 10, utilizando a fun√ß√£o `for()`, um contador `i` em um vetor de dez n√∫meros `1:10` que ser√° iterado, no bloco de c√≥digos definido entre `{}`, usando a fun√ß√£o `print()` para imprimir os valores.

A ideia √© bastante simples: a fun√ß√£o `for()` vai atribuir o primeiro valor da lista ao contador `i`, esse contador ser√° utilizado em todo o bloco de c√≥digos. Quando o bloco terminar, o segundo valor √© atribu√≠do ao contador `i` e entra no bloco de c√≥digos, repetindo esse processo at√© que todos os elementos da lista tenham sido atribu√≠dos ao contador.

```{r}
## Loop for
for(i in 1:10){
    print(i)
}
```

Com essa ideia em mente, a programa√ß√£o funcional faz a mesma opera√ß√£o utilizando a fun√ß√£o `purrr::map()`. O mesmo *loop for* ficaria dessa forma.

```{r, cache=FALSE}
## Loop for com map
purrr::map(.x = 1:10, .f = print)
```

Nessa estrutura, temos:

`map(.x, .f)`

-   `.x`: um vetor, lista ou data frame
-   `.f`: uma fun√ß√£o

Num outro exemplo, aplicaremos a fun√ß√£o `sum()` para somar os valores de v√°rios elementos de uma lista.

```{r}
## Fun√ß√£o map
x <- list(1:5, c(4, 5, 7), c(1, 1, 1), c(2, 2, 2, 2, 2))
purrr::map(x, sum)
```

H√° diferente tipos de retornos da fam√≠lia `purrr::map()`.

-   `map()`: retorna uma lista
-   `map_chr()`: retorna um vetor de strings
-   `map_dbl()`: retorna um vetor num√©rico (double)
-   `map_int()`: retorna um vetor num√©rico (integer)
-   `map_lgl()`: retorna um vetor l√≥gico
-   `map_dfr()`: retorna um data frame (por linhas)
-   `map_dfc()`: retorna um data frame (por colunas)

```{r}
## Varia√ß√µes da fun√ß√£o map
purrr::map_dbl(x, sum)
purrr::map_chr(x, paste, collapse = " ")
```

Essas funcionalidades j√° eram conhecidas no Base R pelas fun√ß√µes da *fam√≠lia `apply()`*: `apply()`, `lapply()`, `sapply()`, `vapply()`, `mapply()`, `rapply()` e `tapply()`. Essas fun√ß√µes formam a base de combina√ß√µes mais complexas e ajudam a realizar opera√ß√µes com poucas linhas de c√≥digo, para diferentes retornos.

Temos ainda duas variantes da fun√ß√£o `map()`: `purrr::map2()` e `purrr::pmap()`, para duas ou mais listas, respectivamente. Como vimos para a primeira fun√ß√£o, existem v√°rias varia√ß√µes do sufixo para modificar o retorno da fun√ß√£o.

```{r}
## Listas
x <- list(3, 5, 0, 1)
y <- list(3, 5, 0, 1)
z <- list(3, 5, 0, 1)

## Fun√ß√£o map2
purrr::map2_dbl(x, y, prod)

## Fun√ß√£o pmap
purrr::pmap_dbl(list(x, y, z), prod)
```

Essas fun√ß√µes podem ser usadas em conjunto para implementar rotinas de manipula√ß√£o e an√°lise de dados com poucas linhas de c√≥digo, mas que n√£o exploraremos em sua completude aqui. Listamos dois exemplos simples.

```{r}
## Resumo dos dados
penguins %>% 
    dplyr::select(where(is.numeric)) %>% 
    tidyr::drop_na() %>% 
    purrr::map_dbl(mean)
```

```{r}
## An√°lise dos dados
penguins %>%
    dplyr::group_split(island, species) %>% 
    purrr::map(~ lm(bill_depth_mm ~ bill_length_mm, data = .x)) %>% 
    purrr::map(summary) %>% 
    purrr::map("r.squared")
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [21 Iteration](https://r4ds.had.co.nz/iteration.html) de Wickham & Grolemund [-@wickham2017].

## Para se aprofundar

Listamos a seguir livros que recomendamos para seguir com sua aprendizagem em R e tidyverse.

### Livros

Recomendamos aos interessados os livros: i) Oliveira e colaboradores [-@oliveira_ciencia_2018] [Ci√™ncia de dados com R](https://cdr.ibpad.com.br/), ii) Grolemund [-@williams_essentials_2018] The Essentials of Data Science: Knowledge Discovery Using R,iii) Holmes e Huber [-@holmes_modern_2019] [Modern Statistics for Modern Biology](https://www.huber.embl.de/msmb/), iv) Ismay e Kim [-@ismay_statistical_2020] [Statistical Inference via Data Science: A ModernDive into R and the Tidyverse](https://moderndive.com/), v) Wickham e Grolemund [-@wickham2017] [R for Data Science: Import, Tidy, Transform, Visualize, and Model Data](https://r4ds.had.co.nz/), vi) Zumel e Mount [-@zumel_practical_2014] Practical Data Science with R Paperback, vii) Irizarry [-@irizarry_data_2017] [Introduction to Data Science: Data Analysis and Prediction Algorithms with R](https://leanpub.com/dataanalysisforthelifesciences), e viii) Irizarry [-@irizarry_introduction_2019] [Introduction to Data Science](https://rafalab.github.io/dsbook/).

### Links

[Ci√™ncia de Dados em R](https://livro.curso-r.com/)

[tidyverse](https://www.tidyverse.org/)

[STHDA - Statistical tools for high-throughput data analysis](http://www.sthda.com/english/)

[Estat√≠stica √© com R! - tidyverse](http://www.estatisticacomr.uff.br/?page_id=741)

[Tidyverse Skills for Data Science in R](https://www.stephaniehicks.com/blog/tidyverse-skills-for-data-science-in-r-coursera-specialization/)

### Links

Para acesso na internet, indicamos os seguintes tutoriais:

- [Getting Started with the Tidyverse] (https://www.datacamp.com/community/tutorials/tidyverse-tutorial-r)
- [Tidyverse Basics](https://www.dataquest.io/blog/load-clean-data-r-tidyverse/)
- [Manipulando Dados com dplyr e tidyr](https://www.ufrgs.br/wiki-r/index.php?title=Manipulando_Dados_com_dplyr_e_tidyr)

## Exerc√≠cios

**5.1**
Reescreva as opera√ß√µes abaixo utilizando pipes `%>%`.

-   `log10(cumsum(1:100))`
-   `sum(sqrt(abs(rnorm(100))))`
-   `sum(sort(sample(1:10, 10000, rep = TRUE)))`

**5.2**
Use a fun√ß√£o `download.file()` e `unzip()` para baixar e extrair o arquivo do data paper de m√©dios e grandes mam√≠feros: [ATLANTIC MAMMALS](https://doi.org/10.1002/ecy.2785). Em seguinda, importe para o R, usando a fun√ß√£o `readr::read_csv()`.

**5.3**
Use a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral dos dados importados no item anterior.

**5.4**
Compare os dados de penguins (*palmerpenguins::penguins_raw* e *palmerpenguins::penguins*). Monte uma s√©rie de fun√ß√µes dos pacotes *tidyr* e `dplyr` para limpar os dados e fazer com que o primeiro dado seja igual ao segundo.

**5.5**
Usando os dados de penguins (*palmerpenguins::penguins*), calcule a correla√ß√£o de Pearson entre comprimento e profundidade do bico para cada esp√©cie e para todas as esp√©cies. Compare os √≠ndices de correla√ß√£o para exemplificar o Paradoxo de Simpsom.

**5.6**
Oficialmente a pandemia de COVID-19 come√ßou no Brasil com o primeiro caso no dia 26 de fevereiro de 2020. Calcule quantos anos, meses e dias se passou desde ent√£o. Calcule tamb√©m quanto tempo se passou at√© voc√™ ser vacinado.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-5---tidyverse.html).

<!--chapter:end:05_tidyverse.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Visualiza√ß√£o de dados {#cap6}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(tidyverse)
library(palmerpenguins)
library(datasauRus)
library(gridExtra)

## Dados
penguins <- palmerpenguins::penguins

## Edi√ß√£o dos nomes das colunas para portugu√™s 
names(penguins)
colnames(penguins) <- c("especies", "ilha", "comprimento_bico", "profundidade_bico", "comprimento_nadadeira", "massa_corporal", "sexo", "ano")
```

## Contextualiza√ß√£o

A visualiza√ß√£o de dados atrav√©s de gr√°ficos frequentemente √© a melhor forma de apresentar e interpretar as informa√ß√µes contidas em seus estudos, fazendo uma s√≠ntese para melhor entendimento de padr√µes. Geralmente, os gr√°ficos s√£o necess√°rios em quase todas as an√°lises estat√≠sticas, al√©m de enriquecer a argumenta√ß√£o e discuss√£o de hip√≥teses levantadas para publica√ß√µes, trabalhos de consultoria, TCCs, disserta√ß√µes, teses, entre outros.

Existem v√°rios tipos de gr√°ficos para representar os padr√µes em seus dados para diferentes finalidades. Esses diferentes tipos de gr√°ficos podem at√© mesmo ser usados para representar o mesmo tipo de dado. Nesta se√ß√£o, focaremos nos gr√°ficos mais simples para representar uma ou duas vari√°veis (i.e., gr√°ficos bidimensionais). Dependendo do tipo de vari√°vel (categ√≥rica ou cont√≠nua ‚Äì veja os tipos de vari√°veis na Figura \@ref(fig:fig-box) do Cap√≠tulo \@ref(cap2)), os gr√°ficos mais indicados para representar os dados mudam. De forma simplificada, os gr√°ficos s√£o representa√ß√µes dos nossos dados tabulares, de modo que os eixos representam as colunas e as fei√ß√µes (pontos, linhas, barras, caixas, etc.) representam as linhas.

Comumente nos gr√°ficos s√£o representados uma ou duas colunas, quando muito tr√™s, em gr√°ficos de tr√™s dimens√µes. Para mais colunas, partimos para dados agregados que podem ser vistos no Cap√≠tulo \@ref(cap9) de an√°lises multivariadas. Al√©m disso, a utiliza√ß√£o de mais de duas colunas pode estar relacionado com outras partes est√©ticas (e.g. `aes()` no pacote `ggplot2`) do gr√°fico como cor, forma ou tamanho de pontos, linhas ou outras fei√ß√µes.

Dessa forma, dedicamos esse cap√≠tulo inteiramente a apresentar os principais conceitos, como a gram√°tica de gr√°ficos, e uma apresenta√ß√£o geral que pode funcionar como "um guia de bolso" de gr√°ficos, uma vez que apresentamos os principais tipos de gr√°ficos para an√°lises ecol√≥gicas e estat√≠sticas. Al√©m disso, no √∫ltimo t√≥pico focamos na finaliza√ß√£o (ajustes finos) de gr√°ficos para publica√ß√µes. Este cap√≠tulo fornece a base conceitual necess√°ria para entender a visualiza√ß√£o gr√°fica de dados apresentada ao longo do livro.

Existe uma ampla gama de pacotes para fazer gr√°ficos no R, sendo esse um ponto muito forte dessa linguagem. Al√©m disso, essa grande disponibilidade de pacotes e fun√ß√µes permitem a visualiza√ß√£o dos mais diferentes tipos de dados, o que torna a linguagem R detentora de alta praticidade, uma vez que a maior parte dos pacotes possui uma sintaxe relativamente simples para a apresenta√ß√£o de gr√°ficos excelentes e de √≥tima qualidade. Mais adiante no Cap√≠tulo \@ref(cap15), ampliamos a discuss√£o da visualiza√ß√£o gr√°fica com ferramentas para visualiza√ß√£o de dados geoespaciais no R.

Este cap√≠tulo foi organizado em quatro partes: i) principais pacotes, ii) gram√°tica dos gr√°ficos, iii) tipos de gr√°ficos (um guia de bolso para visualiza√ß√£o de v√°rios gr√°ficos no R), e iv) edi√ß√£o de gr√°ficos com alta qualidade para publica√ß√£o. Apesar de apresentarmos diferentes pacotes com grande potencial para visualiza√ß√£o gr√°fica, focaremos neste cap√≠tulo no pacote `ggplot2`, talvez o pacote mais comum e com maior gama de possibilidades de cria√ß√£o de excelentes gr√°ficos.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Neste cap√≠tulo, vamos ensinar gradativamente os comandos para construir gr√°ficos e como editar suas diferentes camadas. Por este motivo, o leitor n√£o ver√° uma padroniza√ß√£o nos temas dos gr√°ficos (fonte, cor, fundo do painel, etc.), uma vez que os gr√°ficos sem edi√ß√£o (padr√£o do ggplot2) possuem temas pr√©-definidos. Desse modo, para fazer um gr√°fico com maior qualidade (chamamos aqui de vers√£o "com ajustes finos") ser√° necess√°rio adicionar comandos extras que s√£o exatamente o foco deste cap√≠tulo. Em alguns comandos b√°sicos o leitor vai perceber que devido aos dados utilizados, os eixos v√£o possuir palavras em ingl√™s misturadas com as palavras em portugu√™s. Optamos por n√£o traduzir esses nomes para preservar o padr√£o que ser√° visualizado nos primeiros comandos que cada leitor ir√° fazer em seu computador.  
:::

Usaremos os dados dispon√≠veis no pacote `palmerpenguins` para exemplificar as fun√ß√µes do `ggplot2`, descrito no Cap√≠tulo \@ref(cap5).

## Principais pacotes

A seguir, apresentamos uma listagem dos principais pacotes para visualiza√ß√£o de dados no R, al√©m das principais fun√ß√µes desses pacotes.

-   [*graphics*](http://search.r-project.org/R/library/graphics/html/00Index.html): √© o pacote padr√£o (*default*) do R para produzir gr√°fios simples, por√©m √∫til para visualiza√ß√µes r√°pidas de quase todos as classes de objetos. Possui fun√ß√µes como: `plot()`, `hist()`, `barplot()`, `boxplot()`, `abline()`, `points()`, `lines()` e `polygon()`. Destacamos que a fun√ß√£o `plot()` pode estar presente em diversos pacotes

-   [*ggplot2*](https://ggplot2.tidyverse.org/): pacote integrado ao *tidyverse* (Cap√≠tulo \@ref(cap5)), possui uma sintaxe pr√≥pria baseada na gram√°tica de gr√°ficos por camadas (*layers*), necessitando de fun√ß√µes espec√≠ficas para objetos de classes diferentes, demandando geralmente mais tempo para a constru√ß√£o dos c√≥digos. Possui fun√ß√µes como `ggplot()`, `aes()`, `geom_*()`, `facet_*()`, `stats_*()`, `coord_*()` e `theme_*()`, que s√£o conectadas pelo operador `+`

-   [*ggplot2 extentions*](https://exts.ggplot2.tidyverse.org/): conjunto de pacotes que adicionam diversas expans√µes ao pacote `ggplot2`. Exemplos: [*gganimate*](https://gganimate.com/), [*GGally*](https://ggobi.github.io/ggally/), [*patchwork*](https://patchwork.data-imaginist.com/) e [*esquisse*](https://dreamrs.github.io/esquisse/)

-   [*visdat*](https://docs.ropensci.org/visdat/): cria visualiza√ß√µes preliminares de dados explorat√≥rios de um conjunto de dados inteiro para identificar problemas ou recursos inesperados usando 'ggplot2'. Possui diversas fun√ß√µes espec√≠ficas: `vis_dat()` para vis√£o geral dos dados, `vis_miss()` para vis√£o de dados faltantes (`NA`) e `vis_compare()` para visualizar a diferen√ßa entre dados

-   [*ggpubr*](https://rpkgs.datanovia.com/ggpubr/): pacote que fornece fun√ß√µes simplificadas para criar e personalizar gr√°ficos para publica√ß√£o, baseados no `ggplot2`. Possui fun√ß√µes espec√≠ficas: `gghistogram()`, `ggdensity()`, `ggboxplot()`, `ggviolin()`, `ggbarplot()` e `ggscatter()`

-   [lattice](http://lattice.r-forge.r-project.org/): pacote para visualiza√ß√£o de dados inspirado nos gr√°ficos treli√ßa (do ingl√™s *Trellis*, geralmente para dados com muitas vari√°veis que geram uma matriz retangular de gr√°ficos). Tamb√©m possui fun√ß√µes espec√≠ficas: `xyplot()`, `histogram()`, `densityplot()`, `barchart()`, `bwplot()` e `dotplot()`. O pacote [latticeExtra](http://latticeextra.r-forge.r-project.org/) disponibiliza algumas possibilidade a mais para esse pacote

-   [plotly](https://plotly.com/r/): pacote para criar gr√°ficos interativos da web por meio da biblioteca gr√°fica de JavaScript de c√≥digo aberto [plotly.js](https://plotly.com/). Tamb√©m possui fun√ß√µes espec√≠ficas: `plot_ly()`, `add_histogram()`, `add_bars()`, `add_boxplot()`, `add_markers()`, `add_paths()`, `add_lines()` e `add_polygons()`

## Gr√°matica dos gr√°ficos

O livro *The Grammar of Graphics* [@wilkinson2005] utiliza uma analogia da lingu√≠stica para criar uma "gram√°tica" para a visualiza√ß√£o gr√°fica. Segundo ele, a l√≠ngua se torna expressiva pelo fato da gram√°tica criar um sistema de regras que tornam as declara√ß√µes com significado conhecido. De maneira semelhante, a ideia da *gram√°tica dos gr√°ficos* cria regras para representa√ß√£o gr√°fica dos dados a partir de atributos est√©ticos (do ingl√™s *aesthetic*) como cor, forma e tamanho que definem a geometria dos objetos, como pontos, linhas e barras [@wickham2016]. Al√©m disso, esta gram√°tica reconhece que tais elementos podem ser organizados em camadas, tal como constru√≠mos um mapa com diferentes camadas como eleva√ß√£o, hidrografia, rodovias, limites pol√≠ticos, etc.

Inspirado pela *gram√°tica dos gr√°ficos* proposta por Wilkinson & Wills [-@wilkinson2005], Hadley Wickham cria o pacote `ggplot2`, onde "gg" representa a contra√ß√£o de *Grammar of Graphics* [@wickham2016]. As camadas nesta gram√°tica (*layered-grammar*) s√£o organizadas da seguinte forma:

- **Camada 1** - dados `ggplot()`: s√£o as informa√ß√µes no formato `data.frame` que ser√£o usadas nas diferentes camadas nas fun√ß√µes `aes()`, `geom_*()`, `stat_*()`, `facet_*()` e `scale_*()`
- **Camada 2** - mapeamento `aes()`: atributos est√©ticos, determina que colunas do `data.frame` ser√£o usadas para as representa√ß√µes geom√©tricas, assim como tamanho, forma, cor, preenchimento e transpar√™ncia
- **Camada 3** - defini√ß√£o da geometria `geom_*()`: define o tipo de gr√°fico, como pontos, boxplots, violino, linhas, pol√≠gonos, entre outros
- **Camada 4** - transforma√ß√µes estat√≠sticas `stat_*()`: modificam, quando necess√°rio, os dados que ser√£o inclu√≠dos no gr√°fico, al√©m de produzir estat√≠sticas como regress√µes
- **Camada 5** - sistema de coordenadas `coords_*()`: descreve como as coordenadas dos dados s√£o mapeadas para o plano do gr√°fico
- **Camada 6** - facetas `facets_*()`: especifica como a visualiza√ß√£o dos elementos `aes()` s√£o divididos em diferentes "janelas gr√°ficas"
- **Camada 7** - escala `scale_*()`: permite o controle das caracter√≠sticas visuais (cor, forma e tamanho) dos elementos declarados em `aes()`
- **Camada 8** - temas `theme*()`: controla a apar√™ncia visual dos elementos do gr√°fico, como fontes, cores e legenda

Estruturalmente podemos observar a estrutura da Figura \@ref(fig:fig-camadas).

```{r fig-camadas, echo=FALSE, fig.cap="Esquema gr√°fico ilustrando as camadas que definem a strutura de organiza√ß√£o aditiva da gram√°tica dos gr√°ficos (ggplot2). No exemplo, a partir de uma banco de dados, o mapeamento de quais colunas representam o eixo Y e X e de um atributo gr√°fico (pontos) √© poss√≠vel construir um gr√°fico de dispers√£o que ilustra a rela√ß√£o quantitativa entre a vari√°vel Y e X."}
knitr::include_graphics("img/cap06_fig01.png")
```

Em resumo, o mapeamento gr√°fico do ggplot2 segue a seguinte estrutura [@wickham2017]:

```r
ggplot(data = <DATA>) + 
    <GEOM_FUNCTION>(
        mapping = aes(<MAPPINGS>),
        stat = <STAT>, 
        position = <POSITION>
        ) +
    <COORDINATE_FUNCTION> +
    <FACET_FUNCTION> +
    <SCALE_FUNCTION> +
    <THEME_FUNCTION>
```

## Tipos de gr√°ficos

Nesta se√ß√£o, listamos os principais tipos de gr√°ficos e fazemos uma descri√ß√£o de quantas colunas e o tipo de vari√°vel que eles representam.

-   **Histograma (*histogram*)**: distribui√ß√£o de frequ√™ncia de uma coluna para dados cont√≠nuos (cores diferentes podem representar esp√©cies, popula√ß√µes ou grupos distintos)
-   **Gr√°fico de densidade (*density plot*)**: distribui√ß√£o da densidade de uma coluna para dados cont√≠nuos (assim como no histograma, cores diferentes podem ser utilizadas para representar esp√©cies, popula√ß√µes ou grupos distintos)
-   **Gr√°fico de dispers√£o (*scatter plot*) e gr√°fico de linha**: rela√ß√£o entre valores de duas colunas para dados cont√≠nuos (X e Y)
-   **Diagrama de pontos (*dot plot*)**: distribui√ß√£o da quantidade de valores agrupados de uma coluna para dados cont√≠nuos
-   **Gr√°fico de setores (*pie chart* e *donut chart*)**: representa√ß√£o da quantidade de valores de uma coluna para dados categ√≥ricos, geralmente em propor√ß√£o ou porcentagem
-   **Gr√°fico de barras (*bar plot*)**: representa√ß√£o da quantidade de valores de uma ou mais colunas para dados categ√≥ricos
-   **Gr√°fico de caixa (*box plot* e *violin plot*)**: distribui√ß√£o de valores cont√≠nuos de uma coluna (Y) para dois ou mais fatores categ√≥ricos de outra coluna (X) no formato de caixas e tamb√©m no formato de "violinos" (considerando a varia√ß√£o e distribui√ß√£o)
-   **Gr√°fico pareado (*pairs plot*)**: rela√ß√£o entre valores de duas colunas para dados cont√≠nuos (X e Y), para colunas par a par

Para facilitar a compreens√£o das regras da gram√°tica dos dados, cada tipo de gr√°fico segue a mesma estrutura de organiza√ß√£o, que respeita as camadas de informa√ß√£o descritas na se√ß√£o anterior. Podemos perceber, portanto, que algumas camadas n√£o s√£o necess√°rias dependendo do tipo de gr√°fico ou do conjunto de dados que pretendemos analisar. 

Nos exemplos a seguir, a *vers√£o padr√£o* se refere √† representa√ß√£o determinada no *default* das fun√ß√µes do pacote `ggplot2`. Desse modo, somente informamos as vari√°veis que ser√£o utilizadas dentro de cada camada e a forma geom√©trica (i.e., tipo de gr√°fico) desejada. Por√©m, para cada tipo gr√°fico apresentamos fun√ß√µes e argumentos para ajustes finos e personalizados.

### Histograma (*histogram*)

O [histograma](https://www.data-to-viz.com/graph/histogram.html) √© um gr√°fico extremamente popular, sendo bastante √∫til para visualizar a distribui√ß√£o de vari√°veis cont√≠nuas. √â bem prov√°vel que voc√™ j√° tenha visto um histograma quando aprendeu pela primeira vez a famosa *distribui√ß√£o normal* (Figura \@ref(fig:fig-hist-norm)).

```{r fig-hist-norm, fig.cap="Histograma de uma distribui√ß√£o normal com 10000 observa√ß√µes."}
## Dados
dist_normal <- data.frame(x = rnorm(10000, mean = 0, sd = 1))

## Histograma de uma vari√°vel cont√≠nua
ggplot(data = dist_normal, aes(x = x)) +
    geom_histogram()
```

Neste histograma √© poss√≠vel entender que a maioria dos valores no objeto `dist_normal` est√£o pr√≥ximos ao valor da m√©dia, i.e., zero. Em Ecologia, os histogramas s√£o utilizados para visualizar, por exemplo, a varia√ß√£o morfol√≥gica entre esp√©cies (subesp√©cies, g√™nero, fam√≠lias, etc.), varia√ß√£o de par√¢metros populacionais entre diferentes esp√©cies ou dentro da mesma esp√©cie em diferentes localidades.

**Vers√£o padr√£o**

Vamos utilizar o conjunto de dados *palmerpenguins* para construir um histograma da distribui√ß√£o da vari√°vel *`flipper_length_mm`* com a fun√ß√£o `geom_hitogram()`. Esta fun√ß√£o utiliza uma vari√°vel cont√≠nua no eixo X e a frequ√™ncia de cada categoria de intervalo de valores no eixo Y. O gr√°fico a seguir representa a frequ√™ncia de uma vari√°vel (neste caso, a medida de todos os pinguins, independente da esp√©cie) (Figura \@ref(fig:fig-hist-flipper)).

```{r fig-hist-flipper, fig.cap="Histograma da vari√°vel `comprimento_nadadeira`."}
## Histograma da coluna flipper_length_mm
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_histogram()
```

**Definindo o n√∫mero de classes**

Vamos utilizar o argumento `bins` para definir em quantas classes a vari√°vel `x` deve ser dividida (Figura \@ref(fig:fig-hist-bins)).

```{r fig-hist-bins, fig.cap="Histograma da vari√°vel `comprimento_nadadeira` para diferentes classes de divis√£o."}
## Histograma com 10 classes
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_histogram(bins = 10) +
    labs(title = "10 classes")

## Histograma com 30 classes
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_histogram(bins = 30) +
    labs(title = "30 classes")
```

**Comparando m√∫ltiplas categorias**

Se quisermos comparar a distribui√ß√£o de uma vari√°vel cont√≠nua entre diferentes categorias, podemos utilizar o argumento `fill` para colorir o gr√°fico. No exemplo abaixo, utilizamos cores diferentes para ilustrar a distribui√ß√£o da vari√°vel X (`x = flipper_length_mm`) entre esp√©cies diferentes (`fill = species`) (Figura \@ref(fig:fig-hist-cat)).

```{r fig-hist-cat, fig.cap="Histograma da vari√°vel `comprimento_nadadeira` para diferentes esp√©cies com e sem sobreposi√ß√£o."}
## Histograma com cores para diferentes categorias com sobreposi√ß√£o
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_histogram(alpha = .4) +
    labs(title = "Com sobreposi√ßao")

## Histograma com cores para diferentes categorias sem sobreposi√ß√£o
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_histogram(position = "dodge") +
    labs(title = "Sem sobreposi√ßao")
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-hist-fino, fig.cap="Histograma da vari√°vel `comprimento_nadadeira` com ajustes finos."}
## Histograma exemplo
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_histogram(alpha = .4, position = "identity") +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    theme_bw(base_size = 14) +
    labs(x = "Comprimento da nadadeira (mm)", 
         y = "Frequ√™ncia absoluta", fill = "Esp√©cies")
```

**Principais camadas utilizadas na fun√ß√£o `geom_histogram()`**

- `aes()`
- Eixo X (`x`): vari√°vel cont√≠nua (`comprimento_nadadeira`)
- Preenchimento (`fill`): vari√°vel categ√≥rica (`especies`) que define as cores tendo como base o n√∫mero de n√≠veis dentro desta categoria
- `geom()` 
- `geom_histogram()`: para que a vari√°vel cont√≠nua seja plotada como histograma
- Transpar√™ncia das linhas e preenchimentos (`alpha`): 0.5 (varia de 0, transpar√™ncia m√°xima, a 1, sem transpar√™ncia)
- Posi√ß√£o das barras: o argumento `position` define se as barras devem ser inseridas de maneira sobreposta (`position = "identity"`) ou n√£o (`position = "dodge"`)
- `scale()`
- `scale_fill_manual()`: para definir manualmente as cores
- `theme()`
- `theme_bw()`: para selecionar o tema com fundo branco 
- `labs()`: para personalizar os t√≠tulos dos eixos X e Y, e da legenda

### Gr√°fico de densidade (*density plot*)

Nesta se√ß√£o aprenderemos a criar um [gr√°fico de densidade](https://www.data-to-viz.com/graph/density.html) no R utilizando o `ggplot2`. Assim como o histograma, o **gr√°fico de densidade** √© utilizado para visualizar a distribui√ß√£o de uma vari√°vel cont√≠nua em intervalos. Esse gr√°fico √© uma varia√ß√£o do histograma que utiliza [Kernel Smoother](https://en.wikipedia.org/wiki/Kernel_smoother) e, al√©m de ser muito √∫til para visualizar distribui√ß√µes, pode ser usado para testar v√°rias hip√≥teses ecol√≥gicas, como descrito no Cap√≠tulo \@ref(cap14).

**Vers√£o padr√£o**

Vamos utilizar o conjunto de dados *palmerpenguins* para plotar a distribui√ß√£o da vari√°vel *`flipper_length_mm`* em um gr√°fico de densidade. Utilizaremos a fun√ß√£o `geom_density()` para plotar uma vari√°vel no eixo X (Figura \@ref(fig:fig-dens-flipper)).

```{r fig-dens-flipper, fig.cap="Gr√°fico de densidade da vari√°vel `comprimento_nadadeira`."}
## Gr√°fico de densidade
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_density()
```

Al√©m da vers√£o de densidade em linha, √© poss√≠vel utilizar o argumento `fill` para definir a cor de preenchimento do gr√°fico e o argumento `alpha` para definir a transpar√™ncia do preenchimento. Utilizamos ainda o argumento `color` para definir a cor da linha (Figura \@ref(fig:fig-dens-flipper-color)).

```{r fig-dens-flipper-color, fig.cap="Gr√°fico de densidade da vari√°vel `comprimento_nadadeira` com cor e preenchimento."}
## Argumento fill
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_density(fill = "cyan4")

## Argumento fill, color e alpha
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_density(fill = "cyan4", color = "black", alpha = .4)
```

**Comparando m√∫ltiplas categorias**

Em algumas situa√ß√µes queremos comparar a distribui√ß√£o de uma vari√°vel cont√≠nua entre diferentes categorias. Dessa forma, podemos utilizar o argumento `fill` para colorir o gr√°fico. No exemplo abaixo, utilizamos cores diferentes para ilustrar a distribui√ß√£o da vari√°vel x entre esp√©cies diferentes (`fill = species`) (Figura \@ref(fig:fig-dens-flipper-cat)).

```{r fig-dens-flipper-cat, fig.cap="Gr√°fico de densidade da vari√°vel `comprimento_nadadeira` para diferentes esp√©cies com e sem transpar√™ncia."}
## O argumento fill preenche cada n√≠vel da coluna "especies" (sem transpar√™ncia: alpha = 1)
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_density() +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(title = "Sem transpar√™ncia")

## Gr√°fico de densidade com cores para diferentes categorias com sobreposi√ß√£o
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_density(alpha = .4) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(title = "Com transpar√™ncia")
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-dens-fino, fig.cap="Gr√°fico de densidade da vari√°vel `comprimento_nadadeira` com ajustes finos."}
## Gr√°fico de densidade exemplo
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_density(alpha = .4) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_x_continuous(breaks = seq(from = 160, to = 240, by = 10), limits = c(160, 240)) +
    scale_y_continuous(breaks = seq(from = 0, to = .07, by = .01)) +
    theme_bw(base_size = 14) +
    labs(x = "Comprimento da nadadeira (mm)", y = "Densidade", fill = "Esp√©cies")
```

**Principais camadas utilizadas na fun√ß√£o `geom_density()`**

- `aes()`
- Eixo X (`x`): vari√°vel cont√≠nua (`comprimento_nadadeira`)
- Preenchimento (`fill`): vari√°vel categ√≥rica (`especies`) que define as cores tendo como base o n√∫mero de n√≠veis dentro desta categoria
- `geom()` 
- `geom_density()`: para que a vari√°vel cont√≠nua seja plotada como densidade
- Transpar√™ncia das linhas e preenchimentos (`alpha`): 0.5 (varia de 0, transpar√™ncia m√°xima, a 1, sem transpar√™ncia)
- `scale()`
- `scale_fill_manual()`: para definir manualmente as cores de prefer√™ncia do usu√°rio
- `scale_x_continuous()` e `scale_y_continuous()`: determinam os limites (valores m√≠nimos e m√°ximos) para os dois eixos e, al√©m disso, os intervalos entre os valores (`breaks`)
- `theme()` 
- `theme_bw()`: para selecionar o tema com fundo branco
- `labs()`: para personalizar os t√≠tulos dos eixos X e Y, e da legenda

### Diagrama de pontos (*dot plot*)

Uma alternativa ao histograma e ao gr√°fico de densidade √© o diagrama de pontos ([Dot plot](https://datavizproject.com/data-type/dot-plot/), apesar de ser relativamente menos usado em Ecologia.

**Vers√£o padr√£o**

Vamos utilizar o conjunto de dados palmerpenguins para visualizar a distribui√ß√£o da vari√°vel flipper_length_mm com o diagrama de pontos com a fun√ß√£o `geom_dotplot()` (Figura \@ref(fig:fig-dot-flipper)).

```{r fig-dot-flipper, fig.cap="Diagrama de pontos da vari√°vel `comprimento_nadadeira`."}
## Gr√°fico de pontos
ggplot(data = penguins, aes(x = comprimento_nadadeira)) +
    geom_dotplot(dotsize = .6)
```

**Comparando m√∫ltiplas categorias**

Assim como nas fun√ß√µes `geom_histogram()` e `geom_density()`, √© poss√≠vel comparar categorias na fun√ß√£o `geom_dotplot()` utilizando o argumento `fill`, bem como os argumentos `color`, `alpha` e `dotsize` (Figura \@ref(fig:fig-dot-flipper-cat)).

```{r fig-dot-flipper-cat, fig.cap="Diagrama de pontos da vari√°vel `comprimento_nadadeira` para diferentes esp√©cies com e sem transpar√™ncia."}
## O argumento fill preenche cada n√≠vel da coluna "species" (sem transpar√™ncia: alpha = 1)
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_dotplot(dotsize = .9)

## Diagrama de pontos com cores para diferentes categorias com sobreposi√ß√£o
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_dotplot(dotsize = .7, color = "black", alpha = .4)
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-dot-flipper-fino, fig.cap="Diagrama de pontos da vari√°vel `comprimento_nadadeira` com ajustes finos."}
## Diagrama de pontos exemplo
ggplot(data = penguins, aes(x = comprimento_nadadeira, fill = especies)) +
    geom_dotplot(color = "black", alpha = .7, position = "dodge") +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_x_continuous(breaks = seq(from = 170, to = 240, by = 10), limits = c(170, 240)) +
    scale_y_continuous(breaks = seq(from = 0, to = 1.4, by = .2), limits = c(0, 1.4)) +
    theme_bw(base_size = 14) +
    labs(x = "Comprimento da nadadeira (mm)", y = "Frequ√™ncia", fill = "Esp√©cies")
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Uma das limita√ß√µes do diagrama de pontos √© que a sobreposi√ß√£o dos pontos pode n√£o permitir a visualiza√ß√£o apropriada desses valores sobrepostos entre diferentes grupos quando comparados.
:::

**Principais camadas utilizadas na fun√ß√£o `geom_dotplot()`**

- `aes()`:
- Eixo X (`x`): vari√°vel cont√≠nua (`comprimento_nadadeira`)
- Preenchimento (`fill`): vari√°vel categ√≥rica (`especies`) que define as cores tendo como base o n√∫mero de n√≠veis dentro desta categoria
- `geom():` 
- `geom_dotplot()`: para que a vari√°vel cont√≠nua seja plotada como diagrama de pontos
- Transpar√™ncia dos pontos (`alpha`): 0.5 (varia de 0, transpar√™ncia m√°xima, a 1, sem transpar√™ncia)
- Cor da borda do ponto (`color`): valor padr√£o (se n√£o for especificado) √© `black`
- Tamanho dos pontos (`dotsize`): valor padr√£o (se n√£o for especificado) √© 1
- Posi√ß√£o dos pontos: o argumento `position` define se os pontos devem ser inseridos de maneira sobreposta (`position = "identity"`) ou n√£o (`position = "dodge"`)
- `scale()`:
- `scale_fill_manual()` para definir manualmente as cores de prefer√™ncia do usu√°rio
- `scale_x_continuous()` e `scale_y_continuous()` determinam os limites (valor m√≠nimo e m√°ximo) para os dois eixos e, al√©m disso, os intervalos entre os valores (`breaks`)
- `theme()`: 
- `theme_bw()`para selecionar o tema com fundo branco
- `labs()` para personalizar os t√≠tulos dos eixos X e Y, e da legenda

### Gr√°fico de barras (*bar plot*)

O [gr√°fico de barras](https://www.data-to-viz.com/graph/barplot.html) √© um dos gr√°ficos mais usados em artigos e livros de Ecologia, uma vez que permite comparar valores absolutos ou m√©dios (combinados com alguma medida de varia√ß√£o, como desvio padr√£o) de uma vari√°vel cont√≠nua entre diferentes n√≠veis de uma vari√°vel categ√≥rica.

**Vers√£o padr√£o**

O gr√°fico de barras utiliza ret√¢ngulos para representar uma vari√°vel cont√≠nua ou a contagem de uma vari√°vel categ√≥rica, sendo que o comprimento dos ret√¢ngulos √© proporcional ao valor que ele representa. Por exemplo, √© poss√≠vel comparar qual a quantidade de indiv√≠duos medidos para cada esp√©cie de pinguim (Figura \@ref(fig:fig-bar-species)).

```{r fig-bar-species, fig.cap="Gr√°fico de barras indicando a quantidade de indiv√≠duos medidos de cada esp√©cie de pinguim."}
## N√∫mero de indiv√≠duos coletados
penguins_count <- penguins %>%
    dplyr::count(especies)
penguins_count

## Gr√°fico de barras
ggplot(data = penguins_count, aes(x = especies, y = n)) + 
    geom_bar(stat = "identity")
```

Al√©m disso, √© poss√≠vel alterar as cores (`color`) e preenchimento (`fill`) das barras, bem como sua transpar√™ncia (`alpha`) e largura (`width`), como demonstrado nos pr√≥ximos quatro gr√°ficos (Figura \@ref(fig:fig-bar-species-color)).

```{r fig-bar-species-color, fig.cap="Gr√°ficos de barras indicando a quantidade de indiv√≠duos medidos de cada esp√©cie de pinguim, modificando cor, preenchimento, transpar√™ncia e largura das barras."}
## Modificando o preenchimento
ggplot(data = penguins_count, aes(x = especies, y = n)) + 
    geom_bar(stat = "identity", fill = "cyan4")

## Modificando a cor e o preenchimento
ggplot(data = penguins_count, aes(x = especies, y = n)) + 
    geom_bar(stat = "identity", color = "cyan4", fill = "white")

## Modificando a largura da barra = .75
ggplot(data = penguins_count, aes(x = especies, y = n)) +
    geom_bar(stat = "identity", width = .75) +
    labs(title = "Largura = .75")

## Modificando a largura da barra = .25
ggplot(data = penguins_count, aes(x = especies, y = n)) +
    geom_bar(stat = "identity", width = .25) +
    labs(title = "Largura = .25") 
```

Outra possibilidade para representa√ß√£o do gr√°fico de barras √© inverter a dire√ß√£o das barras com a fun√ß√£o `coord_flip()` (Figura \@ref(fig:fig-bar-species-invert)).

```{r fig-bar-species-invert, fig.cap="Gr√°ficos de barras indicando a quantidade de indiv√≠duos medidos de cada esp√©cie de pinguim, invertendo a dire√ß√£o das barras."}
## Barras vertical
ggplot(data = penguins_count, aes(x = especies, y = n)) +
    geom_bar(stat = "identity", width = .6)

## Barras horizontal
ggplot(data = penguins_count, aes(x = especies, y = n)) +
    geom_bar(stat = "identity", width = .6) + 
    coord_flip()
```

√â poss√≠vel utilizar vari√°veis categ√≥ricas para definir cores e preenchimento e ilustrar, por exemplo, tratamentos ou esp√©cies diferentes com os argumentos `fill` e `color` (Figura \@ref(fig:fig-bar-species-fill)).

```{r fig-bar-species-fill, fig.cap="Gr√°fico de barras indicando a quantidade de indiv√≠duos medidos de cada esp√©cie de pinguim, para diferentes esp√©cies."}
## Gr√°fico de barras com preenchimento colorido
ggplot(data = penguins_count, aes(x = especies, y = n, fill = especies)) +
    geom_bar(stat = "identity")
```

**Adicionando medidas de varia√ß√£o**

Em algumas compara√ß√µes, utilizar somente os valores absolutos pode n√£o ser a visualiza√ß√£o mais apropriada, como, por exemplo, em desenhos de ANOVA (Cap√≠tulo \@ref(cap7)). Desse modo, ao inv√©s do valor m√°ximo da barra representar o valor absoluto (e.g., n√∫mero de indiv√≠duos de uma esp√©cie), ele vai representar o valor m√©dio. Al√©m disso, linhas adicionais (chamadas barras de erro) v√£o representar alguma medida de varia√ß√£o como desvio padr√£o, erro padr√£o, intervalo de confian√ßa, entre outros (Figura \@ref(fig:fig-bar-species-sd))

```{r fig-bar-species-sd, fig.cap="Gr√°fico de barras indicando os valores m√©dios e o desvio padr√£o da vari√°vel `flipper_length_mm` para cada esp√©cie de pinguim."}
## Calcular o desvio padr√£o por esp√©cie
penguins_media <- penguins %>% 
    dplyr::group_by(especies) %>% 
    dplyr::summarise(media = mean(comprimento_nadadeira, na.rm = TRUE),
                     desvio = sd(comprimento_nadadeira, na.rm = TRUE))

## Gr√°fico de barras com desvio padr√£o
ggplot(data = penguins_media, aes(x = especies, y = media, fill = especies)) +
    geom_bar(stat = "identity", alpha = .4) +
    geom_errorbar(aes(ymin = media-desvio, ymax = media+desvio), width = .1) + 
    geom_point()
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-bar-species-fino, fig.cap="Gr√°fico de barras indicando a quantidade de indiv√≠duos medidos de cada esp√©cie de pinguim, com ajustes finos."}
## Gr√°fico de barra exemplo
ggplot(data = penguins_count, aes(x = especies, y = n, fill = especies)) +
    geom_bar(stat = "identity") +
    geom_label(aes(label = n), fill = "white") +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    labs(x = "Esp√©cies", y = "N√∫mero de indiv√≠duos", fill = "Esp√©cies")
```

### Gr√°fico de setores (*pie chart* e *donut chart*)

Al√©m do gr√°fico de barras, o [gr√°fico de setores](https://www.data-to-viz.com/caveat/pie.html) representa uma alternativa para comparar a propor√ß√£o entre categorias. Tais gr√°ficos podem ser representados como [*pie charts*](https://datavizproject.com/data-type/pie-chart/) ou [*donut charts*](https://datavizproject.com/data-type/donut-chart/), como demonstrado abaixo. No exemplo abaixo, utilizamos a mesma compara√ß√£o realizada no item acima. Por√©m, os valores de contagem (n√∫mero de indiv√≠duos por esp√©cie) devem ser transformados previamente em propor√ß√£o.

**Gr√°fico de setores (*pie chart*)**

Gr√°fico de setores do tipo *pie* (Figura \@ref(fig:fig-pie)).

```{r fig-pie, fig.cap="Gr√°fico de setores indicando a propor√ß√£o de indiv√≠duos medidos de cada esp√©cie de pinguim."}
## C√°lculo da propor√ß√£o - pie
penguins_prop <- penguins %>%
    dplyr::count(especies) %>% 
    dplyr::mutate(prop = round(n/sum(n), 4)*100)

## Gr√°fico de setores
ggplot(data = penguins_prop, aes(x = "", y = prop, fill = especies)) + 
    geom_bar(stat = "identity", color = "white") +
    geom_text(aes(label = paste0(prop, "%")), color = "white", 
              position = position_stack(vjust = .5), size = 6) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    coord_polar("y", start = 0) +
    theme_void() +
    labs(fill = "Esp√©cies")
```

**Gr√°fico de setores (*donut chart*)**

Gr√°fico de setores do tipo *donuts* (Figura \@ref(fig:fig-donut)).

```{r fig-donut, fig.cap="Gr√°fico de setores do tipo *donuts* indicando a propor√ß√£o de indiv√≠duos medidos de cada esp√©cie de pinguim."}
## Gr√°fico de setores - donut
ggplot(data = penguins_prop, aes(x = 2, y = prop, fill = especies)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = paste0(prop, "%")), color = "white",
              position = position_stack(vjust = .5), size = 4) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    xlim(0, 2.5) +
    coord_polar(theta = "y", start = 0) +
    theme_void() +
    theme(legend.position = c(.5, .5),
          legend.title = element_text(size = 20),
          legend.text = element_text(size = 15)) +
    labs(fill = "Esp√©cies")
```

**Comparando gr√°ficos de setores com gr√°fico de barras**

O mesmo conjunto de dados pode ser visualizado de diferentes formas. N√£o diferente, a compara√ß√£o da propor√ß√£o de ocorr√™ncias de diferentes categorias pode ser feita de v√°rias maneiras. Abaixo, apresentamos a compara√ß√£o da propor√ß√£o de indiv√≠duos por cada uma das tr√™s esp√©cies dos dados `penguins` (Figura \@ref(fig:fig-prop)).

```{r fig-prop, fig.cap="Compara√ß√£o da propor√ß√£o de indiv√≠duos por cada uma das tr√™s esp√©cies dos dados feita atrav√©s de gr√°fico de barras, setores do tipo *pie* e setores do tipo *donuts*.", message=FALSE, warning=FALSE, out.width="100%"}
## Gr√°fico de barras - vertical  
g_bar_v <- ggplot(data = penguins_prop, aes(x = especies, y = prop, fill = especies)) +
    geom_bar(stat = "identity") +
    geom_label(aes(label = prop), fill = "white") +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw() +
    theme(legend.position = "none") +
    labs(title = "Gr√°fico de Barras (Vertical)", x = "Esp√©cies", 
         y = "N√∫mero de indiv√≠duos", fill = "Esp√©cies")

## Gr√°fico de barras - horizontal  
g_bar_h <- ggplot(data = penguins_prop, aes(x = especies, y = prop, fill = especies)) +
    geom_bar(stat = "identity") +
    geom_label(aes(label = prop), fill = "white") +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    coord_flip() +
    theme_bw() +
    theme(legend.position = "none") +
    labs(title = "Gr√°fico de Barras (Horizonal)", x = "Esp√©cies", 
         y = "N√∫mero de indiv√≠duos", fill = "Esp√©cies")

## Gr√°fico de setores - pie
g_pie <- ggplot(data = penguins_prop, aes(x = "", y = prop, fill = especies)) + 
    geom_bar(stat = "identity", color = "white") +
    geom_text(aes(label = paste0(prop, "%")), color = "white", 
              position = position_stack(vjust = .5), size = 3) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    coord_polar("y", start = 0) +
    theme_void() +
    labs(title = "Pie chart", fill = "Esp√©cies")

## Gr√°fico de setores - donut
g_donut <- ggplot(data = penguins_prop, aes(x = 2, y = prop, fill = especies)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = paste0(prop, "%")), color = "white",
              position = position_stack(vjust = .5), size = 2) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    coord_polar(theta = "y", start = 0) +
    xlim(0, 2.5) +
    theme_void() +
    theme(legend.position = "none") +
    labs(title = "Donut chart", fill = "Esp√©cies")

## Combina√ß√£o dos gr√°figos
grid.arrange(g_bar_v, g_bar_h, g_pie, g_donut, nrow = 2)
```

**Principais camadas utilizadas no gr√°fico de barras e de setores: `geom_bar()`**

- `aes()`
- Eixo X (`x`): vari√°vel categ√≥rica (`species`)
- Eixo Y (`y`): vari√°vel cont√≠nua (`comprimento_nadadeira`)
- Preenchimento (`fill`): a vari√°vel categ√≥rica (`especies`) define a cor do preenchimento e os n√≠veis dentro desta categoria determinam o n√∫mero de cores que devem ser indicadas no `scale_fill_manual()`
- `geom()`
- `geom_bar()`: para que as vari√°veis categ√≥ricas sejam plotadas como gr√°ficos de barra ou setores
- Transpar√™ncia das barras (`alpha`): 0.5 (varia de 0, transpar√™ncia m√°xima, a 1, sem transpar√™ncia)
- `stat`: √© necess√°rio usar o argumento `identity` quando os valores do eixo Y s√£o adicionados pelo usu√°rio
- `geom_label()`: forma geom√©trica que adiciona r√≥tulo dos valores absolutos das barras por categoria (`species`)
- `geom_errorbar()`: `ymin`e `ymax` delimitam os valores m√≠nimos e m√°ximos, respectivamente, das barras de erro. Tais valores s√£o representados pelo valor da m√©dia menos (no caso do ymin) ou mais (no caso do ymax) o valor do intervalo de confian√ßa, desvio ou erro padr√£o
- `coord`
- `coord_polar()`: sistema de coordenadas para gerar barras circulares sobrepostas (*stacked*) que s√£o usadas nos gr√°ficos de setores (*pie chart* e *donut chart*)
- o argumento `start = 0` indica o local de in√≠cio do gr√°fico que, neste caso, come√ßa na "hora" 0 em um "rel√≥gio" de 12 horas
- `scale()`
- `scale_fill_manual()`: para definir manualmente as cores de prefer√™ncia do usu√°rio
- `theme()`
- `theme_bw()`: para selecionar o tema com fundo branco
- `labs()`: para personalizar os t√≠tulos dos eixos X e Y, e da legenda.

### Gr√°fico de caixa (*boxplot*)

O gr√°fico de caixa, tamb√©m conhecido como [boxplot](https://www.data-to-viz.com/caveat/boxplot.html), e amplamente utilizado nos artigos e livros de Ecologia, √© uma visualiza√ß√£o gr√°fica que sintetiza informa√ß√µes importantes de dados cont√≠nuos como mediana e varia√ß√£o (Figura \@ref(fig:fig-boxplot-desc)) para diferentes n√≠veis de uma vari√°vel categ√≥rica.

```{r fig-boxplot-desc, fig.cap="Estrutura e elementos do boxplot.", out.width="90%", echo=FALSE}
knitr::include_graphics("img/cap06_fig03.png")
```

**Vers√£o padr√£o**

Vamos plotar uma vari√°vel cont√≠nua (`comprimento_nadadeira`) no eixo y em fun√ß√£o de uma vari√°vel categ√≥rica no eixo x (`especies`). A defini√ß√£o de qual coluna do bando de dados √© a x e qual √© a y √© feita dentro do na fun√ß√£o `aes()` (Figura \@ref(fig:fig-boxplot)).

```{r fig-boxplot, fig.cap="Gr√°fico de caixa para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de pinguim."}
## Gr√°fico de caixas das coluna comprimento_nadadeira e esp√©cies
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies)) +
    geom_boxplot()
```

√â poss√≠vel destacar, se houver, os pontos referentes aos *outliers* (valores discrepantes) com o argumento `outlier.color`. Caso tenha interesse, √© poss√≠vel tamb√©m remover os outliers do gr√°fico (Figura \@ref(fig:fig-boxplot-outlier)).

```{r fig-boxplot-outlier, fig.cap="Gr√°fico de caixa para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de penguim, destacando e removendo os outliers."}
## Destaque dos outliers
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies)) +
    geom_boxplot(outlier.color = "red") +
    labs(title = "Outliers vermelhos")

## Remo√ß√£o dos outliers
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies)) +
    geom_boxplot(outlier.shape = NA) +
    labs(title = "Outliers removidos")
```

Outra op√ß√£o para os gr√°ficos do tipo boxplot √© utilizar o argumento `notch = TRUE` para produzir diagramas de caixa entalhados (*notched*). Estes diagramas s√£o √∫teis para inferir de forma aproximada se exite diferen√ßa significativa entre as medias dos grupos (Figura \@ref(fig:fig-boxplot-notched)).

```{r fig-boxplot-notched, fig.cap="Gr√°fico de caixa para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de penguim, com entalhamentos."}
## Gr√°fico com caixa entalhadas
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies)) +
    geom_boxplot(notch = TRUE) +
    labs(title = "Caixas entalhadas")
```

**Comparando m√∫ltiplas categorias**

No exemplo abaixo, utilizamos cores diferentes para ilustrar esp√©cies diferentes atrav√©s do argumento `fill = species` (Figura \@ref(fig:fig-boxplot-cat)).

```{r fig-boxplot-cat, fig.cap="Gr√°fico de caixa para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de pinguim, com preenchimentos diferentes."}
## Modificando o preenchimento
ggplot(data = penguins, 
       aes(y = comprimento_nadadeira, x = especies, fill = especies)) +
    geom_boxplot()
```

**Combinando boxplot com pontos (*jitter*)**

Podemos ainda acrescentar pontos para mostrar a distribui√ß√£o dos dados, fazendo uma "agita√ß√£o" (*jitter*) dos pontos sobre as caixas (Figura \@ref(fig:fig-boxplot-jitter)).

```{r fig-boxplot-jitter, fig.cap="Gr√°fico de caixa para a vari√°vel `flipper_length_mm` para cada esp√©cie de penguim, com distribui√ß√£o dos dados."}
## Boxplot com jitters
ggplot(data = penguins, aes(y = comprimento_nadadeira, 
                            x = especies, 
                            fill = especies)) +
    geom_boxplot() +
    geom_jitter(size = .5)
```

**Gr√°fico de violino (*violin plot*) como alternativa ao boxplot**

Al√©m das caixas no boxplot, podemos utilizar o formato de "violino" ([gr√°fico de violino](https://datavizproject.com/data-type/violin-plot/)) para representar a varia√ß√£o dos dados cont√≠nuos para as categorias. A informa√ß√£o adicional ao boxplot que o gr√°fico de violino permite visualizar √© a densidade e distribui√ß√£o dos pontos, assim como apresentamos acima no gr√°fico de densidades `geom_density()`. A diferen√ßa √© que a densidade √© espelhada e, desse modo, podemos visualizar os intervalores dos dados com maior ou menor concentra√ß√£o de valores (Figura \@ref(fig:fig-violin)).

```{r fig-violin, fig.cap="Gr√°fico de violino para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de penguim, com distribui√ß√£o dos dados."}
## Gr√°fico de violino
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies, fill = especies)) +
    geom_violin() +
    geom_jitter(size = .5)
```

√â poss√≠vel tamb√©m combinar boxplot e gr√°fico de violino em um √∫nico gr√°fico (Figura \@ref(fig:fig-boxplot-violin)).

```{r fig-boxplot-violin, fig.cap="Gr√°fico de caixa e de violino para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de penguim."}
## Combinando o gr√°fico de violino com o de caixas
ggplot(data = penguins, aes(y = comprimento_nadadeira, x = especies, fill = especies)) +
    geom_violin() +
    geom_boxplot(width = .1, fill = "gray")
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-boxplot-violin-fino, fig.cap="Gr√°fico de caixa, violino, e caixa e violino para a vari√°vel `comprimento_nadadeira` para cada esp√©cie de penguim, com ajustes finos."}
## Gr√°fico de caixas exemplo
ggplot(data = penguins, aes(x = especies, y = comprimento_nadadeira, fill = especies)) +
    geom_boxplot(width = .5, show.legend = FALSE) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    labs(title = "Boxplot sem pontos", x = "Esp√©cies", y = "Comprimento da nadadeira (mm)")

## Gr√°fico de violino exemplo
ggplot(data = penguins, aes(x = especies, y = comprimento_nadadeira, fill = especies)) +
    geom_violin(width = .5, show.legend = FALSE) +
    geom_jitter(alpha = .4, show.legend = FALSE, 
                position = position_jitter(width = .15, seed = 0)) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    labs(title = "Gr√°fico de violino com jitter", x = "Esp√©cies", y = "Comprimento da nadadeira (mm)")

## Gr√°fico de caixas e violino exemplo
ggplot(data = penguins, aes(x = especies, y = comprimento_nadadeira, fill = especies)) +
    geom_violin(width = .5, show.legend = FALSE) +
    geom_boxplot(width = .3, fill = "gray", show.legend = FALSE) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    labs(title = "Gr√°fico de violino com boxplot", x = "Esp√©cies", y = "Comprimento da nadadeira (mm)")
```

**Principais camadas utilizadas no `geom_boxplot()`e `geom_violin()`**

- `aes()`
- Eixo X (`x`): vari√°vel categ√≥rica (`especies`)
- Eixo Y (`y`): vari√°vel cont√≠nua (`comprimento_nadadeira`)
- Preenchimento (`fill`): a vari√°vel categ√≥rica (`especies`) define a cor do preenchimento e os n√≠veis dentro desta categoria determinam o n√∫mero de cores que devem ser indicadas no `scale_fill_manual()`.
- `geom():`
- `geom_boxplot()`: para que as vari√°veis cont√≠nuas e categ√≥ricas sejam plotadas como gr√°ficos de caixas ou violinos
- `width`: largura das barras ou dos pontos(valor padr√£o: width = 1)
- `fill`: pode definir uma cor padr√£o (caso n√£o tenha utilizado o fill dentro do argumento `aes()`) como `fill = "gray"`
- `notch`: para utilizar a caixa entalhada o argumento deve ser `notch = TRUE`, a escolha padr√£o da fun√ß√£o `geom_boxplot()` √© `notch = FALSE`
- `geom_violin()`: assim como nas outras formas geom√©tricas, √© poss√≠vel controlar largura, cor, preenchimento e transpar√™ncias dos violinos
- `geom_jitter()`: esta fun√ß√£o basicamente "agita" aleatoriamente os pontos para evitar a sobreposi√ß√£o de valores id√™nticos. Esta fun√ß√£o produz a mesma representa√ß√£o se usar a fun√ß√£o `geom_point(position = "jitter")`
- `scale()`
- `scale_fill_manual()`: para definir manualmente as cores de prefer√™ncia do usu√°rio
- `theme()`
- `theme_bw()`: para selecionar o tema com fundo branco 
- `labs()`: para personalizar os t√≠tulos dos eixos X e Y, e da legenda

### Gr√°fico de dispers√£o (*scatter plot*)

O [gr√°fico de dispers√£o](https://datavizproject.com/data-type/scatter-plot/) (em ingl√™s, *scatter plot*) √© famoso na Ecologia por ser a visualiza√ß√£o preferida para representar a rela√ß√£o entre √°rea e riqueza de esp√©cies. Neste gr√°fico, os eixos X e Y s√£o representados por vari√°veis cont√≠nuas. Em especial, os gr√°ficos de dispers√£o s√£o usados para representar os resultados testados por an√°lises estat√≠sticas como regress√£o linear, ANCOVA, mantel, PCA, PCoA, nMDS entre outros (para mais detalhes, consultar os Cap√≠tulos \@ref(cap7), \@ref(cap8) e \@ref(cap9)).

**Vers√£o padr√£o**

Vamos utilizar o conjunto de dados *palmerpenguins* para construir um gr√°fico de dispers√£o relacionando as vari√°veis `comprimento_bico` e `comprimento_nadadeira` com a fun√ß√£o `geom_point()`. Esta fun√ß√£o utiliza vari√°vel cont√≠nuas no eixo X e no Y. O gr√°fico mostra os pares ordenados das medidas das duas vari√°veis (Figura \@ref(fig:fig-scatter)).

```{r fig-scatter, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `comprimento_bico` e `comprimento_nadadeira`."}
## Gr√°fico de dispers√£o das coluna flipper_length_mm e bill_length_mm
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira)) +
    geom_point()
```

**Definindo a cor, tamanho, forma e preenchimento dos pontos**

Da mesma forma que para os outros gr√°ficos, podemos alterar cor, tamanho, forma e preenchimento dos pontos (Figura \@ref(fig:fig-scatter-col)).

```{r fig-scatter-col, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `comprimento_bico` e `comprimento_nadadeira` para cada esp√©cie de penguim, com altera√ß√µes na cor, tamanho e preenchimento dos pontos."}
## Cor e tamanho dos pontos 
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira)) +
    geom_point(color = "cyan4", size = 4) + 
    labs(title = "Sem transpar√™ncia")

## Cor, tamanho dos pontos e transpar√™ncia
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira)) +
    geom_point(color = "cyan4", size = 4, alpha = .4) +
    labs(title = "Com transpar√™ncia")
```

A forma dos pontos permite dois controles importantes: a forma em si (s√≠mbolos como c√≠rculo, quadrado, etc.) e a possibilidade de preenchimento da forma. A figura a seguir discrimina esses s√≠mbolos e o valor que deve ser utilizado para desenhar a forma preferida. √â importante notar que os s√≠mbolos 21 a 25 possuem dois argumentos: (i) cor (que, na verdade, √© a cor da borda do s√≠mbolo) e (ii) a cor que define o preenchimento do s√≠mbolo. O tipo de s√≠mbolo √© definido pelo argumento `shape` (Figura \@ref(fig:fig-point-shape)).

```{r fig-point-shape, out.width ="50%", echo=FALSE, fig.cap="Tipos de s√≠mbolos dispon√≠veis para representar pontos."}
knitr::include_graphics("img/cap06_fig02.png")
```

Assim, √© poss√≠vel controlar cores, formas e preenchimento combinado os argumentos `shape`, `fill`e `color` com a fun√ß√£o `scale_manual()`. √â importante notar que para os s√≠mbolos entre 15 e 20 s√≥ podemos controlar o argumento cor, enquanto os s√≠mbolos entre 21 e 25 podemos controlar a cor e o preenchimento (Figura \@ref(fig:fig-scatter-shape)).

```{r fig-scatter-shape, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `comprimento_bico` e `comprimento_nadadeira` para cada esp√©cie de penguim, com altera√ß√µes no formato."}
## Formato e tamanho
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira)) +
    geom_point(shape = 1, size = 4)

## Formato e tamanho para esp√©cies
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira, color = especies)) +
    geom_point(shape = 19, size = 4)

## Formato e tamanho e cor
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira, fill = especies)) +
    geom_point(shape = 21, size = 4, color = "black")
```

**Definindo linhas de ajuste**

Quando usamos modelos estat√≠sticos como, por exemplo, `lm()`, `glm()`, `gam()`, entre outros (veja mais nos Cap√≠tulos \@ref(cap7) e \@ref(cap8)), podemos utilizar os valores preditos para demonstrar a rela√ß√£o entre as vari√°veis X e Y. No `ggplot2`, a fun√ß√£o `geom_smooth()` faz esse ajuste com certa simplicidade (Figura \@ref(fig:fig-scatter-smooth)).

```{r fig-scatter-smooth, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `comprimento_bico` e `comprimento_nadadeira` para cada esp√©cie de penguim, com linhas de ajustes estat√≠sticos."}
## Linha de ajuste
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira)) +
    geom_point(shape = 20, size = 4, color = "black") +
    geom_smooth(method = lm)
```

**Ajustes finos (vers√£o personalizada)**

```{r fig-scatter-fino, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `bill_length_mm` e `flipper_length_mm` para cada esp√©cie de penguim, com ajustes finos."}
## Gr√°fico de dispers√£o exemplo
ggplot(data = penguins, aes(x = comprimento_bico, y = comprimento_nadadeira,
                            color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 16) +
    labs(x = "Comprimento do bico (mm)", y = "Comprimento da nadadeira (mm)", 
         color = "Esp√©cies", shape = "Esp√©cies")
```

Al√©m disso, podemos relacionar dados n√£o t√£o usuais. Recomendamos a leitura do artigo de Matejka & Fitzmaurice [-@matejka_same_2017] que apresenta as armadilhas t√≠picas que dados podem gerar quando evitamos de visualiz√°-los previamente (Figura \@ref(fig:fig-scatter-dino)).

```{r fig-scatter-dino, fig.cap="Gr√°fico de dispers√£o relacionando as vari√°veis `x` e `y` formando um dinossauro."}
## Gr√°fico do dinossauro
datasaurus_dozen %>% 
    dplyr::filter(dataset == "dino") %>% 
    ggplot() +
    aes(x = x, y = y) +
    geom_point(colour = "black", fill = "black", 
               size = 4, alpha = .7, shape = 21) +
    theme_bw() +
    theme(axis.title = element_text(size = 24),
          axis.text.x = element_text(size = 20),
          axis.text.y = element_text(size = 20))
```

### Visualiza√ß√£o de m√∫ltiplos gr√°ficos pareados

Muitas vezes precisamos plotar a rela√ß√£o de mais de uma vari√°vel, e muitas vezes essas vari√°veis s√£o de mais de um tipo (cont√≠nua, categ√≥rica, etc.). O gr√°fico mais indicado nesses casos √© o gr√°fico pareado [@emerson_generalized_2013] que nos auxilia √† ter uma vis√£o geral do conjunto de dados e de suas interrela√ß√µes. Esse gr√°fico tamb√©m √© chamado de *pairs plot* ou [correlograma](https://www.data-to-viz.com/graph/correlogram.html).

**Gr√°fico pareado com vari√°veis cont√≠nuas**

A fun√ß√£o `ggpairs()`do pacote `GGally` permite criar m√∫ltiplos gr√°ficos pareados comparando as vari√°veis cont√≠nuas no seu conjunto de dados. Al√©m de demonstrar gr√°ficos de dispers√£o de cada par de vari√°veis, ela apresenta gr√°ficos de densidade de cada vari√°vel individualmente e, al√©m disso, os valores de correla√ß√£o entre os pares analisados com ou sem uma potencial vari√°vel categ√≥rica (neste caso, `species`) (Figura \@ref(fig:fig-pairs-cont)).

```{r fig-pairs-cont, fig.cap="Gr√°fico pareado relacionando v√°rias vari√°veis cont√≠nuas para as esp√©cies de penguins."}
## Gr√°fico pareado com vari√°veis cont√≠nuas
penguins %>%
    dplyr::select(massa_corporal, comprimento_bico, profundidade_bico, comprimento_nadadeira) %>%
    GGally::ggpairs(aes(color = penguins$especies)) +
    scale_colour_manual(values = c("darkorange", "purple", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw()
```

**Gr√°fico pareado com v√°rios tipos de vari√°veis**

Como alternativa, a fun√ß√£o **`ggpairs()`** permite tamb√©m incluir vari√°veis categ√≥ricas nas compara√ß√µes. Neste caso, ela reconhece o tipo de gr√°fico (boxplot, dispers√£o, etc.) a partir dos modos das vari√°veis (Figura \@ref(fig:fig-pairs-cont-cat)).

```{r fig-pairs-cont-cat, fig.cap="Gr√°fico pareado relacionando v√°rias vari√°veis cont√≠nuas e categ√≥ricas para as esp√©cies de penguins."}
## Gr√°fico pareado com vari√°veis cont√≠nuas e categ√≥ricas
penguins %>%
    dplyr::select(especies, sexo, massa_corporal, comprimento_bico, profundidade_bico, comprimento_nadadeira) %>%
    GGally::ggpairs(aes(color = especies)) +
    scale_colour_manual(values = c("darkorange", "purple", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw()
```

### Erros comuns dos usu√°rios do `ggplot2` e como evit√°-los

Abaixo, apresentamos uma lista n√£o exaustiva dos erros mais comuns que cometemos (e vimos muitos usu√°rios cometerem) ao fazer gr√°ficos no ggplot2.

- Utilizar ajuste manual nas fun√ß√µes `scale_shape_manual()`, `scale_color_manual()` ou `scale_fill_manual()` sem indicar no argumento `aes()` as vari√°veis que devem definir cada um desses elementos gr√°ficos

- Utilizar ajuste manual na fun√ß√£o `scale_size_manual()` indicando uma vari√°vel categ√≥rica em vez de num√©rica

- N√∫mero de cores indicadas como valores no `scale_fill_manual()` ou `scale_color_manual()`: ao definir as cores de maneira personalizada (ou seja, n√£o usando o padr√£o da fun√ß√£o) √© muito comum utilizarmos o n√∫mero de cores usados por algum tutorial ou livro. Com frequ√™ncia, o exemplo seguido e seus dados n√£o possuem o mesmo n√∫mero de cores dos nossos dados. Deste modo, voc√™ pode usar c√≥digos no R para ajudar a quantificar o n√∫mero de cores necess√°rias. Por exemplo, para os dados `penguins`, o c√≥digo a seguir indica o n√∫mero de cores necess√°rias: `length(levels(penguins\$species))`. Assim, ser√° necess√°rio indicar tr√™s cores diferentes dentro da fun√ß√£o `scale_*()`.

- Fun√ß√£o `geom_smooth()`: como falado, a fun√ß√£o `geom_smooth()` √© muito √∫til (e simples) para gerar as linhas de ajuste (*best fit*) t√≠picas de modelos lineares e n√£o lineares. Por√©m, fique alerta ao usar, por exemplo, `geom_smooth(method = lm)`, o modelo linear utilizado para testar sua predi√ß√£o foi o `lm()`. Se tiver utilizado `glm()`ou `gam()` o ajuste deve ser produzido a partir desses modelos.

- Uso incorreto do modo das vari√°veis: neste caso, o usu√°rio utilizar uma vari√°vel num√©rica (por exemplo, 1, 2 e 3) como vari√°vel categ√≥rica. Neste caso, √© preciso transformar a vari√°vel num√©rica em vari√°vel categ√≥ricas (antes de fazer o ggplot2 ou dentro do `aes()`). 

Veja exemplos (Figura \@ref(fig:fig-plot-error)).

```{r fig-plot-error, fig.cap="Gr√°ficos mostrando erros comuns na cria√ß√£o de gr√°ficos no pacote `ggplot2`."}
## Figura incorreta, sem a transforma√ß√£o da vari√°vel ano
penguins %>%
    ggplot(aes(x = ano, y = comprimento_bico)) +
    geom_boxplot() + 
    theme_bw() +
    labs(title = "Figura incorreta")

## Figura correta, com transforma√ß√£o interna da vari√°vel ano
penguins %>%
    ggplot(aes(x = factor(ano), y = comprimento_bico)) +
    geom_boxplot() + 
    theme_bw() +
    labs(title = "Figura correta com transforma√ß√£o interna")

## Figura correta, com transforma√ß√£o pr√©via da vari√°vel ano
penguins %>%
    mutate(ano_f = as.factor(ano)) %>% 
    ggplot(aes(x = ano_f, y = comprimento_bico)) +
    geom_boxplot() + 
    theme_bw() +
    labs(title = "Figura correta com transforma√ß√£o pr√©via")
```

## Finaliza√ß√£o de gr√°ficos para publica√ß√£o

### Posi√ß√£o, cores e fonte da legenda

√â poss√≠vel controlar a posi√ß√£o, cores e fonte da legenda em diversos locais com alguns argumentos dentro da fun√ß√£o `theme()`:

- `legend.position`: controla a posi√ß√£o na √°rea do gr√°fico: `top`, `right`, `bottom`, `left` ou `none`. Al√©m disso, √© poss√≠vel inserir a legenda internamento no gr√°fico indicando as posi√ß√µes nos eixos X e Y

- `legend.box`: determina as caracter√≠sticas do ret√¢ngulo onde a legenda √© inserida: `legend.box.background` (combinado com `element_rect()`) e `legend.box.margin` (combinado com `margin()`)

- `legend.text`: controla a cor e tamanho da legenda (as duas informa√ß√µes devem ser inseridas dentro da fun√ß√£o `element_text()`)

- `legend.title`: personaliza a cor e tamanho da legenda tamb√©m dentro da fun√ß√£o `element_text()`

Vejamos alguns exemplos (Figura \@ref(fig:fig-plot-final-legenda)).

```{r fig-plot-final-legenda, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o √† posi√ß√£o, cores e fonte da legenda no pacote `ggplot2`."}
## Legenda acima
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    theme(legend.position = "top") +
    labs(title = "Legenda acima do gr√°fico", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")

## Leganda abaixo
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    theme(legend.position = "bottom") +
    labs(title = "Legenda abaixo do gr√°fico", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")

## Sem legenda
ggplot(data = penguins, 
       aes(x = comprimento_bico,  y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    theme(legend.position = "none") +
    labs(title = "Sem legenda", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")

## Legenda personalizada
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 14) +
    theme(legend.position = "right",
          legend.text = element_text(size = 14, colour = "red"),
          legend.title = element_text(face = "bold"),
          legend.box.background = element_rect(color="red", size=2),
          legend.margin = margin(6, 6, 6, 6)) +
    labs(title = "Legenda personalizada", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")

## Legenda interna
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 16) +
    theme(legend.position = c(.2, .8),
          legend.title = element_blank(),
          legend.key =  element_blank(),
          legend.background = element_blank(),
          legend.text = element_text(size = 12, face = "bold")) +
    labs(title = "Legenda interna", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")
```

### Elementos gr√°ficos: eixo, fonte, gride

O gr√°fico padronizado (sem edi√ß√£o extra) geralmente n√£o traz elementos m√≠nimos para publica√ß√£o em revistas, livros ou peri√≥dicos. Al√©m do controle da posi√ß√£o, cor e tamanho da legenda, √© fundamental personalizar os seguintes elementos: eixo, fonte e gride.

- Eixos
- Varia√ß√£o: define limites m√≠nimos e m√°ximos para os eixos X (`xlim()`) e Y (`ylim()`)
- Intervalo: define o valor intervalo entre os n√∫meros dos eixos X e Y

Vejamos mais alguns exemplos (Figura \@ref(fig:fig-plot-final-eixos)).

```{r fig-plot-final-eixos, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o aos elementos gr√°ficos de eixo, fonte, gride no pacote `ggplot2`."}
## Nome dos eixos
ggplot(data = penguins,  
       aes(x = comprimento_bico, y = comprimento_nadadeira, 
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    ylim(170, 230) +
    xlim(30, 60) +
    labs(title = "Nome dos eixos", x = "Eixo X", y = "Eixo Y")

## Intervalo dos eixos
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    scale_x_continuous(limits = c(30, 60), breaks = seq(30, 60, 2)) +
    labs(title = "Intervalo dos eixos", x = "Eixo X", y = "Eixo Y")
```

- Fonte dos eixos X e Y
- Tipo
- Tamanho
- Cor
- Face (it√°lico, negrito, etc.)
- √Çngulo

Vejamos outros exemplos com mudan√ßas nos eixos (Figura \@ref(fig:fig-plot-final-eixos-fonte)).

```{r fig-plot-final-eixos-fonte, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o aos eixos no pacote `ggplot2`."}
## Cor e fonte dos eixos
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    theme(axis.title.x = element_text(face = "bold", size = 20, colour = "cyan4"),
          axis.text.x = element_text(size = 14),
          axis.title.y = element_text(face = "bold", size = 20, colour = "cyan4"),
          axis.text.y = element_text(size = 14)) +
    labs(title = "Cor e fonte dos eixos", x = "Eixo X", y = "Eixo Y")

## Intervalo e √¢ngulos do texto dos eixos
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    scale_x_continuous(limits = c(20, 60), breaks = seq(20, 60, 2)) +
    theme(axis.title.x = element_text(face = "bold", size = 20, colour = "cyan4"),
          axis.text.x = element_text(size = 14, angle = 45),
          axis.title.y = element_text(face = "bold", size = 20, colour = "cyan4"),
          axis.text.y = element_text(size = 14)) +
    labs(title = "Intervalo e √¢ngulos do texto dos eixos", x = "Eixo X", y = "Eixo Y")
```

- Gride
- Linhas de grade principais (`panel.grid.major`)
- Linhas de grade secund√°rias (`panel.grid.minor`)
- Borda do gr√°fico (`panel.border`)

Vejamos outros exemplos com mudan√ßas ao gride (Figura \@ref(fig:fig-plot-final-gride)).

```{r fig-plot-final-gride, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o ao gride no pacote `ggplot2`."}
## Linhas de grade principais
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    scale_x_continuous(limits = c(30, 60), breaks = seq(30, 60, 5)) +
    theme(axis.title.x = element_text(face = "bold", size = 16),
          axis.text.x = element_text(size = 12),
          axis.title.y = element_text(face = "bold", size = 16),
          axis.text.y = element_text(size = 12),
          panel.grid.minor = element_blank()) +
    labs(title = "Linhas de grade principais", x = "Eixo X", y = "Eixo Y")

## Retirar linhas de grade
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    scale_x_continuous(limits = c(30, 60), breaks = seq(30, 60, 5)) +
    theme(axis.title.x = element_text(face = "bold", size = 16),
          axis.text.x = element_text(size = 12),
          axis.title.y = element_text(face = "bold", size = 16),
          axis.text.y = element_text(size = 12),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank()) +
    labs(title = "Retirar linhas de grade", x = "Eixo X", y = "Eixo Y")

## Borda do gr√°fico
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = 0.5) +
    scale_x_continuous(limits = c(30, 60), breaks = seq(30, 60, 5)) +
    theme(axis.title.x = element_text(face = "bold", size = 16),
          axis.text.x = element_text(size = 12),
          axis.title.y = element_text(face = "bold", size = 16),
          axis.text.y = element_text(size = 12),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          panel.border = element_rect(size = 2, colour = "black", fill = NA)) +
    labs(title = "Borda do gr√°fico", x = "Eixo X", y = "Eixo Y")

## Borda do gr√°fico
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .4) +
    scale_x_continuous(limits = c(30, 60), breaks = seq(30, 60, 5)) +
    theme(axis.title.x = element_text(face = "bold", size = 16),
          axis.text.x = element_text(size = 12),
          axis.title.y = element_text(face = "bold", size = 16),
          axis.text.y = element_text(size = 12),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          axis.line = element_line(size = 1)) +
    labs(title = "Borda do gr√°fico", x = "Eixo X", y = "Eixo Y")
```

### Temas personalizados `ggtheme()`

Existem v√°rios temas criados dentro do universo [`ggtheme()`](https://ggplot2.tidyverse.org/reference/ggtheme.html) que podem facilitar a escolha de um modelo com √≥tima qualidade para publica√ß√£o. Abaixo, demonstramos os modelos mais utilizados (Figura \@ref(fig:fig-plot-final-ggtheme)).

```{r fig-plot-final-ggtheme, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o ao `ggtheme()` no pacote `ggplot2`."}
## theme_gray
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_gray(base_size = 16) +
    labs(title = "theme_gray()", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies") 
## theme_bw()
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_bw(base_size = 16) +
    labs(title = "theme_bw()", x = "Comprimento do bico (mm)",
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies") 
## theme_classic()
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme_classic(base_size = 16) +
    labs(title = "theme_classic()", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", shape = "Esp√©cies")
```

### Criando seu pr√≥prio `theme_custom()`

Por fim, √© poss√≠vel criar um tema personalizado como uma fun√ß√£o. Assim, o usu√°rio pode controlar todos os elementos gr√°ficos em um √∫nico c√≥digo. O maior benef√≠cio de personalizar uma fun√ß√£o √© que n√£o ser√° necess√°rio fazer os ajustes finos em todos os gr√°ficos que tiver construindo, o que pode representar grande economia de tempo e linhas de c√≥digo (Figura \@ref(fig:fig-plot-final-theme-custom)).

```{r fig-plot-final-theme-custom, fig.cap="Gr√°ficos mostrando a finaliza√ß√£o de gr√°ficos para publica√ß√£o em rela√ß√£o √† cria√ß√£o de um tema usando o `theme_custom()` no pacote `ggplot2`."}
## Criar uma fun√ß√£o com os ajustes finos
tema_personalizado <- function(){
    
    # Defina uma fonte
    font <- "Times" # Digite names(pdfFonts()) no console do R para ver a lista de fontes dispon√≠veis
    
    theme(
        
        # Defina elementos do gride
        panel.grid.major = element_line(colour = "#d3d3d3"),  
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank(), 
        panel.border = element_rect(colour = "black", fill = NA, size = .5),
        
        # Defina elementos textuais
        # T√≠tulo
        plot.title = element_text(             
            family = font,            # Fonte
            size = 20,                # Tamanho da fonte
            face = 'bold',            # Tipo de fonte
            hjust = 0,                # Alinhamento horizontal
            vjust = 2),               # Alinhamento vertical
        
        # Subt√≠tulo
        plot.subtitle = element_text(          
            family = font,            # Fonte
            size = 14),               # Tamanho da fonte
        
        # R√∫brica
        plot.caption = element_text(           
            family = font,            # Fonte
            size = 10,                # Tamanho da fonte
            hjust = 1),               # Alinhamento horizontal
        
        # T√≠tulo dos eixos
        axis.title = element_text(             
            family = font,            # Fonte
            size = 14),               # Tamanho da fonte
        
        # Texto dos eixos
        axis.text = element_text(              
            family = font,            # Fonte
            size = 14)              # Tamanho da fonte
        
    )}

## Gr√°fico usando a fun√ß√£o de tema criada
ggplot(data = penguins, 
       aes(x = comprimento_bico, y = comprimento_nadadeira,
           color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    tema_personalizado() +
    labs(title = "Tema personalizado", x = "Comprimento do bico (mm)", 
         y = "Profundidade do bico (mm)", color = "Esp√©cies", 
         shape = "Esp√©cies", caption = "Fonte = palmerpinguins")
```

### Exportando dados com alta qualidade com a fun√ß√£o `ggsave()`

O √∫ltimo passo para construir gr√°ficos com qualidade de publica√ß√£o √© exportar em um formato espec√≠fico, como .png, .pdf ou .svg (entre outros). A fun√ß√£o `ggsave()` n√£o s√≥ permite que voc√™ tenha o controle sobre o formato, mas tamb√©m sobre a qualidade e tamanho desejados com os seguintes argumentos:

- `width`: largura do gr√°fico
- `height`: altura do gr√°fico
- `units`: unidade de medida (cm, mm) do gr√°fico para definir largura e tamanho
- `dpi`: resolu√ß√£o ou qualidade da imagem, medida em pontos por polegada (*dots per inch*) (padr√£o = 300)

Vejamos um √∫ltimo exemplo (Figura \@ref(fig:fig-plot-final-export)).

```{r fig-plot-final-export, fig.cap="Gr√°fico criado para a exporta√ß√£o no pacote `ggplot2`."}
## Gr√°fico
g1 <- ggplot(data = penguins, 
             aes(x = comprimento_bico, y = comprimento_nadadeira,
                 color = especies, shape = especies)) +
    geom_point(size = 4, alpha = .7) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_shape_manual(values = c(19, 15, 17)) +
    scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
    theme(legend.position = c(.1, .1),
          legend.title = element_blank(),
          legend.key =  element_blank(),
          legend.background = element_blank()) +
    tema_personalizado() +
    labs(x = "Comprimento do bico (mm)", y = "Profundidade do bico (mm)", 
         color = "Esp√©cies", shape = "Esp√©cies")
g1
```

Podemos exportar esse gr√°fico de diferentes formas.

```{r eval=FALSE}
## Exportar no formato PDF
ggsave(filename = "g1.pdf", 
       plot = g1, 
       width = 15, 
       height = 15, 
       dpi =300,
       units = "cm")

## Exportar no formato PNG
ggsave(filename = "g1.png", 
       plot = g1, 
       width = 15, 
       height = 15, 
       dpi =300,
       units = "cm")

## Exportar no formato SVG
ggsave(filename = "g1.svg", 
       plot = g1, 
       width = 15, 
       height = 15, 
       dpi =300,
       units = "cm")
```

## Para se aprofundar

Listamos a seguir livros e links que recomendamos para seguir com sua aprendizagem em R e gr√°ficos.

### Livros

Recomendamos aos interessados os livros: i) Chang [-@chang_r_2018] R Graphics Cookbook, ii) Healy [-@healy_data_2018] Data Visualization: a practical introduction, iii) Rahlf [-@rahlf_data_2019] Data Visualisation with R: 111 Examples, iv) Sievert [-@sievert_interactive_2020] Interactive web-based data visualization with R, plotly, and shiny, v) Wickham [-@wickham2016] ggplot2: elegant graphics for data analysis, vi) Wilke [-@wilke_fundamentals_2019] Fundamentals of Data Visualization, vii) Wilkinson e colaboradores [-@wilkinson2005] The Grammar of Graphics.

### Links
Existem centenas de ferramentas online para aprender visualiza√ß√£o de dados e ggplot2. Tais ferramentas s√£o bastante variadas, incluindo desde a escolha de tipos de gr√°ficos √† sele√ß√£o de cores. Dentre elas, indicamos os seguintes links em ingl√™s:  

**Visualiza√ß√£o**
- [Data Visualization with R - Rob Kabacoff](https://rkabacoff.github.io/datavis/)
- [The Data Visualisation Catalogue](https://datavizcatalogue.com/index.html)
- [The R Graph Gallery](https://www.r-graph-gallery.com/index.html)
- [From Data to Viz](https://www.data-to-viz.com/)
- [Data Viz Project](https://datavizproject.com/)
- [QuickChart](https://quickchart.io/)
- [Chart.js](https://www.chartjs.org/)
- [drawdata.xyz](https://drawdata.xyz)

**Sele√ß√£o de cores (paletas)**
- [Color Brewer: color advice](https://colorbrewer2.org/)
- [Wes Anderson Palletes](https://github.com/karthik/wesanderson)
- [Choosing colors for data visualization](https://blog.datawrapper.de/colors/)

## Exerc√≠cios

**6.1**
Utilizando o banco de dados `penguins` compare o comprimento do bico entre as diferentes esp√©cies de penguins. Utilize um gr√°fico de caixa ([boxplot](https://analises-ecologicas.netlify.app/cap6.html#gr%C3%A1fico-de-caixa-boxplot)) para ilustrar a varia√ß√£o intraespec√≠fica e poss√≠veis outliers nos dados. Para melhorar o seu gr√°fico, lembre-se de nomear os dois eixos corretamente, definir um tema e posicionar a legenda.

**6.2**
Utilizando o banco de dados `penguins` fa√ßa um [histograma](https://analises-ecologicas.netlify.app/cap6.html#histograma-histogram) com a distribui√ß√£o da massa corporal para cada uma das esp√©cies. Utilize uma cor de preenchimento para cada esp√©cie.

**6.3**
Utilizando o banco de dados `penguins`, fa√ßa tr√™s gr√°ficos com o mesmo eixo Y e eixo X. Coloque o comprimento das nadadeiras no eixo Y e as esp√©cies de pinguins no eixo X. No primeiro gr√°fico, utilize o `geom_jitter()` para plotar os dados brutos. No segundo gr√°fico, utilize o `geom_violin()` para mostrar a distribui√ß√£o de densidade dos dados. No terceiro gr√°fico, utilize o `geom_boxplot()` para destacar a mediana e os quartis.

**6.4**
Se voc√™ conseguiu resolver o exerc√≠cio 6.3, agora d√™ um passo a mais e compare os tr√™s gr√°ficos lado a lado utilizando a fun√ß√£o `grid.arrange()`. Lembre-se de colocar um t√≠tulo informativo em cada um dos gr√°ficos antes de junt√°-los em uma prancha √∫nica. Ao comparar os tr√™s tipos de gr√°ficos, qual voc√™ considera mais informativo? Experimente combinar mais de um "geom" (camadas) e produzir gr√°ficos ainda mais interessantes.

**6.5**
Utilize o conjunto de dados `ecodados::anova_dois_fatores` para construir um [gr√°fico de barras](https://analises-ecologicas.netlify.app/cap6.html#gr%C3%A1fico-de-barras-bar-plot) com a m√©dia e o erro padr√£o do Tempo (Tempo para eliminar a droga do corpo) no eixo Y em fun√ß√£o da vari√°vel Pessoas (XX, ou XY) e Idade (jovem ou idoso). Antes de fazer o gr√°fico leia com aten√ß√£o a descri√ß√£o do mesmo atrav√©s do comando `?ecodados::anova_dois_fatores`. Uma dica, utilize `fill` dentro do `aes()` para representar um dos fatores (ex. Pessoas). O outro fator voc√™ pode representar no eixo X. Veja se consegue, se n√£o conseguir pode olhar a cola com a solu√ß√£o para aprender como √© feito. Outra dica, pesquise sobre a fun√ß√£o `stat_summary()` ela ir√° te ajudar a calcular a m√©dia e o erro padr√£o dentro do comando que gera o gr√°fico.

**6.6**
Utilize o banco de dados `penguins` para criar um [gr√°fico de dispers√£o](https://analises-ecologicas.netlify.app/cap6.html#gr%C3%A1fico-de-dispers%C3%A3o-scatter-plot) entre o tamanho da nadadeira (eixo Y) e a massa corporal (eixo X). Utilize o argumento `fill` para ilustrar com cores as diferen√ßas entre os sexos e utilize a fun√ß√£o `facte_grid()` para criar um gr√°fico separado para cada esp√©cie de pinguim. Se voc√™ n√£o conhece essa fun√ß√£o, d√™ uma olhada no help `?facet_grid()`. Voc√™ tamb√©m pode utilizar a fun√ß√£o `drop_na()` para excluir os dados faltantes da coluna `sexo`.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-6---visualiza%C3%A7%C3%A3o-de-dados.html).

<!--chapter:end:06_graficos.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Modelos lineares {#cap7}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados neste cap√≠tulo.

```{r}
## Pacotes
library(ecodados)
library(car)
library(ggpubr)
library(ggforce)
library(lsmeans)
library(lmtest)
library(sjPlot)
library(nlme)
library(ape)
library(fields)
library(tidyverse)
library(vegan)
library(rdist)

## Dados
CRC_PN_macho <- ecodados::teste_t_var_igual
CRC_LP_femea <- ecodados::teste_t_var_diferente
Pareado <- ecodados::teste_t_pareado
correlacao_arbustos <- ecodados::correlacao
dados_regressao <- ecodados::regressoes
dados_regressao_mul <- ecodados::regressoes
dados_anova_simples <- ecodados::anova_simples
dados_dois_fatores <- ecodados::anova_dois_fatores
dados_dois_fatores_interacao <- ecodados::anova_dois_fatores
dados_dois_fatores_interacao2 <- ecodados::anova_dois_fatores_interacao2
dados_bloco <- ecodados::anova_bloco
dados_ancova <- ecodados::ancova
data("mite")
data("mite.xy")
coords <- mite.xy
colnames(coords) <- c("long", "lat")
data("mite.env")
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Estat√≠sticas frequentistas como as que ser√£o abordadas neste cap√≠tulo s√£o baseadas em testes estat√≠sticos (e.g., F, t, ùõò^2^, etc.), que s√£o resultados n√∫mericos do teste e possuem um valor de probabilidade (valor de P) associado com este teste [@gotelli_primer_2012]. **O valor de P** mede a probabilidade que os valores observados ou mais extremos seriam encontrados caso a hip√≥tese nula seja verdadeira (veja Cap√≠tulo \@ref(cap2)). Ao longo do livro usaremos o crit√©rio convencional de rejeitar a hip√≥tese nula quando P \< 0.05. Contudo, sugerimos a leitura destes artigos [@white2013; @barber2014; @burnham_pvalues_2014; @murtaugh2014; @Halsey2019; @MUFF2021] que discutem as limita√ß√µes e problemas associados ao valor de P.
:::

## Teste T (de Student) para duas amostras independentes

Uma das perguntas mais comuns em estat√≠stica √© saber se h√° diferen√ßa entre as m√©dias de dois grupos ou tratamentos. Para responder a esta pergunta, William Sealy Gosset, qu√≠mico da cervejaria Guinness, desenvolveu em 1908 o Teste T que √© uma est√°tistica que segue uma distribui√ß√£o t de Student para rejeitar ou n√£o uma hip√≥tese nula de m√©dias iguais entre dois grupos.

$$t = \frac{(\bar{X}_1 - \bar{X}_2)}{\sqrt{\frac{2S^2_p}{n}}}$$

Onde:

-   $\bar{X}$<sub>1</sub> - $\bar{X}$<sub>2</sub> = diferen√ßa entre as m√©dias de duas amostras
-   S<sup>2</sup><sub>p</sub> = desvio padr√£o das amostras
-   *n* = tamanho das amostras

**Premissas do Teste t**

-   As amostras devem ser independentes
-   As unidades amostrais s√£o selecionadas aleatoriamente
-   Distribui√ß√£o normal (gaussiana) dos res√≠duos. 
-   Homogeneidade da vari√¢ncia. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\

-   Zar [-@zar_biostatistical_2010] indica que o Teste T √© robusto mesmo com moderada viola√ß√£o da normalidade, principalmente se o tamanho amostral for alto.

-   Caso as vari√¢ncias n√£o sejam homog√™neas, isso deve ser informado na linha de comando, pois o denominador da f√≥rmula acima ser√° corrigido.
:::

**Avalia√ß√£o das premissas**

Uma das maneiras de avaliarmos as premissas de normalidade e homogeneidade da vari√¢ncia relacionadas √†s an√°lises do teste T, ANOVA e regress√µes lineares simples e m√∫ltiplas √© o uso da inspe√ß√£o gr√°fica da distribui√ß√£o dos res√≠duos (Figura \@ref(fig:fig-homo-norm)) [@zuur_protocol_2009]. 

-   A homegeneidade da vari√¢ncia utiliza um gr√°fico dos res√≠duos (eixo X) pelos valores preditos da vari√°vel resposta (eixo Y) (Figura \@ref(fig:fig-homo-norm)A). A distribui√ß√£o dos res√≠duos ser√° homog√™nea se n√£o observarmos nenhum padr√£o na distribui√ß√£o dos pontos (i.e. forma em V, U ou funil). 

-   A normalidade dos res√≠duos utiliza um gr√°fico de quantis-quantis (QQ-plots). A distribui√ß√£o dos res√≠duos ser√° normal se os pontos estiverem pr√≥ximos √† reta (Figura \@ref(fig:fig-homo-norm)B).

```{r fig-homo-norm, echo=FALSE, fig.cap="Inspe√ß√£o gr√°fica da homogeneidade da vari√¢ncia (A) e normalidade dos res√≠duos (B). Os s√≠mbolos verdes indicam que os gr√°ficos em que os res√≠duos apresentam distribui√ß√£o homog√™nea e normal, enquanto os s√≠mbolos vermelhos indicam os gr√°ficos em que os res√≠duos violam as premissas do teste."}
knitr::include_graphics(path = "img/cap07_fig01.jpg")
```

**Exemplo pr√°tico 1 - Teste T para duas amostras com vari√¢ncias iguais**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos o comprimento rostro-cloacal (CRC em mil√≠metros) de machos de *Physalaemus nattereri* (Anura:Leptodactylidae) amostrados em diferentes esta√ß√µes do ano com armadilhas de intercepta√ß√£o e queda na Regi√£o Noroeste do Estado de S√£o Paulo [@daSilva2010].

**Pergunta**

- O CRC dos machos de *P. nattereri* √© maior na esta√ß√£o chuvosa do que na esta√ß√£o seca?

**Predi√ß√µes**

- O CRC dos machos ser√° maior na esta√ß√£o chuvosa porque h√° uma vantangem seletiva para os indiv√≠duos maiores durante a atividade reprodutiva

**Vari√°veis**

- Vari√°veis resposta e preditoras

- Data frame com os indiv√≠duos (unidade amostral) nas linhas e CRC (mm - vari√°vel resposta cont√≠nua) e esta√ß√£o (vari√°vel preditora categ√≥rica) como colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Vamos olhar os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(CRC_PN_macho) 
```

Vamos verificar a normalidade dos res√≠duos usando o QQ-plot (Figura \@ref(fig:fig-qqplot-var-igual)).

```{r fig-qqplot-var-igual, fig.cap="Normalidade dos res√≠duos usando o QQ-plot."}
## Teste de normalidade
residuos <- lm(CRC ~ Estacao, data = CRC_PN_macho)
qqPlot(residuos)
```

Os pontos est√£o pr√≥ximos √† reta, indicando que a distribui√ß√£o dos res√≠duos √© normal (\@ref(fig:fig-homo-norm)).

Outra possibilidade √© usar os testes de Shapiro-Wilk e Levene para verificar a normalidade e a homogeneidade da vari√¢ncia, respectivamente.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A Hip√≥tese Nula (H<sub>0</sub>) destes testes √© que a distribui√ß√£o √© normal ou homog√™nea:

-   Valor de p \< 0.05 significa que os dados **n√£o apresentam** distribui√ß√£o normal ou homog√™nea
-   Valor de p \> 0.05 significa que os dados **apresentam** distribui√ß√£o normal ou homog√™nea
:::

Teste de Shapiro-Wilk para normalidade dos res√≠duos.

```{r}
## Teste de Shapiro-Wilk
residuos_modelo <- residuals(residuos)
shapiro.test(residuos_modelo)
```

Teste de Levene para homogeneidade de vari√¢ncia dos res√≠duos.

```{r}
## Teste de homogeneidade de vari√¢ncia
leveneTest(CRC ~ as.factor(Estacao), data = CRC_PN_macho)
```

Percebam que a distribui√ß√£o dos res√≠duos foi normal e homog√™nea na inspe√ß√£o gr√°fica, assim como nos testes de Shapiro e Levene, respectivamente. Agora podemos realizar a an√°lise sabendo que os dados seguem as premissas requeridas pelo Teste T.

Vamos para os c√≥digos da an√°lise do Teste T para amostragens indenpendentes e vari√¢ncias iguais.

```{r}
## An√°lise Teste T 
t.test(CRC ~ Estacao, data = CRC_PN_macho, var.equal = TRUE)
```

Quatro valores devem ser apresentados ao leitores: i) estat√≠stica do teste - representada por **t = 4,15**, ii) valor de signific√¢ncia - representado por **p-value = 0,0001**, iii) graus de liberdade - representado por **df = 49**, e iv) diferen√ßa entre as m√©dias. Veja abaixo como descrever os resultados no seu trabalho.

Visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-test-t-ind-var-igual)).

```{r fig-test-t-ind-var-igual, fig.cap="Boxplot da an√°lise do Teste T para duas amostras com vari√¢ncias iguais."}
## Gr√°fico
ggplot(data = CRC_PN_macho, aes(x = Estacao, y = CRC, color = Estacao)) + 
    labs(x = "Esta√ß√µes", 
         y = expression(paste("CRC (mm) - ", italic("P. nattereri")))) +
    geom_boxplot(fill = c("darkorange", "cyan4"), color = "black", 
                 outlier.shape = NA) +
    geom_jitter(shape = 16, position = position_jitter(0.1), 
                cex = 5, alpha = 0.7) +
    scale_color_manual(values = c("black", "black")) +
    tema_livro() +
    theme(legend.position = "none")
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, rejeitamos a hip√≥tese nula de que as m√©dias do CRC dos machos entre as esta√ß√µes seca e chuvosa s√£o iguais. Os resultados mostram que os machos de *P. nattereri* coletados na esta√ß√£o chuvosa foram em m√©dia 0,43 mm maiores do que os machos coletados na esta√ß√£o seca (t~49~ = 4,15, P \< 0,001).

**Exemplo pr√°tico 2 - Teste T para duas amostras independentes com vari√¢ncias diferentes**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos o comprimento rostro-cloacal (CRC - mil√≠metros) de f√™meas de *Leptodactylus podicipinus* amostradas em diferentes esta√ß√µes do ano com armadilhas de intercepta√ß√£o e queda na Regi√£o Noroeste do Estado de S√£o Paulo [@daSilva2010]. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Os dados foram alterados em rela√ß√£o a publica√ß√£o original para se enquadrarem no exemplo de amostras com vari√¢ncias diferentes.
:::

**Pergunta**

- O CRC das f√™meas de *L. podicipinus* √© maior na esta√ß√£o chuvosa do que na esta√ß√£o seca?

**Predi√ß√µes**

- O CRC das f√™meas ser√° maior na esta√ß√£o chuvosa porque h√° uma vantangem seletiva para os indiv√≠duos maiores durante a atividade reprodutiva

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   Data frame com os indiv√≠duos (unidade amostral) nas linhas e CRC (mm - vari√°vel resposta cont√≠nua) e esta√ß√£o (vari√°vel preditora categ√≥rica) como colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhar os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(CRC_LP_femea) 
```

Vamos avaliar as premissas do teste. Comen√ßando com o teste de normalidade (Figura \@ref(fig:fig-qqplot-var-dif)).

```{r fig-qqplot-var-dif, fig.cap="Normalidade dos res√≠duos usando o QQ-plot."}
## Teste de normalidade usando QQ-plot
residuos_LP <- lm(CRC ~ Estacao, data = CRC_LP_femea)
qqPlot(residuos_LP)
```

Os res√≠duos apresentam distribui√ß√£o normal. Vamos testar tamb√©m com o Shapiro-Wilk para normalidade dos res√≠duos.

```{r}
## Teste de Shapiro-Wilk
residuos_modelo_LP <- residuals(residuos_LP)
shapiro.test(residuos_modelo_LP)
```

Agora vamos avaliar a homogeneidade da vari√¢ncia.

```{r}
## Teste de homogeneidade da vari√¢ncia
leveneTest(CRC ~ as.factor(Estacao), data = CRC_LP_femea)
```

Os res√≠duos n√£o apresentam homogeneidade da vari√¢ncia. Portanto, vamos realizar o Teste T com vari√¢ncias diferentes. Para isso, use o argumento `var.equal = FALSE`.

```{r}
## Teste T
t.test(CRC ~ Estacao, data = CRC_LP_femea, var.equal = FALSE)
```

Neste exemplo, n√£o rejeitamos a hip√≥tese nula e consideramos que as m√©dias do CRC das f√™meas entre as esta√ß√µes seca e chuvosa s√£o iguais (t~6,49~ = 1,76, P = 0,12).

Vamos visualizar os resultados em um gr√°fico (Figura \@ref(fig:fig-test-t-ind-var-dif)).

```{r fig-test-t-ind-var-dif, fig.cap="Boxplot da an√°lise do Teste T para duas amostras independentes com vari√¢ncias diferentes."}
## Gr√°fico
ggplot(data = CRC_LP_femea, aes(x = Estacao, y = CRC, color = Estacao)) + 
    geom_boxplot(fill = c("darkorange", "cyan4"), width = 0.5, 
                 color = "black", outlier.shape = NA, alpha = 0.7) +
    geom_jitter(shape = 20, position = position_jitter(0.2), color = "black", cex = 5) +
    scale_color_manual(values = c("darkorange", "cyan4")) +
    labs(x = "Esta√ß√µes", 
         y = expression(paste("CRC (mm) - ", italic("L. podicipinus"))), size = 15) +
    tema_livro() +
    theme(legend.position = "none")
```

**Interpreta√ß√£o dos resultados**

Os resultados mostram que as f√™meas de *L. podicipinus* coletadas na esta√ß√£o chuvosa n√£o s√£o maiores do que as f√™meas coletadas na esta√ß√£o seca, apesar de possuirem maior vari√¢ncia, o que pode ser biologicamente interessante.

## Teste T para amostras pareadas

O Teste T Pareado √© uma estat√≠stica que usa dados medidos duas vezes na mesma unidade amostral, resultando em pares de observa√ß√µes para cada amostra (amostras pareadas). Ele determina se a diferen√ßa da m√©dia entre duas observa√ß√µes √© zero.

$$t = \frac{\bar{d}}{S_{\bar{d}}}$$

Onde:
-   $\bar{d}$ = m√©dia da diferen√ßa das medidas pareadas. Observe que o teste n√£o usa as medidas originais, e sim, a diferen√ßa para cada par
-   S<sub>$\bar{d}$</sub> = erro padr√£o da diferen√ßa das medidas pareadas

**Premissas do Teste t para amostras pareadas**

-   As unidades amostrais s√£o selecionadas aleatoriamente
-   As observa√ß√µes **n√£o** s√£o independentes
-   Distribui√ß√£o normal (gaussiana) dos valores da diferen√ßa para cada par

**Exemplo pr√°tico 1 - Teste T para amostras pareadas**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos a diferen√ßa na riqueza de esp√©cies de artr√≥podes registradas em 27 localidades. Todas as localidades foram amostradas duas vezes. A primeira amostragem foi realizada na localidade antes da perturba√ß√£o e a segunda amostragem foi realizada ap√≥s a localidade ter sofrido uma queimada. Portanto, existe uma depend√™ncia temporal, uma vez que amostramos a mesma localidade antes e depois da queimada.

**Pergunta**

- A riqueza de esp√©cies de artr√≥podes √© prejudicada pelas queimadas?

**Predi√ß√µes**

- A riqueza de esp√©cies de artr√≥podes ser√° maior antes da queimada devido a extin√ß√£o local das esp√©cies

**Vari√°veis**

- Vari√°veis resposta e preditoras

-   data frame com as localidades nas linhas e riqueza de esp√©cies (vari√°vel resposta cont√≠nua) e estado (Pre-queimada ou P√≥s-queimada - vari√°vel preditora categ√≥rica) da localidade nas colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhando os dados com a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(Pareado) 
```

C√°lculo do Teste T com amostras pareadas.

```{r}
## An√°lise Teste T Pareado

t.test(Riqueza ~ Estado, paired = TRUE, data = Pareado)
```

Neste exemplo, rejeitamos a hip√≥tese nula de que a riqueza de esp√©cies de artr√≥podes √© igual antes e depois da queimada (t~26~ = 7,57, P \< 0,001).

Podemos visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-test-t-par)).

```{r fig-test-t-par, fig.cap="Boxplot da an√°lise do Teste T para duas amostras pareadas."}
## Gr√°fico
ggpaired(Pareado, x = "Estado", y = "Riqueza",
         color = "Estado", line.color = "gray", line.size = 0.8, 
         palette = c("darkorange", "cyan4"), width = 0.5, 
         point.size = 4, xlab = "Estado das localidades", 
         ylab = "Riqueza de Esp√©cies") +
    expand_limits(y = c(0, 150)) +
    tema_livro() 
```

**Interpreta√ß√£o dos resultados**

Os resultados mostram que as localidades ap√≥s as queimadas apresentam em m√©dia 44,5 esp√©cies de artr√≥podes a menos do que antes das queimadas.

## Correla√ß√£o de Pearson

√â um teste que mede a for√ßa relativa da rela√ß√£o linear entre duas vari√°veis cont√≠nuas (X e Y). Importante ressaltar que a an√°lise de correla√ß√£o n√£o assume que a vari√°vel X influencie a vari√°vel Y, ou que exista uma rela√ß√£o de causa e efeito entre elas [@zar_biostatistical_2010]. A an√°lise √© definida em termos da vari√¢ncia de X, a vari√¢ncia de Y, e a covari√¢ncia de X e Y (i.e. como elas variam juntas).

$$r = \frac{\sum{XY} - \frac{\sum{X} \sum{Y}}{n}}{\sqrt{\left(\sum{X^2} - \frac{\sum{X}^2}{n}\right)\left(\sum{Y^2} - \frac{\sum{Y}^2}{n}\right)}}$$

Onde:

-   r = coeficiente de correla√ß√£o que indica a for√ßa da rela√ß√£o linear entre as duas vari√°veis. Seu limite de valores est√° entre -1 $\leq$ r $\le$ 1. A correla√ß√£o positiva indica que o aumento no valor de uma das vari√°veis √© acompanhado pelo aumento no valor da outra vari√°vel. A correla√ß√£o negativa indica que o aumento no valor de uma das vari√°veis √© acompanhado pela diminui√ß√£o no valor da outra vari√°vel. Se *r* √© igual a zero, n√£o existe correla√ß√£o entre as vari√°veis (Figura \@ref(fig:fig-cor)).

```{r fig-cor, echo=FALSE, fig.cap="Exemplo de correla√ß√µes negativa (A), positiva (B) e nula (C) e vari√°veis que n√£o apresentam rela√ß√µes lineares entre si (D-E)."}
knitr::include_graphics(path = "img/cap07_fig02.jpg")
```

**Premissas da Correla√ß√£o de Person**

-   As amostras devem ser independentes e pareadas (i.e. as duas vari√°veis devem ser medidas na mesma unidade amostral)
-   As unidades amostrais s√£o selecionadas aleatoriamente
-   A rela√ß√£o entre as vari√°veis tem que ser linear

**Exemplo pr√°tico 1 - Correla√ß√£o de Pearson**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos a correla√ß√£o entre a altura do tronco e o tamanho da raiz medidos em 35 indiv√≠duos de uma esp√©cie vegetal arbustiva.

**Pergunta**

- Existe correla√ß√£o entre a altura do tronco e o tamanho da raiz dos arbustos?

**Predi√ß√µes**

- A altura do tronco √© positivamente correlacionada com o tamanho da raiz

**Vari√°veis**

-   Vari√°veis
-   data frame com os indiv√≠duos (unidade amostral) nas linhas e altura do tronco e tamanho da raiz (duas vari√°veis tem que ser cont√≠nuas) como colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Vamos olhar os dados com a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(correlacao_arbustos) 
```

C√°lculo do Teste da Correla√ß√£o de Pearson. Para outros testes de correla√ß√£o como Kendall ou Spearman √© s√≥ alterar o argumento `method` e inserir o teste desejado.

```{r}
## Correla√ß√£o de Pearson
cor.test(correlacao_arbustos$Tamanho_raiz, correlacao_arbustos$Tamanho_tronco, method = "pearson")

## Alternativamente
cor.test(~ Tamanho_tronco + Tamanho_raiz, data = correlacao_arbustos, method = "pearson")
```

Neste exemplo, rejeitamos a hip√≥tese nula de que as vari√°veis n√£o s√£o correlacionadas (r = 0.89, P \< 0,001).

Podemos visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-cor-dados)).

```{r fig-cor-dados, fig.cap="Gr√°fico mostrando a rela√ß√£o entre as vari√°veis e uma linha de tend√™ncia dos dados."}
## Gr√°fico
ggplot(data = correlacao_arbustos, aes(x = Tamanho_raiz, y = Tamanho_tronco)) + 
    labs(x = "Tamanho da raiz (m)", y = "Altura do tronco (m)") +
    geom_point(size = 4, shape = 21, fill = "darkorange", alpha = 0.7) +
    geom_text(x = 14, y = 14, label = "r = 0.89, P < 0.001", 
              color = "black", size = 5) +
    geom_smooth(method = lm, se = FALSE, color = "black", linetype = "dashed") +
    tema_livro() +
    theme(legend.position = "none")
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A linha de tend√™ncia tracejada no gr√°fico √© apenas para ilustrar a rela√ß√£o positiva entre as vari√°veis. Ela n√£o √© gerada pela an√°lise de correla√ß√£o.
:::

**Interpreta√ß√£o dos resultados**

Os resultados mostram que o aumento na altura dos arbutos √© acompanhado pelo aumento no tamanho da raiz.

## Regress√£o Linear Simples

A regress√£o linear simples √© usada para analisar a rela√ß√£o entre uma vari√°vel preditora (plotada no eixo-X) e uma vari√°vel resposta (plotada no eixo-Y). As duas vari√°veis devem ser cont√≠nuas. Diferente das correla√ß√µes, a regress√£o assume uma rela√ß√£o de causa e efeito entre as vari√°veis. O valor da vari√°vel preditora (X) causa, direta ou indiretamente, o valor da vari√°vel resposta (Y). Assim, Y √© uma fun√ß√£o linear de X:

$$Y = \beta_0 + \beta_{1}X_i + \epsilon_i$$

Onde:

-   $\beta_0$ = intercepto (*intercept*) que representa o valor da fun√ß√£o quando X = 0
-   $\beta_{1}$ = inclina√ß√£o (*slope*) que mede a mudan√ßa na vari√°vel Y para cada mudan√ßa de unidade da vari√°vel X
-   $\epsilon_{1}$ = erro aleat√≥rio referente √† vari√°vel Y que n√£o pode ser explicado pela vari√°vel X

**Premissas da Regress√£o Linear Simples**

-   As amostras devem ser independentes
-   As unidades amostrais s√£o selecionadas aleatoriamente
-   Distribui√ß√£o normal (gaussiana) dos res√≠duos
-   Homogeneidade da vari√¢ncia dos res√≠duos

**Exemplo pr√°tico 1 - Regress√£o Linear Simples**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos a rela√ß√£o entre o gradiente de temperatura m√©dia anual (¬∞C) e o tamanho m√©dio do comprimento rostro-cloacal (CRC em mm) de popula√ß√µes de *Dendropsophus minutus* (Anura:Hylidae) amostradas em 109 localidades no Brasil [@boaratti2015].

**Pergunta**

- A temperatura afeta o tamanho do CRC de popula√ß√µes de Dendropsophus minutus?

**Predi√ß√µes**

- O CRC das popula√ß√µes ser√£o menores em localidades mais quentes do que em localidades mais frias de acordo com a Hip√≥tese do Balan√ßo de Calor [@olalla-t√°rraga2007]

**Vari√°veis**

-   Vari√°veis resposta e preditoras
        
    -   Data frame com as popula√ß√µes (unidade amostral) nas linhas e CRC (vari√°vel resposta) m√©dio (mm) e temperatura m√©dia anual (vari√°vel preditora) como colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhando os dados com a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_regressao) 
```

Vamos calcular a regress√£o linear simples.

```{r}
## regress√£o simples
modelo_regressao <- lm(CRC ~ Temperatura, data = dados_regressao)
```

Antes de vermos os resultados, vamos verificar a normalidade e homogeneidade das vari√¢ncias (Figura \@ref(fig:fig-lm-pre)).

```{r fig-lm-pre, fig.cap="Gr√°ficos mostrando as premissas da regress√£o linear simples."}
## Verificar as premissas do teste
par(mfrow = c(2, 2), oma = c(0, 0, 2, 0))
plot(modelo_regressao)
dev.off() # volta a configura√ß√£o dos gr√°ficos para o formato padr√£o 
```

Os gr√°ficos *Residuals vs Fitted*, *Scale-Location*, e *Residual vs Leverage* est√£o relacionados com a homogeneidade da vari√¢ncia. Nestes gr√°ficos, esperamos ver os pontos dispersos no espa√ßo sem padr√µes com formatos em *U* ou funil. Neste caso, vemos que as linhas vermelhas (que indicam a tend√™ncia dos dados) est√£o praticamente retas, seguindo a linha pontilhada, sugerindo que n√£o exista heterogeneidade de vari√¢ncia dos res√≠duos. O gr√°fico *Residual vs Leverage*, identifica os valores extremos que estejam a mais de uma unidade da dist√¢ncia de Cook (linha pontilhada vermelha). Quando muito discrepantes, esses valores podem influenciar os resultados dos testes estat√≠sticos. Tamb√©m n√£o temos problemas com esse pressuposto do modelo aqui. O gr√°fico *Normal Q-Q (quantile-quantile plot)* mede desvios da normalidade. Neste caso, esperamos que os pontos sigam uma linha reta (i.e. fiquem muito pr√≥ximos da linha pontilhada) e n√£o apresentem padr√µes com formatos de *S* ou arco. Podemos observar que tanto a normalidade como a homogeneidade do res√≠duos est√£o dentro dos padr√µes esperados.

Vamos ver os resultados da regress√£o simples usando as fun√ß√µes `anova()` e `summary()`. A fun√ß√£o `anova()` retorna uma tabela contendo o grau de liberdade (df), soma dos quadrados, valor de F e o valor de P.

```{r}
## Resultados usando a fun√ß√£o anova
anova(modelo_regressao)
```

A fun√ß√£o `summary()` retorna uma tabela contendo o valor do intercepto, inclina√ß√£o da reta (*slope*) e o coeficiente de determina√ß√£o (R^2^) que indica a propor√ß√£o da varia√ß√£o na vari√°vel Y que pode ser atribu√≠da √† varia√ß√£o na vari√°vel X. Percebam que a parte final dos resultados apresentados no `summary()` s√£o os mesmo apresentados pela fun√ß√£o `anova()`.

```{r}
## Resultados usando a fun√ß√£o summary
summary(modelo_regressao)
```

Vamos visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-lm)).

```{r fig-lm, fig.cap="Gr√°fico mostrando a rela√ß√£o entre as vari√°veis e modelo linear simples, representado pela linha cont√≠nua."}
## Gr√°fico
ggplot(data = dados_regressao, aes(x = Temperatura, y = CRC)) + 
    labs(x = "Temperatura m√©dia anual (¬∞C)", 
         y = "Comprimento rostro-cloacal (mm)") +
    geom_point(size = 4, shape = 21, fill = "darkorange", alpha = 0.7) +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    tema_livro() +
    theme(legend.position = "none")
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, rejeitamos a hip√≥tese nula de que n√£o existe rela√ß√£o entre o tamanho do CRC das popula√ß√µes de *D. minutus* e a temperatura da localidade onde elas ocorrem (F~1,107~ = 38,92, P \< 0,001). Os resultados mostram que o tamanho do CRC das popula√ß√µes tem uma rela√ß√£o positiva com a temperatura das localidades. Assim, popula√ß√µes de *D. minutus* em localidades mais quentes apresentam maior CRC do que as popula√ß√µes em localidades mais frias. Podemos tamb√©m usar os coeficientes da regress√£o para entender como a mudan√ßa na vari√°vel preditora (temperatura) afeta o tamanho corporal m√©dio dos anuros. Neste caso, ao usar o comando `coef(modelo_regressao)`, obtemos os valores 16,23 e 0,27, respectivamente os valores do intercepto (Œ≤<sub>0</sub>) e da temperatura (Œ≤<sub>1</sub>). O valor de 0,27 indica que a mudan√ßa de uma unidade na vari√°vel preditora (neste caso, graus), aumenta em 0,27 unidades (neste caso, cent√≠metros) da vari√°vel dependente. Por exemplo, o modelo indica que o tamanho m√©dio dos indiv√≠duos em locais com temperatura de 16¬∫ C √© de 20,55 cm, ao passo que em locais com 26¬∫ C o tamanho aumenta para 23,25 cm, o que representa um ganho de 13%.

## Regress√£o Linear M√∫ltipla

A regress√£o linear m√∫ltipla √© uma extens√£o da regress√£o linear simples. Ela √© usada quando queremos determinar o valor da vari√°vel resposta (Y) com base nos valores de duas ou mais vari√°veis preditoras (X~1~, X~2~, X~*n*~).

$$Y = \beta_0 + \beta_{1}X_1 + \beta_{n}X_n + \epsilon_i$$

Onde:

-   $\beta_0$ = intercepto (*intercept*) que representa o valor da fun√ß√£o quando X = 0
-   $\beta_{n}$ = inclina√ß√£o (*slope*) que mede a mudan√ßa na vari√°vel Y para cada mudan√ßa de unidade das vari√°veis X~n~
-   $\epsilon_{1}$ = erro aleat√≥rio referente a vari√°vel Y que n√£o pode ser explicado pelas vari√°veis preditoras

**Premissas da Regress√£o Linear M√∫ltipla**

-   As amostras devem ser independentes
-   As unidades amostrais s√£o selecionadas aleatoriamente
-   Distribui√ß√£o normal (gaussiana) dos res√≠duos
-   Homogeneidade da vari√¢ncia dos res√≠duos

**Exemplo pr√°tico 1 - Regress√£o Linear M√∫ltipla**

**Explica√ß√£o dos dados**

Utilizaremos o mesmo exemplo da regress√£o linear simples. Contudo, al√©m do gradiente de temperatura m√©dia anual (¬∞C), incluiremos o gradiente de precipita√ß√£o anual (mm) como outra vari√°vel preditora do tamanho m√©dio do comprimento rostro-cloacal (CRC em mm) de popula√ß√µes de *Dendropsophus minutus* (Anura:Hylidae) amostradas em 109 localidades no Brasil [@boaratti2015].

**Pergunta**

- O tamanho do CRC das popula√ß√µes de *D. minutus* √© influ√™nciado pela temperatura e precipita√ß√£o das localidades onde os indiv√≠duos ocorrem?

**Predi√ß√µes**

- O CRC das popula√ß√µes ser√£o menores em localidades com clima quente e chuvoso do que em localidades com clima frio e seco

**Vari√°veis**

- Vari√°veis resposta e preditoras

-   data frame com as popula√ß√µes (unidade amostral) nas linhas e CRC (vari√°vel resposta) m√©dio (mm) e temperatura e precipita√ß√£o (vari√°veis preditoras) como colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhando os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_regressao_mul) 
```

C√≥digos para ajustar o modelo de regress√£o m√∫ltipla.

```{r}
## Regress√£o m√∫ltipla
modelo_regressao_mul <- lm(CRC ~ Temperatura + Precipitacao,
                           data = dados_regressao_mul)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Multicolinearidade ocorre quando as vari√°veis preditoras s√£o correlacionadas. Essa correla√ß√£o √© um problema porque as vari√°veis preditoras deveriam ser independentes. Al√©m disso, a multicolinearidade aumentam o erro padr√£o associado aos coeficientes produzindo resultados menos confi√°veis. O Fator de Infla√ß√£o da Vari√¢ncia (VIF) √© um teste que quantifica quanto do erro padr√£o dos coeficientes estimados est√£o inflados devido √† multicolinearidade. Na regress√£o m√∫ltipla, cada vari√°vel preditora tem um valor de VIF. Alguns autores consideram valores de VIF acima de 10 como fortemente correlacionadas, outros mais conservadores consideram o valor de 5, 3 ou at√© mesmo 2. Mais detalhes em @zuur_protocol_2009 e @dormann_collinearity_2013.
:::

Vamos analisar se as vari√°veis apresentam multicolinearidade.

```{r}
# Multicolinearidade
vif(modelo_regressao_mul)
```

Os valores s√£o menores que 3, indicando que n√£o h√° multicolinearidade.

Agora vamos verificar as premissas de normalidade e homogeneidade das vari√¢ncias (Figura \@ref(fig:fig-lm-multi-pre)).

```{r fig-lm-multi-pre, fig.cap="Gr√°ficos mostrando as premissas da regress√£o linear m√∫ltipla."}
## Normalidade e homogeneidade das vari√¢ncias
plot_grid(plot_model(modelo_regressao_mul , type = "diag"))
```

Os res√≠duos apresentam distribui√ß√£o normal e vari√¢ncias homog√™neas.

Podemos ver os resultados da an√°lise.

```{r}
## regress√£o m√∫ltipla
summary(modelo_regressao_mul)
```

Percebam que a temperatura tem uma rela√ß√£o significativa e positiva com o tamanho do CRC das popula√ß√µes (P \< 0.001), enquanto a precipita√ß√£o n√£o apresenta rela√ß√£o com o CRC (P = 0.27). Neste caso, √© interessante saber se um modelo mais simples (e.g. contendo apenas temperatura) explicaria a distribui√ß√£o t√£o bem ou melhor do que este modelo mais complexo considerando duas vari√°veis (temperatura e precipita√ß√£o).

Para isso, podemos utilizar a *Likelihood-ratio test (LRT)* para comparar os modelos. A LRT compara dois modelos aninhados, testando se os par√¢metros do modelo mais complexo diferem significativamente do modelo mais simples. Em outras palavras, ele testa se h√° necessidade de se incluir uma vari√°vel extra no modelo para explicar os dados.

```{r}
## Criando os modelos aninhados
modelo_regressao_mul <- lm(CRC ~ Temperatura + Precipitacao, 
                           data = dados_regressao_mul)
modelo_regressao <- lm(CRC ~ Temperatura, data = dados_regressao_mul)

## Likelihood-ratio test (LRT)
lrtest(modelo_regressao_mul, modelo_regressao)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A Hip√≥tese Nula (H<sub>0</sub>) do teste *Likelihood-ratio test (LRT)* √© de que o modelo mais simples √© o melhor.

-   Valor de p \< 0.05 rejeita a hip√≥tese nula e o modelo mais complexo √© o melhor
-   Valor de p \> 0.05 n√£o rejeita a hip√≥tese nula e o modelo mais simples √© o melhor
:::

```{r}
## Comparando com o modelo somente com o intercepto
# Criando um modelo sem vari√°veis, s√≥ o intercepto.
modelo_intercepto <- lm(CRC ~ 1, data = dados_regressao_mul)
lrtest(modelo_regressao, modelo_intercepto)
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, a precipita√ß√£o n√£o est√° associada com a varia√ß√£o no tamanho do CRC das popula√ß√µes de *D. minutus*. Por outro lado, a temperatura explicou 26% da varia√ß√£o do tamanho do CRC das popula√ß√µes.

## An√°lises de Vari√¢ncia (ANOVA)

ANOVA refere-se a uma variedade de delineamentos experimentais nos quais a vari√°vel preditora √© categ√≥rica e a vari√°vel resposta √© cont√≠nua [@gotelli_primer_2012]. Exemplos desses delineamentos experimentais s√£o: ANOVA de um fator, ANOVA de dois fatores, ANOVA em blocos aleatorizados, ANOVA de medidas repetidas e ANOVA *split-splot*. De forma geral, a ANOVA √© um teste estat√≠stico usado para comparar a m√©dia entre grupos amostrados independentemente. Para isso, o teste leva em conta, al√©m das m√©dias dos grupos, a varia√ß√£o dos dados dentro e entre os grupos. Neste cap√≠tulo, iremos demonstrar os c√≥digos para alguns dos principais delineamentos experimentais.

**Premissas da ANOVA**

-   As amostras devem ser independentes
-   As unidades amostrais s√£o selecionadas aleatoriamente
-   Distribui√ß√£o normal (gaussiana) dos res√≠duos
-   Homogeneidade da vari√¢ncia

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
ANOVA de medidas repetidas e ANOVA *split-plot* s√£o an√°lises com desenhos experimentais que apresentam depend√™ncia entre as amostras, mas controlam esse deped√™ncia nas suas formula√ß√µes matem√°ticas.
:::

### ANOVA de um fator

Este teste considera delineamentos experimentais com apenas um fator (ou tratamento) que pode ser composto por tr√™s ou mais grupos (ou n√≠veis).

**Exemplo pr√°tico 1 - Anova de um fator**

**Explica√ß√£o dos dados**

Neste exemplo hipot√©tico, avaliaremos se o adubo X-2020 disponibilizado recentemente no mercado melhora o crescimento dos indiv√≠duos de *Coffea arabica* como divulgado pela empresa respons√°vel pela venda do produto. Para isso, foi realizado um experimento com indiv√≠duos de *C. arabica* cultivados em tr√™s grupos: i) grupo controle onde os indiv√≠duos n√£o receberam aduba√ß√£o, ii) grupo onde os indiv√≠duos receberam a adi√ß√£o do adubo tradicional mais utilizado pelos produtores de *C. arabica*, e iii) grupo onde os indiv√≠duos receberam a adi√ß√£o do adubo X-2020.

**Pergunta**

- O crescimento dos indiv√≠duos de *C. arabica* √© melhorado pela adi√ß√£o do adubo X-2020?

**Predi√ß√µes**

- O crescimento dos indiv√≠duos de *C. arabica* ser√° maior no grupo que recebeu o adubo X-2020

**Vari√°veis**

-   Vari√°veis resposta e preditoras

    -   Data frame com as plantas (unidade amostral) nas linhas e o crescimento dos indiv√≠duos de *C. arabica* (vari√°vel resposta) e os tratamentos (vari√°vel preditora) nas colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°vel preditora e resposta nas colunas

**An√°lise**

Olhando os dados e criando o modelo para Anova de um fator.

```{r}
## Cabe√ßalho dos dados
head(dados_anova_simples) 

## An√°lise ANOVA de um fator
Modelo_anova <- aov(Crescimento ~ Tratamento, data = dados_anova_simples) 
```

Vamos verificar a normalidade dos res√≠duos e homogeneidade da vari√¢ncia usando os testes de Shapiro-Wilk e Bartlett, respectivamente.

```{r}
## Normalidade 
shapiro.test(residuals(Modelo_anova))

## Homogeneidade da vari√¢ncia
bartlett.test(Crescimento ~ Tratamento, data = dados_anova_simples)
```

Os res√≠duos apresentam distribui√ß√£o normal e homogeneidade de vari√¢ncia.

Vamos ver os resultados da an√°lise.

```{r}
## Resultados da anova
anova(Modelo_anova)
```

Percebam que o resultado da ANOVA (Pr(\>F) \< 0.001) indica que devemos rejeitar a hip√≥tese nula que n√£o h√° diferen√ßa entre as m√©dias dos grupos. Contudo, os resultados n√£o mostram quais s√£o os grupos que apresentam diferen√ßas. Para isso, temos que realizar testes de compara√ß√µes m√∫ltiplas *post-hoc* para detectar os grupos que apresentam diferen√ßas significativas entre as m√©dias.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Os testes *post-hoc* s√≥ devem ser utilizados quando rejeitamos a hip√≥tese nula (P \< 0.05) no teste da ANOVA.
:::

```{r}
## Diferen√ßas entre os tratamentos
# Teste de Tuckey's honest significant difference
TukeyHSD(Modelo_anova)
```

Visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-anova-um-fator)).

```{r fig-anova-um-fator, fig.cap="Gr√°fico de caixa mostrando o resultado da ANOVA de um fator."}
## Reorganizando a ordem que os grupos ir√£o aparecer no gr√°fico
dados_anova_simples$Tratamento <- factor(dados_anova_simples$Tratamento,
                                         levels = c("Controle", "Adubo_Tradicional", "Adubo_X-2020"))

## Gr√°fico
ggplot(data = dados_anova_simples, 
       aes(x = Tratamento, y = Crescimento, color = Tratamento)) + 
    geom_boxplot(fill = c("darkorange", "darkorchid", "cyan4"), 
                 color = "black", show.legend = FALSE, alpha = 0.4) +
    geom_jitter(shape = 16, position = position_jitter(0.1), 
                cex = 4, alpha = 0.7) +
    scale_color_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_y_continuous(limits = c(0, 20), breaks = c(0, 5, 10, 15, 20)) +
    geom_text(x = 1, y = 12, label = "ab", color = "black", size = 5) +
    geom_text(x = 2, y = 17, label = "a", color = "black", size = 5) +
    geom_text(x = 3, y = 17, label = "b", color = "black", size = 5) +
    scale_x_discrete(labels = c("Sem adubo", "Tradicional", "X-2020")) +
    labs(x = "Aduba√ß√£o", y = "Crescimento Coffea arabica (cm)", size = 20) +
    tema_livro() +
    theme(legend.position = "none") 
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, os indiv√≠duos de *C. arabica* que receberam aduba√ß√£o (tradicional e X-2020) apresentaram maior crescimento do que os indiv√≠duos que n√£o receberam aduba√ß√£o. Contudo, diferente do que foi divulgado pela empresa, o adubo X-2020 n√£o apresentou melhor desempenho que o adubo tradicional j√° utilizado pelos produtores.

### ANOVA com dois fatores ou ANOVA fatorial

Este teste considera delineamentos amostrais com dois fatores (ou tratamentos) que podem ser compostos por dois ou mais grupos (ou n√≠veis). Esta an√°lise tem uma vantagem, pois permite avaliar o efeito da intera√ß√£o entre os fatores na vari√°vel resposta. Quando a intera√ß√£o est√° presente, o impacto de um fator depende do n√≠vel (ou grupo) do outro fator.

**Exemplo pr√°tico 1 - ANOVA com dois fatores**

**Explica√ß√£o dos dados**

Neste exemplo hipot√©tico, avaliaremos se o tempo que o corpo leva para eliminar uma droga utilizada em exames de resson√¢ncia magn√©tica est√° relacionado com o sistema XY de determina√ß√£o do sexo e/ou com a idade dos pacientes. Para isso, foi realizado um experimento com 40 pacientes distribu√≠dos da seguinte maneira: i) 10 indiv√≠duos XX - jovens, ii) 10 indiv√≠duos XX - idosas, iii) 10 indiv√≠duos XY - jovens, e iv) 10 indiv√≠duos XY - idosos.

**Pergunta**

- O tempo de elimina√ß√£o da droga √© dependente do sistema XY de determina√ß√£o do sexo e idade dos pacientes?

**Predi√ß√µes**

- O tempo de elimina√ß√£o da droga vai ser mais r√°pido nas pacientes XX e jovens

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   data frame com os pacientes (unidade amostral) nas linhas e o tempo de elimina√ß√£o da droga (vari√°vel resposta) e os tratamentos sexo e idade dos pacientes (vari√°veis preditoras) nas colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e as vari√°veis preditoras e respostas nas colunas

**An√°lise**

Verificando os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_dois_fatores) 
```

C√≥digos para realizar a ANOVA com dois fatores.

```{r}
## An√°lise Anova de dois fatores 
# A intera√ß√£o entre os fatores √© representada por *
Modelo1 <- aov(Tempo ~ Pessoas * Idade, data = dados_dois_fatores) 

# Olhando os resultados
anova(Modelo1)
```

Percebam que a intera√ß√£o n√£o apresenta um efeito significativo (P \> 0.05). Assim, iremos retirar a intera√ß√£o e verificar, usando Likelihood-ratio test, se o modelo mais simples √© melhor.

```{r}
# Criando modelo sem intera√ß√£o.
Modelo2 <- aov(Tempo ~ Pessoas + Idade, data = dados_dois_fatores) 

## LRT
lrtest(Modelo1, Modelo2)
```

Analisando o resultado do teste (P \> 0.05), a intera√ß√£o n√£o √© importante. Ent√£o podemos seguir com o modelo mais simples. Vamos verficiar a normalidade e homogeneidade da vari√¢ncia (Figura \@ref(fig:fig-lm-anova-fat-pre)).

```{r fig-lm-anova-fat-pre, fig.cap="Gr√°ficos mostrando as premissas da ANOVA fatorial."}
# Verificando as premissas do teste.
plot_grid(plot_model(Modelo2, type = "diag"))
```

Dois pontos est√£o fugindo da reta e chamam aten√ß√£o sobre a normalidade da distribui√ß√£o dos res√≠duos. A homogeneidade da vari√¢ncia est√° adequada. Por enquanto, vamos seguir a an√°lise, mas veja o Cap√≠tulo \@ref(cap8) para entender como lidar com modelos que os res√≠duos n√£o apresentam distribui√ß√£o normal.

```{r}
# Resultados do modelo
anova(Modelo2)
```

Percebam que o resultado da ANOVA (Pr(\>F) \< 0.001) indica que devemos rejeitar a hip√≥tese nula de que n√£o h√° diferen√ßa entre as m√©dias dos sistema XY e idade dos pacientes. Neste caso, n√£o precisamos realizar testes de compara√ß√µes m√∫ltiplas *post-hoc* porque os fatores apresentam apenas dois n√≠veis. Contudo, se no seu delineamento experimental um dos fatores apresentar tr√™s ou mais n√≠veis, voc√™ dever√° utilizar os testes de compara√ß√µes *post-hoc* para determinar as diferen√ßas entre os grupos.

Vamos visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-anova-fatorial)).

```{r fig-anova-fatorial, fig.cap="Gr√°fico de caixa mostrando o resultado da ANOVA fatorial."}
## Gr√°fico
ggplot(data = dados_dois_fatores_interacao, 
       aes(y = Tempo, x = Pessoas, color = Idade)) + 
    geom_boxplot() +
    stat_summary(fun = mean, geom ="point", aes(group = Idade, x = Pessoas),
                 color = "black",
                 position = position_dodge(0.7), size  = 4) +
    geom_link(aes(x = 0.8, y = 31, xend = 1.8, yend = 40), color = "darkorange", 
              lwd  = 1.3, linetype = 2) + 
    geom_link(aes(x = 1.2, y = 19, xend = 2.2, yend = 26.5), 
              color = "cyan4", lwd  = 1.3, linetype = 2) + 
    labs(x = "Sistema XY de determina√ß√£o do sexo", 
         y = "Tempo (horas) para eliminar a droga") +
    scale_color_manual(values = c("darkorange", "cyan4", "darkorange", "cyan4")) +
    scale_y_continuous(limits = c(10, 50), breaks = c(10, 20, 30, 40, 50)) +
    tema_livro()  
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, o sistema XY de determina√ß√£o do sexo e a idade dos pacientes t√™m um efeito no tempo de elimina√ß√£o da droga do organismo. Os pacientes XX e jovens apresentaram elimina√ß√£o mais r√°pida da droga do que pacientes XY e idosos.

**Exemplo pr√°tico 2 - ANOVA com dois fatores com efeito da intera√ß√£o**

**Explica√ß√£o dos dados**

Neste exemplo, novamente hipot√©tico, usaremos os mesmos dados do exemplo anterior. Entretanto, alteramos os dados para que agora a intera√ß√£o seja significativa.

```{r}
## Olhando os dados
head(dados_dois_fatores_interacao2)

## An√°lise anova de dois fatores 
Modelo_interacao2 <- aov(Tempo ~ Pessoas * Idade, 
                         data = dados_dois_fatores_interacao2)

## Olhando os resultados
anova(Modelo_interacao2)
```

Percebam que a intera√ß√£o √© significativa (P \< 0.05), mas a idade n√£o √© significativa. Nossa interpreta√ß√£o precisa ser baseada na intera√ß√£o entre os fatores. Vamos visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-anova-fatorial-int)).

```{r fig-anova-fatorial-int, fig.cap="Gr√°fico de caixa mostrando o resultado da ANOVA fatorial com intera√ß√£o."}
## Gr√°fico
ggplot(data = dados_dois_fatores_interacao2, 
       aes(y = Tempo, x = Pessoas, color = Idade)) + 
    geom_boxplot() +
    stat_summary(fun = mean, geom ="point", aes(group = Idade, x = Pessoas), 
                 color = "black", position = position_dodge(0.7), size  = 4) +
    geom_link(aes(x = 0.8, y = 31, xend = 1.8, yend = 27), color = "darkorange", 
              lwd  = 1.3, linetype = 2) + 
    geom_link(aes(x = 1.2, y = 19, xend = 2.2, yend = 41), color = "cyan4", 
              lwd  = 1.3, linetype = 2) + 
    labs(x = "Sistema XY de determina√ß√£o do sexo", 
         y = "Tempo (horas) para eliminar a droga") +
    scale_color_manual(values = c("darkorange", "cyan4", "darkorange", "cyan4")) +
    scale_y_continuous(limits = c(10, 50), breaks = c(10, 20, 30, 40, 50)) +
    tema_livro() 
```

**Interpreta√ß√£o dos resultados**

Percebam que as linhas se cruzam. Esse √© um exemplo cl√°ssico de intera√ß√£o. Novamente, para saber a resposta do fator idade (jovem ou idoso), voc√™ precisa saber com qual pessoa (XX ou XY) ele est√° associado. Jovens s√£o mais r√°pidos para eliminarem a droga em pessoas XX, enquanto os idosos s√£o mais r√°pidos para eliminarem a droga nas pessoas XY.

### ANOVA em blocos aleatorizados

No delineamento experimental com blocos aleatorizados, cada fator √© agrupado em blocos, com r√©plicas de cada n√≠vel do fator representado em cada bloco [@gotelli_primer_2012]. O bloco √© uma √°rea ou per√≠odo de tempo dentro do qual as condi√ß√µes ambientais s√£o relativamente homog√™neas. O objetivo do uso dos blocos √© controlar fontes de varia√ß√µes indesejadas na vari√°vel dependente que n√£o s√£o de interesse do pesquisador. Desta maneira, podemos retirar dos res√≠duos os efeitos das varia√ß√µes indesejadas que n√£o s√£o do nosso interesse, e testar com maior poder estat√≠stico os efeitos dos tratamentos de interesse. Importante, os blocos devem ser arranjados de forma que as condi√ß√µes ambientais sejam mais similares dentro dos blocos do que entre os blocos.

**Exemplo pr√°tico 1 - ANOVA em blocos aleatorizados**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos a riqueza de esp√©cies de anuros amostradas em po√ßas artificiais instaladas a diferentes dist√¢ncias de seis fragmentos florestais no sudeste do Brasil [@daSilva2011]. Os fragmentos florestais apresentam diferen√ßas entre si que n√£o s√£o do interesse do pesquisador. Por isso, eles foram inclu√≠dos como blocos nas an√°lises. As po√ßas artificiais foram instaladas em todos os fragmentos florestais com base no seguinte delineamento experimental [@daSilva2011]: i) quatro po√ßas no interior do fragmento a 100 m de dist√¢ncia da borda do fragmento; ii) quatro po√ßas no interior no fragmento a 50 m de dist√¢ncia da borda do fragmento; iii) quatro po√ßas na borda do fragmento; iv) quatro po√ßas na matriz de pastagem a 50 m de dist√¢ncia da borda do fragmento; e v) quatro po√ßas na matriz de pastagem a 100 m de dist√¢ncia da borda do fragmento. Percebam que todos os tratamentos foram instalados em todos os blocos. 


::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Os valores da riqueza de esp√©cies foram alterados em rela√ß√£o a publica√ß√£o original [@daSilva2011] para deixar o exemplo mais did√°tico.
:::

**Pergunta**

- A dist√¢ncia da po√ßa artifical ao fragmento florestal influencia a riqueza de esp√©cies anuros?

**Predi√ß√µes**

- Po√ßas na borda do fragmento florestal apresentar√£o maior riqueza de esp√©cies do que po√ßas distantes da borda

**Vari√°veis**

-   Vari√°veis resposta e preditoras

    -   Data frame com as po√ßas (unidade amostral) nas linhas e a riqueza de esp√©cies (vari√°vel reposta), dist√¢ncia dos fragmentos florestais (vari√°vel preditora categ√≥rica) e fragmentos florestais (blocos) nas colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhando os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_bloco) 
```

An√°lise da ANOVA em blocos.

```{r}
## An√°lise Anova em blocos aleatorizados
model_bloco <- aov(Riqueza ~ Pocas + Error(Blocos), data = dados_bloco)
summary(model_bloco)
```

Lembre-se que nos delineamentos experimentais em bloco, o pesquisador n√£o est√° interessado no efeito do bloco, mas sim em controlar a varia√ß√£o associada a ele.

O que n√£o pode acontecer √© ignorar o efeito do bloco que √© incorporado pelos res√≠duos quando n√£o informado no modelo. Veja abaixo a forma errada de analisar delineamento experimental com blocos.

```{r}
## Forma errada de an√°lisar Anova em blocos
modelo_errado <- aov(Riqueza ~ Pocas, data = dados_bloco)
anova(modelo_errado)
```

O resultado da ANOVA (Pr(\>F) \< 0.001) indica que devemos rejeitar a hip√≥tese nula que n√£o h√° diferen√ßa entre as m√©dias dos grupos. Contudo, os resultados n√£o mostram quais s√£o os grupos que apresentam diferen√ßas. Para isso, temos que realizar testes de compara√ß√µes m√∫ltiplas *post-hoc* para detectar os grupos que apresentam diferen√ßas significativas entre as m√©dias.

```{r}
## Teste de Tuckey's honest significant difference
pairs(lsmeans(model_bloco, "Pocas"), adjust = "tukey")
```

Visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-anova-blocos)).

```{r fig-anova-blocos, fig.cap="Gr√°fico de caixa mostrando o resultado da ANOVA de blocos aleatorizados."}
# Reordenando a ordem que os grupos ir√£o aparecer no gr√°fico.
dados_bloco$Pocas <- factor(dados_bloco$Pocas, 
                            levels = c("Int-100m", "Int-50m", "Borda", "Mat-50m", "Mat-100m"))

## Gr√°fico
ggplot(data = dados_bloco, aes(x = Pocas, y = Riqueza)) + 
    labs(x = "Po√ßas artificiais", y = "Riqueza de esp√©cies de anuros") +
    geom_boxplot(color = "black", show.legend = FALSE, alpha = 0.4) +
    geom_jitter(shape = 16, position = position_jitter(0.1), cex = 4, alpha = 0.7) +
    scale_x_discrete(labels = c("-100m","-50m","Borda", "50m", "100m")) +
    tema_livro() +
    theme(legend.position = "none") 
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, rejeitamos a hip√≥tese nula de que a dist√¢ncia das po√ßas artificiais at√© as bordas dos fragmentos florestais n√£o influ√™ncia a riqueza de esp√©cies de anuros. As po√ßas artificiais instaladas nas bordas dos fragmentos florestais apresentaram maior riqueza de esp√©cies do que as po√ßas distantes.

### An√°lise de covari√¢ncia (ANCOVA)

A ANCOVA pode ser compreendida como uma extens√£o da ANOVA com a adi√ß√£o de uma vari√°vel cont√≠nua (covari√°vel) medida em todas as unidades amostrais [@gotelli_primer_2012]. A ideia √© que a covari√°vel tamb√©m afete os valores da vari√°vel resposta. N√£o incluir a covari√°vel ir√° fazer com que a varia√ß√£o n√£o explicada pelo modelo concentre-se nos res√≠duos. Incluindo a covari√°vel, o tamanho do res√≠duo √© menor e o teste para avaliar as diferen√ßas nos tratamentos, que √© o interesse do pesquisador, ter√° mais poder estat√≠stico.

**Exemplo pr√°tico 1 - ANCOVA**

**Explica√ß√£o dos dados**

Neste exemplo hipot√©tico, avaliaremos o efeito da herbivoria na biomassa dos frutos de uma esp√©cie de √°rvore na Mata Atl√¢ntica. O delineamento experimental permitiu que alguns indiv√≠duos sofressem herbivoria e outros n√£o. Os pesquisadores tamb√©m mediram o tamanho da raiz dos ind√≠viduos para inseri-la como uma covari√°vel no modelo.

**Pergunta**

- A herbivoria diminiu a biomassa dos frutos?

**Predi√ß√µes**

- Os indiv√≠duos que sofreram herbivoria ir√£o produzir frutos com menor biomassa do que os indiv√≠duos sem herbivoria

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   data frame com as indiv√≠duos da esp√©cie de planta (unidade amostral) nas linhas e a biomassa dos frutos (vari√°vel resposta), herbivoria (vari√°vel preditora categ√≥rica) e tamanho da raiz (covari√°vel cont√≠nua) nas colunas

**Checklist**

-   Verificar se o seu data frame est√° com as unidades amostrais nas linhas e vari√°veis preditoras e respostas nas colunas

**An√°lise**

Olhando os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_ancova) 
```

C√≥digos para o c√°lculo da ANCOVA (Figura \@ref(fig:fig-ancova-diag)).

```{r fig-ancova-diag, fig.cap="Gr√°ficos de diagn√≥stico dos res√≠duos da ANCOVA."}
## Gr√°fico
## Ancova
modelo_ancova <- lm(Biomassa ~ Herbivoria * Raiz, data = dados_ancova)

# Verificando as premissas da Ancova
plot_grid(plot_model(modelo_ancova, type = "diag"))
```

As premissas da ANCOVA est√£o adequadas. Vamos olhar os resultados do modelo.

```{r}
## Resultados do modelo
anova(modelo_ancova)
```

Percebam que o resultado da ANCOVA (Pr(\>F) \< 0.001) indica que tanto a herbivoria como o tamanho da raiz (covari√°vel) t√™m efeitos significativos na biomassa dos frutos. Contudo, a intera√ß√£o entre as vari√°veis n√£o foi signigicativa. Vamos usar o Likelihood-ratio test (LRT) para ver se podemos seguir com um modelo mais simples (sem intera√ß√£o).

```{r}
## Criando modelo sem intera√ß√£o
modelo_ancova2 <- lm(Biomassa ~ Herbivoria + Raiz, data = dados_ancova)

## Likelihood-ratio test
lrtest(modelo_ancova, modelo_ancova2)
```

A intera√ß√£o n√£o √© importante, pois P > 0.05. Seguiremos com o modelo mais simples.

Vamos fazer a visualizar os resultados em gr√°fico (Figura \@ref(fig:fig-ancova)).

```{r fig-ancova, fig.cap="Gr√°fico de caixa mostrando o resultado da ANCOVA."}
## Gr√°fico
ggplot(data = dados_ancova, aes(x = Raiz, y = Biomassa, fill = Herbivoria)) + 
    labs(x = "Tamanho da raiz (cm)", y = "Biomassa dos frutos (g)") +
    geom_point(size = 4, shape = 21, alpha = 0.7) +
    scale_colour_manual(values = c("darkorange", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "cyan4"),
                      labels = c("Com herbivoria", "Sem herbivoria")) +
    geom_smooth(aes(color = Herbivoria), method = "lm", show.legend = FALSE) +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Neste exemplo, o tamanho da raiz (covari√°vel) tem uma rela√ß√£o positiva com a biomassa dos frutos. Quanto maior o tamanho da raiz, maior a biomassa dos frutos. Usando a ANCOVA e controlando o efeito da covari√°vel, percebemos que a herbivoria tamb√©m afeta a biomassa dos frutos. Os indiv√≠duos com o mesmo tamanho de raiz que n√£o sofreram herbivoria produziram frutos com maior biomassa do que os indiv√≠duos com herbivoria.

## Generalized Least Squares (GLS)

Em seu artigo cl√°ssico publicado em 1993, Pierre Legendre se pergunta se a autocorrela√ß√£o espacial √© um problema ou um novo paradigma [@legendre_spatial_1993]. Segundo o autor, estudar estruturas espaciais √© tanto uma necessidade, quanto um desafio para pesquisadores da ecologia e conserva√ß√£o que lidam com dados espacialmente distribu√≠dos. Uma vez que todas as vari√°veis tipicamente utilizadas em estudos de biodiversidade (popula√ß√µes, condi√ß√µes clim√°ticas, diversidade) possuem algum tipo de estrutura espacial, √© fundamental compreender os motivos de como incluir esta informa√ß√£o nos modelos anal√≠ticos. De fato, a Primeira Lei da Geografia postula que "todas as coisas est√£o relacionadas com todas as outras, por√©m coisas pr√≥ximas est√£o mais relacionadas do que coisas distantes". Como resultado, os valores observados em uma localidade (e.g., composi√ß√£o de esp√©cies) ser√£o mais afetados pelo conjunto de esp√©cies que ocorre nas localidades vizinhas e, desse modo, alguns pontos de coleta podem n√£o ser estatisticamente independentes. Como vimos anteriormente, um dos pressupostos dos modelos lineares √© a independ√™ncia das unidades amostrais. Assim, a presen√ßa de autocorrela√ß√£o espacial nos res√≠duos viola este pressuposto e, consequentemente, aumenta a taxa de Erro do Tipo I (rejeitar a hip√≥tese nula quando ela √© verdadeira) nos modelos. Uma das solu√ß√µes para incorporar a depend√™ncia espacial dos res√≠duos √© usar o m√©todo de M√≠nimos Quadrados Generalizados (*Generalized Least Squares* - GLS). Diferente dos modelos apresentados anteriormente, este m√©todo ajusta explicitamente modelos heterosced√°sticos e com res√≠duos correlacionados [@pinheiro_mixed-effects_2000]. Para representar a estrutura espacial (e, assim, a depend√™ncia entre as observa√ß√µes) √© necess√°rio incluir vari√°veis espaciais (geralmente coordenadas geogr√°ficas, i.e., vetores bimensionais: *sensu* @pinheiro_mixed-effects_2000) no argumento `corStruct` na fun√ß√£o `gls()` do pacote `nlme`. Este modelo basicamente assume que a estrutura de covari√¢ncia √© uma fun√ß√£o da dist√¢ncia entre as localidades [@littell2006sas]. √â importante ressaltar, todavia, que existem diferentes fun√ß√µes de covari√¢ncia que s√£o discutidas detalhadamente em @littell2006sas. Aqui, iremos nos
concentrar nas seguintes fun√ß√µes.

-   **Esf√©rica**: `corSpher(form=\~lat+long)`
-   **Exponencial**: `corExp(form=\~lat+long)`
-   **Gaussiana**: `corGaus(form=\~lat+long)`
-   **Linear**: `corLin(form=\~lat+long)`
-   **Raz√£o quadr√°tica**: `corRatio(form=\~lat+long)`

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Neste exemplo, utilizamos os dados de riqueza de esp√©cies de √°caros (Oribatidae) em 70 amostras de musgo (g√™nero *Sphagnum*) [@borcard_partialling_1992]. Para cada amostra, al√©m da riqueza de √°caros, os autores registraram a quantidade de √°gua no substrato e as coordenadas geogr√°ficas. Os dados completos est√£o dispon√≠veis no pacote `vegan`.

```{r}
## Calcular a riqueza de esp√©cies em cada comunidade
riqueza <- specnumber(mite) 

## Selecionar a vari√°vel ambiental - quantidade de √°gua no substrato
agua <- mite.env[,2]

## Criar um data.frame com riqueza, quantidade de √°gua no substrato e coordenadas geogr√°ficas
mite_dat <- data.frame(riqueza, agua, coords)
```

**Modelo linear sem incorporar a estrutura espacial**

Vamos inicialmente ajustar um modelo sem incorporar a estrutura espacial (Figura \@ref(fig:fig-lm-esp-diag)).

```{r fig-lm-esp-diag, fig.cap="Gr√°ficos mostrando as premissas da regress√£o linear simples."}
## Modelo
linear_model <- lm(riqueza ~ agua, mite_dat) 

## Res√≠duos
par(mfrow = c(2, 2)) 
plot(linear_model, which = 1:4)

## Resultados do modelo
res_lm <- summary(linear_model)

## Coeficiente de determina√ß√£o e coeficientes
res_lm$adj.r.squared
res_lm$coefficients
```

**Acessando a informa√ß√£o espacial com o GLS**

Como dito, dependendo da estrutura espacial de suas vari√°veis (dependentes, independentes, covari√°veis), o pressuposto de independ√™ncia dos res√≠duos pode ser afetado e, desse modo, o modelo linear convencional ter√° maior chance de Erro do Tipo I. Abaixo, iremos comparar um modelo GLS sem incorporar estrutura espacial (o que √© exatamente igual ao modelo criado acima *Modelo Linear*) com diferentes modelos que utilizam explicitamente res√≠duos correlacionados.

```{r}
## Modelo gls sem estrutura espacial
no_spat_gls <- gls(riqueza ~ agua, mite_dat, method = "REML")
```

Uma maneira de identificar se os res√≠duos do modelo linear apresentam estrutura espacial √© fazendo uma figura chamada **variograma**. O variograma possui tr√™s par√¢metros: i) *nugget* , ii) *range* e iii) *sill* [@fortin_dale_2005]. O *nugget* √© utilizado para quantificar a variabilidade observada nos valores menores (ou seja, em pequenas dist√¢ncias). O *range*, por sua vez, √© usado para identificar a dist√¢ncia m√°xima em que a autocorrela√ß√£o espacial est√° presente (Figura \@ref(fig:fig-variograma), pontos laranjas). Deste modo, os valores posicionados a partir do *range* (Figura \@ref(fig:fig-variograma), pontos verdes) representam pontos n√£o correlacionados [@fortin_dale_2005]. A posi√ß√£o limiar que representa claramente a "pausa" no crescimento da curva (*range*) indica os pontos n√£o correlacionados e representa o *sill* (Figura \@ref(fig:fig-variograma)). No exemplo da Figura \@ref(fig:fig-variograma), o *sill* √© constante. Por√©m, √© poss√≠vel que os valores de *sill* n√£o sejam constantes [@chiles_1999]. Um exemplo √© o "efeito buraco" que √© caracterizado por um ou mais picos (ou vales) no variograma que correspondem ao n√∫mero de valores negativos na covari√¢ncia. Esses valores sugerem que valores altos podem estar rodeados de valores baixos [@chiles_1999]. Por√©m, os detalhamentos desses comportamentos vai al√©m do escopo deste livro.

```{r fig-variograma, fig.cap="Variograma representando a semi-vari√¢ncia *y(h)* em fun√ß√£o do intervalor espacial *h*. Cada ponto representa a dist√¢ncia entre localidades e a linha a varia√ß√£o te√≥rica a fun√ß√£o de covari√¢ncia esf√©rica (veja abaixo). Adaptado de @fortin_dale_2005.", echo=FALSE}
knitr::include_graphics(path = "img/cap07_fig03.png")
```

Abaixo, podemos analisar o variograma para os res√≠duos do modelo GLS ajustado (Figura \@ref(fig:fig-variog-dados)).

```{r fig-variog-dados, fig.cap="Variograma para os res√≠duos do modelo GLS ajustado."}
## Variograma
variog_mod1 <- nlme::Variogram(no_spat_gls, form = ~lat+long, 
                               resType = "normalized") 

## Gr√°fico
plot(variog_mod1)

## √çndice I de Moran

## Primeiro precisamos calcular uma matriz de dist√¢ncias geogr√°ficas entre as comunidades
dat_dist <- pdist(coords) # matriz de dist√¢ncia

Moran.I(x = mite_dat$riqueza, w = dat_dist)
```

O primeiro passo √© utilizar diferentes variogramas te√≥ricos para identificar o melhor modelo que representa a estrutura espacial dos seus dados.

```{r}
## Covari√¢ncia esf√©rica
espher_model <- gls(riqueza ~ agua, mite_dat, 
                    corSpher(form = ~lat+long, nugget = TRUE))

## Covari√¢ncia exponencial
expon_model <- gls(riqueza ~ agua, mite_dat, 
                   corExp(form = ~lat+long, nugget = TRUE))

## Covari√¢ncia Gaussiana
gauss_model <- gls(riqueza ~ agua, mite_dat, 
                   corGaus(form = ~lat+long, nugget = TRUE))

## Covari√¢ncia linear
cor_linear_model <- gls(riqueza ~ agua, mite_dat, 
                        corLin(form = ~lat+long, nugget = TRUE))

## Covari√¢ncia raz√£o quadr√°tica
ratio_model <- gls(riqueza ~ agua, mite_dat, 
                   corRatio(form = ~lat+long, nugget = TRUE))
```

Agora, depois de ajustar o modelo GLS com os  diferentes variogramas √© necess√°rio comparar os modelos para escolher o mais "prov√°vel", utilizando a sele√ß√£o de modelos pelo Crit√©rio de Sele√ß√£o de Akaike (AIC) [@chiles_1999; @burnham2002; @fortin_dale_2005] (Figura \@ref(fig:fig-diag-ratio)). AIC √© um m√©todo estat√≠stico que compara os modelos criados na sua pesquisa e seleciona o melhor entre eles. Diferente do LRT que compara apenas modelos aninhados, o AIC compara modelos com diferentes combina√ß√µes de vari√°veis preditoras. Uma vez que a f√≥rmula do AIC penaliza par√¢metros extras no modelo, se dois modelos explicam igualmente a varia√ß√£o dos dados, o modelo com menos par√¢metros ter√° o menor valor de AIC e ser√° selecionado como o melhor modelo. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
O valor de AIC por si s√≥ n√£o tem significado. Ele precisa ser comparado com outro modelo. Contudo, um modelo s√≥ ser√° considerado superior a outro quando a diferen√ßa entre os seus valores de AIC (i.e, *delta*) forem maiores do que 2. [@burnham2002]
:::

```{r fig-diag-ratio, fig.cap="Gr√°fico dos res√≠duos em rela√ß√£o aos dodos ajustados do modelo GLS Ratio."}
## Sele√ß√£o de modelos
aic_fit <- AIC(no_spat_gls, espher_model, expon_model, gauss_model, cor_linear_model, ratio_model)
aic_fit %>% arrange(AIC)

## Gr√°fico
plot(residuals(ratio_model, type = "normalized") ~ fitted(ratio_model))
```

O variograma ajustado pelo modelo raz√£o quadr√°tica (*ratio_model*) demonstra que o *range* n√£o √© crescente (indicando correla√ß√£o espacial entre localidades pr√≥ximas) e, desse modo, sugere que √© mais apropriado usar o modelo GLS do que um modelo linear desconsiderando a estrutura espacial (Figura \@ref(fig:fig-variog-ratio)).

```{r fig-variog-ratio, fig.cap="Variogramas para os res√≠duos do modelo GLS Normal e Ratio."}
## Varigrama
ratio_variog <- Variogram(ratio_model, form = ~lat+long, resType = "normalized")

## Resumo dos modelos
summary(ratio_model)$tTable 
summary(no_spat_gls)$tTable

## Gr√°ficos
plot(ratio_variog, main = "Variograma como Modelo Ratio")
plot(variog_mod1, main = "Variograma Modelo Normal")
```

**Interpreta√ß√£o dos resultados**

Dessa forma, O valor mais apropriado da estat√≠stica t √© de -4.33 (*ratio_model*) ao inv√©s de -7.78 (*no_spat_gls*). Neste caso, a decis√£o (quantidade de √°gua afetando a riqueza de √°caros) n√£o foi afetada (*P* \< 0.05 nos dois modelos), somente a estat√≠stica do teste.

## Para se aprofundar

-   Recomendamos aos interessados os livros: i) Zar [-@zar_biostatistical_2010] Biostatiscal analysis, ii) Gotelli & Ellison [-@gotelli_primer_2012] A primer of ecological statistics, iii) Quinn & Keough [-@quinn_experimental_2002] Experimental design and data analysis for biologists, iv) Zuur e colabodores [-@zuur_analysing_2007] Analysing Ecological Data e v) Touchon [-@touchon_applied_2021] Applied statistics with R: a practical guide for the life sciences.

## Exerc√≠cios

**7.1**
Avalie se os indiv√≠duos machos de uma esp√©cie de aranha s√£o maiores do que as f√™meas. Qual a sua interpreta√ß√£o sobre o dimorfismo sexual nesta esp√©cie? Fa√ßa um gr√°fico boxplot usando tamb√©m a fun√ß√£o `geom_jitter()`. Use os dados `Cap7_exercicio1` dispon√≠vel no pacote `ecodados`.

**7.2**
Avalie se o n√∫mero de polinizadores visitando uma determinada esp√©cie de planta √© dependente da presen√ßa ou aus√™ncia de predadores. A mesma planta, em tempos diferentes, foi utilizada como unidade amostral para os tratamentos com e sem predadores. Qual a sua interpreta√ß√£o sobre os resultados? Fa√ßa um gr√°fico boxplot ligando os resultados da mesma planta com e sem a presen√ßa do predador. Use os dados `Cap7_exercicio2` dispon√≠vel no pacote `ecodados`.

**7.3**
Avalie se existe correla√ß√£o entre o n√∫mero de filhotes nos ninhos de uma esp√©cie de ave com o tamanho do fragmento florestal. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico mostrando a rela√ß√£o entre as vari√°veis. Use os dados `Cap7_exercicio3` dispon√≠vel no pacote `ecodados`.

**7.4**
Avalie se a rela√ß√£o entre o tamanho da √°rea de diferentes ilhas e a riqueza de esp√©cies de lagartos. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico mostrando a  rela√ß√£o predita pelo modelo. Use os dados `Cap7_exercicio4` dispon√≠vel no pacote `ecodados`.

**7.5**
Avalie se existe rela√ß√£o entre a abund√¢ncia de uma esp√©cie de roedor com o tamanho da √°rea dos fragmentos florestais e/ou a altitude. Fa√ßa uma regress√£o m√∫ltipla. Em seguida, crie diferentes modelos e selecione o mais parcimonioso com base no valores do teste de *Likelihood-ratio test* (LRT) e *Akaike information criterion* (AIC). Qual a sua interpreta√ß√£o? Use os dados `Cap7_exercicio5` dispon√≠vel no pacote `ecodados`.

**7.6**
Avalie se o local que machos territoriais ocupam (pasto, cana, floresta) influ√™ncia no peso dos indiv√≠duos. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico com os resultados. Use os dados `Cap7_exercicio6` dispon√≠vel no pacote `ecodados`.

**7.7**
Avalie se a abund√¢ncia de formigas est√° relacionada com o fato das dom√°cias estarem abertas ou fechadas e com a idade das dom√°cias. Verifique a intera√ß√£o entre os fatores. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico com os resultados. Use os dados `Cap7_exercicio7` dispon√≠vel no pacote `ecodados`.

**7.8**
Avalie se o n√∫mero de parasitas est√° relacionado com o tamanho corporal de f√™meas de uma esp√©cie de ave. Al√©m disso, use a idade das aves como uma co-vari√°vel explicando o n√∫mero de parasitas. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico com os resultados. Use os dados `Cap7_exercicio8` dispon√≠vel no pacote `ecodados`.

**7.9**
Avalie se a presen√ßa ou aus√™ncia de predadores afeta a riqueza de macroinvertebrados em 10 lagos. Os tratamentos dos predadores foram realizados nos mesmos lagos. Qual a sua interpreta√ß√£o dos resultados? Fa√ßa um gr√°fico com os resultados.Use os dados `Cap7_exercicio9` dispon√≠vel no pacote `ecodados`.

**7.10**
Avalie se a precipita√ß√£o anual afeta a riqueza de esp√©cies de anuros em 44 localidades na Mata Atl√¢ntica. Use as coordenadas geogr√°ficas para controlar o efeito da autocorrela√ß√£o espacial. Qual a sua interpreta√ß√£o dos resultados das an√°lises com e sem levar em considera√ß√£o a autocorrela√ß√£o espacial? Use os dados `anuros_ambientais` dispon√≠vel no pacote `ecodados`.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-7---modelos-lineares.html).

<!--chapter:end:07_modelos_lineares.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Modelos Lineares Generalizados {#cap8}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
library(ecodados)
library(visdat)
library(tidyverse)
library(lattice)
library(RVAideMemoire)
library(DHARMa)
library(performance)
library(MuMIn)
library(piecewiseSEM)
library(MASS)
library(ggExtra)
library(Rmisc)
library(emmeans) 
library(sjPlot)
library(bbmle)
library(glmmTMB)
library(ordinal)
library(car)

## Dados
lagartos <- ecodados::lagartos
parasitas <- ecodados::parasitas
fish <- ecodados::fish
fragmentos <- ecodados::fragmentos
uv_cells <- ecodados::uv_cells
```

## Introdu√ß√£o

No cap√≠tulo \@ref(cap7), descrevemos sobre os modelos lineares (tamb√©m chamados de Modelos Lineares Gerais) que podem ser descritos pelo mesmo modelo matem√°tico de uma equa√ß√£o da reta do tipo::

$$Y = \beta_0 + \beta_{1}X_i + \epsilon_i$$

Nesse tipo de estrutura, o que difere uma regress√£o linear de uma an√°lise de vari√¢ncia √© a natureza do elemento x~i~, vari√°vel cont√≠nua para a regress√£o lineare e vari√°vel categ√≥rica no caso da ANOVA (que √© codificada numa matriz *design* para desenhos mais complexos). Nesse sentido, o que todos esses m√©todos t√™m em comum √© a vari√°vel resposta Y que √© um vetor num√©rico cont√≠nuo. Outro elemento em comum desses m√©todos √© a distribui√ß√£o de frequ√™ncia do erro. Se quiser mais detalhes como sobre modelos lineares podem ser escritos na forma de matrizes, consulte a introdu√ß√£o de [@fox_ecological_2015]. Todos os modelos lineares assumem que a distribui√ß√£o do erro seja Gaussiana (ou Normal). Isso de certa forma limita o tipo de dado que pode ser usado como vari√°vel resposta por estas an√°lises. Por exemplo, dados de contagem (e.g., riqueza e/ou abund√¢ncia de esp√©cies), frequ√™ncia (e.g., frequ√™ncia de ocorr√™ncia, porcentagem de cobertura vegetal), incid√™ncia (e.g., presen√ßa ou aus√™ncia de uma esp√©cie) ou propor√ß√£o (e.g., n√∫meros de animais infectados a cada 1000 animais) n√£o s√£o adequados para serem utilizados como vari√°veis resposta em modelos lineares. Uma pr√°tica comum quando nossos dados n√£o s√£o Normais √© transformar por logar√≠tmo ou raiz quadrada. No entanto, para dados de contagem isso n√£o √© recomendado - veja O'Hara & Kotze [-@ohara2010], Ives [-@ives2015] e Warton [-@warton2018] para mais detalhes.

Nestes casos, devemos recorrer a um conjunto de modelos chamados Modelos Lineares Generalizados (GLM). Nestes modelos, o usu√°rio especifica a distribui√ß√£o de frequ√™ncia que deseja utilizar para modelar a vari√°vel resposta. Esta distribui√ß√£o de frequ√™ncia deve pertencer √† fam√≠lia exponencial, que inclui a distribui√ß√£o de Poisson, Gaussiana, binomial, binomial negativa, Gamma, Bernoulli e Beta. Ainda √© poss√≠vel utilizar Cumulative Link Models para modelar dados ordinais (fatores cuja ordem dos elementos importa, tais como muito baixo, baixo, alto e muito alto). Abaixo vamos ver um pouco sobre como um GLM funciona e exemplos com cada uma destas distribui√ß√µes.

## Como um GLM funciona?

Diferentemente do modelo linear, um GLM estima os par√¢metros por meio de M√°xima Verossimilhan√ßa (ML) ao inv√©s dos M√≠nimos Quadrados Comuns, tamb√©m chamados de M√≠nimos Quadrados Ordin√°rios (OLS).

Portanto, um GLM relaciona a **distribui√ß√£o da vari√°vel resposta** aos **preditores lineares** por meio de uma **fun√ß√£o de liga√ß√£o**. Por exemplo, no caso da distribui√ß√£o de Poisson, usa-se uma liga√ß√£o logar√≠tmica (tamb√©m chamada de log link) que garante que o valores ajustados s√£o sempre n√£o negativos. Portanto, um GLM √© composto por esses tr√™s componentes: i) fun√ß√£o de distribui√ß√£o, ii) preditor linear e iii) fun√ß√£o de liga√ß√£o. A fun√ß√£o de distribui√ß√£o √© uma hip√≥tese sobre a distribui√ß√£o da vari√°vel resposta Y~i~. Isso tamb√©m define a m√©dia e a vari√¢ncia de Y~i~. J√° a fun√ß√£o de liga√ß√£o define a rela√ß√£o entre o valor m√©dio de Y~i~ e da parte sistem√°tica. Esta √© tamb√©m chamada de liga√ß√£o entre a m√©dia e a parte sistem√°tica do modelo. Existem tr√™s tipos de fun√ß√£o de liga√ß√£o:

- **Identity link**, que √© definido por `g(¬µ) = Œº`, e modela a m√©dia ou valor esperado de Y. Usado em modelos lineares padr√£o

- **Log link**, que √© `g(Œº) = log(Œº)`, e modela o log da m√©dia. √â usado para dados de contagem (que n√£o podem assumir valores negativos) em modelos log-linear

- **Logit link**, que √© `g(Œº) = log[Œº/(1-Œº)]`, e √© usado para dados bin√°rios e regress√£o log√≠stica

Logo, um modelo linear pode ser visto como um caso particular de um GLM em que utiliza distribui√ß√£o Gaussiana, com *identity link*.

## Como escolher a distribui√ß√£o correta para seus dados?

### Para dados cont√≠nuos

Se Y √© uma vari√°vel cont√≠nua, a sua distribui√ß√£o de probabilidade deve ser normal. Nesses casos as distribui√ß√µes recomendadas s√£o a **Gaussiana (Normal) ou Gamma**. Para essas distribui√ß√µes, o par√¢metro de dispers√£o √© estimado separadamente da m√©dia e √© √†s vezes, chamado de *nuisance parameter*. Uma particularidade da distribui√ß√£o Gamma √© que ela s√≥ aceita valores cont√≠nuos positivos.

### Para dados de contagem

Se Y √© bin√°rio (e.g., vivo ou morto), a distribui√ß√£o de probabilidade deve ser **binomial**.

Se Y √© uma contagem (e.g., abund√¢ncia ou riqueza de esp√©cies), ent√£o a distribui√ß√£o de probabilidade deve ser **Poisson ou binomial negativa**. Existem tamb√©m corre√ß√µes dessas distribui√ß√µes quando apresentam sobredispers√£o (*overdispersion*), tais como quasi-Poisson ou quasi-Negative binomial. Falaremos delas no momento certo.

Para distribui√ß√µes tais como binomial e Poisson, a vari√¢ncia deve ser igual √† media e o par√¢metro de dispers√£o √© sempre 1. Na maioria dos dados ecol√≥gicos esse pressuposto n√£o √© cumprido, veremos estrat√©gias para lidar com isso logo √† frente.

As fun√ß√µes `Ord_plot()` e `goodfit()` do pacote `vcd` podem auxiliar na escolha da distribui√ß√£o para dados de contagem.

## Dados de contagem: a distribui√ß√£o de Poisson

Para casos em que estamos interessados em quantificar uma vari√°vel discreta, ou seja, uma vari√°vel positiva, representada sempre por n√∫meros inteiros, contendo um n√∫mero finito de possibilidades, devemos utilizar a **distribui√ß√£o de Poisson**. Esta distribui√ß√£o √© peculiar por ser descrita apenas por um par√¢metro livre ($\lambda$). Isso quer dizer que tanto a m√©dia quanto a vari√¢ncia dos dados s√£o descritos por um √∫nico par√¢metro, o que implica em dizer que a m√©dia e a vari√¢ncia t√™m de ser iguais.

Vamos ver um exemplo com dados reais.

**Exemplo 1**

**Explica√ß√£o dos dados**

Neste exemplo, iremos utilizar dados de riqueza de anf√≠bios anuros coletados em 40 po√ßas, a√ßudes e brejos ao redor de fragmentos florestais no Noroeste Paulista [@prado2014]. Os autores mediram seis vari√°veis em escala local e outras tr√™s em escala de paisagem.

**Pergunta**

A dist√¢ncia linear para o corpo d'√°gua mais pr√≥ximo influencia a abund√¢ncia total de esp√©cies de anuros?

**Predi√ß√µes**

Corpos d'√°gua mais conectados permitem que indiv√≠duos dispersem entre eles com maior facilidade, suportando melhor din√¢micas de metapopula√ß√µes. Portanto, espero que po√ßas que estejam mais conectadas entre si tenham maior riqueza total de anuros.

**Vari√°veis**

- Vari√°vel reposta: riqueza de anuros em 40 po√ßas
- Vari√°vel preditora: dist√¢ncia da po√ßa focal para a mais pr√≥xima na escala da paisagem

**Checklist**

- Verificar se o seu data frame est√° com as unidades amostrais nas linhas (neste caso po√ßas) e vari√°veis nas colunas

Antes de come√ßar com a an√°lise, vamos primeiro explorar os dados.

```{r out.width="49%"}
## Explorar os dados
glimpse(fragmentos)
```

Percebam que o data frame cont√©m 40 colunas. Neste conjunto de dados as vari√°veis preditoras j√° est√£o padronizadas com m√©dia 0 e desvio padr√£o 1. As vari√°veis com "2" indicam vari√°veis quadr√°ticas (podem ser usadas para se testar rela√ß√µes n√£o lineares). Tamb√©m temos a riqueza observada e a estimada (`Riqueza_HB`) e as coordenadas geogr√°ficas (X e Y). Vamos agora explorar os dados e ver como √© a rela√ß√£o entre riqueza e dist√¢ncia para a po√ßa mais pr√≥xima. Sempre √© recomendado visualizar os dados antes de efetivamente os modelar para se ter uma id√©ia da rela√ß√£o entre as vari√°veis (Figura \@ref(fig:fig-mod-poi-pre)).

```{r fig-mod-poi-pre, fig.cap="Gr√°fico pareado para explorar as vari√°veis."}
## Gr√°fico
ggplot(fragmentos, aes(dfrag, Riqueza_obs)) +
    geom_point(size = 4, alpha = 0.7) +
    geom_smooth(method = "lm") +
     labs(x = "Dist√¢ncia para o fragmento mais pr√≥ximo", 
         y = "Riqueza observada") +
    tema_livro()
```

Aqui vemos que h√° de fato uma rela√ß√£o linear positiva entre as duas vari√°veis.

- A partir de agora vamos sempre usar uma mesma estrutura para realizar nossos exerc√≠cios de modelagem:

1.  Primeiro vamos especificar o modelo
2.  Depois realizar a diagnose
3.  Por √∫ltimo realizar infer√™ncia a partir do nosso modelo

**Modelagem**

O primeiro argumento da fun√ß√£o `glm()` √© uma f√≥rmula, em que na parte esquerda temos a vari√°vel resposta seguida do s√≠mbolo `~` (l√™-se: modelado em fun√ß√£o de) seguido pelas vari√°veis preditoras. Aqui podemos usar uma ou mais vari√°veis e testar o seu efeito aditivo (usando o sinal de +) ou a intera√ß√£o entre elas (usando o sinal de \*). Um bom resumo sobre como especificar o seu modelo pode ser encontrada [aqui neste blog](https://ridiculas.wordpress.com/2012/07/23/semantica-para-descrever-modelos/). Aqui optamos por um modelo bem simples modelando a riqueza de anf√≠bios apenas em fun√ß√£o da dist√¢ncia para o fragmento mais pr√≥ximo.

```{r}
## Modelo
mod_pois <- glm(Riqueza_obs ~ dfrag, family = poisson(link = "log"), data = fragmentos)
```

Assim como modelos lineares que vimos no Cap√≠tulo \@ref(cap7), GLMs com distribui√ß√£o de Poisson requerem que se realizem testes de pressupostos de normalidade e homogeneidade de vari√¢ncia dos res√≠duos, assim como sobredispers√£o e infla√ß√£o de zeros.

**Diagnose b√°sica dos res√≠duos do modelo**

Iremos realizar tr√™s diagnoses b√°sicas dos GLMs, avaliando diferentes aspectos do modelo:

1.  Homogeneidade da vari√¢ncia e normalidade dos res√≠duos
2.  Sobredispers√£o (*Overdispersion*)
3.  Infla√ß√£o de zeros (*Zero-inflation*)

Vamos come√ßar avaliando as homogeneidade da vari√¢ncia e normalidade dos res√≠duos (Figura \@ref(fig:fig-mod-poi-diag-bas)).

```{r fig-mod-poi-diag-bas, fig.cap="Diagnose b√°sica dos res√≠duos do modelo GLM Poisson."}
## Diagnose b√°sica
par(mfrow = c(2, 2))
plot(mod_pois) 
```

Vemos que as linhas vermelhas (que indicam a tend√™ncia dos dados) est√£o praticamente retas seguindo a linha pontilhada, sugerindo que existe homogeneidade de vari√¢ncia dos res√≠duos. Vemos tamb√©m que nos quatro plots alguns dados, 1, 7 e 30 (referem-se √†s linhas do data frame) aparecem identificados, pois apresentam ligeiro desvio da normalidade e est√£o distantes da m√©dia. No entanto, n√£o √© algo para nos preocuparmos, pois n√£o s√£o valores muito extremos. Portanto, a diagnose b√°sica indicou que o modelo com Poisson parece ser adequado para modelar estes dados, ao menos em termos de homogeneidade de vari√¢ncia.

**Diagnose avan√ßada dos res√≠duos do modelo**

Alguns pacotes permitem calcular outros aspectos do modelo que facilitam a diagnose, ou seja, se podemos de fato confiar nos par√¢metros estimados por eles, incluindo valores de signific√¢ncia. Um pressuposto importante dos modelos de contagem (incluindo Poisson) √© a sobredispers√£o (*overdispersion*).

Vejamos como o pacote `DHARMa` funciona (Figura \@ref(fig:fig-mod-poi-diag-avan)).

```{r fig-mod-poi-diag-avan, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM Poisson."}
## Diagnose avan√ßada
simulationOutput <- simulateResiduals(fittedModel = mod_pois, plot = TRUE)
```

O plot claramente indica que h√° problema com *overdispersion*, mas n√£o em termos de desvios de normalidade (KS test) ou *outlier*, j√° que apenas o primeiro foi significativo (aparece em vermelho).

**Detectando e lidando com overdispersion**

O que √© sobredispers√£o (*overdispersion*)? Ela ocorre quando a vari√¢ncia observada √© muito maior do que aquela predita pelo modelo. Para modelos que utilizam a distribui√ß√£o de Poisson, isso ocorre quando a vari√¢ncia aumenta com a m√©dia. Lembre-se de que esta distribui√ß√£o tem apenas um √∫nico par√¢metro para descrever tanto a m√©dia quanto a vari√¢ncia ($\lambda$). Portanto, a vari√¢ncia tem de ser igual √† m√©dia. No entanto, se a vari√¢ncia nos dados observados for muito maior do que a m√©dia, dizemos que h√° sobredispers√£o nos dados.

Existem duas formas de diagnosticar *overdispersion* que est√£o implementadas na maioria dos pacotes. Aqui vamos demonstr√°-las usando as fun√ß√µes `check_overdispersion()` e `testDispersion()` dispon√≠veis nos pacotes `performance` e `DHARMa`, respectivamente.

A fun√ß√£o `testDispersion()` do `DHARMa` utiliza um m√©todo de aleatoriza√ß√£o dos res√≠duos para determinar se h√° *overdispersion* nos dados, cuja vantagem √© que aborda diretamente a varia√ß√£o nos dados, ao inv√©s de medir o ajuste do modelo em si, com outros testes (Figura \@ref(fig:fig-mod-poi-over-dharma)).

```{r fig-mod-poi-over-dharma, fig.cap="Teste de overdispersion do pacote `DHARMa`."}
## Overdispersion
par(mfrow = c(1, 1))
testDispersion(mod_pois) # modelo tem overdispersion
```

Aqui temos um gr√°fico e o resultado novamente do teste de *overdispersion* (que j√° aparecia no gr√°fico anterior) mostrando que de fato h√° *overdispersion*: perceba que o valor de *P* √© significativo. O gr√°fico nos mostra em cinza a distribui√ß√£o dos res√≠duos aleatorizados e a linha vermelha o valor observado da estat√≠stica. J√° que a linha est√° bem √† direita da distribui√ß√£o, isso indica *overdispersion*, se estivese √† esquerda seria o caso de *underdispersion*.

Agora vamos utilizar a fun√ß√£o `check_overdisperion()` que utiliza uma distribui√ß√£o qui-quadradado e o valor de *dispersion ratio* para testar a presen√ßa de *overdispersion* no modelo. Esse teste tamb√©m pode ser feito com a fun√ß√£o acima ao se especificar o argumento `type="PearsonChisq"`.

```{r}
## Testar a presen√ßa de overdispersion
check_overdispersion(mod_pois) # modelo tem overdispersion
```

Quando este resultado √© significativo, como vimos na √∫ltima linha acima, isso indica que h√° *overdispersion*.

Usando a fun√ß√£o `summary()` podemos ter um resumo e descri√ß√£o dos par√¢metros do modelo.

```{r}
## Resumo do modelo
summary(mod_pois)

## Dispersion parameter
deviance(mod_pois) / df.residual(mod_pois)
```

Na parte de baixo do output da fun√ß√£o `summary()` tamb√©m podemos calcular o *dispersion parameter* dividindo o *residual deviance* pelos graus de liberdade dos res√≠duos. Esta √© outra maneira f√°cil e r√°pida de detectar *overdispersion*. Neste exemplo, temos que *Dispersion parameter* = `r (chat <- deviance(mod_pois) / df.residual(mod_pois))`. Quando esse valor √© pr√≥ximo de 1, isso sugere que n√£o h√° *overdispersion*. No entanto, se ele for maior que 1.5, isso sugere que o modelo sofre de *overdispersion* e que devemos usar outra distribui√ß√£o, tal como a distribui√ß√£o **binomial negativa**, por exemplo.

Al√©m disso, uma outra forma de diagnosticar o modelo √© calcular os res√≠duos de Pearson (res√≠duos normalizados), que √© basicamente a raiz quadrada da vari√¢ncia da vari√°vel resposta.

**Infla√ß√£o de zeros**

Qualquer das formas mostradas acima de diagnosticar *overdispersion* pode ser usada na maioria das vezes, com exce√ß√£o de dados com muitos zeros (pouca vari√¢ncia). Por isso, devemos tamb√©m testar se o nosso modelo sofre de infla√ß√£o de zeros. Vejamos como isso funciona usando as fun√ß√µes `check_zeroinflation()` no pacote `performanace` e `testZeroInflation()` no pacote `DHARMa` (Figura \@ref(fig:fig-mod-poi-over-zero)).

```{r fig-mod-poi-over-zero, fig.cap="Teste de infla√ß√£o de zeros do pacote `DHARMa`."}
## Infla√ß√£o de zeros - performanace
check_zeroinflation(mod_pois) # para diagnosticar se o modelo sofre de zero inflation

## Infla√ß√£o de zeros - DHARMa
testZeroInflation(mod_pois) # para testar se existe zero inflation
```

Tanto a fun√ß√£o do `DHARMa` quanto do `performance` conseguiram detectar que o modelo tem problemas com *overdispersion*, mas isso n√£o √© causado pelo excesso de zeros. Como j√° dissemos acima, no caso da distribui√ß√£o Poisson, tanto a m√©dia quanto a vari√¢ncia s√£o modeladas pelo mesmo par√¢metro ($\lambda$). Isso faz com que esta distribui√ß√£o n√£o seja muito √∫til para modelar dados de contagem em que haja muita vari√¢ncia em torno da m√©dia. Esse infelizmente √© o caso da grande maioria dos dados ecol√≥gicos.

Por estes motivos, n√£o podemos fazer infer√™ncia com este modelo porque os par√¢metros estimados n√£o s√£o confi√°veis. Mas vejamos como seria feita essa infer√™ncia *caso este modelo fosse adequado*.

**Infer√™ncia**

Aqui iremos apresentar v√°rias fun√ß√µes para calcular o coeficiente de determina√ß√£o (R^2^). No caso de GLM(M)s, n√£o h√° um consenso sobre como se calcula este coeficiente, havendo v√°rias propostas que utilizam maneiras diferentes de estimar a homogeneidade de vari√¢ncia e covari√¢ncia entre observa√ß√µes dos res√≠duos, veja [@nakagawa2017] e [@ives2015] para maiores detalhes, assim como o *help* das respectivas fun√ß√µes.

```{r}
## Coeficientes estimados pelo modelo
summary(mod_pois)

## Calculando o R2 do modelo
r.squaredGLMM(mod_pois)
rsquared(mod_pois)
r2(mod_pois)
```

Podemos ver que os valores de R^2^ s√£o bem baixos (em torno de 4 - 5%), independente do m√©todo que usamos pra calcul√°-lo.

**Plot do modelo predito**

Vamos realizar a visualiza√ß√£o do ajusto do modelo Poisson (Figura \@ref(fig:fig-mod-poi-model)).

```{r fig-mod-poi-model, fig.cap="Gr√°fico do GLM Poisson."}
a1 <- ggplot(fragmentos, aes(dfrag, Riqueza_obs)) +
    geom_point(cex = 4,alpha = 0.7) +
    geom_smooth(method = "glm", formula = y~x, 
                method.args = list(family = "poisson"), se = TRUE) +
    labs(x = "Dist√¢ncia para o fragmento mais pr√≥ximo", 
         y = "Riqueza observada") +
    tema_livro()

ggMarginal(a1, fill = "red")
```

**Interpreta√ß√£o dos resultados**

Aqui vemos que h√° uma leve tend√™ncia na rela√ß√£o positiva entre dist√¢ncia para o fragmento mais pr√≥ximo e a riqueza de anf√≠bios observada. No entanto, h√° uma grande dispers√£o nos dados ao redor da reta do modelo, fazendo com que a rela√ß√£o n√£o seja de fato significativa e tenhamos um R^2^ bem baixo. Caso pud√©ssemos confiar nos par√¢metros deste modelo, poder√≠amos dizer que existe uma leve tend√™ncia a um aumento da riqueza observada de anf√≠bios anuros √† medida que aumenta a dist√¢ncia da po√ßa para o fragmento mais pr√≥ximo. 


### O que causa a *overdispersion*?

Existem dois conjuntos de causas: aparente ou real. 

As causas aparentes s√£o geradas pela m√° especifica√ß√£o do modelo, tais como:

1. n√£o inclus√£o de covari√°veis ou intera√ß√µes no modelo
2. presen√ßa de *outliers* na vari√°vel resposta
3. efeitos n√£o lineares da covari√°vel (X2, X3...)
4. escolha errada da fun√ß√£o de liga√ß√£o (*link function*)

As causas reais incluem:

1.  vari√¢ncia maior que a m√©dia
2.  muitos zeros
3.  agrega√ß√£o de observa√ß√µes
4.  correla√ß√£o entre observa√ß√µes (n√£o independ√™ncia)

### O que fazer se seu modelo tiver *overdispersion*?

Depois de tentar corrigir poss√≠veis m√°s especifica√ß√µes, como as listadas acima, existem duas alternativas:

1.  usar outra distribui√ß√£o, tal como binomial negativa, caso o *dispersion parameter* seja maior que 15 ou 20
2.  Usar um modelo com corre√ß√£o de erro da sobredispers√£o, caso 1.5 \< *dispersion* \> 15

Geralmente, dados de contagem em estudos ecol√≥gicos n√£o seguem uma distribui√ß√£o Poisson, pois h√° muita dispers√£o (vari√¢ncia) nos dados. Logo, o pressuposto da distribui√ß√£o Poisson, i.e., de que a m√©dia e vari√¢ncia s√£o descritas por um mesmo par√¢metro ($\lambda$) √© quebrado.

Como vimos, *overdispersion* √© um problema comum ao analisar dados ecol√≥gicos e deve necessariamente ser diagnosticado no modelo. Uma maneira de lidar com esse tipo de problema √© utilizar uma outra distribui√ß√£o diferente da Poisson. A binomial negativa pode ser entendida como uma mistura da distibui√ß√£o Poisson e Gamma, ou seja, ela aceita dados de contagem que sejam positivos, mas sem zero. A grande vantagem desta distribui√ß√£o √© que, diferentemente da Poisson, ela tem um par√¢metro para modelar a m√©dia ($\lambda$) e outro para modelar a vari√¢ncia (*k*). Logo, ela permite modelar dados em que a m√©dia √© diferente da vari√¢ncia. Vejamos um exemplo.

Aqui vamos continuar com estes dados para ver como o modelo se comporta com essa nova distribui√ß√£o especificada. Para isso vamos utilizar a fun√ß√£o `glm.nb` do pacote `MASS`.

**Modelagem**

```{r}
## Ajuste do modelo
mod_nb <- glm.nb(Riqueza_obs ~ dfrag, data = fragmentos)
```

**Diagnose res√≠duos**

Assim como fizemos com o modelo com Poisson, vamos agora diagnosticar os res√≠duos (Figura \@ref(fig:fig-mod-nb-diag-bas)).

```{r fig-mod-nb-diag-bas, fig.cap="Diagnose b√°sica dos res√≠duos do modelo GLM binomial Negativo."}
## Diagnose
par(mfrow = c(2, 2))
plot(mod_nb)
par(mfrow = c(1, 1))
(chat <- deviance(mod_nb) / df.residual(mod_nb)) # DISPERSION PARAMETER
```

Compare estes gr√°ficos (Figura \@ref(fig:fig-mod-nb-diag-bas)) com os do modelo anterior com distribui√ß√£o Poisson (Figura \@ref(fig:fig-mod-poi-diag-bas)). Eles s√£o praticamente id√™nticos, ou seja, o modelo com Poisson j√° tinha homogeneidade de vari√¢ncia e n√£o tinha problemas com normalidade dos res√≠duos. Agora vejamos se o problema com *overdispersion* foi resolvido (Figura \@ref(fig:fig-mod-bn-diag-avan)).

```{r fig-mod-bn-diag-avan, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM binomial Negativo."}
## Diagnose avan√ßada
simulationOutput <- simulateResiduals(fittedModel = mod_nb, plot = TRUE)
```

Na diagnose do modelo pelo `DHARMa`, vemos que bastou mudar a distribui√ß√£o de probabilidade que o problema de *overdispersion* foi resolvido (nenhum teste foi significativo no quadro da esquerda). Como j√° sab√≠amos, n√£o h√° problemas com homogeneidade de vari√¢ncia (plot da direita mostrando a tend√™ncia entre o predito e res√≠duos pra cada quantil), nem de *outliers*. O *dispersion parameter* √© mais pr√≥ximo de 1 do que no modelo com Poisson. Agora sim podemos levar em conta o R^2^.

**Infer√™ncia**

```{r}
## Coeficiente de determina√ß√£o
rsquared(mod_nb)
```

Mas esse valor parece ser um pouco menor do que anteriormente. Perceba que aqui utilizamos somente uma das fun√ß√µes apresentadas anteriormente, j√° que se trata de um modelo GLM com binomial negativa, calculamos o R^2^ pelo m√©todo de Nagelkerke.

Usando a fun√ß√£o `summary()` podemos ter um resumo e descri√ß√£o dos par√¢metros do modelo.

```{r message=FALSE, warning=FALSE}
## Coeficientes estimados pelo modelo
summary(mod_nb)
```

**Interpreta√ß√£o dos resultados**

Aqui vemos que a interpreta√ß√£o do resultado em termos de valor de _P_ n√£o mudou, ou seja, a dist√¢ncia para o fragmento mais pr√≥ximo n√£o foi significativo. Mas vejam que o coeficiente (slope) mudou um pouco, antes era 0.0718 (SE=0.0507) e com binomial negativa passa a ser 0.07248 (SE=0.06571).


**Plot do modelo predito**

Vamos realizar a visualiza√ß√£o do ajusto do modelo binomial Negativo (Figura \@ref(fig:fig-mod-nb-model)).

```{r fig-mod-nb-model, fig.cap="Gr√°fico do GLM binomial Negativo."}
## Gr√°fico
ggplot(fragmentos, aes(dfrag, Riqueza_obs)) +
    geom_point(size = 4, alpha = 0.7) +
    geom_smooth(method = "glm.nb", formula = y~x, se = TRUE) +
    labs(x = "Dist√¢ncia para o fragmento mais pr√≥ximo", 
         y = "Riqueza observada") +
    tema_livro()
```

Aqui vemos que a reta predita pelo modelo √© muito similar ao que tivemos com o modelo Poisson. No entanto, agora que sabemos que este modelo com binomial negativa foi corretamente especificado e podemos confiar nos par√¢metros estimados.

## Dados de contagem: modelos quasi-likelihood

Como dissemos acima, uma outra alternativa para ajustar modelos GLM a dados de contagem s√£o os chamados "quasi-likelihood", tais como quasi-Poisson e quasi-binomial. Dependendo do valor do *dispersion parameter*, pode ser √∫til escolher este tipo de modelo. No entanto, eles v√™m com uma desvantagem: n√£o √© poss√≠vel calcular o valor de *Akaike Information Criterion* (AIC) porque estes modelos n√£o retornam um valor de *likelihood* (verosimilhan√ßa). Este par√¢metro √© comumente utilizado em abordagens estat√≠sticas de teoria da informa√ß√£o para selecionar o melhor modelo que se ajusta aos dados. Neste caso, precisamos utilizar outras fun√ß√µes dispon√≠veis nos pacotes `MuMIn`, `AICcmodavg` e `bbmle` para calcular o QAIC. Para mais detalhes sobre esses modelos, veja o vignette sobre o assunto do pacote `bbmle`.

**An√°lise**

Aqui vamos apenas exemplificar como um modelo com distribui√ß√£o quasi-poisson pode ser especificado.

```{r}
## Modelo
mod_quasipois <- glm(Riqueza_obs ~ dfrag, family = quasipoisson(link = "log"), data = fragmentos)
```

**Diagnose dos res√≠duos**

A fun√ß√£o `resid` n√£o leva em conta a sobredispers√£o e temos de calcular manualmente o par√¢metro de dispers√£o e inclui-lo no plot. Portanto, n√£o podemos realizar a diagnose de modelos quasi-Poisson apenas com a fun√ß√£o `plot` como faz√≠amos at√© ent√£o. Ent√£o, calculamos primeiramente os res√≠duos de Pearson e depois dividindo-o pela raiz quadrada do par√¢metro de dispers√£o (Figura \@ref(fig:fig-mod-quasi-poi-diag)).

```{r fig-mod-quasi-poi-diag, fig.cap="Diagnose dos res√≠duos do modelo GLM Quasi-Poisson."}
## Diagnose dos res√≠duos
EP <- resid(mod_quasipois, type = "pearson")
ED <- resid(mod_quasipois, type = "deviance")
mu <- predict(mod_quasipois, type = "response")
E <- fragmentos$Riqueza_obs - mu
EP2 <- E / sqrt(1.65662 * mu) # dispersion parameter da quasipoisson
op <- par(mfrow = c(2, 2))
plot(x = mu, y = E, main = "Response residuals")
plot(x = mu, y = EP, main = "Pearson residuals")
plot(x = mu, y = EP2, main = "Pearson residuals scaled")
plot(x = mu, y = ED, main = "Deviance residuals")
par(op)
par(mfrow = c(1, 1))
```

Aqui vemos que n√£o existe um padr√£o claro nos res√≠duos, muito similar ao que t√≠nhamos anteriormente. Devido √†s limita√ß√µes de distribui√ß√µes "quasi" e dado que j√° temos um modelo adequado com binomial negativa, sugerimos interpretar apenas o modelo anterior com binomial negativa.

## Dados de contagem: a distribui√ß√£o binomial

Quando temos dados de propor√ß√£o (e.g., n√∫mero de doentes por 1000 habitantes) ou incid√™ncia (i.e., presen√ßa ou aus√™ncia), a distribui√ß√£o mais adequada para modelar os dados √© a distribui√ß√£o binomial. No entanto, temos que especificar o modelo de acordo com o tipo dos dados no argumento `formula`. Vejamos dois exemplos.

### An√°lise com dados de propor√ß√£o

Neste exemplo, vamos ver como podemos modelar a propor√ß√£o de c√©lulas sangu√≠neas em fun√ß√£o do tipo de tratamento.

**Explica√ß√£o dos dados**

Este conjunto de dados foi coletado por [@Franco-Belussi2018a]. Os autores utilizaram um desenho experimental t√≠pico de uma 2x5 ANOVA fatorial (ou *two-way* ANOVA) em que temos dois tratamentos (fatores): pigmenta√ß√£o do girino com dois n√≠veis (Yes e No) e Tempo de exposi√ß√£o com cinco n√≠veis (controle sem UV, 6 h, 12 h, 18 h e 24 h de exposi√ß√£o √† UV).

**Pergunta**

A melanina proteje girinos contra os efeitos da radia√ß√£o ultravioleta?

**Predi√ß√µes**

Como a melanina participa do sistema imune inato, ela desempenharia um papel na resposta do organismo √† radia√ß√£o UV, auxiliando as c√©lulas imunes a combater os seus efeitos delet√©rios.

**Vari√°veis**

- Vari√°vel resposta: Contagem diferencial de eosin√≥filos
- data frame com 10 girinos em cada tratamento, totalizando 50 girinos

```{r}
## Dados
head(uv_cells)

## Traduzir nomes das colunas e n√≠veis de pigmenta√ß√£o 
colnames(uv_cells) <- c("UV", "Pigmentacao", "n_celulas", "linfocito", "neutrofilo", "basofilo", "monocito", "eosinofilo")
uv_cells$Pigmentacao[uv_cells$Pigmentacao=="Yes"] <- "sim"
uv_cells$Pigmentacao[uv_cells$Pigmentacao=="No"] <- "nao"


```

Vamos explorar os dados para tentar entender como s√£o as rela√ß√µes (Figura \@ref(fig:fig-mod-bin-pre)).

```{r fig-mod-bin-pre, fig.cap="Gr√°fico para explorar as rela√ß√µes entre as vari√°veis."}
## Gr√°fico

# Calcular m√©dia e intervalo de confian√ßa
eosinofilo <- summarySE(uv_cells, 
                        measurevar = "eosinofilo",
                        groupvars = c("UV", "Pigmentacao"))

# Definir posi√ß√£o de linhas e pontos no gr√°fico
pd <- position_dodge(0.1)

eosinofilo %>% 
  ggplot(aes(x = UV, y = eosinofilo, colour = Pigmentacao,
             group = Pigmentacao, fill = Pigmentacao)) +
  geom_errorbar(aes(ymin=eosinofilo-se, ymax=eosinofilo +se), 
                width=.1, size = 1.1, position=pd) +
  geom_line(position=pd, size = 1.1) +
  geom_point(pch = 21, colour = "black", position=pd, size=3.5) +
  scale_colour_manual(values = c("darkorange", "cyan4")) +
  scale_fill_manual(values = c("darkorange", "cyan4")) +
  labs(x = "UV", y = "Eosin√≥filo", fill="Pigmenta√ß√£o", colour="Pigmenta√ß√£o")+
  tema_livro()
```

Aqui vemos que a quantidade de eosin√≥filos √© muito maior nos girinos sem pigmenta√ß√£o ("albinos"). J√° que estes animais n√£o t√™m pigmenta√ß√£o mel√¢nica, as c√©lulas brancas do sangue s√£o a √∫nica ferramenta de combate aos efeitos delet√©rios da UV.

**Modelagem**

Aqui vamos usar o `cbind` no argumento `formula` para dizer que queremos modelar a contagem de eosin√≥filos em rela√ß√£o ao n√∫mero total de c√©lulas, ou seja, sua propor√ß√£o. Aqui temos a contagem do n√∫mero de eusin√≥filos (um tipo de c√©lula da s√©rie branca do sangue) em l√¢minas histol√≥gicas de girinos da r√£-touro (*Lithobates catesbeianus*) num total de 1000 c√©lulas.

```{r}
## Modelo
mod1 <- glm(cbind(eosinofilo, n_celulas) ~ UV * Pigmentacao, family = binomial, data = uv_cells)
```

**Diagnose b√°sica dos res√≠duos do modelo**

Vamos fazer a diagnose b√°sica dos res√≠duos do modelo (Figura \@ref(fig:fig-mod-quasi-bin-diag-bas)).

```{r fig-mod-quasi-bin-diag-bas, fig.cap="Diagnose b√°sica dos res√≠duos do modelo GLM binomial."}
## Diagnose dos res√≠duos
par(mfrow = c(2, 2))
plot(mod1)
par(mfrow = c(1, 1))
```

Parece que os res√≠duos n√£o sofrem de heterogeneidade de vari√¢ncia  (linha vermelha est√° reta), mas parece haver um pequeno desvio da normalidade (veja pontos 19, 29 e 32 destacados no plot de quantis e no de outliers). Vejamos o que o `DHARMa` nos diz (Figura \@ref(fig:fig-mod-quasi-bin-diag-avan)).

```{r fig-mod-quasi-bin-diag-avan, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM binomial."}
## Diagnose avan√ßada
simulationBion <- simulateResiduals(fittedModel = mod1, plot = TRUE)
binned_residuals(mod1)
```

Aqui j√° n√£o resta d√∫vidas de que os res√≠duos deste modelo sofrem tanto com heterogeneidade de vari√¢ncia, quanto *overdispersion* e problemas com *outliers*. Provavelmente o problema com *outliers* ocorreu por conta do pequeno tamanho amostral.

**Infer√™ncia**

Sabemos que o modelo n√£o parece ser adequado para os dados, mas vamos interpret√°-lo mesmo assim para que possamos entender a sa√≠da da fun√ß√£o `summary()` e os contrastes entre os n√≠veis dos fatores.

```{r}
## Coeficientes estimados pelo modelo
summary(mod1)
anova(mod1)
```

Aqui temos tanto a tabela com os resultados por n√≠veis dos fatores (`summary()`), quanto a tabela com a *Deviance* que mostra os fatores e suas intera√ß√µes (`anova()`). Vemos que nenhum fator foi significativo. Caso houvesse algum fator significativo, poder√≠amos testar a signific√¢ncia de cada n√≠vel dos fatores usando contrastes, desta forma.

```{r}
## Par√¢metros
pairs(emmeans(mod1, ~ UV|Pigmentacao))
```

Aqui temos o valor de cada combina√ß√£o de n√≠veis dos fatores, com seu respectivo valor de contraste e o valor de *P*. Vemos que para girinos sem pigmenta√ß√£o, apenas tr√™s contrastes foram significativos.

**Plot do modelo predito**

Vamos realizar a visualiza√ß√£o do ajusto do modelo binomial (Figura \@ref(fig:fig-mod-bin-model)).

```{r fig-mod-bin-model, fig.cap="Gr√°fico do GLM binomial."}
ggplot(uv_cells, aes(UV, eosinofilo)) +
    geom_violin(aes(color = Pigmentacao)) +
    geom_jitter(shape = 16, position = position_jitter(0.1), cex = 4, alpha = 0.7) +
    scale_colour_manual(values = c("darkorange", "cyan4")) +
    tema_livro()
```

Usando o `geom_violin()`, podemos perceber que existe uma dispers√£o maior nos tratamentos que utilizaram girinos sem pigmenta√ß√£o do que nos tratamentos com girinos pigmentados.

## An√°lise com dados de incid√™ncia

Uma outra aplica√ß√£o da distribui√ß√£o binomial √© quando temos dados de incid√™ncia, ou seja, presen√ßa ou aus√™ncia, de alguma vari√°vel. Por exemplo, presen√ßa ou aus√™ncia de uma esp√©cie ou indiv√≠duo num local. Neste caso a `formula` √© diferente e o modelo √© similar a uma regress√£o log√≠stica, vejamos.

Aqui vamos utilizar os dados sobre autotomia da cauda de lagartos da esp√©cie *Coleodactylus meridionalis* observados em fragmentos florestais da Mata Atl√¢ntica no estado de Pernambuco [@oliveira2020].

**Pergunta**

A probabilidade de lagartos da esp√©cie *Coleodactylus meridionalis* perderem (autotomizarem) a cauda aumenta com o tamanho do corpo e de acordo com o sexo dos lagarto?

**Predi√ß√µes**

Quanto maior o lagarto, maior a probabilidade de autotomia da cauda e que esta resposta poderia tamb√©m diferir entre sexos devido ao dimorfismo sexual.

**Vari√°veis**

- Vari√°vel resposta: Presen√ßa ou aus√™ncia de cauda autotomizada em lagartos encontrados por busca ativa

**Explora√ß√£o dos dados**

Este conjunto de dados possui muitas entradas faltantes (codificadas como `NA`). Primeiro vamos visualizar o conjunto de dados e depois precisamos remover as linhas que cont√™m dados faltantes. Aqui podemos usar a fun√ß√£o interna do `ggplot2::remove_missing()` para remover linhas cujas vari√°veis informadas no argumento estejam faltando, vejamos (Figura \@ref(fig:fig-mod-inc-na)).

```{r fig-mod-inc-na, fig.cap="Gr√°ficos para explorar os dados faltantes."}

## Traduzir nomes das colunas e n√≠veis de pigmenta√ß√£o 
head(lagartos)
colnames(lagartos) <- c("numero", "sexo", "SVL", "comprimento_cauda", "cauda_autotomizada", "estado_cauda")


## Dados faltantes
vis_dat(lagartos)
vis_miss(lagartos, cluster = TRUE) # 22.9% dos dados est√£o faltando
dados_semNA <- remove_missing(lagartos, vars = "sexo") # excluindo linhas com dados faltantes para a vari√°vel Sex
vis_miss(dados_semNA)
dim(dados_semNA) # verificar as dimens√µes da tabela depois que os dados tiverem sido exclu√≠dos
```

Agora, seguindo o que j√° estamos acostumados a fazer, vamos vizualisar os dados com a nossa hip√≥tese (Figura \@ref(fig:fig-mod-inc-pre)).

```{r fig-mod-inc-pre, fig.cap="Gr√°fico para explorar as rela√ß√µes entre as vari√°veis."}
## Gr√°fico
ggplot(dados_semNA, aes(SVL, estado_cauda)) +
    geom_point(aes(shape = sexo, colour = sexo), size = 4, alpha = 0.4) +
    geom_smooth(method = "glm", method.args = list(family = "binomial")) +
    labs(y = "Estado da Cauda", x = "Comprimento Rostro-Cloacal (mm)", shape = "Sexo", colour = "Sexo") +
    tema_livro()
```

**Modelagem**

Aqui vamos construir dois modelos com a mesma distribui√ß√£o binomial, mas com dois *link function*: logit e probit. A fun√ß√£o logit possui caudas um pouco mais achatadas, isto √©, a curva probit se aproxima dos eixos mais rapidamente que a logit. Geralmente n√£o h√° muita diferen√ßa entre elas. Como n√£o temos nenhuma expectativa de qual dos dois link function √© o melhor, podemos fazer uma sele√ß√£o de modelos.

```{r}
## Modelos
mod_log <- glm(estado_cauda ~ SVL * sexo, data = dados_semNA, family = binomial(link = "logit"))
mod_pro <- glm(estado_cauda ~ SVL * sexo, data = dados_semNA, family = binomial(link = "probit"))

# Sele√ß√£o de modelos
AICctab(mod_log, mod_pro, nobs = 139)
```

Existe pouca diferen√ßa entre o modelo probit e logit. Como o modelo logit √© mais simples vamos interpret√°-lo apenas.

**Diagnose dos res√≠duos do modelo**

Vamos fazer a diagnose dos res√≠duos do modelo (Figura \@ref(fig:fig-mod-inc-diag)).

```{r fig-mod-inc-diag, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM binomial de incid√™ncia."}
## Diagn√≥se avan√ßada
simulationBion <- simulateResiduals(fittedModel = mod_log, plot = T)
binned_residuals(mod_log)
```

**Infer√™ncia**

Para modelos com par√¢metro de dispers√£o conhecida (e.g., binomial e Poisson), o chi-quadrado √© a estat√≠stica mais apropriada.

```{r}
## Coeficientes estimados pelo modelo
summary(mod_log)
anova(mod_log, test = "Chisq" )
```

**Interpreta√ß√£o dos resultados**

A interpreta√ß√£o dos resultados √© que o tamanho de corpo (SVL) afeta negativamente a probabilidade da cauda estar intacta, i.e., com o aumento do tamanho, a probabilidade da cauda permanecer intacta diminui. A intera√ß√£o n√£o foi significativa, ent√£o o efeito √© independente do sexo dos lagartos.

## Dados de contagem com excesso de zeros

Quando se analisa a abund√¢ncia ou riqueza de esp√©cies √© comum que tenhamos dados com muitos zeros. Esse fen√¥meno pode ser causado por v√°rios processos ecol√≥gicos, tais como locais fora do nicho da esp√©cie, falha na detec√ß√£o, amostras feitas fora do habitat ou em locais onde n√£o se espera encontrar a esp√©cie [@blascomoreno2019]. Esse tipo de dado √© problem√°tico porque rompe com os pressupostos da distribui√ß√£o Poisson e binomial negativa, podendo inclusive ser uma das causas da *overdispersion*.

Nesses casos, temos de ajustar modelos que levam em conta esse excesso de zeros nos dados. Esses modelos s√£o chamados de **zero-inflated** e **hurdle models** (tamb√©m chamados de *zero-altered models*), dependendo de como o processo que causou os zeros √© modelado.

*Hurdle models* (ou *zero-altered models*) modelam os dados dividindo-os em dois subconjuntos: um no qual reduzimos os dados √† presen√ßa-aus√™ncia, ou seja, todos os dados maiores que 1 s√£o transformados em 1 e usamos, por exemplo, uma distribui√ß√£o binomial; e uma outra parte que s√≥ considera os valores positivos sem zero, utilizando uma Poisson ou binomial negativa truncadas. Ao fazer isso, a distribui√ß√£o truncada assume que os zeros s√£o gerados tanto por processos ecol√≥gicos, quanto erros de amostragem (ou seja, √© imposs√≠vel distinguir entre essas duas fontes). Portanto, esses zeros s√£o exclu√≠dos da distribui√ß√£o com dados de contagem. Por exemplo, se uma distribui√ß√£o binomial negativa for usada para modelar a parte quantitativa, chamamos o modelo de *Zero-altered Negative binomial*. A interpreta√ß√£o dos modelos deve ser feita de forma conjunta.

Modelos com zero inflados funcionam de maneira similar, mas permitem que a distribui√ß√£o Poisson contenha zeros, ou seja, *n√£o √© utilizada uma distribui√ß√£o truncada*. Ao fazer isso, esta distribui√ß√£o de Poisson pressup√µe que os zeros foram gerados por um processo ecol√≥gico real, tal como, aus√™ncia de habitat adequado.

Para ilustrar como podemos lidar com conjuntos de dados complexos, vamos utilizar os dados do parasita *Raillietiella mottae* infectando duas esp√©cies de lagartos que ocorrem no Nordeste Brasileiro [@lima2018]. Ao todo, 63 indiv√≠duos de *Hemidactylus agrius* e 132 de *Phyllopezus pollicaris* foram amostrados.

**Pergunta**

Quais atributos de hist√≥ria de vida dos lagartos s√£o relacionados com o volume (*load*) de infec√ß√£o, tais como tamanho e sexo?

**Predi√ß√µes**

Quanto maior o lagarto, maior o n√∫mero de parasitas encontrados, esta resposta poderia tamb√©m diferir entre sexos devido ao dimorfismo sexual.

**Vari√°veis**

- Vari√°vel resposta: n√∫mero do parasita *Raillietiella mottae*, que √© um crust√°ceo parasita, infectando o aparelho respirat√≥rio e intestinal de lagartos. 

```{r}
## Cabe√ßalho dos dados
head(parasitas)
```

Vamos explorar os dados (Figura \@ref(fig:fig-mod-zero-pre)).

```{r fig-mod-zero-pre, fig.cap="Gr√°fico para explorar as rela√ß√µes entre as vari√°veis."}
## Gr√°ficos
ggplot(parasitas, aes(Raillietiella_mottae, fill = Especie)) +
    geom_density(alpha = 0.4) +
    facet_grid(Especie ~ Sexo) +
    scale_fill_manual(values = c("darkorange", "cyan4")) +
    tema_livro() +
    theme(legend.position = "none")

ggplot(parasitas, aes(CRC, Raillietiella_mottae, fill = Especie)) +
    geom_point(size = 4, alpha = 0.4, shape = 21) +
    facet_grid(Sexo ~ Especie) +
    scale_fill_manual(values = c("darkorange", "cyan4")) +
    theme(legend.position = "none") +
    labs(x = "Comprimento Rostro-Cloacal", y = expression(italic("Raillietiella mottae")))+
    tema_livro()
```

Os gr√°fico acima mostram a contagem do parasita *Raillietiella mottae* nos dois sexos (F e M para f√™mea e macho) nas duas esp√©cies de lagartos (*Hemidactylus agrius* e *Phyllopezus pollicaris*), tanto na forma de uma distribui√ß√£o de densidade, quanto de gr√°fico de dispers√£o. Aqui podemos ver que de fato existe um excesso de zeros principalmente em *P. pollicaris*.

Quando nos deparamos com dados complexos assim, a estrat√©gia √© sempre come√ßar com um modelo simples e depois adicionar mais par√¢metros. Portanto, vamos iniciar com um modelo Poisson, mesmo sabendo que ele muito provavelmente n√£o ser√° adequado para modelar estes dados.

**Modelagem**

Ajuste do modelo Poisson.

```{r}
## Modelo
pois_plain <- glm(Raillietiella_mottae ~ CRC + Sexo * Especie, data = parasitas, family = "poisson")
```

**Diagnose**

Aqui vamos utilizar as fun√ß√µes do pacote `performance` novamente (Figura \@ref(fig:fig-mod-pois-zero-diag)) para o GLM Poisson.

```{r fig-mod-poi-zero-diag, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM Poisson."}
## Diagnose avan√ßada
check_zeroinflation(pois_plain) # para diagnosticar se o modelo sofre de zero inflation
check_overdispersion(pois_plain)
```

A diagnose n√£o s√≥ nos disse que o modelo possui *overdispersion*, como tamb√©m de *zero-inflation*, como j√° esper√°vamos. Vejamos ent√£o como melhorar o nosso modelo para lidar com esses dois problemas. Especificamente, vamos utilizar um modelo *Hurdle* com binomial negativa truncada (ou seja, desconsiderando os zeros), e um outro modelo *zero-inflated* usando uma distribui√ß√£o binomial negativa. 
Aqui vamos utilizar o pacote `glmmTMB`.

```{r}
## Modelos
hur_NB <- glmmTMB(Raillietiella_mottae ~ CRC + Sexo * Especie, zi = ~., data = parasitas, family = truncated_nbinom2) # Hurdle model

ziNB_mod2 <- glmmTMB(Raillietiella_mottae ~ CRC + Sexo * Especie, zi = ~., data = parasitas, family = nbinom2) # zero-inflated Poisson

ziP_mod2 <- glmmTMB(Raillietiella_mottae ~ CRC + Sexo * Especie, zi = ~., data = parasitas, family = poisson) # zero-inflated Negative binomial
```

**Diagnose**

Vamos fazer a diagnose desses tr√™s modelos ajustados anteriormente.

```{r}
## Diagnose de infla√ß√£o de zeros
check_zeroinflation(hur_NB) # prediz melhor os zeros
check_zeroinflation(ziP_mod2)
check_zeroinflation(ziNB_mod2)
```

Aqui vemos que o modelo zero-altered (Hurdle Model) conseguiu predizer exatamente a quantidade de zeros observada, fazendo com que o modelo seja suficiente para usarmos com esses dados.

```{r}
## Sele√ß√£o de modelos
ICtab(pois_plain, hur_NB, ziP_mod2, ziNB_mod2, type = c("AICc"), weights = TRUE)
```

Mas quando comparamos o AICc entre modelos, os modelos zero-inflated (tanto Poisson, quanto binomial negativa) que tem menos par√¢metros, s√£o ranqueados ligeiramente melhor do que o modelo binomial negativa zero-altered (ou hurdle). N√£o podemos distinguir entre os dois modelos com zero-inflated porque o dAICc < 2, ou seja, o ajuste deles aos dados s√£o praticamente iguais. Vejam que a diferen√ßa de Akaike Weights entre os dois primeiros modelos e o hurdle √© bastante substancial (0.34 e 0.52). Al√©m disso, vemos que os modelos que levam em conta o excesso de zeros se ajustam bem melhor aos dados do que o modelo simples com distribui√ß√£o Poisson.
Vamos ver como os modelos se saem em rela√ß√£o aos outros pressupostos (Figura \@ref(fig:fig-mod-zero-diag)).

```{r fig-mod-zero-diag, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM Hurdle e zero-inflated binomial negativa."}
## Diagnoses
simulationOutput <- simulateResiduals(fittedModel = hur_NB, plot = T)
simulationOutput <- simulateResiduals(fittedModel = ziP_mod2, plot = T)
simulationOutput <- simulateResiduals(fittedModel = ziNB_mod2, plot = T) # tem um outlier nos res√≠duos (asterisco vermelho)
```

Os gr√°ficos de diagnose do `DHARMa` s√£o outra evid√™ncia de que tanto o modelo hurdle quanto o zero-inflated Poisson s√£o adequados para os dados, em termos de homogeneidade de vari√¢ncia, *outliers* e *overdispersion*.

**Interpreta√ß√£o dos resultados**

Apesar de n√£o ter um ajuste t√£o bom aos dados, o modelo hurdle prediz melhor a quantidade de zeros. Portanto, vamos interpretar os coeficientes apenas deste modelo. 
```{r}
## Coeficientes estimados pelo modelo
summary(hur_NB)
```

Para maiores detalhes na interpreta√ß√£o deste tipo de modelo, sugerimos fortemente consultar p. 382-3 de Brooks et al. [-@brooks2017a]. Para fatores com mais de um n√≠vel, o `summary()` mostra os resultados usando contraste, para isto toma como refer√™ncia um dos n√≠veis do fator (o primeiro em ordem alfab√©tica) e o compara com os outros. Note que na parte com excesso de zeros, o contraste √© positivo para Esp√©cie. Ou seja, o *P. pollicaris* tem maior chance de ter aus√™ncia de parasitas que *H. agrius*. O contraste para esp√©cie continua sendo positivo na parte condicional do modelo, mas o valor do par√¢metro n√£o √© t√£o alto. Isso quer dizer que *P. pollicaris* tem abund√¢ncia de parasitas em m√©dia ligeiramente maior que *H. agrius*. Vemos que a intera√ß√£o √© significativa entre sexo e esp√©cie na parte do modelo com excesso de zeros, mas apenas marginalmente significativa na parte condicional. Portanto, a influ√™ncia do sexo na incid√™ncia, mas n√£o na abund√¢ncia do parasita depende conjuntamente da esp√©cie. No entanto, o CRC s√≥ passa a ser significativo na parte de excesso de zeros, ou seja, quando modelamos apenas a incid√™ncia (presen√ßa-aus√™ncia) do parasita. Portanto, o *CRC determina se o lagarto vai ou n√£o ser infectado, mas n√£o <bold>o quanto</bold> vai receber de parasitas*. J√° tanto o sexo quanto a esp√©cie foram significativas em ambas as partes do modelo, ou seja, esses fatores n√£o influenciam diferentemente a infec√ß√£o e a quantidade de parasitas.
Agora vejamos como podemos plotar as predi√ß√µes deste modelo (Figura \@ref(fig:fig-mod-zero-model)).

```{r fig-mod-zero-model, fig.cap="Gr√°fico do GLM Hurdle."}
## Gr√°fico
parasitas$phat <- predict(hur_NB, type = "response")
parasitas <- parasitas[with(parasitas, order(Sexo, Especie)), ]

ggplot(parasitas, aes(x = CRC, y = phat, colour = Especie,
                      shape = Sexo, linetype = Sexo)) +
    geom_point(aes(y = Raillietiella_mottae), size = 4, 
               alpha = .7, position = position_jitter(h = .2)) +
    geom_line(size = 1) +
    scale_fill_manual(values = c("darkorange", "cyan4")) +
    scale_colour_manual(values = c("darkorange", "cyan4")) +
       labs(x = "Comprimento Rostro-Cloacal", 
         y = expression(paste("Abund√¢ncia de ", italic("Raillietiella mottae")))) +
    tema_livro()
```

## Dados ordinais: os modelos cumulative link

Uma outra maneira de codificarmos os dados √© utilizando categorias ordenadas, tais como ranques. Exemplos incluem a escala de Likert, scores e intervalos (e.g., de idade).

Para este exemplo, iremos utilizar um outro conjunto de dados do artigo de [@Franco-Belussi2018a] que manipulou *in vitro* a concentra√ß√£o do horm√¥nio noradrenalina nos olhos de peixes esgana-gato (*Gasterosteus aculeatus*) e avaliaram a express√£o de v√°rias cores conferidas por tipos de c√©lulas (cromat√≥foros). Aqui vamos usar os dados do efeito da noradrenalina na cor vermelha em machos.
Neste experimento, os autores realizaram medidas repetidas no mesmo animal ao longo do tempo (que √© um dos fatores deste experimento). Portanto, para n√£o incorrer no risco de pseudor√©plicas dever√≠amos incluir esta informa√ß√£o no modelo. A maneira mais simples de faz√™-lo √© criar um modelo de efeito misto em que ter√≠amos uma parte fixa (o que de fato estamos interessados em testar) e outra aleat√≥ria (vari√°veis que precisamos controlar). Portanto, `Animal` ser√° inclu√≠do como um um fator aleat√≥rio, tendo um intercepto estimado separadamente para cada animal no modelo. N√£o iremos entrar em detalhes sobre modelos de efeito misto porque necessitar√≠amos de um outro cap√≠tulo para isso, dada a complexidade do assunto. No entanto, recomendamos aos leitores dois artigos intr√≥dut√≥rios muito bons - Harisson [-@Harrison] e Bolker et al. [-@BOLKER2009127].

**Pergunta**

A noradrenalina causa uma diminui√ß√£o da colora√ß√£o vermelha, via agrega√ß√£o dos pigmentos?

**Predi√ß√µes**

A presen√ßa de noradrenalina causa a agrega√ß√£o dos pigmentos, permitindo que os horm√¥nios reprodutivos atuem.

**Vari√°veis**

- Vari√°vel resposta: escala de intensidade de cor. Para mais detalhes veja o artigo original [@Franco-Belussi2018a].

```{r}
## Importar os dados
cores <- read.csv2("https://ndownloader.figshare.com/files/10250700", header = TRUE)
head(cores)

## Tradu√ß√£o dos nomes das colunas
colnames(cores) <- c("animal", "tratamento", "tempo", "sexo", "preto", "vermelho")

## Filtrando dados - macho vermelho
macho_verm <- filter(cores, sexo == "M")
head(macho_verm)
```

Esses dados, no entanto, t√™m de ser codificados como um fator ordenado antes de entrarmos com eles no modelo.

```{r}
## Fator
macho_verm$animal <- factor(macho_verm$animal)
macho_verm$vermelho_ord <- factor(macho_verm$vermelho, 
                      levels = c("1", "2", "3", "4", "5"), 
                      ordered = TRUE)
str(macho_verm)
```

Repare que a classe do objeto muda e temos agora que Red √© um `Ordered factor`.

**Modelagem**

Vamos ajustar um modelo cumulative link, utilizando a fun√ß√£o `clmm()` do pacote `ordinal`.

```{r}
## Modelo
mod3 <- clmm(vermelho_ord ~ tratamento + tempo + (1|animal), data = macho_verm, threshold = "equidistant")
```

**Diagnose**

Infelizmente, o pacote `ordinal` n√£o fornece m√©todos para lidar com modelos mistos, como o nosso. Ent√£o, montamos um modelo fixo apenas para entrar nas duas fun√ß√µes de diagnose. Essas duas fun√ß√µes `scale_test()` e `nominal_test()` testam a qualidade do ajuste (*goodness-of-fit*) do modelo, similar aos *likelihood-ratio test*, s√≥ que para dados ordinais.

```{r}
## Diagnose
assumption3 <- clm(vermelho_ord ~ tratamento + tempo, data = macho_verm, threshold = "equidistant")

scale_test(assumption3)
nominal_test(assumption3)
```

Parece que n√£o h√° problemas com o efeito de escala do dado ordinal, mas a diagnose sugere que possa haver evid√™ncia de rompimento do pressuposto de probabilidades proporcionais em rela√ß√£o ao tratamento. Esse √© um pressuposto importante de modelos ordinais, os quais assumem que os efeitos de qualquer uma das vari√°veis explicativas s√£o consistentes (proporcionais) ao longo de diferentes *thresholds* (que s√£o as quebras entre cada par de categorias da vari√°vel resposta ordinal).

Isto provavelmente se deve ao baixo tamanho amostral. Por quest√£o de brevidade vamos apenas ignorar este aspecto e interpretar o resultado do modelo mesmo assim. Mas se o seu modelo apresentar este problema, a solu√ß√£o deve ser realizar regress√µes log√≠sticas separadamente.

**Infer√™ncia**

Vamos analisar os par√¢metros do modelo.

```{r}
## Coeficientes estimados pelo modelo
summary(mod3)
anova(assumption3)
pairs(emmeans(mod3, ~ tratamento|tempo, adjust = "tukey"))
```

Aqui vemos que tanto o tratamento, quanto o tempo de exposi√ß√£o foram significativos.

**Interpreta√ß√£o dos resultados**

Vamos analisar a predi√ß√£o do modelo (Figura \@ref(fig:fig-mod-ord-model)).

```{r fig-mod-ord-model, fig.cap="Gr√°fico do modelo cumulative link."}
## Gr√°fico

# Calcular m√©dia e erro padr√£o
macho_verm_res <- summarySE(macho_verm, 
                        measurevar = "vermelho",
                        groupvars = c("tempo", "tratamento"))

# Definir posi√ß√£o de linhas e pontos no gr√°fico
pd <- position_dodge(0.1)

macho_verm_res %>% 
  ggplot(aes(x = tempo, y = vermelho, colour = tratamento,
             group = tratamento, fill = tratamento)) +
  geom_errorbar(aes(ymin=vermelho-se, ymax=vermelho +se), 
                width=.1, size = 1.1, position=pd) +
  geom_line(position=pd, size = 1.1) +
  geom_point(pch = 21, colour = "black", position=pd, size=3.5) +
  scale_colour_manual(values = c("darkorange", "cyan4")) +
  scale_fill_manual(values = c("darkorange", "cyan4")) +
  xlab("Tempo de exposi√ß√£o (horas)") +
  ylab("√çndice de eritr√≥foros") +
  tema_livro()
```

Neste gr√°fico vemos que o grupo tratado com o horm√¥nio come√ßa com um √≠ndice de eritr√≥foro ligeiramente maior do que o controle, mas logo tem uma brusca redu√ß√£o com uma hora de exposi√ß√£o, passando a ter √≠ndice 2, demonstrando que houve uma mudan√ßa de cor induzida pela dispers√£o dos cromat√≥foros. J√° no controle, o √≠ndice n√£o muda em rela√ß√£o ao tempo de exposi√ß√£o. Logo, podemos ver que h√° uma intera√ß√£o entre os fatores devido a esta queda do √≠ndice no grupo tratado e a aus√™ncia de efeito no controle.

## Dados cont√≠nuos: distribui√ß√£o beta

Aqui vamos utilizar como exemplo os dados do artigo de [-@Franco-Belussi2018a]. Os pesquisadores fizeram um experimento *in vivo* com peixes esgana-gato (*Gasterosteus aculeatus*) para testar como a colora√ß√£o dos animais respondem ao f√°rmaco ioimbina (YOH), que bloqueia a colora√ß√£o t√≠pica que os machos exibem na √©poca de acasalamento, e o tempo de exposi√ß√£o ao mesmo (al√©m de um controle), num desenho de ANOVA fatorial. Como as medidas foram feitas repetidamente no mesmo animal, iremos incluir o `Animal` como um fator aleat√≥rio no modelo.

```{r}
head(fish)

## Tradu√ß√£o dos nomes das colunas
colnames(fish) <- c("animal", "tratamento", "tempo", "sexo", "preto", "vermelho")
```

Esses dados cont√™m as vari√°veis resposta medidas no experimento: a quantidade de vermelho e preto. Al√©m dos fatores manipulados: Tratamento (controle e presen√ßa de YOH) e tempo de exposi√ß√£o.

**Pergunta**

A YOH aumenta a colora√ß√£o escura no olho e mand√≠bula dos peixes via dispers√£o dos pigmentos?

**Predi√ß√µes**

A YOH promover√° um escurecimento do corpo do animal, j√° que ela inibe a a√ß√£o NorAdrenalia (NA).

**Vari√°veis**

- Vari√°vel resposta: a intensidade de colora√ß√£o escura em peixes machos. Esses dados s√£o expressos em termos de porcentagem e variam continuamente de 0 a 100%. Para facilitar a modelagem e nos adequarmos √† maneira com que a fun√ß√£o requer os dados, vamos simplesmente dividir por 100 para que os dados variem entre 0 e 1

Para modelar os dados vamos utilizar a fun√ß√£o `glmmTMB`. Antes disso, vamos analisar graficamente os dados (Figura \@ref(fig:fig-mod-beta-pre)). Vamos usar apenas os dados dos machos para este exemplo.

```{r fig-mod-beta-pre, fig.cap="Gr√°fico para explorar a distribui√ß√£o da vari√°vel resposta."}
## Filtrando os dados
fish$animal <- factor(fish$animal)
fish$sexo <- factor(fish$sexo)
macho_preto <- dplyr::filter(fish, sexo == "M")

## Gr√°fico
ggplot(macho_preto, aes(preto/100)) +
    geom_density(colour = "cyan4", fill = "cyan4", alpha = 0.4) +
    theme(legend.position = "none") +
    labs(x = "√çndice de escurid√£o do corpo")+
    tema_livro()
```

No histograma podemos ver que os dados de fato variam continuamente no intervalo entre 0 e 1, tendo uma distribui√ß√£o notadamente bimodal.

**Modelagem**

Vamos ajustar um GLM Beta.

```{r}
## Modelo
mod2 <- glmmTMB(preto/100 ~ tratamento * tempo + (1|animal), family = beta_family, data = macho_preto)
```

**Diagnose**

Aqui utilizaremos o mesmo pacote `DHARMa` para realizar a diagnose do modelo
(Figura \@ref(fig:fig-mod-beta-diag)).

```{r fig-mod-beta-diag, fig.cap="Diagnose avan√ßada dos res√≠duos do modelo GLM Beta."}
## Diagn√≥se
simulationOutput <- simulateResiduals(fittedModel = mod2, plot = TRUE)
```

Podemos ver que o modelo n√£o sofre de heterogeneidade de dispers√£o, overdispersion, nem problemas com *outlier*.

**Interpreta√ß√£o dos resultados**

Agora que podemos interpretar a sa√≠da do modelo ajustado com confian√ßa, vamos obter a tabela de anova em que teremos os testes de cada fator do modelo.

```{r}
## Coeficientes estimados pelo modelo
Anova(mod2)
```

Aqui vemos que a intera√ß√£o √© significativa. Portanto, temos de interpretar os n√≠veis do fator da combina√ß√£o, fazemos isso no pacote `emmeans` colocando a barra \|.

```{r}
## n√≠veis do fator da combina√ß√£o
pairs(emmeans(mod2, ~ tratamento|tempo))
```

Agora podemos perceber que a diferen√ßa entre o controle e o tratado s√≥ passa a ser significativa depois de 1 h de exposi√ß√£o.

Isso fica mais evidente quando plotamos os dados (Figura \@ref(fig:fig-mod-beta-model)).

```{r fig-mod-beta-model, fig.cap="Gr√°fico do modelo GLM beta."}
## Gr√°fico
escuridao <- summarySE(macho_preto, 
                        measurevar = "preto",
                        groupvars = c("tempo", "tratamento"))

# Definir posi√ß√£o de linhas e pontos no gr√°fico
pd <- position_dodge(0.1)

escuridao %>% 
  ggplot(aes(x = tempo, y = preto, colour = tratamento,
             group = tratamento, fill = tratamento)) +
  geom_errorbar(aes(ymin=preto-se, ymax=preto +se), 
                width=.1, size = 1.1, position=pd) +
  geom_line(position=pd, size = 1.1) +
  geom_point(pch = 21, colour = "black", position=pd, size=3.5) +
  scale_colour_manual(values = c("darkorange", "cyan4")) +
  scale_fill_manual(values = c("darkorange", "cyan4")) +
  xlab("Tempo de experimento (horas)") +
  ylab("√çndice de escurid√£o do corpo") +
  tema_livro()
```

## Para se aprofundar

Neste cap√≠tulo apenas fizemos uma breve introdu√ß√£o aos modelos lineares generalizados. Para conhecer um pouco mais a fundo todos os detalhes, recomendamos a consulta dos livros "Mixed effects models and extensions in ecology with R" de Zurr et al. [-@zuur_mixed_2009] e "Mixed-Effects Models in S and S-PLUS" de Pinheiro et al. [@pinheiro_mixed-effects_2000] que s√£o as refer√™ncias cl√°ssicas sobre GLM com aplica√ß√µes em Ecologia. Para dados ordinais, sugerimos os livros "Analysis of ordinal categorical data" de Agresti [-@agresti2010] e "Categorical Data Analysis", do mesmo autor, Agresti [-@agresti_categorical_2012].

## Exerc√≠cios

**8.1**

**8.2**

**8.3**

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-8---introdu%C3%A7%C3%A3o-ao-r.html).

<!--chapter:end:08_modelos_lineares_generalizados.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# An√°lises Multidimensionais {#cap9}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados neste cap√≠tulo.

```{r message=FALSE, warning=FALSE}
## Pacotes 
library(ade4)
library(ecodados)
library(tidyverse)
library(vegan) 
library(pvclust)
library(BiodiversityR)
library(labdsv)
library(ggplot2)
library(gridExtra)
library(ape)
library(FactoMineR)
library(factoextra)
library(FD)
library(palmerpenguins)
library(GGally)
library(fields)
library(ade4)
library(ggord)
library(udunits2)
library(adespatial)
library(spdep)
library(mvabund)
library(reshape)

## Dados
sp_compos        <- ecodados::bocaina
species          <- ecodados::com_birds
env              <- ecodados::env_birds
xy               <- ecodados::birds.xy
bocaina.env      <- ecodados::bocaina.env
bocaina.xy       <- ecodados::bocaina.xy
anuros_permanova <- ecodados::anuros_permanova
macroinv         <- ecodados::macroinv
fish_comm        <- ecodados::fish_comm
data(mite)
data(doubs)
data(mite.env)

## Traduzir nomes para portugu√™s 
colnames(penguins) <- c("especies", "ilha", "comprimento_bico", "profundidade_bico", "comprimento_nadadeira", "massa_corporal", "sexo", "ano")

```

## Aspectos te√≥ricos

An√°lises multivariadas avaliam hip√≥teses cuja vari√°vel resposta √© definida por m√∫ltiplas vari√°veis ao mesmo tempo, comumente expressa na forma de uma matriz quadrada ou de dist√¢ncia (dissimilaridade).

Em geral, an√°lises multivariadas t√™m tr√™s principais utilidades: i) reduzir a dimensionalidade dos dados e encontrar a principal dire√ß√£o de varia√ß√£o dos dados, ii) testar rela√ß√µes entre matrizes, ou ainda, iii) encontrar diferen√ßas entre grupos. An√°lises multivariadas podem ser utilizadas como an√°lises explorat√≥rias e/ou para descrever padr√µes em estudos ecol√≥gicos. No entanto, mesmo quando se deseja apenas explorar o conjunto de dados para encontrar poss√≠veis padr√µes, a necessidade de se ter hip√≥teses, ou ao menos expectativas *a priori*, n√£o pode ser ignorada. Antes de entrar de cabe√ßa nas an√°lises multivariadas, tamb√©m sugerimos fortemente o estudo de m√©todos de amostragem e como fazer boas perguntas (Cap√≠tulo \@ref(cap2)).

An√°lises multivariadas podem ser divididas, grosseiramente, em dois tipos: agrupamento e ordena√ß√£o. An√°lises de agrupamento, em geral, tentam agrupar objetos (observa√ß√µes) ou descritores em grupos de maneira que objetos do mesmo grupo sejam mais semelhantes entre si do que objetos de outros grupos [@legendre_numerical_2012]. Por exemplo, os objetos podem ser localidades como "parcelas", "riachos" ou "florestas", enquanto os descritores s√£o as difentes vari√°veis coletadas para esses objetos (e.g., esp√©cies, vari√°veis ambientais). A an√°lise de ordena√ß√£o, por sua vez, √© uma opera√ß√£o pela qual os objetos (ou descritores) s√£o posicionados num espa√ßo que cont√©m menos dimens√µes que o conjunto de dados original; a posi√ß√£o dos objetos ou descritores em rela√ß√£o aos outros tamb√©m pode ser usada para agrup√°-los.

Vamos come√ßar com an√°lises de agrupamento. Aqui vamos exemplificar dois m√©todos: uma t√©cnica de agrupamento hier√°rquica (dendrograma) e outra n√£o-hier√°rquica (k-means).

### Coeficientes de associa√ß√£o

Assim chamados genericamente, os coeficientes de associa√ß√£o medem o qu√£o parecidos objetos ou descritores s√£o entre si. Objetos est√£o nas linhas da matriz, enquanto descritores est√£o nas colunas. Geralmente objetos s√£o as nossas unidades amostrais, enquanto os descritores s√£o as vari√°veis. Quando analisamos a rela√ß√£o entre objetos fazemos uma an√°lise no modo Q, ao passo que o modo R √© quando analisamos a rela√ß√£o entre descritores. Coeficientes de associa√ß√£o do modo Q s√£o medidas de (dis)similaridade ou dist√¢ncia, enquanto para o modo R utilizamos covari√¢ncia ou correla√ß√£o. Como j√° tratamos neste livro sobre covari√¢ncia e correla√ß√£o (ver \@ref(cap7)), neste t√≥pico vamos falar sobre √≠ndices de dist√¢ncia e similaridade. Mas qual a defini√ß√£o destas duas quantitades?

- Similaridade s√£o m√°ximas (*S=1*) quando dois objetos s√£o id√™nticos
- Dist√¢ncias s√£o o contr√°rio da similaridade (*D=1-S*) e n√£o t√™m limites superiores (dependem da unidade de medida)

Existem ao menos 26 √≠ndices de similaridade que podem ser agrupados de acordo com o tipo de dado (qualitativos ou quantitativos) ou a maneira com que lidam com duplos zeros (sim√©tricos ou assim√©tricos) [@legendre_numerical_2012]. Do seu lado, as dist√¢ncias s√≥ se aplicam a dados quantitativos e t√™m como caracter√≠sticas serem m√©tricas, semi-m√©tricas ou n√£o-m√©tricas. Vejamos agora os principais √≠ndices de similaridade e dist√¢ncia de cada tipo.

### M√©tricas de dist√¢ncia

O principal coeficiente de dist√¢ncia usado em ecologia √© a dist√¢ncia euclidiana. Al√©m disso, temos ainda Canberra (varia√ß√£o da Dist√¢ncia Euclidiana), Mahalanobis (calcula a dist√¢ncia entre dois pontos num espa√ßo n√£o ortogonal, levando em considera√ß√£o a covari√¢ncia entre descritores), Manhattan (varia√ß√£o da Dist√¢ncia Euclidiana), Chord (elimina diferen√ßas entre abund√¢ncia total de esp√©cies), ùúí2 (d√° peso maior para esp√©cies raras), Hellinger (n√£o d√° peso para esp√©cies raras). Essas dist√¢ncias s√£o recomendadas nos casos em que as vari√°veis de estudo forem cont√≠nuas, como por exemplo, **vari√°veis morfom√©tricas ou descritores ambientais**.

Uma caracter√≠stica comum de conjuntos de dados ecol√≥gicos s√£o os v√°rios zeros encontrados em matrizes de composi√ß√£o. Eles surgem porque n√£o encontramos nenhum indiv√≠duo de uma determinada esp√©cie num local, seja porque aquele local n√£o tem as condi√ß√µes ambientais adequadas a ela, falha na detectabilidade, ou din√¢micas demogr√°ficas estoc√°sticas de coloniza√ß√£o-extin√ß√£o [@blascomoreno2019]. Logo, quando dois locais compartilham aus√™ncia de esp√©cies, n√£o √© poss√≠vel atribuir uma √∫nica raz√£o da dupla aus√™ncia. Como essas medidas de dist√¢ncia apresentadas acima assumem que os dados s√£o quantitativos e n√£o de contagem, elas n√£o s√£o adequadas para lidar com dados de abund√¢ncia ou incid√™ncia de esp√©cies, porque atribuem um grau de parec√™n√ßa a pares de locais que compartilham zeros [@legendre_numerical_2012]. Por esse motivo, precisamos de coeficientes que desconsiderem os duplos zeros. Eles s√£o chamados de *assim√©tricos*.

**Coeficientes assim√©tricos bin√°rios para objetos**

Esses coeficientes (ou √≠ndices) s√£o apropriados para dados de incid√™ncia de esp√©cies (presen√ßa-aus√™ncia) e desconsideram as duplas aus√™ncias. Os √≠ndices deste tipo mais comuns utilizados em ecologia s√£o S√∏rensen, Jaccard e Ochiai.

$$\beta_j = a/(a+b+c)$$
onde 

- *a* = n√∫mero de esp√©cies compartilhadas
- *b* = n√∫mero de esp√©cies exclusivas da comunidade 1
- *c* = n√∫mero de esp√©cies exclusivas da comunidade 2

A diferen√ßa entre os √≠ndices de Jaccard e S√∏rensen √© que o √≠ndice de S√∏rensen d√° peso dobrado para duplas presen√ßas. Por conta dessas caracter√≠sticas, estes √≠ndices s√£o adequados para quantificar diversidade beta [@anderson2010; @legendre2013]. Esses √≠ndices variam entre 0 (nenhuma esp√©cie √© compartilhada entre o par de locais) a 1 (todas as esp√©cies s√£o compartilhadas entre o par de locais).

$$\beta_s = 2a/(2a+b+c)$$
onde 

- *a* = n√∫mero de esp√©cies compartilhadas
- *b* = n√∫mero de esp√©cies exclusivas da comunidade 1
- *c* = n√∫mero de esp√©cies exclusivas da comunidade 2

**Coeficientes bin√°rios para descritores (R mode)**

Se o objetivo for calcular a similaridade entre descritores bin√°rios (e.g., presen√ßa ou aus√™ncia de caracter√≠sticas ambientais) de pares de locais, geralmente o coeficiente recomendado √© o de Sokal & Michener. Este √≠ndice est√° implementado na `ade4::dist.binary()`.

**Coeficientes quantitativos para objetos**

Estes s√£o os coeficientes utilizados para dados de contagem (e.g., abund√¢ncia) e quantitativos (e.g., frequ√™ncia, biomassa, porcentagem cobertura). Diferentemente das dist√¢ncias, estes coeficientes s√£o assim√©tricos, ou seja, n√£o consideram duplas aus√™ncias, e portanto, s√£o adequados para analisar dados de composi√ß√£o de esp√©cies. Al√©m disso, uma outra caracter√≠stica deles √© serem semi-m√©tricos. Os √≠ndices mais comuns deste tipo s√£o Bray-Curtis (conhecido como *percentage difference*, em ingl√™s), Chord, log-Chord, Hellinger, chi-quadrado e Morisita-Horn.

Todos os √≠ndices discutidos at√© aqui est√£o implementados nas fun√ß√µes `ade4::dist.ktab()`, `adespatial::dist.ldc()` e `vegan::vegdist()`.

**Coeficientes para descritores (R mode) que incluem mistura de tipos de dados**

√â comum em an√°lises de diversidade funcional que tenhamos um conjunto de atributos (*traits*) de esp√©cies que s√£o formados por v√°rios tipos de dados: quantitativos (e.g., tamanho de corpo), bin√°rios (presen√ßa/aus√™ncia de uma dada caracter√≠stica), fuzzy (um atributo multiestado codificado em v√°rias colunas), ordinais e circulares (e.g., distribui√ß√£o de uma fenofase ao longo de um ano). O √≠ndice que lida com todos esses dados √© o Gower. A vers√£o extendida do √≠ndice de Gower pode ser encontrada na fun√ß√£o `ade4::dist.ktab().`

O cap√≠tulo 7 de Legendre & Legendre [-@legendre_numerical_2012] fornece uma chave dicot√¥mica para escolha do √≠ndice mais adequado.

**Padroniza√ß√µes e transforma√ß√µes**

√â comum coletarmos m√∫ltiplas vari√°veis ambientais cujas unidades sejam diferentes. Por exemplo, temperatura (¬∫C), dist√¢ncia da margem (m), √°rea (m^2^), etc. Para diminuir a taxa de Erro do Tipo I das an√°lises (rejeitar a hip√≥tese nula quando ela √© verdadeira), √© recomendado que ***padronizemos*** os dados utilizando distribui√ß√£o *Z*, assim todas as vari√°veis passam a ter m√©dia 0 e desvio padr√£o 1. Essa opera√ß√£o garante que todas as vari√°veis tenham o mesmo peso nas an√°lises que avaliam o padr√£o dos objetos considerando os m√∫ltiplos descritores. Essa padroniza√ß√£o pode ser implementada na fun√ß√£o `vegan::decostand()`.

Um outro problema comum de matrizes de dados de composi√ß√£o de esp√©cies √© o alto n√∫mero de zeros, enquanto outras esp√©cies podem ter altas abund√¢ncias. Isso gera problemas em ordena√ß√µes. Para diminuir essa discrep√¢ncia, podemos **transformar** os dados, por exemplo, utilizando a dist√¢ncia de Hellinger ou Chord. Para dados cont√≠nuos pode ser que transforma√ß√£o log ou raiz quadrada ajude quando h√° valores muito discrepantes (*leverages*) que podem influenciar em demasiado a rela√ß√£o entre objetos ou descritores. Isso pode ser feito na fun√ß√£o `vegan::decostand()`.

## An√°lises de agrupamento

O objetivo da an√°lise de agrupamento √© agrupar objetos admitindo que haja um grau de similaridade entre eles. Esta an√°lise pode ser utilizada ainda para classificar uma popula√ß√£o em grupos homog√™neos de acordo com uma caracter√≠stica de interesse. A grosso modo, uma an√°lise de agrupamento tenta resumir uma grande quantidade de dados e apresent√°-la de maneira f√°cil de visualizar e entender (em geral, na forma de um dendrograma). No entanto, os resultados da an√°lise podem n√£o refletir necessariamente toda a informa√ß√£o originalmente contida na matriz de dados. Para avaliar o qu√£o bem uma an√°lise de agrupamento representa os dados originais existe uma m√©trica --- o coeficiente de correla√ß√£o cofen√©tico --- o qual discutiremos em detalhes mais adiante.

Antes de considerar algum m√©todo de agrupamento, pense porque voc√™ esperaria que houvesse uma descontinuidade nos dados; ou ainda, considere se existe algum ganho pr√°tico em dividir uma nuvem de objetos cont√≠nuos em grupos. O padr√£o apresentado pelo dendograma depende do protocolo utilizado (m√©todo de agrupamento e √≠ndice de dissimilaridade); os grupos formados dependem do n√≠vel de corte escolhido.

A matriz deve conter os objetos a serem agrupados (e.g., esp√©cies) nas linhas e as vari√°veis (e.g., locais de coleta ou medidas morfol√≥gicas) nas colunas. A escolha do m√©todo de agrupamento √© cr√≠tico para a escolha de um coeficiente de associa√ß√£o. √â importante compreender as propriedades dos m√©todos de agrupamento para interpretar corretamente a estrutura ecol√≥gica que eles evidenciam [@legendre_numerical_2012]. De acordo com a classifica√ß√£o de Sneath & Sokal [-@sneath_numerical_1973], existem cinco tipos de m√©todos: i) sequenciais ou simult√¢neos, ii) aglomerativo ou divisivo, iii) monot√©ticos ou polit√©ticos, iv) hier√°rquico ou n√£o hier√°rquicos e v) probabil√≠stico. Sugerimos a leitura do artigo citado anteriormente para aprofundar seus conhecimentos sobre os diferentes m√©todos.

### Agrupamento hier√°rquico

M√©todos hier√°rquicos podem ser divididos naqueles que consideram o centr√≥ide ou a m√©dia aritm√©tica entre os grupos. O principal m√©todo hier√°rquico que utiliza a m√©dia aritm√©tica √© o UPGMA (Agrupamento pelas m√©dias aritm√©ticas n√£o ponderadas), e o principal m√©todo que utiliza centr√≥ides √© a Dist√¢ncia m√≠nima de Ward.

O UPGMA funciona da seguinte forma: a maior similaridade (ou menor dist√¢ncia) identifica os pr√≥ximos agrupamentos a serem formados. Ap√≥s esse evento, o m√©todo calcula a m√©dia aritm√©tica das similaridades ou dist√¢ncias entre um objeto e cada um dos membros do grupo ou, no caso de um grupo previamente formado, entre todos os membros dos dois grupos. Todos os objetos recebem pesos iguais no c√°lculo.

O m√©todo de Ward √© baseado no crit√©rio de quadrados m√≠nimos (OLS), o mesmo utilizado para ajustar um modelo linear (Cap√≠tulo \@ref(cap7)). O objetivo √© definir os grupos de maneira que a soma de quadrados (i.e. similar ao erro quadrado da ANOVA) dentro dos grupos seja minimizada [@borcard2018].

No entanto, para interpretar os resultados precisamos antes definir um n√≠vel de corte, que vai nos dizer quantos grupos existem. H√° v√°rios m√©todos para definir grupos, desde os heur√≠sticos aos que utilizam reamostragem (*bootstrap*). Se quisermos interpretar este dendrograma, podemos, por exemplo, estabelecer um n√≠vel de corte de 50% de dist√¢ncia (ou seja, grupos cujos objetos tenham ao menos 50% de similaridade entre si).

**Checklist**

- Verifique se n√£o h√° espa√ßo nos nomes das colunas e linhas

- Se os dados forem de abund√¢ncia, recomenda-se realizar a transforma√ß√£o de Hellinger [@legendre2001]. Esta transforma√ß√£o √© necess√°ria porque a matriz de comunidades (em especial, com a presen√ßa de muitas esp√©cies raras) pode causar distor√ß√µes nos m√©todos de ordena√ß√£o baseados em dist√¢ncia Euclidiana [@legendre2001]  

-   Se a matriz original contiver muitos valores discrepantes (e.g., uma esp√©cie muito mais ou muito menos abundante que outras) √© necess√°rio transformar os dados usando `log1p()`. No entanto, deve-se fazer ou a transforma√ß√£o de Hellinger ou log e nunca as duas ao mesmo tempo

-   Se as vari√°veis forem medidas tomadas em diferentes escalas (metros, graus celsius etc.), √© necess√°rio padronizar cada vari√°vel para ter a m√©dia 0 e desvio padr√£o 1. Isso pode ser feito utulizando a fun√ß√£o `decostand()` do pacote `vegan`

**Exemplo 1**

Neste exemplo, vamos utilizar um conjunto de dados que cont√©m girinos de esp√©cies de anuros coletados em 14 po√ßas com diferentes coberturas de dossel [@provete_broad-scale_2014].

**Pergunta**

-   Existem grupos de esp√©cies de anf√≠bios anuros com padr√µes de ocorr√™ncia similar ao longo das po√ßas?

**Predi√ß√µes**

-   Iremos encontrar ao menos dois grupos de esp√©cies: aquelas que ocorrem em po√ßas dentro de floresta (i.e., maior cobertura de dossel) *vesus* aquelas que ocorrem em po√ßas de √°reas abertas (menor cobertura de dossel)

**Vari√°veis**

-   Vari√°veis preditoras: a matriz de dados cont√©m a abund√¢ncia das esp√©cies nas linhas e locais (po√ßas) nas colunas

**An√°lises**

Para come√ßar, vamos primeiro importar os dados e depois calcular a matriz de dist√¢ncia que seja adequada para o tipo de dado que temos (abund√¢ncia de esp√©cies - dados de contagem) (Figura \@ref(fig:fig-dend)).

```{r fig-dend, fig.cap="Dendrograma mostrando uma an√°lise de agrupamento de anuros.", message=FALSE, warning=FALSE}
## Composi√ß√£o de esp√©cies (seis primeiras localidades)
head(sp_compos)

## Matriz de similaridade com o coeficiente de Morisita-Horn
distBocaina <- vegdist(x = sp_compos, method = "horn")

## Agrupamento com a fun√ß√£o hclust e o m√©todo UPGMA
dendro <- hclust(d = distBocaina, method = "average")

## Visualizar os resultados
plot(dendro, main = "Dendrograma", 
     ylab = "Similaridade (√≠ndice de Horn)",
     xlab="", sub="")
```

**Assessando a qualidade do dendrograma**

Precisamos verificar se o agrupamento reduziu a dimensionalidade da matiz de forma eficiente, de maneira a n√£o distorcer a informa√ß√£o. Fazemos isso calculando o **Coeficiente de Correla√ß√£o Cofen√©tica**.

```{r}
## Coeficiente de correla√ß√£o cofen√©tica
cofresult <- cophenetic(dendro)
cor(cofresult, distBocaina)
```

Um coeficiente de correla√ß√£o cofen√©tica \> .7 indica uma boa representa√ß√£o. Portanto, o nosso resultado de `r cor(cofresult, distBocaina)` √© alto, garantindo que o dendrograma √© adequado (Figura \@ref(fig:fig-dend-group)). Note que testar a "signific√¢ncia" deste coeficiente n√£o √© adequado, j√° que seria algo tautol√≥gico (circular). Claro que definir o que seria um valor "alto" ou "baixo" da correla√ß√£o √© um pouco arbritr√°rio, mas pode-se usar como "regra do polegar".

```{r fig-dend-group, fig.cap="Dendrograma mostrando uma an√°lise de agrupamento de anuros com uma linha de corte formando cinco grupos.", message=FALSE, warning=FALSE}
## Gr√°fico
plot(dendro, main = "Dendrograma", 
     ylab = "Similaridade (√≠ndice de Horn)",
     xlab="", sub="")
k <- 4
n <- ncol(sp_compos)
MidPoint <- (dendro$height[n-k] + dendro$height[n-k+1]) / 2
abline(h = MidPoint, lty=2)
```

Nesse caso teremos a forma√ß√£o de cinco grupos, representados pelos n√≥s que est√£o abaixo da linha de corte. Portanto, o resultado n√£o suporta a nossa hip√≥tese *a priori* que predizia a forma√ß√£o de apenas dois grupos de esp√©cies.

**Exemplo 2**

No exemplo anterior, vimos que √© dif√≠cil interpretar os grupos baseado num n√≠vel de corte. A seguir, vamos utilizar o pacote `pvclust` que . Uma desvantagem deste m√©todo √© que ele somente aceita √≠ndices de similaridade da fun√ß√£o `dist()`, que possui apenas a dist√¢ncia Euclidiana, Manhattan e Canberra. Uma maneira de contornarmos essa limita√ß√£o √© utilizar transforma√ß√µes dos dados dispon√≠veis na fun√ß√£o `disttransform()` no pacote `BiodiversityR` ou a fun√ß√£o `decostand()` do pacote `vegan`. Tamb√©m √© poss√≠vel utilizar a transforma√ß√£o de Box-Cox para dados multivariados, dispon√≠vel no [material suplementar](http://www.ecography.org/appendix/ecog-03498) de Legendre & Borcard [-@legendre2018]. Esta transforma√ß√£o √© geralmente utilizada para tornar a distribui√ß√£o dos dados mais sim√©trica (menos enviesada para valores extremos: reduzir o *skewness* dos dados).

**An√°lises**

Vamos utilizar o mesmo conjunto de dados do Exemplo 1 para responder √† mesma pergunta. Aqui vamos utilizar a dist√¢ncia de Chord (que √© indicada para dados de composi√ß√£o de esp√©cies) para calcular a matriz de dist√¢ncia. Se transformarmos uma matriz usando a transforma√ß√£o Chord e depois calcularmos a dist√¢ncia Euclidiana, isso equivale √† calcular diretamente a dist√¢ncia de Chord (Figura \@ref(fig:fig-dend-boot-chor)).

```{r fig-dend-boot-chor, fig.cap="Dendrograma mostrando uma an√°lise de agrupamento de anuros com uma linha de corte criada por bootstrap e usando dist√¢ncia de Chord.", message=FALSE, warning=FALSE}
## Dados
head(t(sp_compos))

## Passo 1: transformar para dist√¢ncia de Chord
bocaina_transf <- disttransform(t(sp_compos), "chord")

## Passo 2: realizar pvclust com m√©todo average e dist√¢ncia euclidiana
analise <- pvclust(bocaina_transf, method.hclust = "average", method.dist = "euclidean", quiet = TRUE) 
## Passo 3: dendrograma
plot(analise, hang=-1, main = "Dendrograma com valores de P", 
     ylab = "Dist√¢ncia Euclideana",
     xlab="", sub="")
pvrect(analise)
```

√â poss√≠vel notar que existe um √∫nico grupo com BS \> 95%. Agora vamos tentar usar a dist√¢ncia de Hellinger, que √© recomendada (junto com a dist√¢ncia de Chord) para transformar dados de composi√ß√£o de esp√©cies [@legendre2001] (Figura \@ref(fig:fig-dend-boot-hell)).

```{r fig-dend-boot-hell, fig.cap="Dendrograma mostrando uma an√°lise de agrupamento de anuros com uma linha de corte criada por bootstrap e usando dist√¢ncia de Hellinger.", message=FALSE, warning=FALSE}
## Passo 1: transformar dados com Hellinger
bocaina_transf2 <- disttransform(t(bocaina), "hellinger")

## Passo 2: realizar pvclust com m√©todo average e dist√¢ncia euclidiana
analise2 <- pvclust(bocaina_transf2, method.hclust="average", method.dist="euclidean", quiet = TRUE) 

## Passo 3: dendrograma
plot(analise2, hang=-1, main = "Dendrograma com valores de P", 
     ylab = "Dist√¢ncia Euclideana",
     xlab="", sub="")
k <- 4
n <- ncol(sp_compos)
MidPoint <- (dendro$height[n-k] + dendro$height[n-k+1]) / 2
abline(h = MidPoint, lty=2)
pvrect(analise2)
```

**Interpreta√ß√£o dos resultados**

Notem que se mudarmos o coeficiente de associa√ß√£o, o resultado tamb√©m muda. Agora temos um grupo a mais, composto por *Dendropsophus minutus* e *Scinax duartei* que n√£o apareciam antes. Isso se deve ao fato de que a dist√¢ncia de Hellinger d√° menos peso para esp√©cies raras do que a Chord.

Neste sentido, os dados n√£o suportam a nossa hip√≥tese inicial da forma√ß√£o de dois grupos, independentemente do coeficiente de associa√ß√£o utilizado e do c√°lculo automatico do n√≠vel de corte baseado na reamostragem.

### Agrupamento n√£o-hier√°rquico (*K-means*)

Ao contr√°rio do dendrograma, o K-means √© um agrupamento n√£o-hier√°rquico e, desse modo, n√£o √© otimizado para busca grupos menores aninhados em grupos maiores. Resumidamente, podemos calcular o K-means a partir de uma matriz quadrada ou de dist√¢ncia. Essa t√©cnica procura particionar os objetos em *k* grupos de maneira a minimizar a soma de quadrados entre grupos e maximiz√°-la dentro dos grupos. Um crit√©rio similar ao de uma ANOVA (Cap√≠tulo \@ref(cap7)). Um diferencial do K-means em rela√ß√£o aos agrupamentos hier√°rquicos √© que o usu√°rio pode escolher antecipadamente o n√∫mero de grupos que deseja formar.

**Exemplo 1**

Para este exemplo, iremos utilizar um conjunto de dados dispon√≠vel no pacote `ade4` que cont√©m dados de 27 esp√©cies de peixes coletados em 30 pontos ao longo do Rio Doubs, na fronteira entre a Fran√ßa e Su√≠√ßa.

**Pergunta**

-   Qual √© o n√∫mero de grupos que melhor sumariza o padr√£o de ocorr√™ncia de esp√©cies de peixes ao longo de um riacho?

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Neste caso, estamos realizando uma an√°lise explorat√≥ria e n√£o temos uma predi√ß√£o.
:::

**Vari√°veis**

-   Vari√°veis resposta: composi√ß√£o de esp√©cies de peixes

**Checklist**

-   Vamos normalizar os dados de abund√¢ncia antes de entrar na an√°lise propriamente, j√° que existem muitos zeros na matriz

**An√°lises**

Vamos iniciar selecionando e padronizando os dados.

```{r message=FALSE, warning=FALSE}
## Mostrar somente seis primeiras esp√©cies de seis localidades
head(doubs$fish)[,1:6]

## Verificar se existem localidades sem nenhuma ocorr√™ncia
rowSums(doubs$fish)

## Retirar a linha 8 (rio sem nenhuma ocorr√™ncia de peixe)
spe <- doubs$fish[-8,]

## Fun√ß√£o do pacote vegan para normalizar os dados
spe.norm <- decostand(x = spe, method = "normalize") 
```

O argumento `centers` na fun√ß√£o `kmeans()` indica o n√∫mero de grupos que se quer formar. Neste exemplo, estamos utilizando `centers = 4`.

```{r}
## K-Means
spe.kmeans <- kmeans(x = spe.norm, centers = 4, nstart = 100)
spe.kmeans
```

O objeto que fornece o resultado cont√©m: i) o tamanho (n√∫mero de objetos) em cada um dos 4 grupos, ii) o centroide de cada grupo e o pertencimento de cada esp√©cie a cada grupo, e iii) o quanto da Soma de Quadrados dos dados √© explicada por esta conforma√ß√£o de grupos.

No entanto, n√£o √© poss√≠vel saber *a priori* qual o n√∫mero "ideal" de grupos. Para descobrir isso, repetimos o k-means com uma s√©rie de valores de **K**. Isso pode ser feito na fun√ß√£o `cascadeKM()`.

```{r}
## Repetindo o K-Means
spe.KM.cascade <- cascadeKM(spe.norm, inf.gr = 2, sup.gr = 10, iter = 100, criterion = "ssi") 
```

Tanto **calinski** quando **ssi** s√£o bons crit√©rios para encontrar o n√∫mero ideal de grupos. Quanto maior o valor de **ssi**, melhor (veja `?cascadeKM()` mais detalhes). Os valores de ssi √© o crit√©rio utilizado pelo algor√≠timo para achar o agrupamento √≥timo dos objetos (Figura \@ref(fig:fig-kmeans)).

```{r fig-kmeans, fig.cap="Gr√°ficos mostrando os resultados da an√°lise de K-Means.", message=FALSE, warning=FALSE}
## Resumo dos resultados
spe.KM.cascade$results

## Gr√°fico
plot(spe.KM.cascade, sortg = TRUE)
```

**Interpreta√ß√£o dos resultados**

Diferentemente da nossa predi√ß√£o inicial, o resultado da an√°lise mostra que o n√∫mero ideal de grupos para explicar a vari√¢ncia no padr√£o de ocorr√™ncia de esp√©cies √© 3. Notem que o SSI m√°ximo √© alcan√ßado neste n√∫mero de grupos `r spe.KM.cascade$results[2, 2]` (tamb√©m indicado pela bola vermelha no plot).

### Esp√©cies indicadoras

Uma pergunta normalmente feita por ec√≥logos √©: qual esp√©cie pode ser indicadora de uma determinada condi√ß√£o ambiental (e.g., polui√ß√£o)?

O √≠ndice IndVal mede dois aspectos das esp√©cies: fidelidade e especificidade. Uma alta fidelidade significa que esp√©cies ocorrem em todos os locais do grupo, e uma alta especificidade significa que as esp√©cies ocorrem somente naquele grupo. Uma boa esp√©cie indicadora √© aquela na qual todos os indiv√≠duos ocorrem em todas a amostras referentes a um grupo espec√≠fico. A especificidade √© dada pela divis√£o da abund√¢ncia m√©dia da esp√©cie no grupo pela somat√≥rio das abund√¢ncias m√©dias dos grupos. Fidelidade √© igual ao n√∫mero de lugares no grupo onde a esp√©cie est√° presente dividido pelo n√∫mero total de lugares do grupo [@dufrene_species_1997].

Esp√©cies raras podem receber o mesmo valor de IndVal das esp√©cies indicadoras, por√©m s√£o chamadas de indicadoras assim√©tricas, uma vez que contribuem com a especificidade do habitat, mas n√£o servem para predizer grupos. Ao contr√°rio, as esp√©cies indicadoras s√£o verdadeiros indicadores sim√©tricos e podem ser usadas para predizer grupos.

A an√°lise procede da seguinte forma:

1.  Uma matriz de dist√¢ncia √© constru√≠da e as unidades amostrais s√£o classificadas com alguma an√°lise de agrupamento, hier√°rquico ou n√£o

2.  A vari√°vel ambiental para a qual se deseja classificar os grupos √© inserida

3.  As esp√©cies indicadoreas de cada grupo s√£o formadas atrav√©s do c√°lculo da especificidade e fidelidade, obtendo-se o valor de IndVal para cada esp√©cie

4.  Por fim, o conjunto de dados originais √© comparado para ver se a an√°lise faz sentido

O c√°lculo da signific√¢ncia do √≠ndice de IndVal √© feito por aleatoriza√ß√£o de Monte Carlo. Os m√©todos de Monte Carlo utilizam n√∫meros aleat√≥rios de dados reais para simular certos padr√µes esperados na aus√™ncia de um processo ecol√≥gico espec√≠fico [@legendre_numerical_2012]. Assim, o valor do √≠ndice √© aleatorizado 999 vezes (ou o n√∫mero de vezes que voc√™ optar) dentro dos tratamentos e o valor de *P* √© dado pelo n√∫mero de vezes em que o √≠ndice observado foi igual ou maior que os valores aleatorizados. Portanto, o IndVal fornece um conjunto de esp√©cies que s√£o indicadoras de um grupo de locais (e.g., muito polu√≠dos), que por sua vez precisam ser definidos utilizando alguma t√©cnica de agrupamento, como as que vimos anteriormente.

**Exemplo 1**

Para este exemplo, vamos usar o mesmo conjunto de dados utilizado acima com abund√¢ncia de 16 esp√©cies de girinos coletados em 14 po√ßas com diferentes graus de cobertura de dossel na Serra da Bocaina [@provete_broad-scale_2014].

**Pergunta**

-   Podemos utilizar as esp√©cies de girinos como indicadoras da fitofisionomia?

**Predi√ß√µes**

-   Esp√©cies terrestres ser√£o indicadoras de √°rea aberta, enquanto esp√©cies arbor√≠colas ser√£o indicadoras de √°reas florestais

**Vari√°veis**

-   Vari√°veis resposta: mesma matriz j√° utilizada contendo a abund√¢ncia de girinos ao longo de po√ßas na Serra da Bocaina

**An√°lises**

O IndVal est√° dispon√≠vel tanto no pacote `indicspecies`, quando no `labdsv`. Para este exemplo, iremos usar o `labdsv`. Primeiro, vamos agrupar as unidades amostrais (po√ßas) que informa os grupos de fitofisionomias onde as po√ßas se localizam e para os quais deseja-se encontrar esp√©cies indicadoras.

```{r}
## Dados
head(bocaina)
fitofis <- c(rep(1, 4), rep(2, 4), rep(3, 4), rep(4, 4), rep(5, 4))

## An√°lise de esp√©cies indicadoras
res_indval <- indval(t(sp_compos), fitofis)

# A fun√ß√£o summary s√≥ exibe o resultado para as esp√©cies indicadoras
summary(res_indval)
```

Para apresentar uma tabela dos resultados para todas as esp√©cies temos de processar os dados.

```{r}
## Resultados
res_indval$maxcls # classe de maior valor indicador/esp√©cie 
res_indval$indcls # valor indicador (indval)
res_indval$pval # signific√¢ncia do indval
tab_indval <- cbind.data.frame(maxcls = res_indval$maxcls,
                               ind.value = res_indval$indcls,
                               P = res_indval$pval)
tab_indval

## Esp√©cies
tab_indval[tab_indval$P < 0.05, ]
```

**Interpreta√ß√£o dos resultados**

No resultado apresentado, podemos ver que temos duas esp√©cies indicadoras da fitofisionimia 1: *Rhinella icterica* (Rict) e *Scinax duartei* (Sduar). Nenhuma esp√©cie foi indicadora dos outros grupos neste exemplo.

## An√°lises de Ordena√ß√£o

As an√°lises de ordena√ß√£o representam um conjunto de m√©todos e t√©cnicas multivariadas que organizam objetos (e.g., localidades, indiv√≠duos) em alguma ordem considerando o conjunto de descritores que podem estar mais ou menos relacionados entre si. Se os descritores estiverem bem relacionados, eles s√£o redundantes e organizam os objetos de forma similar. Esse fen√¥meno √© observado, por exemplo, quando queremos organizar um conjunto de unidades amostrais baseado em vari√°veis que indicam um mesmo processo: ver o padr√£o de similaridade geral de lagos usando v√°rias vari√°veis relacionada com a produtividade do sistema: clorofila-a, concentra√ß√£o de f√≥sforo, nitrog√™nio, entre outros. Por exemplo, tais m√©todos permitem identificar se existem grupo de esp√©cies que ocorrem exclusivamente em um determinado h√°bitat. Ao buscar esta *ordem*, as t√©cnicas de ordena√ß√£o possuem tr√™s principais utilidades: i) reduzir a dimensionalidade e revelar padr√µes, ii) separar as vari√°veis mais e menos importantes em combina√ß√µes complexas e iii) separar rela√ß√µes mais e menos fortes ao comparar vari√°veis preditoras e dependentes. 

Em geral, os m√©todos s√£o divid√≠dos em ordena√ß√µes irrestritas (ou an√°lise de gradiente indireto) e restritas (ou an√°lise de gradiente direto). As ordena√ß√µes irrestritas organizam os objetos (e.g., esp√©cies) de acordo com sua estrutura de covari√¢ncia (ou correla√ß√£o), o que demonstra que a proximidade (ou dist√¢ncia) dentro do espa√ßo multidimensional representa semelhan√ßa (ou diferen√ßa) dos objetos. Por outro lado, as ordena√ß√µes restritras posicionam os objetos (e.g., esp√©cies) de acordo com sua rela√ß√£o linear com outras vari√°veis coletadas nas mesmas unidades amostraits (e.g., temperatura e precipita√ß√£o). Ao passo que as ordena√ß√µes irrestritas dependem somente de uma matriz (e.g., esp√©cies por localidades), as ordena√ß√µes restritas utilizam no m√≠nimo duas matrizes (e.g., esp√©cies por localidades e vari√°veis clim√°ticas por localidade). Desse modo, fica claro esta diferen√ßa entre os dados utilizados que as an√°lises irrestritas s√£o mais explorat√≥rias, enquanto an√°lises restritas s√£o ideais para testar hip√≥teses com dados multidimensionais. A tabela a seguir apresenta as principais an√°lises utilizadas em ecologia.

+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| M√©todo                   | Tipo de vari√°vel                                                                                                    | Fun√ß√£o R           |
+==========================+=====================================================================================================================+====================+
| **Ordena√ß√£o irrestrita** |                                                                                                                     |                    |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| PCA                      | Vari√°veis cont√≠nuas (dist√¢ncia euclidiana)                                                                          | `PCA()`, `rda()`, `dudi.pca()` |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| PCoA                     | Aceita qualquer tipo de vari√°vel, mas depende da escolha apropriada de uma medida de dist√¢ncia                      | `pcoa()`, `dudi.pco()`     |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| nMDS                     | Aceita qualquer tipo de vari√°vel, mas depende da escolha apropriada de uma medida de dist√¢ncia                      | `metaMDS()`, `nmds()`      |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| CA                       |                                                                                                                     | `dudi.coa()`           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| Hill-Smith               | Aceita qualquer tipo de vari√°vel                                                                                    | `dudi.hillsmith()`     |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| **Ordena√ß√£o restrita**   |                                                                                                                     |                    |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| RDA                      | Vari√°veis preditoras de qualquer tipo e vari√°veis dependentes cont√≠nuas (ou presen√ßa e aus√™ncia)                    | `rda()`                |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| RDA parcial              | Vari√°veis preditoras de qualquer tipo e vari√°veis dependentes cont√≠nuas (ou presen√ßa e aus√™ncia)                    | `rda()`                |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| dbRDA                    | Vari√°veis preditoras de qualquer tipo e matriz de dist√¢ncia obtida a partir das vari√°veis dependentes               | `capscale()`, `dbrda()`   |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| CCA                      | Vari√°veis preditoras de qualquer tipo e vari√°veis dependentes cont√≠nuas (ou presen√ßa e aus√™ncia)                    | `rda()`               |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| PERMANOVA                | Vari√°veis preditoras de qualquer tipo e matriz de dist√¢ncia obtida a partir das vari√°veis dependentes               | `adonis()`, `adonis2()`    |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+
| PCR                      | Vari√°vel dependente necessariamente representada por escores da PCA ou PCoA e vari√°veis preditoras de qualquer tipo | `pca()`, `pcoa()`, `lm()`, `glm()` |
+--------------------------+---------------------------------------------------------------------------------------------------------------------+--------------------+

## Ordena√ß√£o irrestrira

Ordena√ß√µes irrestritas, ou an√°lise de gradiente indireto ou ainda an√°lises de fator, s√£o um conjunto de m√©todos multivariados que lidam com uma √∫nica matriz quadrada. Esta matriz pode ou n√£o ter pesos nas linhas ou colunas. Geralmente, o objetivo deste tipo de an√°lise √© resumir a informa√ß√£o contida na matriz de maneira gr√°fica, por meio de um diagrama de ordena√ß√£o. Quanto maior e mais complexa for a matriz, mais eficiente √© este tipo de an√°lise. Os tipos de an√°lise ir√£o diferir de acordo com o tipo de dado contido nesta matriz, se cont√≠nuo ou contagem, etc. De maneira geral, essas ordena√ß√µes irrestritas calculam combina√ß√µes lineares, cuja formula√ß√£o ir√° diferir ligeiramente entre os m√©todos. Da mesma forma, essas combina√ß√µes lineares ir√£o preservar um tipo de dist√¢ncia. Por exemplo, a An√°lise de Componentes Principais preserva a dist√¢ncia Euclidiana, enquanto a An√°lise de Correspond√™ncia preserva a dist√¢ncia de chi-quadrado.

### An√°lise de Componentes Principais (PCA)

A An√°lise de Componentes Principais (*Principal Component Analysis* - PCA) √© uma das ordena√ß√µes mais utilizadas em diversas √°reas do conhecimento. Em Ecologia, ela se popularizou por facilitar a visualiza√ß√£o de dados complexos como de distribui√ß√£o de esp√©cies em diferentes localidades e de potenciais vari√°veis explicativas. Ao mesmo tempo que ganhou tamanha popularidade, a PCA tem sido empregada de maneira incorreta, uma vez que muitos estudos utilizam a visualiza√ß√£o gr√°fica da ordena√ß√£o (o biplot) para intepretar "rela√ß√µes" entre vari√°veis preditoras (ambientais) e dependentes (esp√©cies). Por√©m, como informado anteriormente, as ordena√ß√µes irrestritas utilizam a estrutura de covari√¢ncia dos objetos para organizar suas rela√ß√µes de similaridade.

Antes de explicar a an√°lise, imagine que vamos usar uma matriz com cinco esp√©cies de aranhas que foram encontradas em oito cidades diferentes. A quantidade de indiv√≠duos de cada esp√©cie coletada em cada cidade ser√° o valor de preenchimento desta matriz. Sendo assim, a matriz possui oito objetos (cidades, representando unidades amostrais) e cinco descritores (esp√©cies), como na Tabela \@ref(tab:tab-pca-dados).

```{r tab-pca-dados, echo=FALSE}
knitr::kable(data.frame(
    Cidade = paste("Cidade", 1:8),
    `Esp√©cie 1` = c(5, 7, 2, 0, 0, 0, 0, 0),
    `Esp√©cie 2` = c(0, 6, 3, 4, 0, 0, 0, 0),
    `Esp√©cie 3` = c(0, 0, 0, 9, 12, 3, 0, 0),
    `Esp√©cie 4` = c(0, 0, 0, 0, 4, 10, 8, 0),
    `Esp√©cie 5` = c(0, 0, 0, 0, 0, 6, 9, 12)),
    align = "c",
    caption = "Matriz com cinco esp√©cies de aranhas que foram encontradas em oito cidades diferentes.")
```

O primeiro passo da PCA √© obter uma matriz centralizada, onde cada valor √© subtra√≠do da m√©dia da coluna que aquele valor pertence. Esta centraliza√ß√£o pode ser calculada com a fun√ß√£o `scale()`.

```{r}
## Dados
aranhas <- data.frame(
    sp1 = c(5, 7, 2, 0, 0, 0, 0, 0),
    sp2 = c(0, 6, 3, 4, 0, 0, 0, 0),
    sp3 = c(0, 0, 0, 9, 12, 3, 0, 0),
    sp4 = c(0, 0, 0, 0, 4, 10, 8, 0),
    sp5 = c(0, 0, 0, 0, 0, 6, 9, 12),
    row.names = paste0("cidade", 1:8))

## Centraliza√ß√£o
aranha.cent <- as.data.frame(base::scale(aranhas, center = TRUE, scale=FALSE))
```

O segundo passo √© calcular uma matriz de covari√¢ncia (ou matriz de dispers√£o) e, a partir desta matriz, obter os autovalores e autovetores. Os autovalores representam a porcentagem de explica√ß√£o de cada eixo e podem ser calculados dividindo a soma do autovalor de cada eixo pela soma de todos os autovalores. No exemplo que apresentamos, os dois primeiros eixos representam 47,20% e 35,01% de toda varia√ß√£o, respectivamente. Os autovetores, por sua vez, representam os valores que multiplicam as vari√°veis originais e, desse modo, indicam a dire√ß√£o desses valores. Por fim, os componentes principais (Matriz F) s√£o obtidos multiplicando os autovetores com os valores da matriz centralizada.

```{r}
## Matriz de covai√¢ncia
matriz_cov <- cov(aranha.cent)

## Autovalores e autovetores
eigen_aranhas <- eigen(matriz_cov)
autovalores <- eigen_aranhas$values
autovetores <- as.data.frame(eigen_aranhas$vectors)
autovalores # eigenvalue
colnames(autovetores) <- paste("PC", 1:5, sep="")
rownames(autovetores) <- colnames(aranhas)
autovetores

## Componentes principais
matriz_F <- as.data.frame(as.matrix(aranha.cent) %*% as.matrix(autovetores))
matriz_F

## Porcentagem de explica√ß√£o de cada eixo
100 * (autovalores/sum(autovalores))
```

Agora, √© poss√≠vel visualizar a rela√ß√£o entre as cidades e similaridade na esp√©cies de aranhas que vivem em cada uma delas (Figura \@ref(fig:fig-pca)).

```{r fig-pca, fig.cap="Biplot da PCA ordenando as cidades pela composi√ß√£o das esp√©cies de aranhas.", message=FALSE, warning=FALSE}
## Gr√°fico
ggplot(matriz_F, aes(x = PC1, y = PC2, label = rownames(matriz_F))) +
    geom_label() + 
    geom_hline(yintercept = 0, linetype=2) +
    geom_vline(xintercept = 0, linetype=2) +
    tema_livro()
```

**Checklist**

-   Verifique se todas as vari√°veis utilizadas s√£o cont√≠nuas. Caso contr√°rio, considere utilizar PCoA (veja mais no pr√≥ximo t√≥pico)

-   Apesar do exemplo acima ter apresentado a ocorr√™ncia de esp√©cies de aranhas em diferentes cidades, √© fundamental saber que utilizar a PCA com esses dados pode ser problem√°tico. Assim, tenha cuidado em usar dados de composi√ß√£o de esp√©cies, especialmente abund√¢ncia, com PCA, uma vez que 'duplos zeros' podem gerar distor√ß√µes na ordena√ß√£o [@legendre_numerical_2012]. Como alternativa, √© poss√≠vel utilizar PCA com dados padronizados com o m√©todo de Hellinger [@legendre2001].

**Exemplo 1**

Neste exemplo vamos utilizar um conjunto de dados morfol√≥gicos de pinguins do arquip√©lago Palmer (Pen√≠nsula Ant√°rtica) dispon√≠veis no pacote 'palmerpenguins'. Os dados representam medidas do comprimento e largura do bico (mm), comprimento da nadadeira (mm) e massa corporal (gramas) de tr√™s esp√©cies: Ad√©lie, Chinstrap e Gentoo. Como descrito acima, a PCA deve ser utilizada para explora√ß√£o de dados ou para testes *a posteriori* (e.g., Regress√£o de Componentes Principais - PCR, t√≥pico explorado mais a frente nesse cap√≠tulo). Neste exemplo, iremos usar a estrutura de perguntas e predi√ß√µes para manter a proposta do livro.

**Pergunta**

-   Existe diferen√ßas nas caracter√≠sticas morfol√≥gicas das esp√©cies de pinguins do arquip√©lago Palmer?

**Predi√ß√µes**

-   Pinguins com dieta diferente possuem diferentes caracter√≠sticas morfol√≥gicas

**Vari√°veis**

-   Preditora: esp√©cie (categ√≥rica com tr√™s n√≠veis)
-   Dependentes: vari√°veis morfol√≥gicas (cont√≠nua)

**An√°lises**

Antes de come√ßar, √© necess√°rio remover dados ausentes (se houver) e editar nomes das vari√°veis (ponto importante para determinar como devem aparecer no gr√°fico).

```{r message=FALSE, warning=FALSE}
## Verificar se existem NAs nos dados
sum(is.na(penguins))

## Remover dados ausentes (NA), quando houver
penguins <- na.omit(penguins)

## Manter somentes dados cont√≠nuos que pretende aplicar a PCA
penguins_trait <- penguins[, 3:6]
```

Agora sim, os dados est√£o prontos para fazer a PCA. Um argumento √© essencial na an√°lise, o `scale.unit`. Se voc√™ utilizar dentro deste argumento o sele√ß√£o `TRUE`, a fun√ß√£o padroniza automaticamente as vari√°veis para terem a m√©dia 0 e vari√¢ncia 1. Esta padroniza√ß√£o √© essencial quando as vari√°veis est√£o em escalas muito diferentes. No exemplo selecionado, temos vari√°veis como comprimento do bico (em mil√≠metros) e massa corporal (em gramas).

```{r message=FALSE, warning=FALSE}
## Compare com este c√≥digo a vari√¢ncia das vari√°veis
penguins_trait %>% 
    dplyr::summarise(across(where(is.numeric), 
                            ~var(.x, na.rm = TRUE)))

## Agora, veja o mesmo c√°lculo se fizer a padroniza√ß√£o (scale.unit da fun√ß√£o PCA)
penguins_pad <- decostand(x = penguins_trait, method = "standardize")
penguins_pad %>% 
    dplyr::summarise(across(where(is.numeric), 
                            ~var(.x, na.rm = TRUE)))

## PCA
pca.p <- PCA(X = penguins_trait, scale.unit = TRUE, graph = FALSE)
```

Apesar da simplicidade do c√≥digo para executar a PCA, o objeto resultante da an√°lise possui diversas informa√ß√µes que s√£o essenciais para sua plena interpreta√ß√£o. Dentre elas, se destacam os autovalores, escores e cargas (*loadings*). Os autovalores representam a porcentagem de explica√ß√£o de cada eixo. Os escores representam as coordenadas (posi√ß√µes no espa√ßo multidimensional) representando os objetos (geralmente localidades ou indiv√≠duos) e descritores (geralmente esp√©cies ou vari√°veis ambientais e espaciais). Os *loadings*, por sua vez, representam a combina√ß√£o linear entre os escores (nova posi√ß√£o do valor do descritor no espa√ßo ordenado) e os valores originais dos descritores (Figura \@ref(fig:fig-pca-scree)).

```{r fig-pca-scree, fig.cap="Scree plot mostrando a porcentagem de contribui√ß√£o de cada eixo para a ordena√ß√£o dos dados de penguins.", message=FALSE, warning=FALSE}
## Autovalores: porcentagem de explica√ß√£o para usar no gr√°fico
pca.p$eig 

## Visualiza√ß√£o da porcentagem de explica√ß√£o de cada eixo
# nota: √© necess√°rio ficar atento ao valor m√°ximo do eixo 1 da an√°lise para determinar o valor do ylim (neste caso, colocamos que o eixo varia de 0 a 70).
fviz_screeplot(pca.p, addlabels = TRUE, ylim = c(0, 70), main = "", 
               xlab = "Dimens√µes",
               ylab = "Porcentagem de vari√¢ncia explicada") 
## Outros valores importantes
var_env <- get_pca_var(pca.p)

## Escores (posi√ß√£o) das vari√°veis em cada eixo
var_env$coord 

## Contribui√ß√£o (%) das vari√°veis para cada eixo
var_env$contrib 

## Loadings - correla√ß√£o das vari√°veis com os eixos
var_env$cor 

## Qualidade da representa√ß√£o da vari√°vel. Esse valor √© obtido multiplicado var_env$coord por var_env$coord
var_env$cos2

## Escores (posi√ß√£o) das localidades ("site scores") em cada eixo 
ind_env <- get_pca_ind(pca.p)
```

O pacote `FactoMineR` criou uma fun√ß√£o (`dimdesc()`) que seleciona as melhores vari√°veis (aquelas mais explicativas) para cada eixo atrav√©s de uma an√°lise fatorial. No exemplo com pinguins, o primeiro eixo (objeto `pca.p$eig`) explica \~69% da varia√ß√£o morfol√≥gica. A fun√ß√£o `dimdesc()` mostra que as quatro vari√°veis morfol√≥gicas est√£o fortemente associadas com o eixo 1. Por√©m, enquanto comprimento da nadadeira, massa corporal e comprimento do bico est√£o positivamente associados com o eixo 1 (correla√ß√£o positiva), a largura do bico tem rela√ß√£o negativa. O eixo 2, por sua vez, explica \~20% da varia√ß√£o, sendo relacionado somente com largura e comprimento do bico.

```{r message=FALSE, warning=FALSE}
## Vari√°veis mais importantes para o Eixo 1
dimdesc(pca.p)$Dim.1 

## Vari√°veis mais importantes para o Eixo 2
dimdesc(pca.p)$Dim.2 
```

Agora podemos utilizar o famoso **biplot** para representar a compara√ß√£o morfol√≥gica dos pinguins dentro e entre esp√©cies (Figura \@ref(fig:fig-pca-biplot)).

```{r fig-pca-biplot, fig.cap="Biplot da PCA ordenando os dados morfol√≥gicos de penguins.", message=FALSE, warning=FALSE}
fviz_pca_biplot(X = pca.p, 
                geom.ind = "point", 
                fill.ind = penguins$especies, 
                col.ind = "black",
                alpha.ind = 0.7,
                pointshape = 21, 
                pointsize = 4,
                palette = c("darkorange", "darkorchid", "cyan4"),
                col.var = "black",
                invisible = "quali",
                title = NULL) +
    labs(x = "PC1 (68.63%)", y = "PC2 (19.45%)") + 
    xlim(c(-3, 4)) +
    ylim(c(-3, 3)) +
    tema_livro()
```

### An√°lises de Coordenadas Principais (PCoA)

Diferentemente da PCA, a An√°lises de Coordenadas Principais (*Principal Coordinate Analysis* - PCoA) √© uma an√°lise de ordena√ß√£o irrestrita que aceita dados de diferentes tipos, como cont√≠nuos, categ√≥ricos, ordinais, bin√°rios, entre outros. Assim, a PCoA √© aplicada para casos em que a dist√¢ncia euclidiana n√£o √© aplicada (como na PCA). Desse modo, o primeiro passo da an√°lise √© calcular uma matriz de similaridade ou de dist√¢ncia (discutido acima). Depois, os passos para obter autovalores e autovetores s√£o bastante parecidos com a PCA. Da mesma forma, os eixos da PCoA e os valores ou posi√ß√µes dos objetos nesses eixos representam a rela√ß√£o de semelhan√ßa (ou diferen√ßa) baseada nos descritores desses objetos. A diferen√ßa, neste caso, √© que a PCoA representa um espa√ßo n√£o-euclidiano, que ir√° ser afetado pela escolha do m√©todo de similaridade.

As utiliza√ß√µes mais comuns da PCoA s√£o a ordena√ß√£o: i) da matriz de composi√ß√£o de esp√©cies usando a dist√¢ncia apropriada (Jaccard, Sorensen, Bray-Curtis), ii) da matriz de vari√°veis ambientais com mistos (cont√≠nuos, categ√≥ricos, circulares, etc.), e iii) da matriz filogen√©tica [m√©todo PVR @diniz-filho_eigenvector_1998]. Abaixo, exemplificamos a ordena√ß√£o da matriz de composi√ß√£o de esp√©cies.

**Checklist**

-   Compare as dimens√µes das matrizes utilizadas para a PCoA. Com bastante frequ√™ncia, a tentativa de combinar dados categ√≥ricos (algum descritor dos objetos) com os valores obtidos com a PCoA gera erros para plotar a figura ou para executar a an√°lise. Verifique, ent√£o, se as linhas s√£o as mesmas (nome das localidades ou indiv√≠duos e quantidade)

-   √â fundamental conhecer o tipo de dados que est√° usando para selecionar a medida de dist√¢ncia apropriada. Essa escolha vai afetar a qualidade da ordena√ß√£o e sua habilidade para interpretar a rela√ß√£o de semelhan√ßa entre os objetos comparados

-   Diferente da PCA, a PCoA aceita dados ausentes se a medida de dist√¢ncia escolhida tamb√©m n√£o tiver esta limita√ß√£o. Por exemplo, a dist√¢ncia de Gower produz matrizes de similaridade mesmo com dados ausentes em determinados objetos

-   Em alguns casos, autovalores negativos s√£o produzidos na ordena√ß√£o com PCoA. Veja as principais causas desses valores em Legendre & Legendre [-@legendre_numerical_2012]. Apesar deste problema, os autovalores mais importantes (eixos iniciais) n√£o s√£o afetados e, deste modo, a qualidade da representa√ß√£o dos objetos no espa√ßo multidimensional n√£o √© afetada. Alguns autores sugerem utilizar corre√ß√µes m√©todos de corre√ß√£o, como Lingoes ou Cailliez [@legendre_numerical_2012].

**Exemplo 1**

Neste exemplo, vamos utilizar a composi√ß√£o de √°caros Oribatidae em 70 manchas de musgo coletados por Borcard et al. [-@borcard_partialling_1992].

**Pergunta**

-   A composi√ß√£o de esp√©cies de √°caros muda entre diferentes topografias?

**Predi√ß√µes**

-   Iremos encontrar ao menos dois grupos de esp√©cies: aquelas que ocorrem em po√ßas dentro de floresta *versus* aquelas que ocorrem em po√ßas de √°reas abertas

**Vari√°veis**

-   Preditora: topografia (categ√≥rica com dois n√≠veis)
-   Dependentes: composi√ß√£o de esp√©cies de √°caro

**An√°lises**

Vamos primeramente padronizar dos dados, calcular uma matriz de dist√¢ncia com m√©todo Bray-Curtis e depois calcular a PCoA.

```{r message=FALSE, warning=FALSE}
## Padroniza√ß√£o dos dados com Hellinger
mite.hel <- decostand(x = mite, method = "hellinger") 

## C√°lculo da matriz de dist√¢ncia com m√©todo Bray-Curtis
sps.dis <- vegdist(x = mite.hel, method = "bray") 

## PCoA
pcoa.sps <- pcoa(D = sps.dis, correction = "cailliez")
```

Assim como na PCA, a porcentagem de explica√ß√£o dos eixos √© uma das informa√ß√µes mais importantes pois descrevem a efetividade da redu√ß√£o da dimensionalidade dos dados.

```{r message=FALSE, warning=FALSE}
## Porcentagem de explica√ß√£o do Eixo 1
100 * (pcoa.sps$values[, 1]/pcoa.sps$trace)[1]

## Porcentagem de explica√ß√£o dos Eixo 2
100 * (pcoa.sps$values[, 1]/pcoa.sps$trace)[2]

## Porcentagem de explica√ß√£o acumulada dos dois primeiros eixos 
sum(100 * (pcoa.sps$values[, 1]/pcoa.sps$trace)[1:2])

## Selecionar os dois primeiros eixos
eixos <- pcoa.sps$vectors[, 1:2]

## Juntar com algum dado categ√≥rico de interesse para fazer a figura
pcoa.dat <- data.frame(topografia = mite.env$Topo, eixos)
```

Para visualizar os resultados da PCoA, vamos exportar os escores dos eixos para usar no pacote `ggplot2` (Figura \@ref(fig:fig-pcoa-biplot)).

```{r fig-pcoa-biplot, fig.cap="Biplot da PCoA ordenando as esp√©cies de √°caros entre diferentes topografias.", message=FALSE, warning=FALSE}
## Escores dos dois primeiros eixos
eixos <- pcoa.sps$vectors[, 1:2] 

## Combinar dados dos escores com um dado categ√≥rico de interesse para nossa pergunta
pcoa.dat <- data.frame(topografia = mite.env$Topo, eixos)

### Gr√°fico biplot da PCoA
ggplot(pcoa.dat, aes(x = Axis.1, y = Axis.2, fill = topografia, 
                     color = topografia, shape = topografia)) +
    geom_point(size = 4, alpha = 0.7) + 
    scale_shape_manual(values = c(21, 22)) + 
    scale_color_manual(values = c("black", "black")) + 
    scale_fill_manual(values = c("darkorange", "cyan4")) + 
    labs(x = "PCO 1 (49.11%)", y = "PCO 2 (14.30%)") + 
    geom_hline(yintercept = 0, linetype = 2) + 
    geom_vline(xintercept = 0, linetype = 2) +
    tema_livro()
```

**Limita√ß√µes importantes das ordena√ß√µes irrestritas**

Com frequ√™ncia, pesquisadores utilizam an√°lises como PCA e PCoA para "testar" diferen√ßas na composi√ß√£o de esp√©cies entre determinados fatores relevantes (altitude, clima, etc.). Por√©m, como falado acima, as an√°lises de ordena√ß√£o irrestritas n√£o s√£o utilizadas para testar qualquer hip√≥tese. Ao inv√©s disso, essas an√°lises representam uma poderosa ferramente para explorar padr√µes em vari√°veis dependentes ou independentes para ajudar na interpreta√ß√£o ou mesmo para testar hip√≥teses em an√°lises combinadas com as ordena√ß√µes restritas.

### Regress√£o de Componentes Principais (PCR)

Uma maneira de testar hip√≥teses utilizando ordena√ß√µes irrestritas √© utilizando os resultados da ordena√ß√£o (escores) como vari√°veis preditoras ou dependentes como, por exemplo, em modelos lineares (e.g., regress√£o m√∫ltipla Cap√≠tulo \@ref(cap7)). O primeiro passo √© utilizar uma ordena√ß√£o, como a PCA, para gerar os "novos" dados que ser√£o usados na an√°lise. A utiliza√ß√£o desses novos dados (que representam as coordenadas principais ou escores da PCA) vai depender da pergunta em quest√£o. Por exemplo, pode ser que esses valores representem gradientes clim√°ticos e, por este motivo, ser√£o utilizados como vari√°veis preditoras em um modelo linear (e.g., regress√£o m√∫ltipla). Por outro lado, esses valores podem representar o espa√ßo morfol√≥gicos de esp√©cies de peixes e, como consequ√™ncia, ser√£o utilizados como vari√°veis dependentes para entender o efeito da presen√ßa de predador sobre a morfologia. √â importante ressaltar que existem algumas limita√ß√µes importantes na PCR como, por exemplo, as coordenadas principais (escores da PCA) utilizadas como vari√°veis preditoras podem n√£o representam, biologicamente, as mais importantes para explicar a varia√ß√£o na vari√°vel resposta [@hadi_cautionary_1998].   


**Checklist**

-   Compare as dimens√µes das matrizes utilizadas para a PCR. Com bastante frequ√™ncia, a tentativa de combinar dados categ√≥ricos (algum descritor dos objetos) com os valores obtidos com a PCoA gera erros para plotar a figura ou para executar a an√°lise. Verifique, ent√£o, se as linhas s√£o as mesmas (nome das localidades ou indiv√≠duos e quantidade)

-   Estudos recentes t√™m criticado a utiliza√ß√£o de PCR para testar hip√≥teses ecol√≥gicas pelo fato dos escores n√£o representarem, necessariamente, a varia√ß√£o total das vari√°veis originais, bem como a rela√ß√£o entre a vari√°vel preditora e a dependente

**Exemplo 1**

Neste exemplo, vamos utilizar a composi√ß√£o de esp√©cies de aves em 23 regi√µes dos alpes franceses. Os dados ambientais (env) representam vari√°veis clim√°ticas (temperatura e chuva) e altitude.

**Pergunta**

-   Gradientes clim√°ticos afetam a riqueza de aves?

**Predi√ß√µes**

-   O aumento da umidade e redu√ß√£o da temperatura aumentam o n√∫mero de esp√©cies de aves

**Vari√°veis**

-   Preditora: temperatura e chuva (cont√≠nuas) e altitude (categ√≥rica com tr√™s n√≠veis)
-   Dependentes: riqueza de esp√©cies de aves

```{r message=FALSE, warning=FALSE}
## Dados
env_cont <- env[,-8]
env.pca <- PCA(env_cont, scale.unit = TRUE, graph = FALSE)
var_env <- get_pca_var(env.pca) 

## Contribui√ß√£o (%) das vari√°veis para cada eixo
var_env$contrib 

## Loadings - correla√ß√£o das vari√°veis com os eixos
var_env$cor 
ind_env <- get_pca_ind(env.pca)
env.pca$eig 
```

O objeto `env.pca$eig` demonstra que os tr√™s primeiros eixos explicam 94.54% da varia√ß√£o total dos dados clim√°ticos. O intuito da PCR √© reduzir a dimensionalidade, ou seja, o n√∫mero de vari√°veis preditoras ou depedentes para facilitar a interpreta√ß√£o e garantir que as vari√°veis n√£o sejam correlacionadas. O pr√≥ximo passo ent√£o √© obter os valores dos escores que representam os valores convertidos para serem usados em uma determinada an√°lise, como a regress√£o m√∫ltipla.

```{r}
## Passo 1: obter os primeiros eixos 
pred.env <- ind_env$coord[, 1:3] 

## Passo 2: calcular a riqueza de esp√©cies
riqueza <- specnumber(species)

## Passo 3: combinar os dois valores em um √∫nico data.frame
dat <- data.frame(pred.env, riqueza) 
```

Agora que os dados foram combinados em uma √∫nico data frame, podemos utilizar os c√≥digos apresentados no Cap√≠tulo \@ref(cap7) para testar nossa hip√≥tese (Figura \@ref(fig:fig-pcr-aves-diag)).

```{r fig-pcr-aves-diag, fig.cap="Diagn√≥sticos dos modelo PCR para aves.", message=FALSE, warning=FALSE}
## Regress√£o m√∫ltipla
mod1 <- lm(riqueza ~ Dim.1 + Dim.2 + Dim.3, data = dat)
par(mfrow = c(2, 2))
plot(mod1) # verificar pressupostos dos modelos lineares
summary(mod1) # resultados do  teste
dimdesc(env.pca)$Dim.1 
```

Como percebemos, a Dim.1 foi o √∫nico gradiente ambiental que afetou a riqueza de esp√©cies. Para interpretar esta dimens√£o (e outras importantes), podemos usar a fun√ß√£o `dimdesc()` para verificar as vari√°veis mais importantes. Neste caso, os valores mais extremos de correla√ß√£o (maior que 0.8) indicam que a temperatura do m√™s de janeiro e julho bem como a chuva do m√™s de julho foram as vari√°veis mais importantes para determinar o gradiente ambiental expresso na dimens√£o 1. Assim, podemos fazer um gr√°fico para representar a rela√ß√£o entre Eixo 1 (gradiente chuva-temperatura) e a riqueza de esp√©cies de aves. Valores negativos do eixo 1 (Gradiente ambiental - PC1) representam localidades com mais chuva, ao passo que valores positivos indicam localidades com temperaturas maiores (Figura \@ref(fig:fig-pcr-aves-model)).

```{r fig-pcr-aves-model, fig.cap="Modelo linear representando a rela√ß√£o entre Eixo 1 (gradiente chuva-temperatura) e a riqueza de esp√©cies de aves.", message=FALSE, warning=FALSE}
ggplot(dat, aes(x = Dim.1, y = riqueza)) + 
    geom_smooth(method = lm, fill = "#525252", color = "black") + 
    geom_point(size = 4, shape = 21, alpha = 0.7, color = "#1a1a1a", fill = "cyan4") +
    labs(x = "Gradiente ambiental (PC1)", y = "Riqueza de aves") + 
    tema_livro()
```

**Exemplo 2**

√â poss√≠vel que os dados utilizados em seu estudo sejam mistos, ou seja, incluem tanto vari√°veis categ√≥ricas quanto cont√≠nuas. Como falado acima, nesses casos a an√°lise indicada √© a PCoA. Assim como na PCA, podemos extrair os escores da PCoA para utilizar em an√°lises univariadas e multivariadas.

**Pergunta**

-   Vari√°veis clim√°ticas, vegetacionais e topogr√°ficas afetam a riqueza de √°caros?

**Predi√ß√µes**

-   A densidade da vegeta√ß√£o e disponibilidade de √°gua aumentam a riqueza de esp√©cies de √°caros

**Vari√°veis**

-   Preditoras: densidade de substrado e disponibilidade de √°gua (cont√≠nuas), tipo de substrado (categ√≥rica com 7 n√≠veis), densidade arbusto (ordinal com 3 n√≠veis), e topografia (categ√≥rica com 2 n√≠veis)
-   Dependentes: riqueza de esp√©cies de √°caros

O primeiro passo ent√£o √© utilizar um m√©todo de dist√¢ncia apropriado para o seu conjunto de dados. Em nosso exemplo, utilizaremos a dist√¢ncia de Gower, que √© usada para dados mistos (veja Cap√≠tulo \@ref(cap14)).

```{r message=FALSE, warning=FALSE}
## Matriz de dist√¢ncia
env.dist <- gowdis(mite.env)

## PCoA
env.mite.pco <- pcoa(env.dist, correction = "cailliez")

## Porcentagem de explica√ß√£o do Eixo 1
100 * (env.mite.pco$values[, 1]/env.mite.pco$trace)[1]

## Porcentagem de explica√ß√£o dos Eixo 2
100 * (env.mite.pco$values[, 1]/env.mite.pco$trace)[2]
```

O pr√≥ximo passo √© exportar os escores para as an√°lises *a posteriori* (Figura \@ref(fig:fig-pcr-acaros-diag)).

```{r fig-pcr-acaros-diag, fig.cap="Diagn√≥sticos dos modelo PCR para √°caros.", message=FALSE, warning=FALSE}
## Selecionar os dois primeiros eixos
pred.scores.mite <- env.mite.pco$vectors[, 1:2] 

## Juntar com os dados da √°rea para fazer a figura 
mite.riqueza <- specnumber(mite)
pred.vars <- data.frame(riqueza = mite.riqueza, pred.scores.mite)

### Regress√£o m√∫ltipla 
mod.mite <- lm(riqueza ~ Axis.1 + Axis.2, data = pred.vars)
par(mfrow = c(2, 2))
plot(mod.mite)
summary(mod.mite)
```

Finalmente, ap√≥s interpretar os resultados do modelo, podemos fazer a figura com as vari√°veis (eixos) importantes (Figura \@ref(fig:fig-pcr-acaros-model)).

```{r fig-pcr-acaros-model, fig.cap="Modelo linear representando a rela√ß√£o entre Eixo 1 e Eixo 2 e a riqueza de esp√©cies de √°caros.", message=FALSE, warning=FALSE}
g_acari_axi1 <- ggplot(pred.vars, aes(x = Axis.1, y = riqueza)) + 
    geom_smooth(method = lm, fill = "#525252", color = "black") + 
    geom_point(size = 4, shape = 21, alpha = 0.7, color = "#1a1a1a", fill="cyan4") + 
    labs(x = "Gradiente ambiental (PC1)", y = "Riqueza de √°caros") + 
    tema_livro()

g_acari_axi2 <- ggplot(pred.vars, aes(x = Axis.2, y = riqueza)) + 
    geom_smooth(method = lm, fill = "#525252", color = "black") + 
    geom_point(size = 4, shape = 21, alpha = 0.7, color = "#1a1a1a", fill = "darkorange") + 
    labs(x = "Gradiente ambiental (PC2)", y = "Riqueza de √°caros") + 
    tema_livro()

## Fun√ß√£o para combinar os dois plots em uma √∫nica janela
grid.arrange(g_acari_axi1, g_acari_axi2, nrow = 1)
```

## Ordena√ß√£o restrita

A ordena√ß√£o restrita ou an√°lise de gradiente direto, organiza os objetos de acordo com suas rela√ß√µes com outras vari√°veis (preditoras) coletadas nas mesmas unidades amostrais. O exemplo mais comum na ecologia √© de investigar a rela√ß√£o entre diversas vari√°veis ambientais (matriz **X**) coletadas em *n* localidades e a abund√¢ncia (ou presen√ßa aus√™ncia) de *y* esp√©cies coletadas nas mesmas localidades (matrix **Y**). Com frequ√™ncia, outras dados s√£o utilizados como as coordenadas geogr√°ficas das unidades amostrais (matriz **W**), os atributos funcionais das esp√©cies coletadas (matriz **T**) e a rela√ß√£o filogen√©tica dessas esp√©cies (matriz **P**). Diversos m√©todos s√£o utilizados para combinar duas ou mais matrizes, mas neste cap√≠tulo iremos apresentar a An√°lise de Redund√¢ncia (RDA), An√°lise de Redund√¢ncia parcial (RDAp) e m√©todos espaciais para incluir a matriz **W** nas an√°lises de gradiente direto.

### An√°lise de Redund√¢ncia (RDA)

A RDA √© uma an√°lise semelhante √† regress√£o m√∫ltipla (Cap√≠tulo \@ref(cap7)), mas que usa dados multivariados como vari√°vel dependente. As duas matrizes comuns, matriz X (*n* unidades amostraits e *m* vari√°veis) e matriz Y (*n* unidades amostrais e *p* descritores - geralmente, esp√©cies). O primeiro passo da RDA √© centralizar (assim como na PCA, exemplo acima) as matrizes X e Y. Ap√≥s a centraliza√ß√£o, realiza-se regress√µes lineares entre X e Y para obter os valores preditos de Y (ou seja, os valores de Y que representa√ß√£o uma combina√ß√£o linear com X). O passo seguinte √© realizar uma PCA dos valores preditos de Y. Este √∫ltimo procedimento gera os autovalores, autovetores e os eixos can√¥nicos que correspondem √†s coordenadas dos objetos (unidades amostrais), vari√°veis preditoras e das vari√°veis resposta. A diferen√ßa da ordena√ß√£o do valor de Y predito e da ordena√ß√£o somente de Y (como na PCA implementada acima) √© que a segunda mostra a posi√ß√£o prevista pela rela√ß√£o linear entre X e Y. Logo, essa √© exatamente o motivo da ordena√ß√£o ser conhecida como restrita, pois a varia√ß√£o em Y √© restrita (linearmente) pela varia√ß√£o de X. Assim como na regress√£o m√∫ltipla, a estat√≠stica da RDA √© representada pelo valor de *R^2^* e *F*. O valor de *R^2^* indica a for√ßa da rela√ß√£o linear entre X e Y e o valor do *F* representa o teste global de signific√¢ncia. Al√©m disso, √© poss√≠vel testar a signific√¢ncia de cada um dos eixos da ordena√ß√£o (e a presen√ßa de pelo menos um eixo significativo √© pr√©-requisito para que exista a rela√ß√£o linear entre X e Y) e de cada uma das vari√°veis preditoras da matriz X.

**Checklist**

-   Vari√°veis preditoras: importante verificar se: i) a estrutura de correla√ß√£o das vari√°veis ambientais, e a ii) presen√ßa de autocorrela√ß√£o espacial

-   Composi√ß√£o de esp√©cies como matriz Y: fundamental observar se os valores utilizados representam abund√¢ncia ou presen√ßa-aus√™ncia e qual a necessidade de padroniza√ß√£o (e.g., Hellinger)

-   Assim como em modelos de regress√£o linear simples e m√∫ltipla, os valores de *R^2^* ajustado devem ser selecionados ao inv√©s do valor de *R^2^*

**Exemplo 1**

Esp√©cies de aves que ocorrem em localidades com diferentes altitudes.

**Pergunta**

-   O clima e a altitude modificam a composi√ß√£o de esp√©cies de aves?

**Predi√ß√µes**

-   Diferen√ßas clim√°ticas (temperatura e chuva) e altitudinais alteram a composi√ß√£o de esp√©cies de aves

**Vari√°veis**

-   Preditoras: Temperatura e precipita√ß√£o (cont√≠nuas) e altitude (categ√≥rica com tr√™s n√≠veis)
-   Dependente: composi√ß√£o de esp√©cies de aves

**An√°lises**

```{r message=FALSE, warning=FALSE}
## Passo 1: transforma√ß√£o de hellinger da matriz de esp√©cies
# caso tenha dados de abund√¢ncia.
species.hel <- decostand(x = species, method = "hellinger")

## Passo 2: selecionar vari√°veis importantes
# Para isso, √© necess√°rio remover a vari√°vel categ√≥rica.
env.contin <- env[, -8]

## Evite usar vari√°veis muito correlacionadas
sel.vars <- forward.sel(species.hel, env.contin)
sel.vars$variables
env.sel <- env[,sel.vars$variables]

## Passo 3: padronizar matriz ambiental (somente vari√°veis cont√≠nuas)
env.pad <- decostand(x = env.sel, method = "standardize")

## Matriz final com vari√°veis preditoras
env.pad.cat <- data.frame(env.pad, altitude = env$altitude)
```

Depois de selecionar um subconjunto dos dados com o m√©todo Forward Selection e padroniz√°-los (m√©dia 0 e desvio padr√£o 1), o modelo da RDA √© constru√≠do como modelos lineares (Figura \@ref(fig:fig-rda)). A Ordena√ß√£o Multi-Escala (MSO) tamb√©m √© ajustada para analisar a autocorrela√ß√£o espacial.

```{r fig-rda, fig.cap="Ordena√ß√£o multi-escala (MSO) para entender os resultados da ordena√ß√£o em rela√ß√£o √† dist√¢ncia geogr√°fica.", message=FALSE, warning=FALSE}
## RDA com dados selecionados e padronizados
rda.bird <- rda(species.hel ~ rain.jul + maxi.jul + altitude, data = env.pad.cat)

## Para interpretar, √© necess√°rio saber a signific√¢ncia dos eixos para representar a rela√ß√£o entre as vari√°veis preditoras e a composi√ß√£o de esp√©cies
res.axis <- anova.cca(rda.bird, by = "axis") 
res.axis

## Em seguida, √© poss√≠vel identificar quais s√£o as vari√°veis que contribuem ou que mais contribuem para a varia√ß√£o na composi√ß√£o de esp√©cies 
res.var <- anova.cca(rda.bird, by = "term") ## Qual vari√°vel?
res.var

## Al√©m disso, √© poss√≠vel obter o valor do R2 do modelo
r_quadr <- RsquareAdj(rda.bird)
r_quadr

## Ordena√ß√£o multi-escala (MSO) para entender os resultados da ordena√ß√£o em rela√ß√£o √† dist√¢ncia geogr√°fica
bird.rda <- mso(rda.bird, xy, grain = 1, permutations = 99)
msoplot(bird.rda)
```

Da mesma forma que nas ordena√ß√µes irrestritas, podemos fazer um gr√°fico para visualizar as ordena√ß√µes, mas agora esse gr√°fico √© denominado "triplot", pois possui os dados das duas ordena√ß√µes (Figura \@ref(fig:fig-rda-triplot)).

```{r fig-rda-triplot, fig.cap="Triplot da RDA.", message=FALSE, warning=FALSE}
## Triplot da RDA
ggord(rda.bird, ptslab = TRUE, size = 1, addsize = 3, repel = TRUE) +
    geom_hline(yintercept = 0, linetype = 2) +
    geom_vline(xintercept = 0, linetype = 2) + 
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Os objetos `res.axis`, `res.var` e `r_quadr` mostram, respectivamente, i) as dimens√µes (RDA1, RDA2, etc.) que possuem varia√ß√£o na composi√ß√£o de esp√©cies, ii) as vari√°veis preditoras que explicam esta varia√ß√£o, e iii) o valor do *R^2^* ajustado. Neste exemplo, podemos observar que somente a dimens√£o 1 (RDA1) representa uma varia√ß√£o significativa da composi√ß√£o de esp√©cies (**P** = 0,001). As vari√°veis *rain.jul*, *maxi.jul* e *altitude* foram todas preditoras importantes da composi√ß√£o de esp√©cies, mas *rain.jul* se destacada com maior valor de **F**. Al√©m disso, o valor do *R^2^* ajustado de 0.381 indica forte contribui√ß√£o dessas vari√°veis preditoras. Por√©m, uma das limita√ß√µes desta an√°lise √© n√£o considerar que tanto esp√©cies quanto vari√°veis preditoras podem estar estruturadas espacialmente. Como resultado, os res√≠duos da an√°lises podem apresentar autocorrela√ß√£o espacial que, por sua vez, aumenta o Erro do Tipo I [@legendre_numerical_2012]. A figura obtida com o c√≥digo `msoplot(bird.rda)` demonstra que existe autocorrela√ß√£o espacial em algumas dist√¢ncias da an√°lise. Veja abaixo algumas alternativas para res√≠duos com autocorrela√ß√£o espacial.

### An√°lise de Redund√¢ncia parcial (RDAp)

Um dos problemas da abordagem anterior √© que tanto a composi√ß√£o de esp√©cies como as vari√°veis ambientais est√£o estruturadas espacialmente. Talvez mais importantes, para que os valores de probabilidade da RDA sejam interpretados corretamente (e para evitar Erro do Tipo I), os res√≠duos do modelo n√£o devem estar correlacionados espacialmente, como demonstrado com a an√°lise MSO. Uma alternativa √© incluir a matriz de dados espaciais (matrix W) como valor condicional dentro da RDA. Esta an√°lise √© conhecida como RDA parcial.

Por√©m, a obten√ß√£o dos dados espaciais da matriz W √© mais complexo do que simplesmente incluir dados de localiza√ß√£o geogr√°fica (latitude e longitude), como feito em alguns modelos lineares (e.g., *Generalized Least Squares* - GLS Cap√≠tulos \@ref(cap7) e \@ref(cap10)). Existem diversas ferramentas que descrevem e incorporam o componente espacial em m√©todos mulitidimensionais, mas os Mapas de Autovetores de Moran (MEM) s√£o certamente os mais utilizados [@dray_community_2012]. A an√°lise MEM consiste na ordena√ß√£o (PCoA) de uma matriz truncada obtida atrav√©s da localiza√ß√£o geogr√°fica das localidades utilizando dist√¢ncia euclidiana, matriz de conectividade e matriz espacial ponderada. Os autovalores obtidos no MEM s√£o id√™nticos aos coeficientes de correla√ß√£o espacial de Moran *I*. Um procedimento chave desta an√°lise √© a defini√ß√£o de um limiar de trucamento (do ingl√™s *truncate threshold*). Este limiar √© calculado a partir de uma "√°rvore de espa√ßo m√≠nimo" (*Minimum Spanning Tree* - MST) que conecta todos os pontos de coleta. Na pr√°tica, os valores menores do que o limiar definido pela MST indicam que os pontos com aqueles valores est√£o conectados e, assim possuem correla√ß√£o positiva. Outro ponto importante desta an√°lise √© a obten√ß√£o da matriz espacial ponderada (*Spatial Weighting Matrix* - SWM). A sele√ß√£o da matriz SWM √© parte essencial do c√°lculo dos MEM e n√£o deve ser feita arbitratiamente [@bauman_optimizing_2018]. Por este motivo, a an√°lise recebe este nome [@legendre_numerical_2012]. Finalmente, o m√©todo produz autovetores que representam preditores espaciais que podem ser utilizados na RDA parcial (e em outras an√°lises). √â importante ressaltar que o crit√©rio de sele√ß√£o do n√∫mero de autovetores √© bastante debatido na literatura e, para isso, sugerimos a leitura dos seguintes artigos: [@diniz-filho_spatial_2012, @bauman_optimizing_2018, @bauman_disentangling_2018].

Ent√£o, o primeiro passo para realizar uma RDA parcial √© de gerar os autovetores espaciais (MEMs).

```{r message=FALSE, warning=FALSE}
## Dados
# Matriz padronizada de composi√ß√£o de esp√©cies. 
head(species.hel)[, 1:6] 

## Latitude e longitude
head(xy)

## dados ambientais padronizados e altitude
head(env.pad.cat)

## Passo 1: Gerar um arquivo LIST W: list bin√°ria de vizinhan√ßa
mat_knn <- knearneigh(as.matrix(xy), k = 2, longlat = FALSE)
mat_nb <- knn2nb(mat_knn, sym = TRUE)
mat_listw <- nb2listw(mat_nb, style = "W")
mat_listw

## Passo 2: Listar os m√©todos "candidatos" para obter a matriz SWM
MEM_mat <- scores.listw(mat_listw, MEM.autocor = "positive")
candidates <- listw.candidates(xy, nb = c("gab", "mst", "dnear"), 
                               weights = c("binary", "flin"))

## Passo 3: Selecionar a melhor matriz SWM e executar o MEM
W_sel_mat <- listw.select(species.hel, candidates, MEM.autocor = "positive",
                          p.adjust = TRUE, method = "FWD")

## Passo 4: Matriz dos preditores espaciais escolhidos (MEMs)
spatial.pred <- as.data.frame(W_sel_mat$best$MEM.select)

## √â necess√°rio atribuir os nomes das linhas
rownames(spatial.pred) <- rownames(xy) 
```

Depois de gerar os valores dos autovetores espaciais (MEM), √© poss√≠vel executar a RDA parcial utilizando esses valores no argumento `Conditional`.

```{r message=FALSE, warning=FALSE}
## Combinar vari√°veis ambientais e espaciais em um √∫nico data.frame
pred.vars <- data.frame(env.pad.cat, spatial.pred)

## RDA parcial
rda.p <- rda(species.hel ~
                 rain.jul + maxi.jul + altitude + # Preditores ambientais
                 Condition(MEM1 + MEM2 + MEM4 + MEM5), # Preditores espaciais
             data = pred.vars)

## Interpreta√ß√£o
# Para interpretar, √© necess√°rio saber a signific√¢ncia dos eixos para representar a rela√ß√£o entre as vari√°veis preditoras e a composi√ß√£o de esp√©cies.
res.p.axis <- anova.cca(rda.p, by = "axis") 
res.p.axis

## Contribui√ß√£o
# Em seguida, √© poss√≠vel identificar quais s√£o as vari√°veis que contribuem ou que mais contribuem para a varia√ß√£o na composi√ß√£o de esp√©cies.
res.p.var <- anova.cca(rda.p, by = "term") ## Qual vari√°vel?
res.p.var
RsquareAdj(rda.p)
```

Se voc√™ comparar os resultados do objeto res.p.var (RDA parcial) com res.var (RDA simples) √© poss√≠vel perceber como a estrutura espacial nos res√≠duos aumenta a probabilidade de cometer Erro do Tipo I. O modelo da RDA parcial mostra que n√£o existem qualquer efeito direto das vari√°veis ambientais sobre a composi√ß√£o de esp√©cies (conclus√£o com a RDA simples). Na verdade, tanto a composi√ß√£o de esp√©cies quanto as vari√°veis clim√°ticas est√£o fortemente estruturadas no espa√ßo, como demonstramos a seguir.

```{r, tinytex.verbose = TRUE, cache = FALSE}
## Padr√£o espacial na composi√ß√£o de esp√©cies
pca.comp <- dudi.pca(species.hel, scale = FALSE, scannf = FALSE)
moran.comp <- moran.mc(pca.comp$li[, 1], mat_listw, 999)

## Padr√£o espacial das vari√°veis ambientais
env$altitude <- as.factor(env$altitude)
ca.env <- dudi.hillsmith(env, scannf = FALSE)
moran.env <- moran.mc(ca.env$li[, 1], mat_listw, 999)

## Estrutura espacial na composi√ß√£o de esp√©cies?
moran.comp

## Estrutura espacial na varia√ß√£o ambiental?
moran.env
```

Como resultado, √© poss√≠vel que a varia√ß√£o ambiental espacialmente estruturada √© o principal efeito sobre a composi√ß√£o de esp√©cies. Uma maneira de visualizar a contribui√ß√£o relativa de diferentes matrizes (ambiental e espacial, por exemplo) √© utilizar o m√©todo de parti√ß√£o de vari√¢ncia. O resultado deste modelo indica que, de fato, n√£o existe efeito direto das vari√°veis ambientais e sim do componente representado pela autocorrela√ß√£o espacial dessas vari√°veis (Figura \@ref(fig:fig-rda-parcial)).

```{r fig-rda-parcial, fig.cap="Diagrama de Venn mostrando a parti√ß√£o de vari√¢ncia da RDA.", message=FALSE, warning=FALSE}
## Triplot da RDA
# Parti√ß√£o de vari√¢ncia.
pv.birds <- varpart(species.hel, env.pad.cat, spatial.pred)
plot(pv.birds, cutoff = -Inf)
mtext("Diagrama de Venn: parti√ß√£o de vari√¢ncia")
```

### An√°lise de Redund√¢ncia baseada em dist√¢ncia (db-RDA)

Acima, apresentamos a an√°lise RDA que permite comparar, por exemplo, se vari√°veis ambientais determinam a varia√ß√£o na composi√ß√£o de esp√©cies. A RDA utiliza os dados brutos de composi√ß√£o de esp√©cies e √© baseada em uma PCA (i.e., requer dist√¢ncia euclidiana). Por√©m, em algumas situa√ß√µes √© necess√°rio utilizar outras medidas de dist√¢ncia tais como Bray-Curtis ou Gower. Esta analise √© bastante √∫til tamb√©m quando a matriz resposta j√° √© uma matriz de dist√¢ncia, tais como as que s√£o geradas por decomposi√ß√£o da diversidade beta. Neste caso, Legendre & Anderson [-@legendre_distance-based_1999] propuseram a an√°lise db-RDA (RDA baseada em dist√¢ncia). O primeiro passo da an√°lise √© gerar uma matriz de dist√¢ncia a partir da matriz bruta (e.g., composi√ß√£o de esp√©cies). Depois, a t√©cnica executa uma PCoA (corrigindo potenciais autovetores com autovalores negativos; ver discuss√£o acima) para comparar com os termos do modelo (matriz **X**, como na RDA). 
Para exemplificar como esta an√°lise pode ser implementada no R, vamos usar o mesmo exemplo demontrado na an√°lise RDA (ver acima). Por√©m, vamos fazer um ajuste sutil na pergunta "o clima e a altitude modificam a dissimilaridade (diversidade beta) de esp√©cies de aves?". Veja que neste caso, estamos perguntando diretamente sobre uma medida de diversidade beta, que ser√° calculada com o m√©todo Bray-Curtis. As vari√°veis preditoras ser√£o as mesmas obtidas no exemplo da RDA: `env.pad.cat`.   

**An√°lise**

```{r message=FALSE, warning=FALSE}
## Passo 1: transforma√ß√£o de hellinger da matriz de esp√©cies
# caso tenha dados de abund√¢ncia.
species.hel <- decostand(species, "hellinger")

## Passo 2: gerar matriz de dist√¢ncia (Diversidade beta: Bray-Curtis)
dbeta <- vegdist(species.hel, "bray")

## Passo 2: dbRDA 
dbrda.bird <- capscale (dbeta~rain.jul+maxi.jul+altitude, data=env.pad.cat)

# Para interpretar, √© necess√°rio saber a signific√¢ncia dos eixos para representar a rela√ß√£o entre as vari√°veis preditoras e a composi√ß√£o de esp√©cies
db.res.axis <- anova.cca(dbrda.bird, by = "axis") 
db.res.axis

# Em seguida, √© poss√≠vel identificar quais s√£o as vari√°veis que contribuem ou que mais contribuem para a varia√ß√£o na composi√ß√£o de esp√©cies 
db.res.var <- anova.cca(rda.bird, by = "term") ## Qual vari√°vel?
db.res.var

# Al√©m disso, √© poss√≠vel obter o valor do R2 do modelo
db_r_quadr <- RsquareAdj(dbrda.bird)
db_r_quadr
```

**Interpreta√ß√£o dos resultados**

Assim como apresentado na RDA, os resultados obtidos em `db.res.var` sugerem que as vari√°veis `rain.jul`, `maxi.jul` e `altitude` afetam a diversidade beta de aves. O valor do *R^2^* ajustado (0.495) sugere forte rela√ß√£o entre o gradiente ambiental e a diversidade beta. A compara√ß√£o entre o valor do `db_r_quadr` e `r_quadr` indica que a db-RDA teve melhor ajuste para comparar o mesmo conjunto de dados.

## PERMANOVA

A PERMANOVA √© uma sigla, em ingl√™s, de *Permutational Multivariate Analysis of Variance*, an√°lise proposta por Marti Anderson [@anderson_new_2001]. A PERMANOVA √© usada para testar hip√≥teses multivariadas que comparam a abund√¢ncia de diferentes esp√©cies em resposta a diferentes tratamentos ou gradientes ambientais. Essa an√°lise foi desenvolvida como forma de solucionar algumas limita√ß√µes da tradicional ANOVA multivariada (MANOVA). Em especial, o pressuposto da MANOVA de distribui√ß√£o normal multivariada √© raramente encontrado em dados ecol√≥gicos.

O primeiro passo da PERMANOVA √© selecionar uma medida de dist√¢ncia apropriada aos dados e, al√©m disso, verificar a necessidade de padroniza√ß√£o ou transforma√ß√£o dos dados. Em seguida, as dist√¢ncias s√£o comparadas entre os grupos de interesse (por exemplo, tratamento versus controle) usando a estat√≠stica *F* de maneira muito parecida com uma ANOVA (Cap√≠tulo \@ref(cap7)), chamada de *pseudo-F*:

$$F_pseudo = (SSa / SSr)*[(N-g) / (g-1)]$$

Nessa equa√ß√£o 

- *SSa* representa a soma dos quadrados entre grupos
- *SSr* a soma de quadrados dentro do grupo (residual) 
- *N* o n√∫mero de unidades amostrais
- *g* os grupos (ou n√≠veis da vari√°vel categ√≥rica)

Esta f√≥rmula do *pseudo-F* √© espec√≠fica para desenho experimental com um fator. Outros desenhos mais complexos s√£o apresetandos em Anderson [-@anderson_new_2001, -@anderson_permutational_2017]. O c√°lculo do valor de probilidade √© realizado por m√©todos de permuta√ß√£o que s√£o discutidos em Anderson & Ter Braak [-@anderson_permutation_2003].

**Exemplo 1**

Esp√©cies de aves que ocorrem em localidades com diferentes altitudes.

**Pergunta**

-   O clima e a altitude modificam a composi√ß√£o de esp√©cies de aves?

**Predi√ß√µes**

-   Diferen√ßas clim√°ticas (temperatura e chuva) e altitudinais alteram a composi√ß√£o de esp√©cies de aves

**Vari√°veis**

-   Preditoras: Temperatura e chuva (cont√≠nuas) e altitude (categ√≥rica com tr√™s n√≠veis)
-   Dependente: composi√ß√£o de esp√©cies de aves

```{r message=FALSE, warning=FALSE}
## Composi√ß√£o de esp√©cies padronizar com m√©todo de Hellinger
species.hel <- decostand(x = species, method = "hellinger")

## Matriz de dist√¢ncia com m√©todo Bray-Curtis
sps.dis <- vegdist(x = species.hel, method = "bray")
```

Para reduzir o n√∫mero de vari√°veis no modelo, voc√™ pode considerar duas abordangens. A primeira, e mais importante delas, √© manter somente vari√°veis preditoras que voc√™ tenha raz√£o biol√≥gica para mant√™-la e, al√©m disso, que esteja relacionada com suas hip√≥teses. Assim, uma vez que voc√™ j√° removeu vari√°veis que n√£o possuem relev√¢ncia biol√≥gica, voc√™ deve usar diferentes m√©todos para remover as vari√°veis muito correlacionadas (*forward selection*, *Variance Inflation Factor (VIF)*, entre outros). Neste exemplo, vamos simplesmente fazer uma correla√ß√£o m√∫ltipla e remover as vari√°veis com correla√ß√£o maior do que 0.9 ou -0.9. A fun√ß√£o `ggpairs()` mostra um gr√°fico bem did√°tico para representar a rela√ß√£o entre todas as vari√°veis e o valor (r) desta correla√ß√£o (mais em Cap√≠tulo \@ref(cap7)) (Figura \@ref(fig:fig-permanova-prev)).

```{r fig-permanova-prev, fig.cap="Correlograma mostrando a correla√ß√£o entre as vari√°veis.", message=FALSE, warning=FALSE}
## Verifica correla√ß√£o entre as vari√°veis
ggpairs(env) +
    tema_livro()

## Ap√≥s verificar a estrutura de correla√ß√£o, vamos manter somente tr√™s vari√°veis
env2 <- env[, c("mini.jan", "rain.tot", "altitude")]
```

Ap√≥s selecionar as vari√°veis do modelo, vamos executar a PERMANOVA e entender as principais etapas para interpretar corretamente o teste. A fun√ß√£o `adonis()` do pacote `vegan` √© uma boa op√ß√£o. Por√©m, √© importante referir o programa PRIMER e PERMANOVA+ como √≥tima op√ß√£o para implementar a PERMANOVA e ter maior controle em desenhos complexos [@anderson_permanova+_2008]. Assim como nos modelos lineares apresentados no Cap√≠tulo \@ref(cap7), os argumento seguem o mesmo formato, com vari√°vel dependente separada por um "~" das vari√°veis preditoras. Por√©m, alguns autores demonstraram que a PERMANOVA (assim como Mantel e ANOSIM) n√£o pode identificar se diferen√ßas significativas do teste (usando a estat√≠stica *pseudo-F*) se devem a diferen√ßas no posi√ß√£o, na dispers√£o ou ambos. Ou seja, ao comparar grupos n√£o √© poss√≠vel identificar se existe mudan√ßas de composi√ß√£o (posi√ß√£o) ou a varia√ß√£o da composi√ß√£o de esp√©cies dentro de um grupo (dispers√£o) √© maior do que a varia√ß√£o dentro do outro grupo [@anderson_permanova_2013]. Para solucionar este problema, √© poss√≠vel combinar a PERMANOVA com a an√°lise PERMDISP (ou BETADISPER, como chamado no pacote `vegan` implementado atrav√©s da fun√ß√£o `betadisper()`). Esta an√°lise permite comparar se existe heterogeneidade nas vari√¢ncias entre grupos. Deste modo, com a presen√ßa de heterogeneidade de vari√¢ncias (valor do BETADISPER significativo), √© poss√≠vel saber que as diferen√ßas entre os grupos ocorre principalmente por diferen√ßas na dispers√£o e n√£o, necessariamente, de posi√ß√£o. Mais detalhes sobre a relev√¢ncia de combinar essas duas an√°lises est√£o dispon√≠veis em Anderson & Walsh [-@anderson_permanova_2013].

```{r message=FALSE, warning=FALSE}
## PERMANOVA
perm.aves <- adonis2(sps.dis ~ mini.jan + rain.tot + altitude, data = env2)
perm.aves ### Diferen√ßas entre os tratamentos?

## BETADISPER
betad.aves <- betadisper(sps.dis, env2$altitude)
permutest(betad.aves)
```

Em nosso exemplo, a temperatura, precipita√ß√£o e altitude afetaram a varia√ß√£o na composi√ß√£o de esp√©cies. Por√©m, para identificar se as diferen√ßas de composi√ß√£o entre os n√≠veis da vari√°vel altitude, √© necess√°rio interpretar os resultados da an√°lise BETADISPER. O c√≥digo `permutest(betad.aves)` mostra que o valor de probabilidade da an√°lise foi de 0.253, ou seja, a hip√≥tese nula de que a vari√¢ncia entre grupos √© homog√™nea √© aceita. Assim, n√£o existe diferen√ßas na dispers√£o entre grupos, sugerindo que a diferen√ßa encontrada na PERMANOVA (objeto `perm.aves`) se deve, em parte, √† mudan√ßa na composi√ß√£o de esp√©cies de aves entre diferentes altitudes (R^2^ = 0.135). Al√©m disso, a precipita√ß√£o (R^2^ = 0.183) e temperatura (R^2^ = 0.127) foram fatores importantes na varia√ß√£o da composi√ß√£o de esp√©cies.

Como falado anteriormente, as an√°lises de ordena√ß√£o irrestritas (PCA, PCoA, nMDS) s√£o utilizadas para explorar dados. Uma maneira poderosa de us√°-las √© combinando com an√°lises que testam hip√≥teses, como PERMANOVA e RDA. A literatura ecol√≥gica tem usado a An√°lise de Escalonamento n√£o-M√©trico (*non-Metric Multidimensional Scaling* - nMDS) combinado com an√°lises multidimensionais de vari√¢ncia (como a PERMANOVA) para visualiza√ß√£o da similaridade na composi√ß√£o de esp√©cies dentro e entre grupos. A seguir, implementamos o nMDS na matriz de composi√ß√£o de esp√©cies de √°caros (Figura \@ref(fig:fig-nmds)).

```{r fig-nmds, fig.cap="Biplot mostrando o resultado do nMDS.", message=FALSE, warning=FALSE, }
## Matriz de dist√¢ncia representando a varia√ß√£o na composi√ß√£o de esp√©cies (m√©todo Bray-Curtis)
as.matrix(sps.dis)[1:6, 1:6]

## √â preciso calcular uma primeira "melhor" solu√ß√£o do nMDS
sol1 <- metaMDS(sps.dis)

## Melhor solu√ß√£o
# Depois, executar a mesma fun√ß√£o, mas utilizando uma "melhor solu√ß√£o inicial" para evitar resultdos sub√≥timos no nMDS .
nmds.beta <- metaMDS(sps.dis, previous.best = sol1)

## Stress
# O stress √© o valor mais importante para interpretar a qualidade da ordena√ß√£o.
nmds.beta$stress # valor ideal entre 0 e 0.2

## Exportar os valores para fazer gr√°fico 
dat.graf <- data.frame(vegan::scores(nmds.beta), altitude = env2$altitude)

## Definir os grupos ("HULL") para serem categorizados no gr√°fico 
grp.mon <- dat.graf[dat.graf$altitude == "Montanhoso", ][chull(dat.graf[dat.graf$altitude == "Montanhoso", c("NMDS1", "NMDS2")]), ]

grp.int <- dat.graf[dat.graf$altitude == "Intermedi√°rio", ][chull(dat.graf[dat.graf$altitude == "Intermedi√°rio", c("NMDS1", "NMDS2")]), ]

grp.pla <- dat.graf[dat.graf$altitude == "Plano", ][chull(dat.graf[dat.graf$altitude == "Plano", c("NMDS1", "NMDS2")]), ]

## Combinar dados dos grupos para cada Convex Hull
hull.data <- rbind(grp.mon, grp.int, grp.pla) 
head(hull.data)

## Gr√°fico
ggplot(dat.graf, aes(x = NMDS1, y = NMDS2, color = altitude, shape = altitude)) + 
    geom_point(size = 4, alpha = 0.7) + 
    geom_polygon(data = hull.data, aes(fill = altitude, group = altitude), alpha = 0.3) + 
    scale_color_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(x = "NMDS1", y = "NMDS2") + 
    tema_livro()
```

## Mantel e Mantel parcial

O teste de Mantel se aplica quando temos duas ou mais matrizes de dist√¢ncia (triangulares). Em estudos ecol√≥gicos, essas matrizes normalmente descrevem dados de dist√¢ncia ou (dis)similaridade na composi√ß√£o de esp√©cies, dist√¢ncia geogr√°fica, e similaridade ambiental. Mas este teste tamb√©m √© amplamente aplicado na √°rea de gen√©tica de paisagem para testar hip√≥teses sobre como a composi√ß√£o gen√©tica de uma popula√ß√£o varia em fun√ß√£o do ambiente e/ou espa√ßo geogr√°fico [@legendre2010]. O teste nada mais √© do que uma generaliza√ß√£o do coeficiente de correla√ß√£o de Pearson (Cap√≠tulo \@ref(cap7)) para lidar com matrizes de dist√¢ncia. Como essas matrizes descrevem a rela√ß√£o entre v√°rios pares de locais, temos a repeti√ß√£o do mesmo local em outros pares. Neste caso √© preciso um procedimento semelhante ao de corre√ß√£o para m√∫ltiplos testes. 

J√° o Mantel parcial pretende testar a correla√ß√£o entre duas matrizes controlando para o efeito de uma terceira. Por exemplo, testar a associa√ß√£o entre a dissimilaridade na composi√ß√£o de esp√©cies e dissimilaridade ambiental, controlando para a dist√¢ncia geogr√°fica entre os locais. Isso nos permite levar em conta a poss√≠vel autocorrela√ß√£o espacial nas vari√°veis ambientais, ou seja, estar√≠amos testando de fato o efeito da dissimilaridade ambiental "pura" na dissimilaridae na composi√ß√£o de esp√©cies, evitando o efeito do espa√ßo em si. Portanto, note que sempre estamos raciocinando em termos de (dis)similaridade e n√£o dos dados brutos em si, seja composi√ß√£o de esp√©cies ou vari√°veis ambientais. √â importante ter isto em mente na hora de interpretar os resultados.

**Exemplo 1**

Neste exemplo, vamos utilizar um conjunto de dados que cont√©m girinos de esp√©cies de anf√≠bios anuros coletados em 14 po√ßas d'√°gua e os respectivos dados de vari√°veis ambientais destas mesmas po√ßas [@provete_broad-scale_2014].

**Pergunta**

-   Existe correla√ß√£o entre a dissimilaridade na composi√ß√£o de esp√©cies de girinos e a dissimilaridade ambiental?

**Predi√ß√µes**

-   Assumindo que processos baseados no nicho sejam predominantes, quanto mais diferentes as po√ßas forem maior ser√° a diferen√ßa na composi√ß√£o de esp√©cies

**Vari√°veis**

-   Vari√°veis: a matriz de dist√¢ncia (Bray-Curtis) da composi√ß√£o das esp√©cies e outra matriz de dist√¢ncia (Euclideana) das vari√°veis ambientais

**An√°lises**

Aqui vamos utilizar al√©m do conjunto de dados `bocaina` j√° conhecido, outras duas matrizes dispon√≠veis no pacote `ecodados`: `bocaina.xy` e `bocaina.env`, que cont√™m as coordenadas geogr√°ficas e vari√°veis ambientais das po√ßas, respectivamente.

```{r}
## Dados
head(bocaina.env)
head(bocaina.xy)

## Matriz de dist√¢ncia geogr√°fica
Dist.km <- as.dist(rdist.earth(bocaina.xy, miles=F)) # matriz de dist√¢ncia geogr√°fica (geod√©sica) considerando a curvatura da Terra

## Padroniza√ß√µes
comp.bo.pad <- decostand(t(bocaina), "hellinger")
env.bocaina <- decostand(bocaina.env[,-9], "standardize")

## Similaridades
simil.bocaina <- vegdist(comp.bo.pad, "bray")
simil.env <- vegdist(env.bocaina, "euclidian")
```

```{r}
## Mantel
# Espa√ßo vs. ambiente
mantel(Dist.km, simil.env) 

# Espa√ßo vs. composi√ß√£o
mantel(Dist.km, simil.bocaina) 

# Ambiente vs. composi√ß√£o
mantel(simil.env, simil.bocaina) 
```

Vamos agora fazer os gr√°ficos relacionando as matrizes de similaridade dos dados (Figura \@ref(fig:fig-mantel)).

```{r fig-mantel, fig.cap="Rela√ß√£o das matrizes de (dis)similaridade dos dados."}
## Dados
matrix.bocaina.env <- data.frame(x = melt(as.matrix(simil.bocaina))$value, 
                                 y = melt(as.matrix(simil.env))$value)

matrix.dist.env <- data.frame(x = melt(as.matrix(Dist.km))$value, 
                              y = melt(as.matrix(simil.env))$value)

matrix.dist.bocaina <- data.frame(x = melt(as.matrix(log(Dist.km)))$value, 
                              y = melt(as.matrix(log(1-simil.bocaina)))$value)

## Gr√°ficos
ggplot(matrix.bocaina.env, aes(x, y)) +
    geom_point() +
    labs(x = "Similaridade Bocaina", 
         y = "Similaridade Ambiental") +
    tema_livro()

ggplot(matrix.dist.env , aes(x, y)) +
    geom_point() +
    labs(x = "Dist√¢ncia geogr√°fica (km)", 
         y = "Similaridade Ambiental") +
    tema_livro()

ggplot(matrix.dist.bocaina , aes(x, y)) +
    geom_point() +
    labs(x = "Dist√¢ncia geogr√°fica (km)", 
         y = "Similaridade (Bray-Curtis)") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Os resultados mostraram que existe uma rela√ß√£o positiva, embora fraca, entre a dissimilaridade ambiental e a dissimilaridade na composi√ß√£o de esp√©cies. Este resultado est√° de acordo com a nossa hip√≥tese inicial. No entanto, vimos tamb√©m que existe uma rela√ß√£o positiva e significativa entre a dist√¢ncia em linha reta entre as po√ßas e a dissimilaridade ambiental. Logo, para de fato testar a rela√ß√£o entre o ambiente e a composi√ß√£o de esp√©cies temos de levar em conta o espa√ßo.

Para isto temos de realizar um teste de Mantel Parcial.

```{r}
## Mantel Parcial
mantel.partial(simil.bocaina, simil.env, Dist.km) #comp. vs. ambiente controlando o espa√ßo
```

Agora sim, vimos que a rela√ß√£o entre ambiente e esp√©cies se mant√©m, mas que a for√ßa dessa rela√ß√£o diminuiu bastante (veja o valor de r) quando controlamos o espa√ßo.

## Mantel espacial com modelo nulo restrito considerando autocorrela√ß√£o espacial

Embora seja um tipo de an√°lise bastante popular, o Mantel e a sua vers√£o parcial parecem n√£o ser muito adequadas para lidar com autocorrela√ß√£o espacial. Os autores dos artigos abaixo sugerem inclusive que esse tipo de an√°lise n√£o √© adequado para testar a maioria das hip√≥teses em Ecologia, incluindo diversidade beta. Esse √© um tema bastante discutido na literatura e n√£o vamos nos alongar muito sobre isso, mas referimos o(a) leitor(a) para os seguintes artigos chave: Legendre et al. 2015 [-@legendre2015], Legendre & Fortin 2010 [-@legendre2010], e Legendre [-@legendre2000].

No entanto, Crabot et al. [-@crabot2019] propuseram uma modifica√ß√£o no teste que leva em conta autocorrela√ß√£o espacial ao gerar o modelo nulo usado para o teste de hip√≥tese. √â utilizado um procedimento chamado *Moran Spectral Randomization* porque preserva a autocorrela√ß√£o global medida por meio do I de Moran global. A grande vantagem √© que este teste utiliza toda a flexibilidade dos *Moran Eigenvector Maps* (MEMs), que √© apresentado na parte de RDA, permitindo analisar rela√ß√µes entre as matrizes em m√∫ltiplas escalas espaciais. Vejamos como o teste funciona.

Primeiro precisamos construir um objeto com as duas matrizes que desejamos testar, no nosso caso composi√ß√£o de esp√©cies e espa√ßo. Depois precisamos construir explicitamente a nossa hip√≥tese de rela√ß√£o espacial entre os locais por meio de uma rede de vizinhan√ßa. Esta rede √© uma estrutura que nos dir√° como (e eventualmente com qual intensidade) se h√° rela√ß√£o entre os locais. Aqui, entende-se que nos referimos √† probabilidade de fluxo de indiv√≠duos entre os locais.

```{r}
## Mantel
compos_espac <- mantel.randtest(sqrt(simil.bocaina), Dist.km)
compos_espac
```

Note que at√© aqui n√£o h√° nada de novo, apenas utilizamos uma fun√ß√£o diferente para realizar o teste de Mantel, agora no pacote `ade4` ao inv√©s do `vegan`. Agora temos de construir a nossa rede de vizinhan√ßa. Optamos neste exemplo por uma rede bastante simples, que √© a *Minimum Spanning Tree*. Essa √© a rede espacial m√≠nima que mant√©m todos os pontos ligados entre si (Figura \@ref(fig:fig-mantel-espacial)).

```{r fig-mantel-espacial, fig.cap="Rede de vizinhan√ßa com a *Minimum Spanning Tree*"}
## Minimum Spanning Tree
nb.boc <- mst.nb(Dist.km) # calcula uma Minimum Spanning Tree
plot(nb.boc, bocaina.xy)
```

No gr√°fico, podemos ver a "cara" da rede. Cada ponto representa um local (po√ßa) e as linhas representam a liga√ß√£o hip√≥tetica entre eles, plotamos no espa√ßo geogr√°fico, ou seja, o Norte aponta pra cima. Agora temos apenas que converter o formato `nb` para `listw` e finalmente entrar com esses objetos na fun√ß√£o que realizar√° a an√°lise.

```{r}
## Convers√£o
lw <- nb2listw(nb.boc)

## Mantel espacial
msr(compos_espac, lw, method = "pair")
```

**Interpreta√ß√£o dos resultados**

Vamos comparar com o Mantel comum.

```{r}
## Mantel comum
compos_espac
```

Note que o valor da estat√≠stica do teste, ou seja, o r de Mantel √© exatamente o mesmo. No entanto, o valor de *P* que indicava que o teste havia sido significativo anteriormente mudou e passou a ser n√£o significativo. Isso ocorreu porque, embora a maneira de calcular a estat√≠stica do teste seja a mesma, a forma de construir a distribui√ß√£o nula, a partir da qual ser√° calculado o valor de *P* mudou drasticamente, resultando num teste n√£o significativo.

## PROCRUSTES e PROTEST

Uma alternativa ao Mantel para comparar o grau de associa√ß√£o entre conjuntos multidimensionais de dados (e.g., matriz de esp√©cies e matriz ambiental) √© a an√°lise conhecida como Procrustes [@gower_statistical_1971; @jackson_protest_1995]. Esta an√°lise compara duas matrizes (objetos nas linhas e vari√°veis nas colunas) minimizando a soma dos desvios quadrados entre os valores atrav√©s das seguintes t√©cnicas: transla√ß√£o, escalonamento e rota√ß√£o. √â importante notar que os objetos devem ser os mesmos e, desse modo, o n√∫mero de linhas √© obrigatoriamente igual, ao passo que o n√∫mero de colunas pode variar. A posi√ß√£o do objeto X~i~ (i = 1, ...n)  √© comparada com o objeto Y~i~ da matriz correspondente, movimentando os pontos via transla√ß√£o, reflex√£o, rota√ß√£o e dilata√ß√£o. Assim, os objetos da matriz X resultam na matrix X' que √© representada pelo melhor ajuste (menor valor residual da soma dos quadrados: estat√≠stica m~12~) entre a matriz X e Y. A estat√≠stica m~12~ mede, ent√£o, o grau de concord√¢ncia entre as duas matrizes. Os valores de m~12~ variam de 1 (sem concord√¢ncia) a 0 (m√°xima concord√¢ncia) [@peres-neto_how_2001; @lisboa_much_2014]. Para testar a signific√¢ncia do valor observado de m~12~, Jackson [-@jackson_protest_1995] sugeriu um teste de aleatoriza√ß√£o chamado PROTEST. 

As possibilidades de aplica√ß√£o do Procrustes para ecologia s√£o diversas. Dentre elas, se destacam a: i) morfometria geom√©trica e ii) ecologia de comunidades (concord√¢ncia de comunidades). Uma caracter√≠stica interessante do Procrustes √© a possibilidade de usar matriz bruta (e.g., vari√°veis ambientais) ou matriz de dist√¢ncia, o que amplia as possibilidades anal√≠ticas. Para compara√ß√µes com matrizes brutas, an√°lises de ordena√ß√£o irrestrita (PCA, CA) devem ser realizadas antes do Procrustes. Por outro lado, para compara√ß√µes com matrizes de dist√¢ncia (e.g., Euclidiana, Jaccard, Bray-Curtis), an√°lises como PCoA e nMDS devem preceder √† an√°lise de Procrustes [veja Figura 4 em @peres-neto_how_2001]. Nos dois casos, a ordena√ß√£o √© importante para gerar matrizes com a mesma dimensionalidade o que, por sua vez, permite comparar matrizes com n√∫mero de colunas diferentes.

**Exemplo 1**

Neste exemplo, vamos utilizar dois conjuntos de dados simulados de peixes e macroinvertebrados aqu√°ticos coletados em riachos. Neste exemplo hipot√©tico, existe uma rede de 12 riachos com diferentes graus de polui√ß√£o. Em cada riacho, foi produzida uma lista de esp√©cies de peixes e de macroinvertebrados (com dados de abund√¢ncia).

**Pergunta**

-   Existe concord√¢ncia na distribui√ß√£o na composi√ß√£o de esp√©cies de peixes e macroinvertebrados?

**Predi√ß√µes**

-   Assumindo que alguns poluentes, tais como metais pesados, podem atuar como filtro ambiental e limitar a ocorr√™ncia de determinados organismos aqu√°ticos, espera-se encontrar alta concord√¢ncia entre as duas matrizes (peixes e macroinvertebrados). Ou seja, a comunidade tanto de peixes quanto de macroinvertebrados responder√£o de forma similar ao gradiente ambiental

**Vari√°veis**

-   Vari√°veis: composi√ß√£o das esp√©cies de peixes e macroinverebrados aqu√°ticos

**An√°lises**

No exemplo escolhido, as duas matrizes representam a composi√ß√£o de esp√©cies em diferentes riachos. Desse modo, o ideal √© transformar esta matriz bruta em matriz de dist√¢ncia com o m√©todo Bray-Curtis (`vegdist()`). O pr√≥ximo passo, ent√£o, √© realizar uma `An√°lise de Coordenadas Principais (PCoA)` (veja abaixo) para gerar duas matrizes de ordena√ß√£o que ser√£o comparadas com a fun√ß√£o `procrustes()`. Por fim, utilizamos a fun√ß√£o `protest()` para testar a signific√¢ncia da concord√¢ncia entre as matrizes (Figura \@ref(fig:fig-procrustes)).

```{r fig-procrustes, fig.cap="Biplot mostrando o resultado da an√°lise de PROCRUSTES."}
## Dados
head(fish_comm)
head(macroinv)

## Fixar a amostragem
set.seed(1001) 

## Matrizes de dist√¢ncia de PCoA 
d_macro <- vegdist(macroinv, "bray")
pcoa_macro <- cmdscale(d_macro)

d_fish <- vegdist(fish_comm, "bray")
pcoa_fish <- cmdscale(d_fish)

## PROCRUSTES
concord <- procrustes(pcoa_macro, pcoa_fish)
protest(pcoa_macro, pcoa_fish)

## Gr√°fico
plot(concord, main = "", 
     xlab = "Dimens√£o 1",
     ylab = "Dimens√£o 2")
```

**Interpreta√ß√£o dos resultados**

A fun√ß√£o `protest()` apresenta dois resultados importantes: i) a estat√≠stica m~12~ e ii) o valor de signific√¢ncia (p). No exemplo, o valor de m~12~ √© igual a `0.6185` e o valor de p √© `0,019`. Desse modo, podemos concluir que existe concord√¢ncia entre a composi√ß√£o de esp√©cies de peixes e macroinvertebrados aqu√°ticos, sugerindo que o n√≠vel de polui√ß√£o pode gerar padr√µes previs√≠veis de distribui√ß√£o de diferentes organismos aqu√°ticos. A figura produzida pelo c√≥digo `plot(concord)` mostra um gr√°fico t√≠pico do Procrustes, onde a base da seta representa a matriz **X** e a ponta da seta a matriz alvo (**Y**) ap√≥s a rota√ß√£o para comparar o grau de concord√¢ncia entre **X** e **Y**. Cada ponto representa um objeto (linha) das matrizes **X** e **Y**. Quanto menor for o tamanho das setas, mais concordantes s√£o as observa√ß√µes em cada objeto.

## M√©todos multivariados baseados em modelos

Mais recentemente, alguns autores t√™m proposto m√©todos multivariados baseados em modelos. Estes m√©todos t√™m se diversificado hoje em dia e existem pacotes que realizam praticamente todas as an√°lises que vimos acima, com a diferen√ßa que utilizam distribui√ß√µes de probabilidade dado um modelo (e.g., Poisson) ao inv√©s de coeficientes de dissimilaridades. Vamos exemplificar o uso de um desses m√©todos, mas n√£o vamos fazer uma revis√£o extensiva. Caso o(a) leitor(a) deseje conhecer mais, recomendamos consultar principalmente os pacotes `gllvm`, `ecoCopula` e `Hmsc`.

Um dos primeiros m√©todos foi proposto em 2012 pelo grupo de David Warton [@warton2012], implementado no pacote `mvabund`. Anteriormente neste mesmo ano foi publicado um artigo pelo mesmo grupo [@wang2012] em que os autores demonstraram que m√©todos baseados em dissimilaridade, especialmente PERMANOVA, n√£o conseguem modelar adequadamente dados multivariados de contagem (e.g., abund√¢ncia) por n√£o levarem em conta a rela√ß√£o monot√¥nica entre m√©dia e vari√¢ncia. Vejamos o que isso quer dizer utilizando os dados do artigo de  da Silva et al. [-@dasilva2017] (Figura \@ref(fig:fig-media-var)).

```{r fig-media-var, fig.cap="Gr√°fico mostrando a m√©dia-vari√¢ncia para dados de abund√¢ncia multivariada."}
## Dados com seis primeiras localidades e esp√©cies
head(anuros_permanova)[1:6]
anuros_abund <- as.data.frame(anuros_permanova[,-28])#retirando a coluna que cont√©m o fator e deixando apenas dados de abund√¢ncia
grupos <- factor(anuros_permanova[,28])#incluindo apenas o fator a ser testado no modelo

## M√©dia-vari√¢ncia
abund_tr <- mvabund(anuros_abund) # criando um objeto da classe mvabund com os dados de abund√¢ncia
meanvar.plot(abund_tr)
```

Este conjunto de dados cont√©m abund√¢ncias de anf√≠bios coletados num conjunto de cidades do interior de S√£o Paulo e tamb√©m sua presen√ßa em museus. Aqui, vemos que h√° uma clara rela√ß√£o monot√¥nica entre a m√©dia e a vari√¢ncia da abund√¢ncia das esp√©cies na matriz. Ou seja, √† medida que esp√©cies aumentam sua m√©dia de abund√¢ncia, elas tamb√©m aumentam quase que proporcionalmente a sua vari√¢ncia. Esta √© uma propriedade bastante comum de dados multivariados de contagem, mas que n√£o √© muito bem modelada por m√©todos baseados em dissimilaridade, j√° que nesse caso apenas as esp√©cies mais abundantes t√™m de fato um peso na an√°lise.

A proposta implementada no pacote `mvabund` √© baseada em Modelos Lineares Generalizados (GLMs) que voc√™ j√° conhece do Cap√≠tulo \@ref(cap8). Ou seja, este m√©todo permite que sejam modeladas as abund√¢ncias das esp√©cies num contexto multivariado utilizando explicitamente distribui√ß√µes de probabilidade, tais como aquelas que utilizamos (e.g., Poisson, Binomial negativa, etc.). Isso faz com que demos peso semelhante √†s esp√©cies. Vejamos um exemplo de como o modelo √© ajustado e como √© feito teste de hip√≥tese.

**Exemplo 1**

A principal pergunta do artigo citado acima foi testar se a composi√ß√£o de esp√©cies que obtemos em campo e de cole√ß√£o cient√≠ficas √© diferente. Isso tem implica√ß√µes para levantamentos de fauna, j√° que podemos complementar um tipo de dado com outro ou saber se eles s√£o redundantes. Aqui, `grupos` √© apenas um fator que indica se aquela linha da matriz apresenta dados obtidos em campo ou cole√ß√£o. Vamos testar a hip√≥tese nula de que n√£o h√° diferen√ßa na composi√ß√£o entre as duas fontes de dados ajustando um modelo com Binomial negativa (Figura \@ref(fig:fig-mvabund)).

```{r fig-mvabund, fig.cap="Gr√°fico mostrando as abund√¢ncias para os dois grupos."}
## Gr√°fico
plot(abund_tr ~ grupos, cex.axis = 0.8, cex = 0.8)

## Modelo
modelo1 <- manyglm(abund_tr ~ grupos, family = "negative.binomial")
```

O gr√°fico mostrando os dados possui log da abund√¢ncia das esp√©cies e o fator (campo vs. cole√ß√£o). Com essa an√°lise explorat√≥ria de dados j√° podemos identificar se h√° diferen√ßa ou n√£o na abund√¢ncia das esp√©cies em cada local. Vemos que algumas esp√©cies s√£o bem mais abundantes no campo do que em cole√ß√µes, tais como *Leptodactylus mystacinus* e *Rhinella ornata*.

Uma grande vantagem desse tipo de m√©todo baseado em modelos √© que, assim como um GLM t√≠pico, tamb√©m podemos realizar diagnose dos res√≠duos utilizando plots de res√≠duos versus predito. Vejamos como isso funciona (Figura \@ref(fig:fig-mvabund-diag)).

```{r fig-mvabund-diag, fig.cap="Diagnose dos res√≠duos do modelo ajustado."}
## Diagnose
plot(modelo1)
```

Aqui vemos que os dados se distribuem de maneira mais ou menos homog√™nea e sem um padr√£o claro ao redor do zero. Isso indica que a distribui√ß√£o Binomial negativa foi adequada para modelar estes dados. E agora sim podemos interpretar os resultados com mais seguran√ßa.

**Interpreta√ß√£o dos resultados**

```{r}
## Resultados
summary(modelo1)
```

Aqui vemos que h√° sim uma diferen√ßa significativa na abund√¢ncia relativa das esp√©cies entre o campo e cole√ß√£o. Mas at√© ent√£o estamos levando em conta toda a matriz numa abordagem multivariada. No entanto, n√£o sabemos qual(is) esp√©cie(s) s√£o respons√°veis por este padr√£o. Para investigar isso, podemos realizar uma An√°lise de Deviance separada para cada esp√©cie, isso √© o que a linha abaixo faz.

```{r}
## ANOVA
anova(modelo1, p.uni = "adjusted")
```

Aqui vemos que algumas esp√©cies j√° identificadas no plot explorat√≥rio de fato s√£o importantes para determinar o padr√£o, tais como: *Leptodactylus mystacinus*, *Physalaemus nattereri* e *Rhinella ornata*. Essas foram esp√©cies cuja Deviance foi significativa.

## Para se aprofundar

### Livros
Listamos a seguir livros e artigos com material que recomendamos para seguir com sua aprendizagem em an√°lises multivariadas em R: i) Legendre & Legendre [-@legendre_numerical_2012] Numerical Ecology, ii) Borcard e colaboradores [-@borcard2018] Numerical Ecology with R, iii) Thioulouse e colaboradores [-@thioulouse_multivariate_2018] Multivariate Analysis of Ecological Data with ade4, iv) Ovaskainen & Abrego [-@ovaskainen_joint_2020] Joint Species Distribution Modelling, v) James & McCulloch [-@james_multivariate_1990] Multivariate Analysis in Ecology and Systematics: Panacea or Pandora's Box? e vi) Dunstan e colaboradores [-@dunstan_model_2011] Model based grouping of species across environmental gradients.

### Links

Existem alguns tutoriais online bem interessantes, mas todos em ingl√™s. Veja lista abaixo:

- [An√°lises de ordena√ß√£o - 1](https://www.davidzeleny.net/anadat-r/doku.php/en:ordination)
- [An√°lises de ordena√ß√£o - 2](http://ordination.okstate.edu/overview.htm)
- [Classifica√ß√£o num√©rica - agrupamento e kmeans](https://www.davidzeleny.net/anadat-r/doku.php/en:classification)

## Exerc√≠cios

**9.1**

**9.1**

**9.1**

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-9---introdu%C3%A7%C3%A3o-ao-r.html).

<!--chapter:end:09_analises_multidimensionais.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Rarefa√ß√£o {#cap10}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(iNEXT)
library(ecodados)
library(ggplot2)
library(vegan)
library(nlme)
library(dplyr)
library(piecewiseSEM)

## Dados
data("mite")
data("mite.xy")
coord <- mite.xy
colnames(coord) <- c("long", "lat")
data("mite.env")
agua <- mite.env[, 2]
dados_rarefacao <- ecodados::rarefacao_morcegos
rarefacao_repteis <- ecodados::rarefacao_repteis
rarefacao_anuros <- ecodados::rarefacao_anuros
dados_amostras <- ecodados::morcegos_rarefacao_amostras
```

## Aspectos te√≥ricos

Uma das grandes dificuldades na compara√ß√£o da riqueza de esp√©cies (n√∫mero de esp√©cies) entre comunidades √© decorrente da diferen√ßa no esfor√ßo amostral (e.g. diferen√ßa no n√∫mero de indiv√≠duos, discrep√¢ncia na quantidade de unidades amostrais ou √°rea amostrada) que inevitavelmente influenciar√° no n√∫mero de esp√©cies observadas [@gotelli_primer_2012; @roswell2021]. O m√©todo de rarefa√ß√£o nos permite comparar o n√∫mero de esp√©cies entre comunidades quando o tamanho da amostra (e.g. n√∫mero de unidades amostrais), o esfor√ßo amostral (e.g. tempo de amostragem) ou a n√∫mero de indiv√≠duos n√£o s√£o iguais. A rarefa√ß√£o calcula o n√∫mero esperado de esp√©cies em cada comunidade tendo como base comparativa um valor em que todas as amostras atinjam um tamanho padr√£o. Gotelli & Colwell [-@gotelli2001] descrevem dois tipos de curvas de rarefa√ß√£o: i) baseada em indiv√≠duos (*individual-based*) - as compara√ß√µes s√£o feitas considerando a abund√¢ncia da comunidade padronizada pelo menor n√∫mero de indiv√≠duos, e ii) baseada na amostra (*sampled-based*) - as compara√ß√µes s√£o padronizadas pela comunidade com menor n√∫mero de amostragens.

O m√©todo foi formulado considerando a seguinte pergunta: Se considerarmos *n* indiv√≠duos ou amostras (*n* \< N) para cada comunidade, quantas esp√©cies registrar√≠amos nas comunidades considerando o mesmo n√∫mero de indiv√≠duos ou amostras? Gotelli & Colwell [-@gotelli2001] descrevem este m√©todo e discutem em detalhes as restri√ß√µes sobre seu uso na ecologia.

-   As amostras a serem comparadas devem ser consistentes do ponto de vista taxon√¥mico, ou seja, todos os indiv√≠duos devem pertencer ao mesmo grupo taxon√¥mico
-   As compara√ß√µes devem ser realizadas somente entre amostras com as mesmas t√©cnicas de coleta. Por exemplo, n√£o √© recomendado comparar amostras onde a riqueza de esp√©cies de anuros de uma amostra foi estimada utilizando armadilhas de intercepta√ß√£o e queda e a outra foi estimada por vocaliza√ß√µes em s√≠tios de reprodu√ß√£o
-   Os tipos de h√°bitat onde as amostras s√£o obtidas devem ser semelhantes
-   √â um m√©todo para estimar a riqueza de esp√©cies em uma amostra menor -- n√£o pode ser usado para extrapolar a riqueza para amostras maiores

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Esta √∫ltima restri√ß√£o foi superada por Colwell et al. [-@colwell2012] e Chao & Jost [-@chao2012], que desenvolveram uma nova abordagem onde os dados podem ser interpolados (rarefeito) para amostras menores e extrapolados para amostras maiores. Al√©m disso, Chao & Jost [-@chao2012] prop√µem a curva de rarefa√ß√£o *coverage-based* que padroniza as amostras pela cobertura ou totalidade (*completeness*) da amostra ao inv√©s do tamanho. As rarefa√ß√µes tradicionais apresentam limita√ß√µes matem√°ticas que s√£o superadas por essa nova abordagem [@chao2012].
:::

## Curva de rarefa√ß√£o baseada no indiv√≠duo (*individual-based*)

**Exemplo pr√°tico 1 - Morcegos**

**Explica√ß√£o dos dados**

Usaremos os dados de esp√©cies de morcegos amostradas em tr√™s fragmentos florestais [@breviglieri2008]: i) Mata Ciliar do C√≥rrego Talhadinho com 12 hectares, ii) Mata Ciliar do C√≥rrego dos Tenentes com 10 hectares, e iii) Fazenda Experimental de Pindorama com 128 hectares.

**Pergunta**

- A riqueza de esp√©cies de morcegos √© maior na Fazenda Experimental do que nos fragmentos florestais menores?

**Predi√ß√µes**

- O n√∫mero de esp√©cies ser√° maior em fragmentos florestais maiores

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   Matriz ou data frame com as abund√¢ncias das esp√©cies de morcegos (vari√°vel resposta) registradas nos tr√™s fragmentos florestais (vari√°vel preditora)

**Checklist**

-   Verificar se a sua matriz ou data frame est√£o com as esp√©cies nas linhas e os fragmentos florestais nas colunas

**An√°lise**

Vamos olhar os dados usando a fun√ß√£o `head()`.

```{r}
## Cabe√ßalho dos dados
head(dados_rarefacao)

## N√∫mero de indiv√≠duos por local
colSums(dados_rarefacao)
```

Usaremos as fun√ß√µes do pacote `iNEXT` (iNterpolation e EXTrapolation) para o c√°lculo da rarefa√ß√£o [@hsieh_inext_2016]. Esta fun√ß√£o permite estimar a riqueza de esp√©cies utilizando a fam√≠lia *Hill-numbers* (Hill 1973; explica√ß√£o dos conceitos da fam√≠lia *Hill-numbers* est√° detalhada no Cap√≠tulo \@ref(cap12). O argumento `q` refere-se a fam√≠lia Hill-numbers onde: 0 = riqueza de esp√©cies, 1 = diversidade de Shannon e 2 = diversidade de Simpson. No exemplo abaixo, utilizamos somente q = 0.

```{r}
## Rarefa√ß√£o
# Datatype refere-se ao tipo de dados que voc√™ vai analisar (e.g. abund√¢ncia, incid√™ncia).
# Endpoint refere-se ao valor m√°ximo que voc√™ determina para a extrapola√ß√£o.
resultados_morcegos <- iNEXT(dados_rarefacao, q = 0, 
                             datatype = "abundance", endpoint = 800)
```

Vamos visualizar os resultados (Figura \@ref(fig:fig-rare-ind-morcegos)).

```{r fig-rare-ind-morcegos, fig.cap="Curvas de rarefa√ß√£o baseada nos indiv√≠duos de morcegos."}
## Gr√°fico
# type define o tipo de curva de rarefa√ß√£o
# 1 = curva de rarefa√ß√£o baseada no indiv√≠duo ou amostra
# 2 = curva de representatividade da amostra
# 3 = curva de rarefa√ß√£o baseada na representatividade (coverage-based)

ggiNEXT(resultados_morcegos, type = 1) +
    geom_vline(xintercept = 166, lty = 2) +
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(x = "N√∫mero de indiv√≠duos", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Foram registrados 166 indiv√≠duos na MC_Tenentes, 413 na MC_Talhadinho e 223 na FF_Experimental. Lembrando, voc√™ n√£o pode comparar a riqueza de esp√©cies observada diretamente: 15 esp√©cies na MC_Tenentes, 19 esp√©cies na MC_Talhadinho, e 17 esp√©cies no FF_Experimental. A compara√ß√£o da riqueza de esp√©cies entre as comunidades deve ser feita com base na riqueza de esp√©cies rarefeita, que √© calculada com base no n√∫mero de indiv√≠duos da comunidade com menor abund√¢ncia (166 indiv√≠duos - linha preta tracejada). Olhando o gr√°fico √© poss√≠vel perceber que a riqueza de esp√©cies de morcegos rarefeita n√£o √© diferente entre os tr√™s fragmentos florestais quando corrigimos o problema da diferen√ßa na abund√¢ncia pela rarefa√ß√£o. A interpreta√ß√£o √© feita com base no intervalo de confian√ßa de 95%. As curvas ser√£o diferentes quando os intervalos de confian√ßa n√£o se sobreporem [@chao2014]. Percebam que esta abordagem, al√©m da interpola√ß√£o (rarefa√ß√£o), tamb√©m realiza extrapola√ß√µes que podem ser usadas para estimar o n√∫mero de esp√©cies caso o esfor√ßo de coleta fosse maior. Este √© o assunto do Cap√≠tulo \@ref(cap11).

**Exemplo pr√°tico 2 - Anuros e R√©pteis**

**Explica√ß√£o dos dados**

Neste exemplo, iremos comparar o n√∫mero de esp√©cies de anuros e r√©pteis (serpentes e lagartos) usando informa√ß√µes dos indiv√≠duos depositados em cole√ß√µes cient√≠ficas e coletas de campo [@silva2017].

**Pergunta**

- A riqueza de esp√©cies estimada para uma mesma regi√£o √© maior usando informa√ß√µes de cole√ß√µes cient√≠ficas do que informa√ß√µes de coletas de campo?

**Predi√ß√µes**

- O n√∫mero de esp√©cies ser√° maior em cole√ß√µes cient√≠ficas devido ao maior esfor√ßo amostral (i.e. maior varia√ß√£o temporal para depositar os indiv√≠duos e maior n√∫mero de pessoas contribuindo com coletas espor√°dicas)

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   Matriz ou data frame com as abund√¢ncias das esp√©cies de anuros e r√©pteis (vari√°vel resposta) registradas em cole√ß√µes cient√≠ficas e coletas de campo (vari√°vel preditora)

**Checklist**

-   Verificar se a sua matriz ou data frame est√£o com as esp√©cies nas linhas e a fonte dos dados nas colunas

**An√°lise**

Olhando os dados dos r√©pteis.

```{r}
## Cabe√ßalho
head(rarefacao_repteis)
```

An√°lise usando o pacote `iNEXT` (Figura \@ref(fig:fig-rare-ind-repteis)).

```{r fig-rare-ind-repteis, fig.cap="Curvas de rarefa√ß√£o baseada nos indiv√≠duos de r√©pteis."}
## An√°lise
resultados_repteis <- iNEXT(rarefacao_repteis, q = 0,
                            datatype = "abundance", 
                            endpoint = 200)

## Visualizar os resultados
ggiNEXT(resultados_repteis, type = 1) +
    geom_vline(xintercept = 48, lty = 2) +
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = c("darkorange", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "cyan4")) +
    labs(x = "N√∫mero de indiv√≠duos", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Foram registradas oito esp√©cies de r√©pteis nas coletas de campo (48 indiv√≠duos) e 28 esp√©cies nas cole√ß√µes cient√≠ficas (77 indiv√≠duos). Com base na rarefa√ß√£o, conclu√≠mos que a riqueza de esp√©cies de r√©pteis obtida nas cole√ß√µes cient√≠ficas (20,5) √© 2,9 vezes maior do que a obtida em coletas de campo (7,05).

Olhando os dados dos anuros.

```{r}
## Cabe√ßalho
head(rarefacao_anuros)
```

An√°lise e visualiza√ß√£o do gr√°fico (Figura \@ref(fig:fig-rare-ind-anuros)).

```{r fig-rare-ind-anuros, fig.cap="Curvas de rarefa√ß√£o baseada nos indiv√≠duos de anuros."}
## An√°lise
resultados_anuros <- iNEXT(rarefacao_anuros, q = 0, 
                           datatype = "abundance", endpoint = 800)

## Visualizar os resultados
ggiNEXT(resultados_anuros, type = 1) + 
    geom_vline(xintercept = 37, lty = 2) +
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = c("darkorange", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "cyan4")) +
    labs(x = "N√∫mero de indiv√≠duos", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados - anuros**

Foram registradas 21 esp√©cies de anuros nas coletas de campo (675 indiv√≠duos) e 12 esp√©cies nas cole√ß√µes cient√≠ficas (37 indiv√≠duos). Com base na rarefa√ß√£o, conclu√≠mos que n√£o h√° diferen√ßa entre a riqueza de esp√©cies de anuros obtida em coletas de campo e cole√ß√µes cient√≠ficas.

## Curva de rarefa√ß√£o baseada em amostras (*sample-based*)

**Exemplo pr√°tico 3 - Morcegos**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados de esp√©cies de morcegos amostradas em tr√™s fragmentos florestais [@breviglieri2008]. Contudo, ao inv√©s de padronizarmos a riqueza de esp√©cies pela abund√¢ncia, iremos padronizar pelo n√∫mero de amostras.

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   Lista de vetores. Cada vetor deve conter como primeira informa√ß√£o o n√∫mero total de amostras (vari√°vel preditora), seguido da frequ√™ncia de ocorr√™ncia das esp√©cies (i.e. n√∫mero de amostras em que cada esp√©cie foi registrada - vari√°vel resposta)

**Checklist**

-   Verificar se sua lista est√° com o n√∫mero total de amostras e a frequ√™ncia de ocorr√™ncia das esp√©cies

**An√°lise**

Vamos olhar os dados.

```{r}
## Cabe√ßalho
head(dados_amostras)
```

Vamos criar uma lista com as amostragens de cada comunidade e os c√≥digos da an√°lise.

```{r}
## Dados
# Usamos [,] para excluir os NAs. Lembrando que valores antes da 
# v√≠rgula representam as linhas e os posteriores representam as colunas.
lista_rarefacao <- list(Tenentes = dados_amostras[1:18, 1],
                        Talhadinho = dados_amostras[, 2],
                        Experimental = dados_amostras[1:16, 3])

## An√°lise
res_rarefacao_amostras <- iNEXT(lista_rarefacao, q = 0, 
                                datatype = "incidence_freq")
```

Visualizar os resultados (Figura \@ref(fig:fig-rare-amos-morcegos)).

```{r fig-rare-amos-morcegos, fig.cap="Curvas de rarefa√ß√£o baseada em amostras de morcegos."}
## Gr√°fico
ggiNEXT(res_rarefacao_amostras , type = 1, color.var = "site") + 
    geom_vline(xintercept = 12, lty = 2) +
    scale_linetype_discrete(name = "M√©todo", labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(x = "N√∫mero de amostras", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Olhando o gr√°fico √© poss√≠vel perceber que a riqueza de esp√©cies de morcegos rarefeita n√£o √© diferente entre os tr√™s fragmentos florestais, quando corrigimos o problema da diferen√ßa no n√∫mero de amostras.

## Curva de rarefa√ß√£o *coverage-based*

**Exemplo pr√°tico 4 - Morcegos**

**Explica√ß√£o dos dados**

Neste exemplo, usaremos os mesmos dados de esp√©cies de morcegos amostradas em tr√™s fragmentos florestais [@breviglieri2008].

**An√°lise**

Os c√≥digos para a realiza√ß√£o da rarefa√ß√£o *coverage-based* s√£o id√™nticos aos utilizados para o c√°lculo das curvas de rarefa√ß√µes baseadas nas abund√¢ncias e amostras. Portanto, n√£o repetiremos as linhas de c√≥digo aqui e utilizaremos os resultados j√° calculados para a visualiza√ß√£o dos gr√°ficos. Para isso, digitamos `type` = 3 que representa a curva de rarefa√ß√£o *coverage-based* (Figura \@ref(fig:fig-rare-cover-morcegos)).

```{r fig-rare-cover-morcegos, fig.cap="Curvas de rarefa√ß√£o baseada coverage-based de morcegos."}
## Gr√°fico
# Visualizar os resultados da rarefa√ß√£o *coverage-based*. 
ggiNEXT(res_rarefacao_amostras, type = 3, color.var = "site") + 
    geom_vline(xintercept = 0.937, lty = 2) +
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    scale_fill_manual(values = c("darkorange", "darkorchid", "cyan4")) +
    labs(x = "Representatividade nas amostras", y = "Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

*Coverage* √© uma medida que determina a propor√ß√£o de amostras (*sampled-based*) ou do n√∫mero de indiv√≠duos (*abundance-based*) da comunidade que representa as esp√©cies presentes na amostra. Um valor de *coverage* = 0,85 representa a riqueza estimada com base em 85% das amostragens ou da abund√¢ncia da comunidade. No nosso exemplo, os valores de *coverage* foram acima de 0,93, indicando que precisamos de praticamente todas as amostras para estimar a riqueza observada em cada comunidade. Comparando as comunidades considerando o mesmo valor de *coverage* 0,937 na comunidade *Tenentes*, identificamos que a riqueza de esp√©cies de morcegos estimada na comunidade *Experimental* √© menor do que a estimada para a comunidade de *Talhadinho* (n√£o h√° sobreposi√ß√£o do intervalo de confian√ßa). Percebam que usando a curva de rarefa√ß√£o *coverage-based*, a interpreta√ß√£o dos resultados foi diferente das observadas usando as curvas baseadas nos indiv√≠duos ou amostras. Veja Chao & Jost [-@chao2012] e Roswell et al. [-@roswell2021] para explica√ß√µes mais detalhadas sobre esta metodologia.

**Exemplo pr√°tico 5 - Generalized Least Squares (GLS)**

**Explica√ß√£o dos dados**

Neste exemplo, iremos refazer o exerc√≠cio do Cap√≠tulo \@ref(cap7) onde usamos Generalized Least Squares (GLS) para testar a rela√ß√£o da riqueza de √°caros com a quantidade de √°gua no substrato. Contudo, ao inv√©s de considerar a riqueza de esp√©cies de √°caros observada como vari√°vel resposta, iremos utilizar a riqueza rarefeita para controlar o efeito da amostragem (i.e. diferentes abund√¢ncias entre as comunidades). Os dados que usaremos est√£o dispon√≠veis no pacote `vegan` e representam a composi√ß√£o de esp√©cies de √°caros amostradas em 70 amostras.

**Pergunta**

- A riqueza rarefeita de esp√©cies de √°caros √© maior em comunidades localizadas em √°reas com substratos secos?

**Predi√ß√µes**

- O n√∫mero de esp√©cies rarefeita ser√° maior em substratos secos, uma vez que as limita√ß√µes fisiol√≥gicas impostas pela umidade limitam a ocorr√™ncia de v√°rias esp√©cies de √°caros

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   Matriz ou data frame com as abund√¢ncias das esp√©cies de √°caros (vari√°vel resposta) registradas em 70 comunidades (vari√°vel preditora)

**Checklist**

-   Verificar se a sua matriz ou data frame est√£o com as esp√©cies nas linhas e as comunidades nas colunas

**An√°lise**

Vamos calcular a riqueza rarefeita com base na comunidade com menor abund√¢ncia.

```{r}
## Menos abund√¢ncia
# Os dados est√£o com as comunidades nas colunas e as esp√©cies nas linhas. 
# Para as an√°lises teremos que transpor a planilha.
composicao_acaros <- t(mite)

# Verificar qual √© a menor abund√¢ncia registrada nas comunidades. 
abun_min <- min(colSums(composicao_acaros))
```

Vamos calcular a riqueza rarefeita de esp√©cies para todas as comunidades considerando a menor abund√¢ncia. 

Para padronizar e facilitar a extra√ß√£o dos resultados, definimos os argumentos `knots` (i.e. representa o intervalo igualmente espa√ßado que a fun√ß√£o ir√° utilizar para determinar a riqueza estimada) e `endpoint` (i.e. o valor final de amostras ou abund√¢ncia extrapolados) com o valor de abund√¢ncia = 8.

```{r warning=FALSE, message=FALSE}
## Riqueza rarefeita
resultados_rarefacao <- iNEXT(composicao_acaros, q = 0, 
                              datatype = "abundance", 
                              knots = abun_min,
                              endpoint = abun_min)

```

Lembrando, estamos interessados no valor rarefeito considerando a abund√¢ncia de 8 indiv√≠duos. Esta informa√ß√£o est√° armazenada na linha 8 e na coluna 4 dos data frames salvos no objeto `resultados_rarefa√ß√£o$iNextEst`. Assim, para obtermos o valor rarefeito de interesse, vamos criar um `loop for` para facilitar a extra√ß√£o da riqueza rarefeita para as 70 comunidades. 

```{r}
## Riqueza rarefeita para cada comunidade
riqueza_rarefeita <- c()

for (i in 1:70) {
  resultados_comunidades <- resultados_rarefacao$iNextEst[[i]]
  subset_res <- resultados_comunidades %>% dplyr::filter(m==abun_min)
  riqueza_rarefeita[i] <- subset_res$qD
}
```

Vamos juntar esses resultados com os dados geogr√°ficos e ambientais.

```{r}
## Dados finais
# Agrupando os dados em um data frame final.
dados_combinado <- data.frame(riqueza_rarefeita, agua, coord)
```

Agora, seguindo os passos descritos no Cap√≠tulo \@ref(cap7), vamos identificar o melhor modelo que representa a estrutura espacial dos dados da riqueza rarefeita.

```{r}
## Criando diferentes modelos usando a fun√ß√£o gls
## Sem estrutura espacial
no_spat_gls <- gls(riqueza_rarefeita ~ agua, data = dados_combinado, 
                   method = "REML")

## Covari√¢ncia esf√©rica 
espher_model <- gls(riqueza_rarefeita ~ agua, data = dados_combinado, 
                    corSpher(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia exponencial 
expon_model <- gls(riqueza_rarefeita ~ agua, data = dados_combinado, 
                   corExp(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia Gaussiana 
gauss_model <- gls(riqueza_rarefeita ~ agua, data = dados_combinado, 
                   corGaus(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia raz√£o quadr√°tica 
ratio_model <- gls(riqueza_rarefeita ~ agua, data = dados_combinado, 
                   corRatio(form = ~lat + long, nugget = TRUE))
```

Agora vamos usar a sele√ß√£o de modelo por AIC para selecionar o modelo mais "prov√°vel" explicando a distribui√ß√£o da riqueza rarefeita das esp√©cies de √°caros (Figura \@ref(fig:fig-rare-resi-acaros)).

```{r fig-rare-resi-acaros, fig.cap="Visualiza√ß√£o dos res√≠duos do modelo selecionado."}
## Sele√ß√£o dos modelos
aic_fit <- AIC(no_spat_gls, espher_model, expon_model, 
               gauss_model, ratio_model)
aic_fit %>% arrange(AIC)

## Visualizando os res√≠duos do modelo selecionado
plot(gauss_model)
```

Percebam que os pontos est√£o dispersos no gr√°fico e n√£o apresentam padr√µes que indiquem heterogeneidade de vari√¢ncia (Figura \@ref(fig:fig-rare-model-acaros)).

```{r fig-rare-model-acaros, fig.cap="Gr√°fico do modelo GLS selecionado."}
## Visualizando os resultados
summary(gauss_model)$tTable 

## Calculando o R-squared
rsquared(gauss_model)

## Obtendo os valores preditos pelo modelo
predito <- predict(gauss_model) 

## Plotando os resultados no gr√°fico
ggplot(data = dados_combinado, aes(x= agua, y= riqueza_rarefeita)) + 
    geom_point(size = 4, shape = 21, fill = "gray", alpha = 0.7) +
    geom_line(aes(y = predito), size = 1) +
    labs(x = "Concentra√ß√£o de √°gua no substrato", 
         y = "Riqueza rarefeita \ndas esp√©cies de √°caros") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

A concentra√ß√£o de √°gua no substrato explica 29,9% da varia√ß√£o na riqueza rarefeita das esp√©cies de √°caros. Como predito, a riqueza de esp√©cies de √°caros foi maior em comunidades localizadas em √°reas com substratos secos do que em √°reas com substratos √∫midos (t = -4.71, df = 68, P \< 0.01).

## Para se aprofundar

### Livros

-   Recomendamos o livro *Biological Diversity Frontiers in Measurement and Assessment* [@magurran_biological_2011]
   
### Links
-   Recomendamos tamb√©m que acessem a p√°gina do [EstimateS software](http://viceroy.eeb.uconn.edu/estimates) e baixem o manual do usu√°rio que cont√©m informa√ß√µes detalhadas sobre os √≠ndices de rarefa√ß√£o. Este site foi criado e √© mantido pelo Dr. Robert K. Colwell, um dos maiores especialistas do mundo em estimativas da biodiversidade

-   Recomendamos a p√°gina pessoal da pesquisadora [Anne Chao](http://chao.stat.nthu.edu.tw/wordpress/software_download/inext-online/) que √© uma das respons√°veis pelo desenvolvimento da metodologia e do pacote iNEXT. Nesta p√°gina, voc√™s ir√£o encontrar exemplos e explica√ß√µes detalhadas sobre as an√°lises


## Exerc√≠cios

**10.1**
Usando os dados `Cap10_exercicio1` dispon√≠vel no pacote `ecodados`, avalie se diferentes tipos de uso da terra (fragmento florestal, borda de mata, √°rea de pastagem e cana de a√ß√∫car) apresentam diferentes riquezas de esp√©cies? Qual a sua interpreta√ß√£o? Fa√ßa um gr√°fico com os resultados.

**10.2**
O estudo √© o mesmo do exerc√≠cio anterior. Contudo, ao inv√©s da rarefa√ß√£o baseada na abund√¢ncia, fa√ßa rarefa√ß√µes baseadas no n√∫mero de amostras. Qual a sua interpreta√ß√£o considerando os resultados do exerc√≠cio 1? Fa√ßa um gr√°fico com os resultados.

**10.3**
Use os dados dos exerc√≠cios anteriores e calcule a rarefa√ß√£o baseada na cobertura de amostragem (coverage-based). Qual a sua interpreta√ß√£o considerando os resultados anteriores? Fa√ßa um gr√°fico com os resultados. 

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-10---rarefa%C3%A7%C3%A3o.html).

<!--chapter:end:10_rarefacao.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Estimadores de riqueza {#cap11}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(iNEXT)
library(devtools)
library(ecodados)
library(ggplot2)
library(vegan)
library(nlme)
library(dplyr)
library(piecewiseSEM)

## Dados
dados_coleta <- poca_anuros
data(mite)
data(mite.xy)
coord <- mite.xy
colnames(coord) <- c("long", "lat") # altera o nome das colunas
data(mite.env)
agua <- mite.env[, 2] # seleciona a vari√°vel de interesse
```

## Aspectos te√≥ricos

Uma vez que determinar o n√∫mero total de esp√©cies numa √°rea √© praticamente imposs√≠vel, principalmente em regi√µes com alta riqueza de esp√©cies, os estimadores s√£o √∫teis para extrapolar a riqueza observada e tentar estimar a riqueza total atrav√©s de uma amostra incompleta de uma comunidade biol√≥gica [@walther2005]. Neste cap√≠tulo, ser√£o considerados os estimadores n√£o param√©tricos que usam informa√ß√µes da frequ√™ncia de esp√©cies raras na comunidade [@gotelli2013]. Isto porque tanto os testes param√©tricos que tentam determinar os par√¢metros de uma curva usando o formato da curva de acumula√ß√£o de esp√©cies (e.g. equa√ß√£o log√≠stica, Michaelis-Menten), quanto os testes que usam a frequ√™ncia do n√∫mero de indiv√≠duos para enquadr√°-las em uma das distribui√ß√µes de abund√¢ncia das esp√©cies (e.g. distribui√ß√µes log-s√©ries, log-normal) n√£o funcionam muito bem com dados emp√≠ricos [@gotelli2013]. Para mais detalhes sobre os testes param√©tricos veja Magurran & McGill [-@magurran_biological_2011] e  Colwell & Coddington [-@colwell1994].

Para que estimador de riqueza seja considera bom, ele precisa atender a quatro caracter√≠sticas  [@chazdon1998; @hortal2006].

1. Independ√™ncia do tamanho da amostra (quantidade de esfor√ßo amostral realizado)
1. Insensibilidade a diferentes padr√µes de distribui√ß√µes (e.g. agrupado, disperso ou aleat√≥rio)
1. Insensibilidade em rela√ß√£o √† ordem das amostragens
1. Insensibilidade √† heterogeneidade entre as amostras usadas entre os estudos

## Estimadores baseados na abund√¢ncia das esp√©cies

### CHAO 1

Estimador simples do n√∫mero absoluto de esp√©cies em uma comunidade. √â baseado no n√∫mero de esp√©cies raras dentro de uma amostra [@chao1984; @chao1987].

$$Chao_{1} = S_{obs} + \left(\frac{n-1}{n}\right)\frac{F_1(F_1-1)}{2(F_2+1)}$$

onde:

- S~obs~ = n√∫mero de esp√©cies observadas na comunidade
- *n* = n√∫mero de amostras
- F~1~ = n√∫mero de esp√©cies observadas com abund√¢ncia de um indiv√≠duo (esp√©cies *singleton*)
- F~2~ = n√∫mero de esp√©cies observadas com abund√¢ncia de dois indiv√≠duos (esp√©cies *doubletons*)

O valor de Chao 1 √© m√°ximo quando todas as esp√©cies menos uma s√£o √∫nicas (*singleton*). Neste caso, a riqueza estimada √© aproximadamente o dobro da riqueza observada.

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos os dados hipot√©ticos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o noroeste do estado de S√£o Paulo, Brasil.

**Pergunta**

- Quantas esp√©cies a mais poderiam ser amostradas caso aument√°ssemos o esfor√ßo amostral at√© o infinito?

**Predi√ß√µes**

- O n√∫mero de esp√©cies estimadas √© similar ao n√∫mero de esp√©cies observadas
- O n√∫mero de esp√©cies estimadas √© maior do que o n√∫mero de esp√©cies observadas

**Vari√°veis**

-   Vari√°veis resposta e preditora

-   data frame com as abund√¢ncias das esp√©cies de anuros (vari√°vel resposta) registradas em 14 dias de amostragens (vari√°vel preditora) em um habitat reprodutivo

**Checklist**

-   Verificar se a sua matriz est√° com as esp√©cies nas colunas e as amostragens nas linhas 
-   Verificar se os dados s√£o de abund√¢ncia e n√£o de incid√™ncia (presen√ßa e aus√™ncia)

**An√°lise**

Vamos olhar os dados.

```{r}
## Cabe√ßalho
head(poca_anuros)
```

C√°lculo do estimador de riqueza - Chao 1.

```{r}
## An√°lise
est_chao1 <- estaccumR(dados_coleta, permutations = 100)
summary(est_chao1, display = "chao")
```

Percebam que a fun√ß√£o retorna: N = n√∫mero de amostragens, Chao = valor m√©dio da estimativa do √≠ndice de Chao, 2.5% e 97.5% = intervalo de confian√ßa de 95%, e Std.Dev = desvio padr√£o. Essas dados s√£o obtidos usando permuta√ß√µes, sem reposi√ß√£o, que alteram a ordem das amostragens. Neste exemplo, usamos 100 permuta√ß√µes.

Vamos visualizar os resultados com intervalo de confian√ßa de 95% (Figura \@ref(fig:fig-chao1)).

```{r fig-chao1, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador Chao 1."}
## Preparando os dados para fazer o gr√°fico
resultados <- summary(est_chao1, display = c("S", "chao"))
res_chao <- cbind(resultados$chao[, 1:4], resultados$S[, 2:4])
res_chao <- as.data.frame(res_chao)
colnames(res_chao) <- c("Amostras", "Chao", "C_inferior", "C_superior", 
                        "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_chao, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = Chao, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 7.5, x = 9, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 5.9, x = 9, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 7.5, x = 12, label = "Riqueza estimada - Chao 1") +
    geom_label(y = 5.9, x = 11.3, label = "Riqueza observada") + 
    geom_line(aes(y = Chao, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = C_inferior, ymax = C_superior,
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior,
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs (x = "N√∫mero de amostras", y = "Riqueza estimada - Chao 1") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base no n√∫mero de esp√©cies raras (*singletons* e *doubletons*), o estimador Chao 1 indicou a possibilidade de encontrarmos mais tr√™s esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estima tend√™ncia de estabiliza√ß√£o da curva em uma ass√≠ntota.

### ACE - *Abundance-based Coverage Estimator*

Este m√©todo trabalha com a abund√¢ncia das esp√©cies raras (i.e. abund√¢ncia baixa) [@chao1992; @chao2000]. Entretanto, diferente do estimador anterior, esse m√©todo permite ao pesquisador determinar os limites para os quais uma esp√©cie seja considerada rara. Em geral, s√£o consideradas raras esp√©cies com abund√¢ncia entre 1 e 10 indiv√≠duos. A riqueza estimada pode variar conforme se aumente ou diminua o limiar de abund√¢ncia, e infelizmente n√£o existem crit√©rios biol√≥gicos definidos para a escolha do melhor intervalo.

$$ACE = S_{abund} + \frac{S_{rare}}{C_{ace}} + \frac{F_1}{C_{ace}}Y_{ace}^2$$

onde:

- $$Y_{ace}^2 = max \left[\frac{S_{rare}}{C_{ace}}\frac{\sum_{i=i}^{10}i(i-1)F1}{(N_{rare})({N_{rare} - 1)}}-1,0\right]$$

- $$C_{ace} = 1 - \frac{F1}{N_{rare}}$$

- $$N_{rare} = \sum_{i=1}^{10}iF_i$$

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados hipot√©ticos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo do estimador de riqueza - ACE.

```{r}
## An√°lise
est_ace <- estaccumR(dados_coleta, permutations = 100)
summary(est_ace, display = "ace")
```

Visualizar os resultados com intervalo de confian√ßa de 95% (Figura \@ref(fig:fig-ace)).

```{r fig-ace, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador ACE."}
## Preparando os dados para fazer o gr√°fico
resultados_ace <- summary(est_ace, display = c("S", "ace"))
res_ace <- cbind(resultados_ace$ace[, 1:4], resultados_ace$S[, 2:4])
res_ace <- as.data.frame(res_ace)
colnames(res_ace) <- c("Amostras", "ACE", "ACE_inferior", "ACE_superior", 
                       "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_ace, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = ACE, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 7.5, x = 9, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 5.9, x = 9, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 7.5, x = 11.7, label = "Riqueza estimada - ACE") +
    geom_label(y = 5.9, x = 11.3, label = "Riqueza observada") +
    geom_line(aes(y = ACE, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = ACE_inferior, ymax = ACE_superior, 
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior,
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs(x = "N√∫mero de amostras", y = "Riqueza estimada - ACE") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base no n√∫mero de esp√©cies raras (abund√¢ncia menor que 10 indiv√≠duos - *default*), o estimador ACE indica a possibilidade de encontrarmos mais sete esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estimou tend√™ncia de estabiliza√ß√£o da curva em uma ass√≠ntota.

## Estimadores baseados na incid√™ncia das esp√©cies

### CHAO 2

De acordo com [Anne Chao](http://chao.stat.nthu.edu.tw/wordpress/), o estimador Chao 1 pode ser modificado para uso com dados de presen√ßa/aus√™ncia levando em conta a distribui√ß√£o das esp√©cies entre amostras [@chao1987]. Neste caso √© necess√°rio somente conhecer o n√∫mero de esp√©cies encontradas em somente uma amostra e o n√∫mero de esp√©cies encontradas exatamente em duas amostras. Essa varia√ß√£o ficou denominada como Chao 2.

$$Chao_{2} = S_{obs} + \left(\frac{m-1}{m}\right)\left(\frac{Q_1(Q_1-1)}{2(Q_2 + 1}\right)$$

onde:

-   S~obs~ = o n√∫mero de esp√©cies observada na comunidade
-   *m* = n√∫mero de amostras
-   Q~1~ = n√∫mero de esp√©cies observadas em uma amostra (esp√©cies *uniques*)
-   Q~2~ = n√∫mero de esp√©cies observadas em duas amostras (esp√©cies *duplicates*)

O valor de Chao2 √© m√°ximo quando as esp√©cies menos uma s√£o √∫nicas (*uniques*). Neste caso, a riqueza estimada √© aproximadamente o dobro da riqueza observada.

Colwell & Coddington [-@colwell1994] encontraram que o valor de Chao 2 mostrou ser o estimador menos enviesado para amostras com tamanho pequeno.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Voc√™ perceber√° que ao longo do cap√≠tulo as recomenda√ß√µes sobre qual √© o melhor √≠ndice varia entre estudos [e.g. @palmer1990; @walther2005].
:::

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos novamente os mesmos dados hipot√©ticos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo do estimador de riqueza - Chao 2.

```{r}
## An√°lise
est_chao2 <- poolaccum(dados_coleta, permutations = 100)
summary(est_chao2, display = "chao")
```

Visualizar os resultados com intervalo de confian√ßa de 95% (Figura \@ref(fig:fig-chao2)).

```{r fig-chao2, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador Chao 2."}
## Preparando os dados para fazer o gr√°fico
resultados_chao2 <- summary(est_chao2, display = c("S", "chao"))
res_chao2 <- cbind(resultados_chao2$chao[, 1:4], resultados_chao2$S[, 2:4])
res_chao2 <- as.data.frame(res_chao2)
colnames(res_chao2) <- c("Amostras", "Chao2", "C_inferior", "C_superior",
                         "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_chao2, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = Chao2, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 9.8, x = 10, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 7.7, x = 10, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 9.8, x = 12.95, label = "Riqueza estimada - Chao 2") +
    geom_label(y = 7.7, x = 12.3, label = "Riqueza observada") +
    geom_line(aes(y = Chao2, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = C_inferior, ymax = C_superior, 
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior,
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs(x = "N√∫mero de amostras", y = "Riqueza estimada - Chao 2") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base no n√∫mero de esp√©cies raras (*uniques* e *duplicates*), o estimador Chao 2 encontrou a possibilidade de acharmos mais dezesseis esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estimou tend√™ncia de estabiliza√ß√£o da curva em uma ass√≠ntota.

### JACKKNIFE 1

Este estimador baseia-se no n√∫mero de esp√©cies que ocorrem em somente uma amostra (Q~1~) [@burnham1978; @burnham1979].

$$S_{jack1} = S_{obs} + Q_1\left(\frac{m - 1}{m}\right)$$

onde:

-   S~obs~ = o n√∫mero de esp√©cies observadas na comunidade
-   Q~1~ = n√∫mero de esp√©cies observadas em uma amostra (esp√©cies *uniques*)
-   *m* = n√∫mero de amostras

Jackknife √© um m√©todo de reamostragem (sem repeti√ß√£o) n√£o param√©trico usado para estimar a riqueza de esp√©cies e a vari√¢ncia associada com a estimativa. Para isso, o m√©todo: i) exclui uma amostra e contabiliza o valor da riqueza estimada usando a f√≥rmula acima, ii) repete este processo *n* vezes at√© que todas as amostras tenham sido exclu√≠das, e iii) estima a m√©dia e a vari√¢ncia da riqueza de esp√©cie [@smith1984].

Palmer [-@palmer1990] verificou que Jackknife 1 foi o estimador mais preciso e menos enviesado comparado a outros m√©todos de extrapola√ß√£o.

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados hipot√©ticos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo do estimador de riqueza - Jackknife 1.

```{r}
## An√°lise
est_jack1 <- poolaccum(dados_coleta, permutations = 100)
summary(est_jack1, display = "jack1")
```

Visualizar os resultados com 95% intervalo de confian√ßa (Figura \@ref(fig:fig-jack1)).

```{r fig-jack1, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador Jackknife 1."}
## Preparando os dados para fazer o gr√°fico
resultados_jack1 <- summary(est_jack1, display = c("S", "jack1"))
res_jack1 <- cbind(resultados_jack1$jack1[, 1:4], resultados_jack1$S[, 2:4])
res_jack1 <- as.data.frame(res_jack1)
colnames(res_jack1) <- c("Amostras", "JACK1", "JACK1_inferior", "JACK1_superior", 
                         "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_jack1, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = JACK1, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 9.9, x = 9, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 8.6, x = 9, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 9.9, x = 12.5, label = "Riqueza estimada - Jackknife 1") +
    geom_label(y = 8.6, x = 11.5, label = "Riqueza observada") +
    geom_line(aes(y = JACK1, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = JACK1_inferior, ymax = JACK1_superior, 
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior, 
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs(x = "N√∫mero de amostras", y = "Riqueza estimada - Jackknife 1") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base no n√∫mero de esp√©cies raras, o estimador Jackknife 1 estimou possibilidade de encontrarmos mais seis esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estimou tend√™ncia de estabiliza√ß√£o da curva em uma ass√≠ntota.

### JACKKNIFE 2

Este m√©todo baseia-se no n√∫mero de esp√©cies que ocorrem em apenas uma amostra e no n√∫mero de esp√©cies que ocorrem em exatamente duas amostras  [@burnham1978; @burnham1979; @palmer1991].

$$S_{jack2} = S_{obs} + \left[\frac{Q_1(2m - 3)}{m}-\frac{Q_2(m - 2)^2}{m(m-1)}\right]$$

onde:

-   S~obs~ = o n√∫mero de esp√©cies observadas na comunidade
-   *m* = n√∫mero de amostras
-   Q~1~ = n√∫mero de esp√©cies observadas em uma amostra (esp√©cies *uniques*)
-   Q~2~ = n√∫mero de esp√©cies observadas em duas amostras (esp√©cies *duplicates*)

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados hipot√©ricos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo do estimador de riqueza - Jackknife 2.

```{r}
## An√°lise
est_jack2 <- poolaccum(dados_coleta, permutations = 100)
summary(est_jack2, display = "jack2")
```

Visualizar os resultados com intervalo de confian√ßa de 95% (Figura \@ref(fig:fig-jack2)).

```{r fig-jack2, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador Jackknife 2."}
## Preparando os dados para fazer o gr√°fico
resultados_jack2 <- summary(est_jack2, display = c("S", "jack2"))
res_jack2 <- cbind(resultados_jack2$jack2[, 1:4], resultados_jack2$S[, 2:4])
res_jack2 <- as.data.frame(res_jack2)
colnames(res_jack2) <- c("Amostras", "JACK2", "JACK2_inferior", "JACK2_superior", 
                         "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_jack2, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = JACK2, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 9.9, x = 9, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 8.2, x = 9, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 9.9, x = 12.5, label = "Riqueza estimada - Jackknife 2") +
    geom_label(y = 8.2, x = 11.5, label = "Riqueza observada") +
    geom_line(aes(y = JACK2, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = JACK2_inferior, ymax = JACK2_superior, 
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior, 
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs(x = "N√∫mero de amostras", y = "Riqueza estimada - Jackknife 2") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base no n√∫mero de esp√©cies raras, o estimador Jackknife 2 estimou a possibilidade de encontrarmos mais dez esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estimou tend√™ncia estabiliza√ß√£o da curva em uma ass√≠ntota.

### BOOTSTRAP

Este m√©todo difere dos demais por utilizar dados de todas as esp√©cies coletadas para estimar a riqueza total, n√£o se restringindo √†s esp√©cies raras [@smith1984]. Ele requer somente dados de incid√™ncia. A estimativa pelo bootstrap √© calculada somando-se a riqueza observada √† soma do inverso da propor√ß√£o de amostras em que cada esp√©cie ocorre.

$$S_{boot} = S_{obs} + \sum_{k=1}^{S_{obs}}(1-P_k)^m$$

onde:

-   S~obs~ = o n√∫mero de esp√©cies observadas na comunidade
-   *m* = n√∫mero de amostragens
-   P~k~ = propor√ß√£o do n√∫mero de amostras em que cada esp√©cie foi registrada

Bootstrap √© um m√©todo n√£o param√©trico usado para estimar os par√¢metros de uma popula√ß√£o por reamostragem. A premissa √© que as reamostragens podem ser entendidas como pseudo-popula√ß√µes, com caracter√≠sticas similares as da popula√ß√£o original. Para isso, o m√©todo: i) seleciona ao acaso um conjunto de amostras (no nosso exemplo 14 amostras) **com reposi√ß√£o**, ii) repete este processo *n* vezes, e iii) estima a m√©dia e a vari√¢ncia da riqueza de esp√©cie [@smith1984].

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados hipot√©ricos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo do estimador de riqueza - Bootstrap.

```{r}
## An√°lise
est_boot <- poolaccum(dados_coleta, permutations = 100)
summary(est_boot, display = "boot")
```

Visualizar os resultados com intervalo de confian√ßa de 95% (Figura \@ref(fig:fig-boot)).

```{r fig-boot, fig.cap="Resultados com intervalo de confian√ßa de 95% para o estimador Bootstrap."}
## Preparando os dados para fazer o gr√°fico
resultados_boot <- summary(est_boot, display = c("S", "boot"))
res_boot <- cbind(resultados_boot$boot[,1:4], resultados_boot$S[,2:4])
res_boot <- as.data.frame(res_boot)
colnames(res_boot) <- c("Amostras", "BOOT", "BOOT_inferior", "BOOT_superior", 
                        "Riqueza", "R_inferior", "R_superior")

## Gr√°fico
ggplot(res_boot, aes(y = Riqueza, x = Amostras)) +
    geom_point(aes(y = BOOT, x = Amostras + 0.1), size = 4, 
               color = "darkorange", alpha = 0.7) +
    geom_point(aes(y = Riqueza, x = Amostras), size = 4, 
               color = "cyan4", alpha = 0.7) +
    geom_point(y = 10.4, x = 9, size = 4, color = "darkorange", alpha = 0.7) + 
    geom_point(y = 9.3, x = 9, size = 4, color = "cyan4", alpha = 0.7) + 
    geom_label(y = 10.4, x = 12.3, label = "Riqueza estimada - Bootstrap") +
    geom_label(y = 9.3, x = 11.5, label = "Riqueza observada") +
    geom_line(aes(y = BOOT, x = Amostras), color = "darkorange") +
    geom_line(aes(y = Riqueza, x = Amostras), color = "cyan4") +
    geom_linerange(aes(ymin = BOOT_inferior, ymax = BOOT_superior, 
                       x = Amostras + 0.1), color = "darkorange") +
    geom_linerange(aes(ymin = R_inferior, ymax = R_superior, 
                       x = Amostras), color = "cyan4") +
    scale_x_continuous(limits = c(1, 15), breaks = seq(1, 15, 1)) +
    labs(x = "N√∫mero de amostras", y = "Riqueza estimada - Bootstrap") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Com base na frequ√™ncia de ocorr√™ncia das esp√©cies, o estimador bootstrap estimou a possibilidade de encontrarmos mais duas esp√©cies, caso o esfor√ßo amostral fosse maior e n√£o estimou tend√™ncia de estabiliza√ß√£o da curva em uma ass√≠ntota.

## Interpola√ß√£o e extrapola√ß√£o baseadas em rarefa√ß√£o usando amostragens de incid√™ncia ou abund√¢ncia

Este m√©todo utiliza teoria de amostragem (e.g. modelos multinomial, Poisson e Bernoulli) para conectar rarefa√ß√£o (interpola√ß√£o) e predi√ß√£o (extrapola√ß√£o) com base no tamanho da amostra [@chao2012; @colwell2012]. Ele utiliza uma abordagem com bootstrap para calcular o intervalo de confian√ßa de 95%.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A extrapola√ß√£o torna-se altamente incerta quando estendida para o dobro ou mais do tamanho da amostragem.
:::

**Exemplo pr√°tico 1**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados hipot√©ticos de 17 esp√©cies de anuros amostradas em 14 dias de coletas de campo em um habitat reprodutivo localizado na regi√£o Noroeste do Estado de S√£o Paulo, Brasil.

**An√°lise**

C√°lculo da extrapola√ß√£o da riqueza com base no n√∫mero de indiv√≠duos (Figura \@ref(fig:fig-extra)).

```{r fig-extra, fig.cap="Resultados com intervalo de confian√ßa de 95% para a extrapola√ß√£o."}
## Preparando os dados para an√°lises considerando a abund√¢ncia
dados_inext_abu <- colSums(dados_coleta) 
resultados_abundancia <- iNEXT(dados_inext_abu, q = 0, datatype = "abundance", 
                               endpoint = 600)

## Gr√°fico
ggiNEXT(resultados_abundancia, type = 1) + 
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = "darkorange") +
    scale_fill_manual(values = "darkorange") +
    labs(x = "N√∫mero de indiv√≠duos", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Veja que o ponto no final da linha cont√≠nua representa as 17 esp√©cies de anuros (eixo Y) observadas entre os 304 individuos (eixo X). A extrapola√ß√£o m√°xima (600 indiv√≠duos no nosso exemplo) estima um aumento de at√© oito esp√©cies (intervalo de confian√ßa) caso amostr√°ssemos mais 296 indiv√≠duos.

C√°lculo da extrapola√ß√£o da riqueza com base no n√∫mero de amostras (Figura \@ref(fig:fig-boot-riq)).

```{r fig-boot-riq, fig.cap="Resultados com intervalo de confian√ßa de 95% para extrapola√ß√£o da riqueza."}
## Preparando os dados para an√°lises considerando a incid√™ncia
# Precisa transpor o data frame.
dados_inext <- as.incfreq(t(dados_coleta)) 
resultados_incidencia <- iNEXT(dados_inext, q = 0, datatype = "incidence_freq", 
                               endpoint = 28)

## Gr√°fico
ggiNEXT(resultados_incidencia, type = 1) +
    scale_linetype_discrete(labels = c("Interpolado", "Extrapolado")) +
    scale_colour_manual(values = "darkorange") +
    scale_fill_manual(values = "darkorange") +
    labs(x = "N√∫mero de amostras", y = " Riqueza de esp√©cies") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Veja que o ponto no final da linha cont√≠nua representa as 17 esp√©cies de anuros (eixo Y) observadas nos 14 dias de coleta (eixo X - amostras). A extrapola√ß√£o m√°xima (28 dias de coleta no nosso exemplo) estima um aumento de at√© 12 esp√©cies (intervalo de confian√ßa) caso amostr√°ssemos mais 14 dias.

**Exemplo pr√°tico 2**

**Explica√ß√£o dos dados**

Neste exemplo, iremos refazer o exemplo do Cap√≠tulo \@ref(cap7) que usa Generalized Least Squares (GLS) para testar a rela√ß√£o da riqueza de √°caros com a quantidade de √°gua no substrato. Contudo, ao inv√©s de considerar a riqueza de esp√©cies de √°caros observada como vari√°vel resposta, iremos utilizar a riqueza extrapolada. Os dados que usaremos est√£o dispon√≠veis no pacote `vegan` e representam a composi√ß√£o de esp√©cies de √°caros amostradas em 70 comunidades/amostras.

**Pergunta**

- A riqueza extrapolada de esp√©cies de √°caros √© maior em comunidades localizadas em √°reas com substratos secos?

**Predi√ß√µes**

- O n√∫mero de esp√©cies extrapolada ser√° maior em substratos secos uma vez que as limita√ß√µes fisiol√≥gicas impostas pela umidade limitam a ocorr√™ncia de v√°rias esp√©cies de √°caros

**Vari√°veis**

-   Vari√°veis resposta e preditoras

-   matriz ou data frame com as abund√¢ncias das esp√©cies de √°caros (vari√°vel resposta) registradas em 70 comunidades/amostras (vari√°vel preditora)

**Checklist**

-   Verificar se a sua matriz ou data frame est√£o com as esp√©cies nas linhas e as comunidades nas colunas

**An√°lise**

Vamos iniciar calculando a riqueza extrapolada com base na comunidade com maior abund√¢ncia.

```{r warning=FALSE, message=FALSE}
## Transposi√ß√£o
# Os dados est√£o com as comunidades nas colunas e as esp√©cies nas linhas. 
# Para as an√°lises teremos que transpor a planilha.
composicao_acaros <- t(mite)

## Dados
# A comunidade com maior abund√¢ncia tem 781 indiv√≠duos. 
max(colSums(composicao_acaros))

# Calcular a riqueza extrapolada de esp√©cies para todas as comunidades 
# considerando a maior abund√¢ncia. 
resultados_extrapolacao <- iNEXT(composicao_acaros, q = 0, 
                                 datatype = "abundance", 
                                 endpoint = 781)
```

Lembrando, estamos interessados no valor rarefeito considerando a abund√¢ncia total de 781 indiv√≠duos. Esta informa√ß√£o est√° armazenada na linha 40 e na coluna 4 dos data frames salvos no objeto `resultados_extrapolacao$iNextEst`. Assim, para obtermos o valor rarefeito de interesse, vamos criar um `loop for` para facilitar a extra√ß√£o da riqueza rarefeita para as 70 comunidades. 

```{r}
## Dados
# Criando um data.frame vazio para salvar os dados
resultados_comunidades_ext <- data.frame()

# Criando um vetor vazio para salvar os resultados
riqueza_extrapolada <- c()

## Lopp
# Loop repetindo as an√°lises para as 70 comunidades
# O objetivo √© extrair a riqueza estimada extrapolada para 781 individuos
for (i in 1:70){
    resultados_comunidades_ext <- data.frame(resultados_extrapolacao$iNextEst[i])
    riqueza_extrapolada[i] <- resultados_comunidades_ext[40, 4] # 8 abund√¢ncia e 4 riqueza rarefeita
}
```

Agora, seguindo os passos descritos no Cap√≠tulo \@ref(cap7), vamos identificar o melhor modelo que representa a estrutura espacial dos dados extrapolados.

```{r}
## Dados
# Criando data frame com todas as vari√°veis
dados_combinado_ext <- data.frame(riqueza_extrapolada, agua, coord)

## Modelo gls sem estrutura espacial
no_spat_gls <- gls(riqueza_extrapolada ~ agua, 
                   data = dados_combinado_ext, 
                   method = "REML")

## Covari√¢ncia esf√©rica
espher_model <- gls(riqueza_extrapolada ~ agua, 
                    data = dados_combinado_ext, 
                    corSpher(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia exponencial
expon_model <- gls(riqueza_extrapolada ~ agua, 
                   data = dados_combinado_ext, 
                   corExp(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia Gaussiana
gauss_model <- gls(riqueza_extrapolada ~ agua,
                   data = dados_combinado_ext, 
                   corGaus(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia linear
cor_linear_model <- gls(riqueza_extrapolada ~ agua,
                        data = dados_combinado_ext,
                        corLin(form = ~lat + long, nugget = TRUE))

## Covari√¢ncia raz√£o quadr√°tica
ratio_model <- gls(riqueza_extrapolada ~ agua, 
                   data = dados_combinado_ext, 
                   corRatio(form = ~lat + long, nugget = TRUE))
```

Vamos usar a sele√ß√£o de modelos por o AIC para selecionar o modelo mais "prov√°vel" explicando a distribui√ß√£o da riqueza extrapolada das esp√©cies de √°caros (Figura \@ref(fig:fig-ext-resi-acaros)).

```{r fig-ext-resi-acaros, fig.cap="Visualiza√ß√£o dos res√≠duos do modelo selecionado."}
## Sele√ß√£o dos modelos
aic_fit_ext <- AIC(no_spat_gls, espher_model, 
                   cor_linear_model, expon_model, 
                   gauss_model, ratio_model)
aic_fit_ext %>% arrange(AIC)

## Visualizando os res√≠duos do modelo com menor valor de AIC (veja Cap√≠tulo 7)
plot(ratio_model)
```

De forma geral, a distribui√ß√£o dos res√≠duos est√° adequada com apenas dois pontos fugindo da nuvem. Contudo, eles podem influenciar os resultados (Figura \@ref(fig:fig-ext-model-acaros)).

```{r fig-ext-model-acaros, fig.cap="Gr√°fico do modelo GLS selecionado."}
## Visualizando os resultados e calculando pseudo-R-squared.
summary(ratio_model)$tTable 
rsquared(ratio_model)

## Gr√°fico
predito_ext <- predict(ratio_model) 

ggplot(data = dados_combinado_ext, aes(x= agua, y= riqueza_extrapolada)) + 
    geom_point(size = 4, shape = 21, fill = "darkorange", alpha = 0.7) +
    geom_line(aes(y = predito_ext), size = 1) +
    labs(x = "Concentra√ß√£o de √°gua no substrato", 
         y = "Riqueza extrapolada \ndas esp√©cies de √°caros") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

A riqueza extrapolada das esp√©cies de √°caros foi maior em comunidades localizadas em √°reas com substratos secos do que em √°reas com substratos √∫midos. Contudo, apesar do modelo apresentar um rela√ß√£o significativa entre as vari√°veis, a concentra√ß√£o de √°gua explica apenas 5,9% da varia√ß√£o da riqueza extrapolada das esp√©cies de √°caros. O padr√£o observado, valor de P \< 0.05 e o baixo valor de R^2^, provavelmente est√° relacionado com as duas comunidades com altos valores de riqueza extapolada (e.g. *outilers*). Refa√ßa as an√°lises sem os dois pontos e vejam o padr√£o dos novos resultados.

## Para se aprofundar

### Livros

-   Recomendamos o livro *Biological Diversity Frontiers in Measurement and Assessment* [@magurran_biological_2011]

### Links

-   Recomendamos tamb√©m que acessem a p√°gina do [EstimateS software](http://viceroy.eeb.uconn.edu/estimates) e baixem o manual do usu√°rio que cont√©m informa√ß√µes detalhadas sobre os √≠ndices de rarefa√ß√£o e estimadores de riqueza. Este site foi criado e √© mantido pelo Dr. Robert K. Colwell, um dos maiores especialistas do mundo em estimativas da biodiversidade

-   Recomendamos a p√°gina pessoal da pesquisadora [Anne Chao](http://chao.stat.nthu.edu.tw/wordpress/software_download/inext-online/) que √© uma das respons√°veis pelo desenvolvimento da metodologia e do pacote iNEXT. Nesta p√°gina, voc√™s ir√£o encontrar exemplos e explica√ß√µes detalhadas sobre as an√°lises

## Exerc√≠cios

**11.1** 
Carregue os dados - Cap11_exercicio1 - que est√° no pacote `ecodados`. Este conjunto de dados representa a abund√¢ncia de 50 esp√©cies de besouros coletados em 30 amostras. Calcule os estimadores de riqueza - Chao1 e ACE - e fa√ßa um gr√°fico contendo a riqueza observada e os dois estimadores de riqueza. Qual a sua interpreta√ß√£o sobre o esfor√ßo amostral?

**11.2**
Utilize o mesmo conjunto de dados do exerc√≠cio anterior. Calcule os estimadores de riqueza - Jackknife 1 e bootstrap. Fa√ßa um gr√°fico contendo a riqueza observada e os dois estimadores de riqueza. Qual a sua interpreta√ß√£o sobre o esfor√ßo amostral? Compare com os resultados do exerc√≠cio anterior que utilizam estimadores baseados na abund√¢ncia das esp√©cies. 

**11.3** 
Vamos refazer o exerc√≠cio 10 do Cap√≠tulo 7 que usa Generalized Least Squares (GLS) para testar a rela√ß√£o da riqueza de anuros em 44 localidades na Mata Atl√¢ntica com a precipita√ß√£o anual. Contudo, ao inv√©s de considerar a riqueza de esp√©cies de anuros observada como vari√°vel resposta, iremos utilizar a riqueza extrapolada. Utilize os dados "anuros_composicao" para estimar a riqueza extrapolada e o dados "anuros_ambientais" para acessar os dados de precipita√ß√£o anual e coordenadas geogr√°ficas. Qual a sua interpreta√ß√£o dos resultados utilizando a riqueza observada e extrapolada? 

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-11---estimadores-de-riqueza.html).

<!--chapter:end:11_estimadores_riqueza.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Diversidade Taxon√¥mica {#cap12}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(devtools)
library(ecodados)
library (vegan)
library(ggplot2)
library(BiodiversityR)
library(hillR)
library(betapart)

## Dados
composicao_especies <- ecodados::composicao_anuros_div_taxonomica
precipitacao        <- ecodados::precipitacao_div_taxonomica
```

## Aspectos te√≥ricos

A diversidade biol√≥gica √© um conceito multifacetado que pode ser definido e analisado de diferentes maneiras (e.g. diversidade gen√©tica, taxon√¥mica, funcional, filogen√©tica, ecossist√™mica, etc.) [@magurran_biological_2011; @gotelli2013]. Whittaker [-@whittaker1960; -@whittaker1972] particionou a diversidade em tr√™s componentes: i) diversidade alfa que √© caracterizada pela diversidade dentro do habitat ou unidade amostral, ii) diversidade beta que √© caracterizada pela varia√ß√£o na diversidade entre habitats ou unidades amostrais, e iii) diversidade gama que √© caracterizada pela combina√ß√£o da diversidade alfa e beta ou definida como a diversidade regional englobando todos os habitat ou unidades amostrais. Portanto, n√£o existe um m√©todo que quantifique todos os par√¢metros associados √† diversidade biol√≥gica. Consequentemente, a escolha da m√©trica de diversidade depender√°: i) do objetivo do estudo, e ii) das informa√ß√µes dispon√≠veis para o pesquisador.

Neste cap√≠tulo, iremos abordar a diversidade taxon√¥mica que ignora a rela√ß√£o de parentesco entre as esp√©cies (e.g. diversidade filogen√©tica - Cap√≠tulo \@ref(cap13)) e as diferentes fun√ß√µes que as esp√©cies realizam no ecossistema (e.g. diversidade funcional - Cap√≠tulo \@ref(cap14)). Na diversidade taxon√¥mica, pesquisadores est√£o interessados na riqueza de esp√©cies (e.g. n√∫mero de esp√©cies), na distribui√ß√£o de abund√¢ncia das esp√©cies (e.g. fato que algumas esp√©cies s√£o comuns e outras raras) e/ou diversidade de esp√©cies (e.g. √≠ndices que descrevem a rela√ß√£o entre a riqueza e a distribui√ß√£o da abund√¢ncia relativa das esp√©cies) nas localidades.

## Diversidade alfa

### Riqueza de esp√©cies ou n√∫mero de esp√©cies

Riqueza de esp√©cies √© uma m√©trica intuitiva e de f√°cil compreens√£o, uma vez que se refere ao n√∫mero de esp√©cies observadas em uma localidade. √â importante ter em mente que a riqueza de esp√©cies √© influenciada pelo esfor√ßo amostral e sua estimativa real √© um imenso desafio [@magurran_biological_2011]. Compara√ß√µes entre comunidades com diferen√ßas no n√∫mero de amostragens ou abund√¢ncia das esp√©cies devem ser realizadas por meio de rarefa√ß√µes (veja Cap√≠tulo \@ref(cap10)), enquanto que o n√∫mero de esp√©cies n√£o detectadas pode ser estimado pelos estimadores de riqueza (veja Cap√≠tulo \@ref(cap11)). Embora raramente usados como alternativas √† rarefa√ß√£o, existem alguns √≠ndices que calculam a riqueza de esp√©cies ponderando a abund√¢ncia total (i.e. tamanho da amostra) dentro de cada comunidade. 

Esses √≠ndices s√£o:

**1. √çndice de Margalef**

$$D_{Mg} = \frac{S-1}{ln (N)}$$

onde:

-   S = o n√∫mero de esp√©cies na comunidade
-   ln = logaritmo natural
-   N = n√∫mero total de indiv√≠duos na comunidade
-   D~Mg~ n√£o tem um valor m√°ximo e sua interpreta√ß√£o √© comparativa, com valores maiores indicando maior riqueza de esp√©cies

**2. √çndice de Menhinick**

- $$D_{Mn} = \frac{S}{\sqrt{N}}$$

onde:

-   S = o n√∫mero de esp√©cies na comunidade
-   N = n√∫mero total de indiv√≠duos na comunidade
-   D~Mn~ n√£o tem um valor m√°ximo e sua interpreta√ß√£o √© comparativa, com valores maiores indicando maior riqueza de esp√©cies

**Exemplo pr√°tico 1**

**Explica√ß√£o dos dados**

Neste exemplo, avaliaremos a riqueza de esp√©cies de 10 comunidades. Os dados de ocorr√™ncia das esp√©cies nas comunidades foram simulados para demonstrar as propriedades das m√©tricas de diversidade taxon√¥micas. Utilizaremos este conjunto de dados para todos os exemplos deste cap√≠tulo.

**Pergunta**

- A varia√ß√£o espacial na riqueza de esp√©cies nas comunidades est√° associada com a varia√ß√£o na precipita√ß√£o?

**Predi√ß√µes**

- Os valores de riqueza de esp√©cies ser√£o maiores nas comunidades localizadas em regi√µes que recebem grande volume de precipita√ß√£o do que em regi√µes mais secas

**Vari√°veis**

-   Vari√°veis resposta e preditoras

    -   Data frame com as comunidades (unidade amostral) nas linhas e as esp√©cies (vari√°vel resposta) nas colunas
    -   Data frame com as comunidades (unidade amostral) nas linhas e precipita√ß√£o anual (vari√°vel preditora) na coluna

**Checklist**

-   Verificar se os data frames de composi√ß√£o de esp√©cies e vari√°veis ambientais est√£o com as unidades amostrais nas linhas e vari√°veis preditores nas colunas

-   Verificar se as comunidades nos data frames de composi√ß√£o de esp√©cies e vari√°veis ambientais est√£o distribu√≠dos na mesma sequ√™ncia/ordem nos dois arquivos

**An√°lise**

Abaixo, demonstramos os c√≥digos no R para determinar a riqueza de esp√©cies para cada comunidade a partir dos dados de composi√ß√£o de esp√©cies. Os dados est√£o dispon√≠veis no pacote `ecodados`.

```{r}
## Ver os dados das comunidades
head(composicao_especies)
```

Vamos ver a riqueza de esp√©cies para cada comunidade.

```{r}
## Calculando a riqueza observada de esp√©cies para cada comunidade
riqueza_sp <- specnumber(composicao_especies)
riqueza_sp
```

Vamos ver a abund√¢ncia total de cada comunidade.

```{r}
## Calculamos a abund√¢ncia total para cada comunidade
abundancia <- apply(composicao_especies, 1, sum)
abundancia
```

Calculando o √çndice de Margalef.

```{r}
## √çndice de Margalef
# A fun√ß√£o round √© para limitar o resultado para duas casas decimais.
Margalef <- round((riqueza_sp - 1)/log(abundancia), 2)
Margalef
```

Calculando o √çndice de Menhinick.

```{r}
## √çndice de Menhinick
Menhinick <- round(riqueza_sp/sqrt(abundancia), 2)
Menhinick
```

Agora vamos analisar a rela√ß√£o entre a riqueza de esp√©cies e a precipita√ß√£o anual.

```{r}
## Juntando todos os dados em um √∫nico data frame
dados <- data.frame(precipitacao$prec, riqueza_sp, Margalef, Menhinick)

## Renomenado as colunas
colnames(dados) <- c("Precipitacao", "Riqueza", "Margalef", "Menhinick")

## ANOVA
anova_riq <- lm(Riqueza ~ Precipitacao, data = dados)
anova(anova_riq)

```

H√° uma rela√ß√£o positiva entre a riqueza de esp√©cies e a precipita√ß√£o anual (F~1,8~ = 8,91, P = 0,01).

Analisar a rela√ß√£o entre o √çndice de Margalef e a precipita√ß√£o anual.

```{r}
## ANOVA
anova_marg <- lm(Margalef ~ Precipitacao, data = dados)
anova(anova_marg)

```

N√£o h√° uma rela√ß√£o positiva entre o √≠ndice de Margalef e a precipita√ß√£o anual (F~1,8~ = 2,12, P = 0,18).

Agora vamos analisar a rela√ß√£o entre o √≠ndice de Menhinick e a precipita√ß√£o anual.

```{r}
## ANOVA
anova_menh <- lm(Menhinick ~ Precipitacao, data = dados)
anova(anova_menh)

```

N√£o h√° uma rela√ß√£o positiva entre o √≠ndice de Menhinick e a precipita√ß√£o anual (F~1,8~ = 1,09, P = 0,32).

Com base nos resultados, vamos plotar apenas o gr√°fico com os resultados da riqueza de esp√©cies ao longo do gradiente de precipita√ß√£o anual (Figura \@ref(fig:fig-alfa-model)).

```{r fig-alfa-model, fig.cap="Gr√°fico do modelo linear da rela√ß√£o entre riqeuza e precipita√ß√£o."}
## Gr√°fico
ggplot(data = dados, aes(x= Precipitacao, y= Riqueza)) + 
    labs(x = "Precipita√ß√£o anual (mm)", y = "Riqueza de esp√©cies") +
    geom_point(size = 4, shape = 21, fill = "darkorange", alpha = 0.7) +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

O n√∫mero de esp√©cies √© maior em comunidades com maior precipita√ß√£o. Contudo, quando ponderamos pela abund√¢ncia (√≠ndices de Margalef ou Menhinick), a rela√ß√£o com a precipita√ß√£o n√£o √© significativa.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Percebam que ponderar a riqueza de esp√©cies pela abund√¢ncia altera a interpreta√ß√£o dos resultados.
:::

### Diversidade de esp√©cies

Diferente dos √≠ndices de riqueza de esp√©cies que n√£o levam em considera√ß√£o a abund√¢ncia relativa das esp√©cies (i.e. todas as esp√©cies tem o mesmo peso), os √≠ndices de diversidade avaliam al√©m da riqueza, a domin√¢ncia ou raridade das esp√©cies nas comunidades. Assim, quando comparamos duas comunidades com a mesma riqueza de esp√©cies, e uma das comunidades √© dominada por uma √∫nica esp√©cie e a outra comunidade apresenta esp√©cies com abund√¢ncias parecidas, consideramos a segunda comunidade mais diversa. Os √≠ndices de diversidade variam porque eles d√£o pesos diferentes para a riqueza e equitabilidade das esp√©cies. Assim, um determinado √≠ndice de diversidade pode indicar que uma comunidade X √© mais diversa que uma comunidade Y, enquanto outro √≠ndice indica o oposto [@melo2008]. Portanto, uma maneira de determinar qual √≠ndice de diversidade usar √© saber se voc√™ quer dar maior peso para riqueza ou equitabilidade das esp√©cies nas comunidades. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Ressaltamos que h√° v√°rias cr√≠ticas em rela√ß√£o ao uso dos √≠ndices de diversidade que s√£o abstratos e dif√≠ceis de se interpretar [@hurlbert1971]. Por exemplo, dizer que o valor X estimado por √≠ndices de diversidade √© alto ou baixo √© irrelevante se n√£o tivermos uma base comparativa (para mais detalhes veja Melo [-@melo2008]).
:::

Os dois √≠ndices de diversidade mais usados em Ecologia s√£o:

**1. √çndice de Shannon-Wiener**

Quantifica a incerteza associada em predizer a identidade de uma esp√©cie dado o n√∫mero de esp√©cies e a distribui√ß√£o de abund√¢ncia para cada esp√©cie. Este √≠ndice √© mais sens√≠vel √† mudan√ßas nas esp√©cies raras da comunidade.

$$H' = -\sum_{i=1}^{S}p_i * ln p_i$$

onde:

-   p~i~ = abund√¢ncia relativa de cada esp√©cie, calculada pela propor√ß√£o dos indiv√≠duos de uma esp√©cie pelo n√∫mero total dos indiv√≠duos na comunidade
-   ln = logaritmo natural, mas outras bases logar√≠tmas podem ser utilizadas
-   H' = n√£o tem um valor m√°ximo e sua interpreta√ß√£o √© comparativa, com valores maiores indicando maior diversidade

**2. √çndice de Simpson**

Quantifica a probabilidade de dois indiv√≠duos retirados ao acaso da comunidade pertencerem √† mesma esp√©cie. Este √≠ndice √© na verdade uma medida de domin√¢ncia. Assim como a probabilidade dos indiv√≠duos serem da mesma esp√©cie diminui com o aumento da riqueza de esp√©cies, o √≠ndice de Simpson tamb√©m diminui com a riqueza.

$$D = \sum_{i=1}^{S}p_i^2$$

onde:

-   P~i~ = abund√¢ncia relativa de cada esp√©cie, calculada pela propor√ß√£o dos indiv√≠duos de uma esp√©cie pelo n√∫mero total dos indiv√≠duos na comunidade

-   D = varia de 0 a 1, com valores pr√≥ximos de 1 indicando menor diversidade enquanto valores pr√≥ximos de 0 indicam maior diversidade. Para evitar confus√£o nas interpreta√ß√µes, normalmente o √≠ndice de Simpson √© expressado como o valor inverso (1 - D) para que os maiores valores representem maior diversidade. Neste caso, o valor inverso √© conhecido na literatura como √≠ndice Gini-Simpson. Para o √≠ndice Gini-Simpson estamos avaliando a probabilidade de dois indiv√≠duos retirados ao acaso da comunidade sejam de esp√©cies diferentes.

**Exemplo pr√°tico 2**

**Explica√ß√£o dos dados**

Usaremos os mesmos dados simulados do exemplo pr√°tico 1.

**Pergunta**

- A varia√ß√£o espacial na diversidade de esp√©cies das comunidades est√° associado com o gradiente de precipita√ß√£o?

**Predi√ß√µes**

- Os valores de diversidade de esp√©cies ser√£o maiores nas comunidades localizadas em regi√µes maior volume de precipita√ß√£o do que em regi√µes mais secas

**An√°lise**

Abaixo demonstramos os c√≥digos no R para determinar a diversidade de esp√©cies para cada comunidade a partir da planilha de composi√ß√£o de esp√©cies.

```{r}
## √çndice de Shannon
# MARGIN = 1 significa que a fun√ß√£o ir√° calcular o √≠ndice considerando 
# as linhas do data.frame (comunidades).
shannon_res <- diversity(composicao_especies, index = "shannon", MARGIN = 1)
shannon_res
```

O argumento `index = "simpson"`, calcula o √≠ndice Gini-Simpson (1-D).

```{r} 
## √çndice de Simpson
simpson_res <- diversity(composicao_especies, index = "simpson", MARGIN = 1) 
simpson_res
```

**Interpreta√ß√£o dos resultados**

A comunidade 1 foi a comunidade que apresentou a maior diversidade de esp√©cies (Shannon-Wiener = 2,3 e Gini-Simpson = 0.9), enquanto a comunidade 2 foi a comunidade que apresentou a menor diversidade (Shannon-Wiener = 0,5 e Gini-Simpson = 0,17). Gostar√≠amos de chamar a aten√ß√£o para a import√¢ncia da distribui√ß√£o da abund√¢ncia relativa das esp√©cies dentro das comunidades. Percebam que tanto a comunidade 1 quanto a comunidade 2 abrigam o mesmo n√∫mero de esp√©cies (10 esp√©cies) e abund√¢ncia total (100 indiv√≠duos), mas o padr√£o de distribui√ß√£o da abund√¢ncia relativa entre as esp√©cies dentro das comunidades s√£o bem discrepantes. Na comunidade 1 as esp√©cies apresentam abund√¢ncias semelhantes entre elas (i.e. alta equitabilidade), enquanto na comunidade 2 uma esp√©cie √© dominante e as outras raras (i.e. baixa equitabilidade). Essa diferen√ßa na distribui√ß√£o da abund√¢ncia relativa entre as comunidades √© um fator muito importante para os √≠ndices de diversidade. 

Dentro desta perspectiva, alguns √≠ndices fornecem uma estimativa sobre a equitabilidade da distribui√ß√£o da abund√¢ncia nas comunidades. Entre eles, o mais conhecido foi proposto por Pielou [-@pielou1966].

**√çndice de Equabilidade (ou Equitabilidade) de Pielou** 

√â uma m√©trica derivada do √≠ndice de Shannon-Wiener que descreve o padr√£o de distribui√ß√£o da abund√¢ncia relativa das esp√©cies na comunidade.

$$J = \frac{H'}{Hmax} = \frac{H'}{ln (S)}$$

onde:

-  H' = √≠ndice de Shannon-Wiener
-  H~max~ = todas as esp√©cies teriam a mesma abund√¢ncia relativa
-  H~max~ √© calculado aplicando o logaritmo natural (ln) para a riqueza de esp√©cies (S)
-   Se todas as esp√©cies apresentam a mesma abund√¢ncia relativa, ent√£o J = 1. Se uma esp√©cie apresenta forte domin√¢ncia, J aproxima-se de zero

N√£o h√° uma fun√ß√£o no R que calcule o √≠ndice de Pielou, mas ele pode facilmente ser calculado usando os valores de diversidade de Shannon-Wiener e o logaritmo da riqueza de esp√©cies de cada comunidade.

```{r}
## √çndice de Pielou
Pielou <- shannon_res/log(specnumber(composicao_especies))
```

Agora que temos uma ideia de como a riqueza de esp√©cies e a distribui√ß√£o da abund√¢ncia relativa s√£o importantes para quantificar os valores dos √≠ndices de diversidade, vamos testar se h√° alguma rela√ß√£o entre os √≠ndices de diversidade e precipita√ß√£o anual nas comunidades.

```{r}
## Juntando todos os dados em um √∫nico data frame
dados_div <- data.frame(precipitacao$prec, shannon_res, 
                        simpson_res, Pielou)

## Renomeando as colunas
colnames(dados_div) <- c("Precipitacao", "Shannon", "Simpson", "Pielou")
```

Vamos realizar uma regress√£o simples para verificar a rela√ß√£o entre o √≠ndice de Shannon-Wiener e a precipita√ß√£o anual nas comunidades.

```{r}
## ANOVA
anova_shan <- lm(Shannon ~ Precipitacao, data = dados_div)
anova(anova_shan)

```

Agora, vamos realizar uma regress√£o simples para verificar a rela√ß√£o entre o √≠ndice de Simpson e a precipita√ß√£o anual nas comunidades.

```{r}
## ANOVA
anova_simp <- lm(Simpson ~ Precipitacao, data = dados_div)
anova(anova_simp)

```

Por fim, vamos fazer regress√£o simples para verificar a rela√ß√£o entre o √≠ndice de Pielou e a precipita√ß√£o anual nas comunidades.

```{r}
## ANOVA
anova_piel <- lm(Pielou ~ Precipitacao, data = dados_div)
anova(anova_piel)

```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
As an√°lises acima s√£o apenas ilustrativas. N√£o estamos avaliando as premissas de normalidade e homogeneidade da vari√¢ncia dos res√≠duos (veja Cap√≠tulo \@ref(cap7)). Al√©m disso, √© importante estar ciente das cr√≠ticas e limita√ß√µes de usar √≠ndices de Shannon e Simpson como nesses exemplos [@jost_partitioning_2007].
:::

**Interpreta√ß√£o dos resultados**

A varia√ß√£o espacial na diversidade de esp√©cies, obtida atrav√©s dos √≠ndices de Shannon-Wiener e Simpson, e a equitabilidade de Pielou n√£o foram associados com a varia√ß√£o na precipita√ß√£o anual entre as √°reas (P \> 0,05).

### Diagramas de Whittaker ou Curva de Domin√¢ncia

Embora os √≠ndices de diversidade de esp√©cies englobem os componentes de riqueza e abund√¢ncia relativa das esp√©cies nas suas estimativas, n√£o √© poss√≠vel conhecer o n√∫mero de esp√©cies ou quais s√£o as esp√©cies dominantes ou raras dentro das comunidades. Por exemplo, duas comunidades podem ter o mesmo valor de diversidade e ainda assim apresentarem diferen√ßas na riqueza e equitabilidade [@melo2008]. O **Diagrama de Whittaker** √© um m√©todo que lida com essas quest√µes utilizando informa√ß√µes visuais do n√∫mero de esp√©cies e abund√¢ncia relativa de cada esp√©cie nas comunidades. Este m√©todo plota as esp√©cies ranqueadas no eixo X da mais abundante para a menos abundante, enquanto no eixo Y as abund√¢ncias relativas das esp√©cies s√£o plotadas em escala logar√≠tmica (log~10~). Este gr√°fico permite ao leitor reconhecer: i) a riqueza de esp√©cies observando o eixo X, ii) a equitabilidade da abund√¢ncia relativa das esp√©cies pela inclina√ß√£o da reta, e iii) quais s√£o as esp√©cies dominantes, intermedi√°rias e raras nas comunidades atrav√©s da observa√ß√£o em rela√ß√£o ao eixo Y. A partir destas curvas, v√°rios autores propuseram modelos matem√°ticos para explicar a distribui√ß√£o de abund√¢ncia das esp√©cies gerando diferentes modelos te√≥ricos (e.g. s√©rie geom√©trica, *broken-stick*, log-series e log-normal). Cada modelo possui predi√ß√µes distintas: o modelo geom√©trico prediz distribui√ß√£o de abund√¢ncias desiguais, *broken-stick* prediz distribui√ß√£o de abund√¢ncias uniformes, enquanto log-normal e log-series s√£o intermedi√°rias com predi√ß√µes distintas sobre as propor√ß√µes de esp√©cies raras - alta em log-series, baixa em log-normal (veja McGill et al. [-@mcgill2007] para revis√£o).

Para an√°lises explorat√≥rias onde voc√™ tem interesse em visualizar o padr√£o da distribui√ß√£o relativa das esp√©cies por comunidade, a fun√ß√£o `rankabundance` do pacote `BiodiversityR` √© uma op√ß√£o interessante (Figura \@ref(fig:fig-whittaker)).

```{r fig-whittaker, fig.cap="Diagramas de Whittaker para duas comunidades."}
## C√°lculo da curva para as comunidades 2 e 3
rank_com2 <- rankabundance(composicao_especies[2, composicao_especies[2,] > 0])
rank_com3 <- rankabundance(composicao_especies[3, composicao_especies[3,] > 0])

## Gr√°fico 
# Veja a ajuda da fun√ß√£o rankabundplot para outros exemplos de gr√°ficos.
rankabunplot(rank_com2, scale = "logabun", specnames = c(1), 
             pch = 19, col = "darkorange")
rankabunplot(rank_com3, scale = "logabun", specnames = c(1), pch = 19, 
             xlim = c(0,10), addit = TRUE, col = "cyan4" , legend = TRUE)
legend(5, 40, legend = c("Comunidade 2", "Comunidade 3"),
       col = c("darkorange", "cyan4"), lty = 1, cex = 0.8, box.lty = 0)
```

**Interpreta√ß√£o dos resultados**

Percebam que olhando os eixos do gr√°fico conseguimos determinar que a Comunidade 2 (c√≠rculo laranja) abriga 10 esp√©cies no total (i.e. comprimento do eixo X), com a esp√©cie sp1 apresentando alta domin√¢ncia e as outras esp√©cies apresentando abund√¢ncias muito baixas. A Comunidade 3 (c√≠rculo ciano) abriga cinco esp√©cies no total, sendo que a esp√©cie sp4 apresenta alta domin√¢ncia, duas esp√©cies apresentam abund√¢ncias intermedi√°rias e outras duas abund√¢ncias baixas.

### Curvas de distribui√ß√£o de abund√¢ncias

Caso o interesse seja avaliar qual dos modelos te√≥ricos melhor explica a distribui√ß√£o das abund√¢ncias das esp√©cies, a fun√ß√£o `radift()` do pacote `vegan` √© a melhor op√ß√£o.

::: {.alert .alert-info}
A fun√ß√£o `radfit` avalia cinco modelos te√≥ricos para determinar qual deles melhor se ajustam aos dados. Os modelos te√≥ricos avaliados na fun√ß√£o s√£o:

-   Null = modelo broken-stick
-   preemption = s√©rie geom√©trica
-   log-normal
-   Zipf
-   Zipf-Mandelbrot
:::

Voc√™ pode realizar as an√°lises separadamente para cada comunidade ou para todas as comunidades ao mesmo tempo.

Vamos come√ßar avaliando separadamente a Comunidade 2.

```{r}
## Teste das curvas de distribui√ß√£o de abund√¢ncias
curvas_dominancia_com2 <- radfit(composicao_especies[2,])
curvas_dominancia_com2
```

Agora vamos fazer um gr√°fico com as predi√ß√µes dos modelos (Figura \@ref(fig:fig-whittaker-teste)).

```{r fig-whittaker-teste, fig.cap="Teste de cinco Diagramas de Whittaker para a Comunidade 2."}
plot(curvas_dominancia_com2, 
     ylab = "Abund√¢ncia", 
     xlab = "Ranqueamento das esp√©cies")
```

**Interpreta√ß√£o dos resultados**

Os pontos brancos representam as esp√©cies ranqueadas de acordo com a abund√¢ncia e as linhas representam as predi√ß√µes dos modelos mat√©maticos. Com base nos valores de AIC (veja Cap√≠tulo \@ref(cap7)), o modelo **Zipf** √© o melhor modelo que explica a distribui√ß√£o da abund√¢ncia relativa das esp√©cies na Comunidade 2.

Agora vamos analisar os dados considerando todas as comunidades (Figura \@ref(fig:fig-whittaker-testes)).

```{r fig-whittaker-testes, fig.cap="Testes de cinco Diagramas de Whittaker para todas as comunidades."}
## Teste das curvas de distribui√ß√£o de abund√¢ncias
curvas_dominancia_todas <- radfit(composicao_especies)
curvas_dominancia_todas

# Vamos fazer um gr√°fico para cada comunidade
plot(curvas_dominancia_todas, log = "y")
```

**Interpreta√ß√£o dos resultados**

A Comunidade 1 foi associada com o modelo **log-normal**, as Comunidades 2 e 4 com o modelo **Zipf**, a Comunidade 3 com o modelo **s√©rie geom√©trica** e as outras comunidades com o **modelo nulo**. Para explorar a explica√ß√£o biol√≥gica por tr√°s destes modelos veja os artigos [@wilson1991; @mcgill2007; @magurran_biological_2011]. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A liga√ß√£o entre o modelo matem√°tico e a explica√ß√£o biol√≥gica precisa ser interpretada com cuidado porque diferentes modelos matem√°ticos podem levar ao mesmo padr√£o de distribui√ß√£o de abund√¢ncia.
:::

### N√∫meros de Hill ou S√©rie de Hill

Embora os √≠ndices de Shannon-Wiener e Gini-Simpson sejam amplamente usados em estudos ecol√≥gicos e de conserva√ß√£o, eles sofrem de propriedades matem√°ticas e n√£o representam a diversidade propriamente dita [@jost2006]. Portanto, quando o objetivo √© avaliar a diversidade, os √≠ndices de Shannon-Wiener e Gini-Simpson n√£o deveriam ser utilizados na sua forma padr√£o, mas transformados em n√∫meros efetivos de esp√©cies ou diversidade verdadeira [@jost2006]. O n√∫mero efetivo de esp√©cies √© o n√∫mero de esp√©cies igualmente abundantes (i.e. todas as esp√©cies com a mesma abund√¢ncia) necess√°rias para produzir o valor observado para um determinado √≠ndice. Por exemplo, uma comunidade com √≠ndice de Shannon-Wiener estimado de 4,5 teria um n√∫mero efetivo de 90 esp√©cies igualmente abundantes. Jost et al. [-@jost2006] usam o seguinte exemplo para explicar o conceito do n√∫mero efetivo de esp√©cies - uma comunidade com 16 esp√©cies igualmente abundantes √© duas vezes mais diversa do que uma comunidade com 8 esp√©cies igualmente abundantes. Neste caso, a diversidade deveria ser proporcional ao n√∫mero de esp√©cies. Contudo, quando aplicamos os √≠ndices de diversidade para estas comunidades com 16 e 8 esp√©cies (cada esp√©cie com 5 indiv√≠duos), o √≠ndice de Shannon-Wiener √© 2,772 e 2,079, respectivamente, e o √≠ndice de Gini-Simpson √© 0,937 e 0,875, respectivamente. Claramente, os valores estimados pelos √≠ndices de diversidade n√£o representam a diferen√ßa entre as comunidades porque eles carecem de uma particularidade matem√°tica conhecida como propriedade de duplica√ß√£o. 

O pr√≥ximo exemplo (modificado do website de Lou Jost; [http://www.loujost.com/](http://www.loujost.com/Statistics%20and%20Physics/Diversity%20and%20Similarity/EffectiveNumberOfSpecies.htm)), demostra a import√¢ncia da transforma√ß√£o dos √≠ndices de diversidade em n√∫meros efetivos de esp√©cies. Imagine que voc√™ foi contratado para avaliar a diversidade de peixes em um riacho antes e depois da instala√ß√£o de uma usina hidrel√©trica. Suponha que os valores estimados pelo √≠ndice de Gini-Simpson foi de 0,99 antes da instala√ß√£o e de 0,97 depois da instala√ß√£o. A princ√≠pio, voc√™ poderia concluir que a diversidade diminuiu somente 2% e que a instala√ß√£o da hidrel√©trica n√£o afetou a diversidade de peixes no riacho. Contudo, transformando os valores do √≠ndice de diversidade em n√∫meros efetivos, percebemos que antes da instala√ß√£o a diversidade do riacho equivale a 100 esp√©cies igualmente abundantes, enquanto ap√≥s a instala√ß√£o, a diversidade equivale a 33 esp√©cies igualmente abundantes. Portanto, a queda da diversidade foi de 66% e n√£o 2%. 

Hill [-@hill1973] derivou uma equa√ß√£o geral para o c√°lculo do n√∫mero efetivo de esp√©cies ou diversidade verdadeira que depende apenas do valor de *q* e da abund√¢ncia relativa das esp√©cies.

$$^qD = (\sum_{i=1}^{S}p_i^q)^{1/(1-q)}$$

Onde:

- q = √© um par√¢metro conhecido como ordem da diversidade e √© usado para dar peso √†s esp√©cies comuns ou raras. q = 0 n√£o considera a frequ√™ncia das esp√©cies e representa a riqueza observada de esp√©cies, q = 1 equivale a transforma√ß√£o do √≠ndice de Shannon-Wiener (i.e. exp(H')) e atribui pesos √†s esp√©cies com base na propor√ß√£o das suas frequ√™ncias e, q = 2 equivale √† transforma√ß√£o do √≠ndice de Gini-Simpson (i.e. 1/(1-D)) e atribui peso √†s esp√©cies mais comuns. Valores de q \<1 favorecem esp√©cies raras, enquanto valores de q \> 1 favorecem esp√©cies comuns.

- p~i~ = abund√¢ncia relativa de cada esp√©cie, calculada pela propor√ß√£o dos indiv√≠duos de uma esp√©cie pelo n√∫mero total dos indiv√≠duos na comunidade

Vamos calcular o N√∫mero de Hill para as comunidades do nosso exemplo.

Calculando o N√∫mero de Hill com q = 0.

```{r}
## N√∫mero de Hill para q = 0
hill_res_q_0 <- hill_taxa(composicao_especies, q  = 0)
hill_res_q_0
```

Calculando o N√∫mero de Hill com q = 1.

```{r}
## N√∫mero de Hill para q = 1
hill_res_q_1 <- hill_taxa(composicao_especies, q  = 1)
hill_res_q_1
```

Calculando o N√∫mero de Hill com q = 2.

```{r}
## N√∫mero de Hill para q = 2
hill_res_q_2 <- hill_taxa(composicao_especies, q  = 2)
hill_res_q_2
```

Criando um data frame com os tr√™s resultados anteriores.

```{r}
## Resultados
res_hill <- data.frame(hill_res_q_0, hill_res_q_1, hill_res_q_2)
colnames(res_hill) <- c("q=0", "q=1", "q=2")
head(res_hill)
```

**Interpreta√ß√£o dos resultados**

Como na comunidade 1 todas as esp√©cies s√£o igualmente abundantes, alterar os valores de *q* n√£o altera o n√∫mero efetivo de esp√©cies que permanece sempre 10. Contudo, na comunidade 2, que apresenta alta domin√¢ncia de uma esp√©cie, alterar os valores de q diminui consideravelmente a estimativa da diversidade. A vantagem dos N√∫meros de Hill √© que eles s√£o de f√°cil interpreta√ß√£o e compara√ß√£o entre as comunidades. Fator ausente para os √≠ndices de diversidade. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Neste ponto, esperamos que tenha ficado claro que mais do que a riqueza de esp√©cies, a abund√¢ncia relativa das esp√©cies (e.g. comuns ou raras) tem um papel fundamental na estimativa da diversidade de esp√©cies.
:::

## Diversidade beta

O termo diversidade beta foi proposto por Whittker [-@whittaker1960] e foi definido como a raz√£o entre a diversidade gama e a diversidade alfa (i.e. diversidade beta multiplicativa), quantificando n√£o s√≥ a rela√ß√£o entre a diversidade regional e local, mas tamb√©m o grau de diferencia√ß√£o entre as comunidades. Para demonstrar como a diversidade beta varia entre comunidades locais dentro de uma regi√£o usaremos a explica√ß√£o do Baselga (<http://webspersoais.usc.es/persoais/andres.baselga/beta.html>). Imagine tr√™s comunidades, cada comunidade abrigando as mesmas cinco esp√©cies. Neste caso, a m√©dia da diversidade alfa = 5, a diversidade gama = 5 e a raz√£o entre elas (gama/alfa) indica uma diversidade beta = 1. Isso significa que na regi√£o existe apenas uma unidade distinta de composi√ß√£o. Quando a composi√ß√£o de esp√©cies das tr√™s comunidades √© completamente diferente (i.e. diferencia√ß√£o m√°xima), temos que a m√©dia da diversidade alfa = 5, a diversidade gama = 15 e a raz√£o entre elas indica uma diversidade beta = 3. Neste caso, existem tr√™s unidades distintas dentro da regi√£o. Assim, a diversidade beta multiplicativa varia de 1 at√© o n√∫mero de comunidades dentro da regi√£o. 

A maioria dos √≠ndices de (dis)similaridade utilizadas na ecologia (e.g. √≠ndices de Jaccard e S√∏rensen) s√£o √≠ndices que padronizam a diversidade beta e geram valores independentes do n√∫mero de comunidades. Eles podem ser calculados para dados de incid√™ncia (presen√ßa e aus√™ncia) ou abund√¢ncia [@legendre_numerical_2012] e considerando compara√ß√µes par-a-par entre as comunidades ou compara√ß√£o entre m√∫ltiplas comunidades (i.e. multiple-site). Por muito tempo, os valores de (dis)similaridade foram interpretados como sin√¥nimo de substitui√ß√£o de esp√©cies (*turnover*) entre comunidades. Contudo, √≠ndices de (dis)similaridade como Jaccard e S√∏rensen geram valores de (dis)similaridade para comunidades que n√£o apresentam diferen√ßas na composi√ß√£o de esp√©cies, mas apresentam diferen√ßas na riqueza de esp√©cies (i.e. comunidades aninhadas). Pensando nestes fatores, Baselga [-@baselga2009; -@baselga2012] prop√¥s uma abordagem que particiona a diversidade beta total ($\beta$~jac~) em dois componentes: o componente resultante da substitui√ß√£o de esp√©cies (*turnover* - $\beta$~tur~) e o componente resultante do aninhamento (*nestedness*, i.e. diferen√ßa na riqueza de esp√©cies - $\beta$~nes~). Vejam a (Figura \@ref(fig:fig-div-beta)) onde temos 3 comunidades (X, Y e Z). No primeiro exemplo, temos apenas diferen√ßa no n√∫mero de esp√©cies entre as comunidades. Neste caso, o componente subsitui√ß√£o de esp√©cies ($\beta$~tur~) √© zero porque as esp√©cies na comunidade Z s√£o um sub-grupo das esp√©cies nas comunidades X e Y. O mesmo para as esp√©cies na comunidade Y que s√£o um sub-grupo das esp√©cies da comunidade X. No segundo exemplo, temos o cen√°rio oposto com as comunidades abrigando a mesma riqueza de esp√©cies e assim, o componente resultante do aninhamento ($\beta$~nes~) √© zero, temos um valor m√°ximo para o $\beta$~tur~. Percebam que somando $\beta$~tur~ com $\beta$~nes~ temos o valor da diversidade beta total ($\beta$~jac~). Baselga [-@baselga2013] tamb√©m prop√¥s a parti√ß√£o da diversidade beta para √≠ndices de dissimilaridade que lidam com dados de abund√¢ncia. Neste caso os componentes da diversidade beta s√£o chamados de varia√ß√£o balanceada na abund√¢ncia (similar ao componente substitui√ß√£o de esp√©cies) e gradiente de abund√¢ncia (similar ao componente aninhamento). Reconhecer estes componentes da diversidade beta √© importante porque eles apresentam padr√µes distintos (substitui√ß√£o de esp√©cies *versus* perda ordenada de esp√©cies), que provavelmente est√£o sendo gerados por processos ecol√≥gicos diferentes [@baselga2009; @baselga2012; @baselga2013].

```{r fig-div-beta, fig.cap="Parti√ß√£o da diversidade beta taxon√¥mica. Os tr√™s cen√°rios apresentados representama a diversidade beta explicada somente por substitui√ß√£o, aninhamento e uma combina√ß√£o dos dois.", echo=FALSE}
knitr::include_graphics(path = "img/cap12_fig01.png")
```

Aqui, vamos demonstrar alguns exemplos de como calcular a parti√ß√£o da diversidade beta para os dados deste cap√≠tulo.

Para isso, primeiro vamos transformar nossos dados de abund√¢ncia em presen√ßa e aus√™ncia.

```{r}
## Transformando dados em presencia e aus√™ncia.
composicao_PA <- decostand(composicao_especies, method = "pa")
```

Calculando a diversidade beta par a par usando os dados de presen√ßa e aus√™ncia.

```{r}
## Diversidade beta
resultado_PA <- beta.pair(composicao_PA, index.family = "sorensen")
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A fun√ß√£o `beta.pair()` gera tr√™s listas com matrizes triangulares:

-   **Diversidade beta total** = √≠ndice de S√∏rensen (beta.sor)
-   **Componente de substitui√ß√£o** = √≠ndice de Simpson (beta.sim)
-   **Componente de aninhamento** = diferen√ßa na riqueza (beta.sne)
:::

Vamos olhar os resultados da diversidade beta total.

```{r}
## Resultados
resultado_PA$beta.sor
```

Vamos montar um data.frame com os resultados

```{r}
## Data frame com os resultados
data.frame_PA <- data.frame(round(as.numeric(resultado_PA$beta.sor), 2),
                            round(as.numeric(resultado_PA$beta.sim), 2),
                            round(as.numeric(resultado_PA$beta.sne), 2))
colnames(data.frame_PA) <- c("Sorensen", "Simpson", "Aninhamento")
head(data.frame_PA)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Percebam que a primeira linha e primeira coluna do data frame (i.e., 0.00) representa a dissimilaridade de S√∏rensen entre a Com1 e Com2 (compare com os valores da matriz triangular acima). As linhas subsequentes representam a dissimilaridade da Com1 com todas as outras comunidades, depois da Com2 com todas as comunidades e assim sucessivamente. Lembrem-se que os componentes, subsitui√ß√£o (Simpson) e aninhamento (beta.sor - beta.sim), s√£o um desdobramento da diversidade beta total (S√∏rensen). Assim, a soma da dissimilaridade de Simpson e aninhamento √© igual ao valor de dissimilaridade de S√∏rensen [@baselga2009; @baselga2012].
:::

Vamos calcular a dissimilaridade entre a precipita√ß√£o anual das comunidades usando o √≠ndice de dist√¢ncia euclidiana. Vejam a ajuda da fun√ß√£o `vegdist()` que calcula 17 √≠ndices diferentes de dissimilaridade.

```{r}
## Dissimilaridade
prec_dis <- vegdist(precipitacao, method = "euclidian")
dados_prec <- as.numeric(prec_dis) 
```

Agora vamos juntar os resultados.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
As comunidades devem estar dispostas na mesma ordem nas duas planilhas (composi√ß√£o de esp√©cies e precipita√ß√£o) para que os resultados representem as dissimilaridades par a par para as mesmas comunidades no data frame.
:::

Criando data frame.

```{r}
## Data frame
dados_dis <- data.frame(dados_prec, data.frame_PA)
head(dados_dis)
```

Vamos testar a rela√ß√£o entre as diferen√ßa na composi√ß√£o de esp√©cies e
precipita√ß√£o nas comunidades.

```{r}
## ANOVA
# Avaliar a rela√ß√£o entre os valores de diversidade beta total (S√∏rensen) e precipita√ß√£o.
anova_sore <-lm(Sorensen ~ dados_prec, data = dados_dis)
anova(anova_sore)

# Avaliar a rela√ß√£o entre os valores do componente substitui√ß√£o (Simpson) e precipita√ß√£o
anova_simp <-lm(Simpson ~ dados_prec, data = dados_dis)
anova(anova_simp)

# Avaliar a rela√ß√£o entre os valores do componente aninhamento e precipita√ß√£o
anova_anin <-lm(Aninhamento ~ dados_prec, data = dados_dis)
anova(anova_anin)

```

**Interpreta√ß√£o dos resultados**

H√° uma rela√ß√£o positiva entre o componente aninhado da diversidade beta e a diferen√ßa na precipita√ß√£o entre as comunidades (F~1,43~ = 6,4, P = 0,01). Contudo, n√£o h√° rela√ß√£o entre a diversidade beta total (S√∏rensen) e o componente substitui√ß√£o de esp√©cies (Simpson) com a precipita√ß√£o (P \> 0,05).

Agora vamos fazer um gr√°fico com o componente aninhamento da diversidade
beta (Figura \@ref(fig:fig-beta-model)).

```{r fig-beta-model, fig.cap="Rela√ß√£o entre o componente de aninhamento da diversidade beta e a diferen√ßa da precipita√ß√£o."}
## Gr√°fico
ggplot(data = dados_dis, aes(x = dados_prec, y = Aninhamento)) + 
    geom_point(size = 4, shape = 21, fill = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa precipita√ß√£o (mm)", 
         y = "Componente aninhamento da\n diversidade beta") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

As comunidades localizadas em locais com baixa precipita√ß√£o anual apresentam esp√©cies que s√£o um subgrupo das esp√©cies presentes nas comunidades com alta precipita√ß√£o anual.

Agora vamos fazer um exemplo considerando os dados de abund√¢ncia das esp√©cies.

::: {.alert .alert-info}
A fun√ß√£o `beta.pair.abund()` gera tr√™s listas com matrizes triangulares:

-   **Diversidade beta total** = √≠ndice de Bray-Curtis (beta.bray)
-   **Componente varia√ß√£o balanceada (beta.bray.bal)**
-   **Componente gradiente de abund√¢ncia (beta.bray.gra)**
:::

An√°lise.

```{r}
## Diversidade beta para abund√¢ncia
resultado_AB <- beta.pair.abund(composicao_especies, index.family = "bray")
```

Cria um data frame com os resultados.

```{r}
## Data frame
# Vamos montar um data.frame com os resultados.
data.frame_AB <- data.frame(round(as.numeric(resultado_AB$beta.bray), 2),
                            round(as.numeric(resultado_AB$beta.bray.bal), 2),
                            round(as.numeric(resultado_AB$beta.bray.gra), 2))
colnames(data.frame_AB) <- c("Bray", "Balanceada", "Gradiente")
head(data.frame_AB)

## Agora vamos juntar os resultados com a precipita√ß√£o
dados_dis_AB <- data.frame(dados_prec, data.frame_AB)
```

Testar a rela√ß√£o da dissimilaridade considerando a abund√¢ncia com a diferen√ßa na precipita√ß√£o entre as comunidades.

```{r}
## ANOVA
# Avaliar a rela√ß√£o entre os valores de diversidade beta total e precipita√ß√£o
anova_dis_AB <- lm(Bray ~ dados_prec, data = dados_dis_AB)
anova(anova_dis_AB)

# Avaliar a rela√ß√£o entre os valores do componente balanceada e precipita√ß√£o
anova_balan <- lm(Balanceada ~ dados_prec, data = dados_dis_AB)
anova(anova_balan)

# Avaliar a rela√ß√£o entre os valores do componente gradiente e precipita√ß√£o
anova_grad <- lm(Gradiente ~ dados_prec, data = dados_dis_AB)
anova(anova_grad)
```

**Interpreta√ß√£o dos resultados**

H√° uma rela√ß√£o positiva entre os componentes varia√ß√£o balanceada (F~1,43~ = 7,07, P = 0,01) e gradiente (F~1,43~ = 18,7, P \< 0,001) de abund√¢ncia da diversidade beta com a diferen√ßa na precipita√ß√£o entre as comunidades. Contudo, n√£o h√° rela√ß√£o entre a diversidade beta total (Bray) com a precipita√ß√£o (F~1,43~ = 0,84, P = 0,36).

Vamos fazer um gr√°fico para a varia√ß√£o balanceada da diversidade beta (Figura \@ref(fig:fig-beta-abund-balan-model)).

```{r fig-beta-abund-balan-model, fig.cap="Rela√ß√£o entre o componente varia√ß√£o balanceada da diversidade beta e a diferen√ßa da precipita√ß√£o."}
ggplot(data = dados_dis_AB, aes(x = dados_prec, y = Balanceada)) + 
    geom_point(size = 4, shape = 21, fill = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa precipita√ß√£o (mm)",
         y = "Componente varia√ß√£o balanceada\n da diversidade beta") +
    tema_livro() 
```

**Interpreta√ß√£o dos resultados**

Olhando o √≠nicio do eixo X onde as comunidades apresentam precipita√ß√£o anual similares (i.e. baixa diferen√ßa na precipita√ß√£o), o componente varia√ß√£o balanceada indica que h√° uma tend√™ncia das esp√©cies com maiores abund√¢ncias n√£o serem as mesmas quando comparamos duas comunidades (i.e. maiores valores de dissimilaridade). Por outro lado, quando a diferen√ßa na precipita√ß√£o entre duas comunidades √© alta, o componente varia√ß√£o balanceada √© baixo, indicando que as mesmas esp√©cies est√£o dominando a abund√¢ncia nas comunidades comparadas.

Vamos fazer agora um gr√°fico para a varia√ß√£o gradiente da diversidade beta (Figura \@ref(fig:fig-beta-abund-grad-model)).

```{r fig-beta-abund-grad-model, fig.cap="Rela√ß√£o entre o componente varia√ß√£o gradiente da diversidade beta e a diferen√ßa da precipita√ß√£o."}
ggplot(data = dados_dis_AB, aes(x = dados_prec, y = Gradiente)) + 
    geom_point(size = 4, shape = 21, fill = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa precipita√ß√£o anual (mm)", 
         y = "Componente gradiente de abund√¢ncia\n da diversidade beta") +
    tema_livro()
```

**Interpreta√ß√£o dos resultados**

Olhando o √≠nicio do eixo X onde as comunidades apresentam precipita√ß√£o anual similares (i.e. baixa diferen√ßa na precipita√ß√£o), o componente gradiente indica que h√° uma tend√™ncia das esp√©cies apresentarem abund√¢ncias parecidas (i.e. menor valor de dissimilaridade). Por outro lado, quando a diferen√ßa na precipita√ß√£o entre duas comunidades √© alta, o componente gradiente √© alto, indicando que as mesmas esp√©cies tem valores discrepantes de abund√¢ncias entre as comunidades. 

## Para se aprofundar

### Livros
-   Recomendamos a leitura dos artigos citados no cap√≠tulo e os livros de Magurran & McGill [-@magurran_biological_2011] - Biological Diversity Frontiers in Measurement and Assessment, e Legendre & Legendre [-@legendre_numerical_2012] - Numerical Ecology.

### Links

Recomendamos a p√°gina pessoal do pesquisador Lou Jost que apresenta e discute diversas medidas de diversidade taxon√¥mica:

- [Medidas de diversidade e similaridade](http://www.loujost.com/Statistics%20and%20Physics/Diversity%20and%20Similarity/DiversitySimilarityHome.htm)
- [Medindo a diversidade de uma √∫nica localidade](http://www.loujost.com/Statistics%20and%20Physics/Diversity%20and%20Similarity/DiversitySimilarityHome.htm)
- [Comparando a diversidade entre duas comunidades](http://www.loujost.com/Statistics%20and%20Physics/Diversity%20and%20Similarity/How%20to%20compare%20the%20diversities%20of%20two%20communities.htm)
- [N√∫mero efetivo de esp√©cies](http://www.loujost.com/Statistics%20and%20Physics/Diversity%20and%20Similarity/EffectiveNumberOfSpecies.htm)


## Exerc√≠cios

**12.1**
Carregue os dados - `anuros_composicao` - que est√° no pacote `ecodados`. Este conjunto de dados representa a abund√¢ncia de 211 esp√©cies de anuros coletados em 44 localidades na Mata Atl√¢ntica. Calcule a riqueza de esp√©cies para cada comunidade e os √≠ndices de Margalef, Menhinich, Shannon-Wiener, Gini-Simpson e Equitabilidade de Pielou. Salve todos os resultados em novo `data frame`. Fa√ßa uma gr√°fico usando o fun√ß√£o `ggpairs` para ver a correla√ß√£o entre as m√©tricas. Qual a sua interpreta√ß√£o sobre os resultados?

**12.2**
Usando os resultados anteriores, selecione as duas comunidades com os maiores e menores valores de Shannon-Wiener. Em seguida, fa√ßa um Diagrama de Whittaker. Por fim, interprete as curvas considerando as curvas te√≥ricas (i.e., geom√©trica, broken-stick, etc.) descritas nos livros de ecologia. 

**12.3**
Usando os dados - `anuros_composicao` - calcule a parti√ß√£o da diversidade beta considerando os dados de abund√¢ncia e presen√ßa e aus√™ncia. a) Fa√ßa um gr√°fico boxplot com os resultados. Discuta se os resultados usando abund√¢ncia ou presen√ßa e aus√™ncia s√£o congruentes ou discrepantes. b) Calcule a dist√¢ncia geogr√°fica (use a planilha `anuros_ambientais`) entre as localidaes (use a Dist√¢ncia Euclidiana). Em seguida, fa√ßa uma an√°lise de regress√£o para verificar se as localidades que est√£o pr√≥ximas apresentam maior similaridade na composi√ß√£o de esp√©cies (use componente turnover - Bsim) do que as comunidades que est√£o distantes (e.g., Decaimento da similaridade).

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-12---diversidade-tax%C3%B4nomica.html).

<!--chapter:end:12_diversidade_taxonomica.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
#  Diversidade Filogen√©tica {#cap13}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(devtools)
library(ecodados)
library(V.PhyloMaker)
library(vegan)
library(ggplot2)
library(GGally)
library(ggpubr)
library(picante)
library(phytools)
library(ape)
library(geiger)
library(phyloregion)
library(pez)
library(reshape2)
library(betapart)

## Dados
minha_arvore <- ecodados::filogenia_aves
especies_plantas <- ecodados::sp_list
comunidade <- ecodados::comm
composicao_especies <- ecodados::composicao_aves_filogenetica
filogenia_aves <- ecodados::filogenia_aves
precipitacao <- precipitacao_filogenetica
```

## Aspectos te√≥ricos

A diversidade filogen√©tica captura a ancestralidade compartilhada entre as esp√©cies em termos de quantidade da hist√≥ria evolutiva e o grau de parentesco entre as esp√©cies. Pesquisadores t√™m utilizado diferentes m√©tricas de diversidade filogen√©tica em duas linhas de investiga√ß√µes principais: i) incorporar a hist√≥ria evolutiva das esp√©cies na sele√ß√£o das √°reas priorit√°rias para conserva√ß√£o visando minimizar a perda da diversidade evolutiva [@vane-wright1991; @faith1992; @v√©ron2019], e ii) produzir explica√ß√µes sobre os processos atuando na montagem das comunidades [@webb2002; @helmus2007]. A quantidade de artigos abordando ecologia, macroecologia e conserva√ß√£o com diversidade filogen√©tica cresceram exponencialmente nas √∫ltimas d√©cadas [@v√©ron2019]. Seguindo esta tend√™ncia, o n√∫mero de m√©tricas de diversidade filogen√©tica propostas n√£o param de aumentar. Tucker et al. [-@tucker2016] revisaram 70 m√©tricas de diversidade filogen√©tica e classificaram estas m√©tricas em tr√™s dimens√µes: i) **riqueza** - representa a soma da diferen√ßa filogen√©tica acumulada entre t√°xons, ii) **diverg√™ncia** - representa o padr√£o de diferen√ßa filogen√©tica entre t√°xons de uma assembleia, e iii) **regularidade** - representa o grau de varia√ß√£o das diferen√ßas filogen√©ticas entre t√°xons em uma assembleia. Outros autores utilizaram diferentes classifica√ß√µes [@pavoine2010; @vellend2011; @garamszegi2014]. Neste cap√≠tulo, iremos seguir a classifica√ß√£o de Tucker et al. [-@tucker2016] e mostrar algumas das principais m√©tricas dentro de cada uma dessas dimens√µes. Alguns autores recomendam que os pesquisadores n√£o foquem em apenas uma dimens√£o, mas comparem m√©tricas de diferentes dimens√µes [@tucker2016].

## Manipula√ß√£o de filogenias

Nesta se√ß√£o, iremos descrever os c√≥digos em R para carregar, plotar, acessar os dados, e excluir e adicionar esp√©cies em filogenias. Estes s√£o c√≥digos introdut√≥rios e necess√°rios para realizarmos as an√°lises de diversidade filogen√©tica. N√£o iremos descrever os comandos necess√°rios para construir uma filogenia. Estamos assumindo que j√° existe uma filogenia dispon√≠vel para os organismos de interesse.

Mas antes, vamos entender as principais terminologias de uma filogenia e analis√°-las graficamente (Figura \@ref(fig:fig-filo)).

::: {.alert .alert-info}
-   **√Årvore filogen√©tica**: s√£o hip√≥teses que representam o rela√ß√£o de parentesco entre as esp√©cies (pode ser tamb√©m indiv√≠duos, genes, etc.) com informa√ß√µes sobre quais esp√©cies compartilham um ancestral comum e a dist√¢ncia (tempo, gen√©tica, ou diferen√ßas nos caracteres) que as separam

-   **N√≥**: o ponto onde uma linhagem d√° origem a duas ou mais linhagens descendentes

-   **Politomia**: tr√™s ou mais linhagens descendendo de um √∫nico n√≥

-   **Ramo**: uma linha orientada ao longo de um eixo terminais-raiz que conecta os n√≥s na filogenia

-   **Terminal (do ingl√™s *tip*)**: o final do ramo representando uma esp√©cie atual ou extinta (pode tamb√©m representar g√™neros, indiv√≠duos, genes, etc.)

-   **Raiz**: representa o ancestral comum de todas as esp√©cies na filogenia

-   **Clado**: um grupo de esp√©cies aparentadas descendendo de um √∫nico n√≥ na filogenia

-   **Ultram√©trica**: a dist√¢ncia de todos os terminais at√© a raiz s√£o id√™nticas. Caracter√≠stica requerida pela maioria dos √≠ndices de diversidade filogen√©tica
:::

```{r fig-filo, fig.cap="Ilustra√ß√µes de diferentes √°rvores filogen√©ticas. A) √Årvore enraizada e ultram√©trica indicando a raiz da √°rvore, n√≥s, ramos, comprimento do ramo, politomias e terminais. B) √Årvore n√£o enraizada que mostra as rela√ß√µes entre as esp√©cies, mas n√£o define a hist√≥ria evolutiva. C) √Årvore n√£o ultram√©trica onde as esp√©cies apresentam diferentes dist√¢ncias at√© a raiz.", echo=FALSE}
knitr::include_graphics(path = "img/cap13_fig1.jpg")
```

Agora vamos plotar a filogenia para visualizar as rela√ß√µes entre as 37 esp√©cies de aves end√™micas da Mata Atl√¢ntica. Essa filogenia foi extra√≠da de Jetz et al. [-@jetz2012]. Os dados est√£o dispon√≠veis no pacote *ecodados* (Figura \@ref(fig:fig-filo-aves)).

```{r fig-filo-aves, fig.cap="Filogenia de 37 esp√©cies de aves end√™micas da Mata Atl√¢ntica."}
## Gr√°fico
plot.phylo (minha_arvore, type = "phylogram", show.tip.label = TRUE, 
            show.node.label = TRUE, edge.color = "black", edge.width = 1.5, 
            tip.color = "black", cex = 0.45, label.offset = 2) 
```

Podemos alterar o formato de apresenta√ß√£o da filogenia usando o argumento `type` e a cor dos ramos usando o argumento `edge.color` (Figura \@ref(fig:fig-filo-aves-col)).

```{r fig-filo-aves-col, fig.cap="Filogenia de 37 esp√©cies de aves end√™micas da Mata Atl√¢ntica, com altera√ß√µes de parametros de visualiza√ß√£o."}
## Gr√°fico
plot.phylo (minha_arvore, type = "fan", show.tip.label = TRUE, 
            show.node.label = TRUE, edge.color = "blue", edge.width = 1.5, 
            tip.color = "black", cex = 0.45, label.offset = 2) 
```

Percebam que existem v√°rios argumentos para modificar a largura e cor dos ramos, tamanho da fonte, dist√¢ncia entre a filogenia e o nomes da esp√©cies e muito mais. Uma sugest√£o √© visitar o blog do professor Liam Revell (<http://blog.phytools.org/>) que √© o criador e mantenedor do pacote `phytools` no R.

**Acessar informa√ß√µes da filogenia**

Um das caracter√≠sticas mais interessantes do R √© que podemos acessar as informa√ß√µes do objeto que cont√©m a filogenia. Neste caso, o nosso objeto √© a filogenia e, muitas vezes, temos interesse nas informa√ß√µes que est√£o inseridas dentro da filogenia. Para sabermos quais s√£o as informa√ß√µes que podemos acessar na filogenia, vamos usar a fun√ß√£o `names()`.

```{r}
## Nomes
names(minha_arvore)
```

Temos acesso a quatro componentes da filogenia: i) ramo (`edge`), ii) comprimento do ramo (`edge.length`), iii) n√∫mero de n√≥s (`Nnode`), e iv) nome das esp√©cies (`tip.label`). Podemos usar o operador `$` para acessar estes componentes. Veja abaixo como acessar o nome das 37 esp√©cies de aves na filogenia ou o comprimento de cada um dos ramos da filogenia.

```{r}
## Nome das esp√©cies
minha_arvore$tip.label

## Comprimento dos ramos
minha_arvore$edge.length
```

**Remover esp√©cies da filogenia**

Nas an√°lises de diversidade filogen√©tica, as esp√©cies que estar√£o presentes na filogenia normalmente s√£o aquelas que foram amostradas no seu estudo. Contudo, muitas vezes utilizamos filogenias contendo esp√©cies que n√£o est√£o presentes no nosso estudo. Neste caso, precisamos excluir essas esp√©cies da filogenia. A fun√ß√£o `drop.tip()` faz essa tarefa.

```{r}
## Remover esp√©cies da filogenia
# Vamos criar um novo nome para o objeto e excluir as esp√©cies Leucopternis polionotus e Aramides saracura da filogenia
filogenia_cortada <- drop.tip(minha_arvore, c("Leucopternis_polionotus", "Aramides_saracura"))
filogenia_cortada
```

Vejam que agora a filogenia tem 35 esp√©cies de aves. As duas esp√©cies que selecionamos foram exclu√≠das da filogenia.

**Adicionar esp√©cies na filogenia**

Outra situa√ß√£o bem comum √© quando precisamos inserir esp√©cies que foram amostradas no nosso estudo, mas n√£o est√£o presente na filogenia. Para isso, vamos usar a fun√ß√£o `add.species.to.genus()`. A fun√ß√£o `force.ultrametric()` √© usada para que a filogenia continue sendo ultram√©trica (sem essa fun√ß√£o a √°rvore perde os comprimentos dos ramos)

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
O comprimento do ramo que a esp√©cie ir√° receber depender√° de onde voc√™ indicar a inser√ß√£o da esp√©cie.

As op√ß√µes s√£o:
-   **root**: insere a esp√©cie no ancestral comum mais recente (MRCA) de todas as esp√©cies do g√™nero (*default*)
-  **random**: insere a esp√©cie aleatoriamente dentro do clado do MRCA contendo todos as esp√©cies do g√™nero
:::

```{r message = FALSE}
## Adicionar esp√©cies √† filogenia
# Vamos inserir as esp√©cies Megascops_sp1, Carponis_sp, Strix_sp1, Strix_sp2 e
# Strix_sp3 na filogenia
Megascops <- c("Megascops_sp1")
Carpornis <- c("Carpornis_sp1")
Strix <- c("Strix_sp1", "Strix_sp2", "Strix_sp3")

# Inserindo esp√©cies como politomias
filogenia_nova <- add.species.to.genus(force.ultrametric(minha_arvore, message = FALSE), Megascops)
filogenia_nova <- add.species.to.genus(force.ultrametric(filogenia_nova, message = FALSE), Carpornis)
```

Agora vamos inserir v√°rias esp√©cies dentro do mesmo g√™nero.

```{r message = FALSE}
## Adicionar v√°rias esp√©cies √† filogenia
# Para inserir mais de uma esp√©cie dentro do g√™nero, vamos utilizar um loop.  
for(i in 1:length(Strix)) 
    filogenia_nova <- add.species.to.genus(force.ultrametric(filogenia_nova, message = FALSE),
                                           Strix[i], where = "root")
```

Vamos plotar essa nova filogenia (Figura \@ref(fig:fig-filo-aves-add)).

```{r fig-filo-aves-add, fig.cap="Filogenia de esp√©cies de aves end√™micas da Mata Atl√¢ntica, com adi√ß√£o de esp√©cies."}
## Gr√°fico
plot(filogenia_nova, cex = 0.5, no.margin = TRUE)
```

Vamos fazer outro exemplo usando a fun√ß√£o `phylo.maker()` do pacote `V.PhyloMaker` que adiciona as esp√©cies nos g√™neros ou os g√™neros nas fam√≠lias usando uma filog√™nia *backbone*. 

Essa fun√ß√£o permite a adi√ß√£o dos g√™neros ou esp√©cies considerando tr√™s cen√°rios diferentes:

- **Cen√°rio 1**: adiciona g√™neros ou esp√©cies como politomias basais dentro das fam√≠lias ou g√™neros da filogenia respectivamente
- **Cen√°rio 2**: adiciona g√™neros e esp√©cies aleatoriamente nas fam√≠lias ou g√™neros da filogenia respectivamente
- **Cen√°rio 3**: adiciona g√™neros e esp√©cies nas fam√≠lias ou g√™neros da filogenia respectivamente usando as abordagens implementadas no *Phylomatic* e *BLADJ*

```{r}
## phylo.maker
# A fun√ß√£o phylo.maker usa uma filogenia default de plantas (i.e. GBOTB.extended).
# Caso voc√™ queira utilizar outra filogenia, √© s√≥ alterar o argumento tree
novas_filogenias <- phylo.maker(especies_plantas,
                                tree = GBOTB.extended,
                                scenarios = c("S1","S2","S3"))
```

Vamos essa filogenia criada pelo pacote `V.PhyloMaker` (Figura \@ref(fig:fig-filo-phylomaker)).

```{r fig-filo-phylomaker, fig.cap="Filogenia de esp√©cies de plantas criada pelo pacote `V.PhyloMaker`."}
## Gr√°fico
par(mfrow = c(1, 2))
plot.phylo(novas_filogenias$scenario.1, cex = 0.5, main = "Cen√°rio 1")
plot.phylo(novas_filogenias$scenario.3, cex = 0.5, main = "Cen√°rio 3")
dev.off()
```

## M√©tricas de diversidade alfa filogen√©tica

M√©tricas de diversidade alfa utilizam os dados de incid√™ncia (presen√ßa e aus√™ncia) ou abund√¢ncia das esp√©cies para determinar um valor de diversidade para cada comunidade ou s√≠tio de interesse.

**Exemplo pr√°tico 1**

**Explica√ß√£o dos dados**

Avaliaremos a diversidade filogen√©tica de 10 comunidades de aves amostradas ao longo de um gradiente de precipita√ß√£o. Utilizaremos este conjunto de dados para todos os exemplos deste cap√≠tulo.

**Pergunta**

- A varia√ß√£o na distribui√ß√£o espacial dos valores de diversidade filogen√©tica das comunidades est√° associada com o gradiente de precipita√ß√£o?

**Predi√ß√µes**

- Os valores de diversidade filogen√©tica ser√£o maiores nas comunidades localizadas em regi√µes com altas precipita√ß√µes do que em regi√µes mais secas

**Vari√°veis**

-   Vari√°veis resposta e preditoras

    - Data frame com as comunidades (unidade amostral) nas linhas e as esp√©cies de aves nas colunas (vari√°vel resposta)
    - Data frame com as comunidades (unidade amostral) nas linhas e a vari√°vel precipita√ß√£o anual na coluna (vari√°vel preditora)
    - Arquivo com a filogenia das 37 esp√©cies de aves (vari√°vel resposta)

**Checklist**

-   Verificar se os data frames de composi√ß√£o de esp√©cies e vari√°veis ambientais est√£o com as unidades amostrais nas linhas e vari√°veis preditoras nas colunas

-   Verificar se as comunidades nos data frames de composi√ß√£o de esp√©cies e vari√°veis ambientais est√£o distribu√≠dos na mesma sequ√™ncia/ordem nos dois arquivos.

-   Verificar se o nome das esp√©cies de aves no data frame de composi√ß√£o de esp√©cies √© id√™ntico ao nome das esp√©cies na filogenia.

### Riqueza da diversidade alfa filogen√©tica

As m√©tricas de riqueza somam a quantidade da diferen√ßa filogen√©tica presente em uma comunidade [@tucker2016].

**Phylogenetic diversity (PD)**

Esta m√©trica √© definida pela soma do comprimento dos ramos conectando todas as esp√©cies na comunidade. √â a m√©trica mais conhecida e usada nos estudos de conserva√ß√£o e comunidade [@faith1992].

Vamos conferir se os nomes das esp√©cies de aves no data frame de composi√ß√£o s√£o os mesmos da filogenia. O resultado `OK` indica que os nomes est√£o corretos. Caso contr√°rio, voc√™ deve verificar e arrumar.

```{r}
## Conferir os nomes das esp√©cies
name.check(filogenia_aves, t(composicao_especies))

## Colocar os nomes das esp√©cies do data frame na mesma ordem que aparecem na filogenia
composicao_especies_P <- match.phylo.comm(phy = filogenia_aves, comm = composicao_especies)$comm
```

Os nomes das esp√©cies que est√£o na planilha s√£o iguais e est√£o na mesma ordem dos nomes das esp√©cies que est√£o na filogenia. Agora podemos continuar as an√°lises.

Abaixo, demonstramos os c√≥digos no R para o c√°lculo de PD para as comunidades de aves.

```{r}
## Phylogenetic diversity (PD)
# Calculando a m√©trica de diversidade filogen√©tica proposta por Faith (1992).
resultados_PD <- pd(composicao_especies_P, filogenia_aves)

# Mostra o valor de PD e riqueza de esp√©cies para cada comunidade.
resultados_PD
```

A comunidade 2 abriga a maior diversidade filogen√©tica com a composica√ß√£o de esp√©cies contemplando 1293,15 milh√µes de anos (i.e. soma do comprimento dos ramos ligando todas as esp√©cies da comunidade). Por outro lado, a comunidade 10 abriga a menor diversidade filogen√©tica contemplando 599,69 milh√µes de anos.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Este √≠ndice √© correlacionado com a riqueza de esp√©cies. Discutiremos essa quest√£o na se√ß√£o de modelos nulos.
:::

**Phylogenetic Species Richness (PSR)**

Esta m√©trica √© calculada multiplicando a riqueza de esp√©cies registrada na comunidade pela *Phylogenetic Species Variability* (PSV) da comunidade [@helmus2007]. PSR √© diretamente compar√°vel ao n√∫mero de esp√©cies na comunidade, mas inclui o parentesco filogen√©tico entre as esp√©cies.

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do PSR utilizando os dados das comunidades de aves.

```{r}
## Phylogenetic Species Richness (PSR)
# An√°lise com dados de composi√ß√£o das esp√©cies nas comunidades.
resultados_PSR <- psr(composicao_especies_P,filogenia_aves)

# Mostra os valores de PSR para cada comunidade.
resultados_PSR 
```

A comunidade 2 abriga o maior valor de PSR enquanto a comunidade 10 abriga o menor valor. Vejam que PSR √© fortemente correlacionado com n√∫mero de esp√©cies nas comunidades (r = 0.99, p <0.0001). Contudo, existe uma variabilidade residual no PSR em rela√ß√£o ao n√∫mero de esp√©cies que afeta o ranqueamento das comunidades quando utilizando PSR ou n√∫mero de esp√©cies. Consequentemente, a escolha da m√©trica pode gerar diferentes delineamentos de  √°reas priorit√°rias para conserva√ß√£o [@helmus2007].

**Phylogenetic Endemism (PE)**

Esta m√©trica calcula a fra√ß√£o dos ramos restritas a regi√µes espec√≠ficas. PE identifica √°reas ou comunidades que abrigam componentes restritos da diversidade filogen√©tica. PE √© uma m√©trica proposta para auxiliar estudos de conserva√ß√£o estabelecendo crit√©rios para priorizar regi√µes a serem conservadas com base na import√¢ncia evolutiva (i.e. partes da filog√™nia com distribui√ß√£o espacial limitada) das esp√©cies que ocorrem nestes locais [@rosauer2009].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do PE utilizando os dados das comunidades de aves.

```{r}
## Phylogenetic Endemism (PE)
# Transformando data.frame em matriz.
dados_matriz <- as.matrix(composicao_especies_P)

# An√°lise.
resultados_PE <- phylo_endemism(dados_matriz, filogenia_aves, 
                                weighted = TRUE)

# Mostra os valores de PE para cada comunidade.
resultados_PE 
```

O √≠ndice PE considera as 10 comunidades como o range espacial m√°ximo. Se todas as esp√©cies ocorressem nas 10 comunidades, o valor de PE seria 1, indicando baixo endemismo filogen√©tico. A comunidade 2 abriga um conjunto de esp√©cies cujo os ramos com distribui√ß√£o espacial restrita contemplam 272,6 milh√µes de anos. Por outro lado, a comunidade 10 abriga um conjunto de esp√©cies cujo os ramos com distribui√ß√£o espacial restrita contemplam 68,5 milh√µes de anos. Assim, as comunidades 1, 2 e 4 s√£o as √°reas que abrigam os maiores endemismo filogen√©ticos.

**Species Evolutionary Distinctiveness (ED)**

Esta m√©trica calcula qual √© a fra√ß√£o da √°rvore filogen√©tica que √© atribu√≠da para uma esp√©cie. ED reflete qu√£o evolutivamente isolada uma esp√©cie √© comparada com as outras esp√©cies na filogenia [@redding2006]. ED √© uma m√©trica proposta para auxiliar estudos de conserva√ß√£o estabelecendo crit√©rios para priorizar as esp√©cies a serem conservadas com base na sua import√¢ncia evolutiva (exclusividade do comprimento do ramo) que n√£o √© comportilhada com outras esp√©cies. Portanto, apenas as informa√ß√µes da filogenia s√£o utilizadas para o c√°lculo de ED.

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do ED utilizando os dados das comunidades de aves.

```{r}
## Species Evolutionary Distinctiveness (ED)
# An√°lise.
resultados_ED <- evol.distinct(filogenia_aves)

# Mostra os valores de ED para cada esp√©cie.
head(resultados_ED)
```

Com base na filogenia estudada, *Tinamus solitarius* (112,58 milh√µes de anos), *Ortalis guttata* (108,39 m.a.) e *Aramides saracura* (96,86 m.a.) s√£o as esp√©cies com maior distin√ß√£o evolutiva devido a elevada fra√ß√£o dos ramos n√£o compartilhado com as outras esp√©cies. 

### Diverg√™ncia da diversidade alfa filogen√©tica

As m√©tricas de diverg√™ncia utilizam a m√©dia da distribui√ß√£o das unidades extra√≠das da √°rvore filogen√©tica [@tucker2016].

**Mean Pairwise Distance (MPD)**

Esta m√©trica utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a dist√¢ncia m√©dia do parentesco entre pares de esp√©cies em uma comunidade. Este √≠ndice pode ser calculado considerando dados de incid√™ncia ou considerando dados de abund√¢ncia das esp√©cies. Importante, o MPD √© uma m√©trica que pesa a estrutura interna da filogenia (e.g., rela√ß√µes entre esp√©cies de fam√≠lias diferentes) [@webb2002].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do MPD utilizando os dados das comunidades de aves. 

Vamos iniciar com dados de incid√™ncia (presen√ßa e aus√™ncia) das esp√©cies nas comunidades. A fun√ß√£o  `cophenetic()` gera uma matriz com as dist√¢ncias par a par entre as esp√©cies. Essas dist√¢ncias s√£o utilizadas para computar a dist√¢ncia m√©dia do parentesco das esp√©cies dentro das comunidades. 

```{r}
## Mean Pairwise Distance (MPD)
# An√°lise com dados de incid√™ncia das esp√©cies nas comunidades.
resultados_MPD_PA <- mpd(composicao_especies_P, cophenetic(filogenia_aves), 
                         abundance.weighted = FALSE)

# Mostra os valores de MPD para cada comunidade.
resultados_MPD_PA 
```

A comunidade 9 abriga a composi√ß√£o de esp√©cies mais aparentada (i.e. menor diversidade filogen√©tica) com dist√¢ncia m√©dia entre as esp√©cies de 139,62 milh√µes de anos. Por outro lado, a comunidade 2 abriga a composi√ß√£o de esp√©cies menos aparentada (i.e. maior diversidade filogen√©tica) com dist√¢ncia m√©dia de 157,31 milh√µes anos.

Vamos refazer a an√°lise do MPD, mas desta vez, considerando a abund√¢ncia das esp√©cies de aves nas comunidades. Para isso, alteramos o argumento `abundance.weighted = TRUE`.

```{r}
## Mean Pairwise Distance (MPD)
# An√°lise com dados de abund√¢ncia das esp√©cies nas comunidades.
resultados_MPD_AB <- mpd(composicao_especies_P, cophenetic(filogenia_aves), 
                         abundance.weighted = TRUE)

# Mostra os valores de MPD para cada comunidade.
resultados_MPD_AB 
```

Percebam que pesando o comprimento do ramo pela abund√¢ncia das esp√©cies altera-se os valores do √≠ndice de diversidade filogen√©tica. Neste caso, a comunidade 10 passa a ser a comunidade que abriga a composi√ß√£o de esp√©cies mais aparentada (i.e. menor diversidade filogen√©tica) com dist√¢ncia m√©dia entre as esp√©cies de 117,88 milh√µes de anos.

**Mean Nearest Taxon Distance (MNTD)**

Esta m√©trica utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a m√©dia dos valores m√≠nimos de parentesco entre pares de esp√©cies em uma comunidade. Ou seja, qual o valor m√©dio da dist√¢ncia para o vizinho mais pr√≥ximo. Este √≠ndice pode ser calculado considerando dados de incid√™ncia (presen√ßa e aus√™ncia) ou considerando dados de abund√¢ncia das esp√©cies. Diferente do MPD, o MNTD √© uma m√©trica terminal que pesa as rela√ß√µes nas pontas da filogenia (e.g. esp√©cies dentro do mesmo g√™nero) [@webb2002].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do MNTD utilizando os dados das comunidades de aves.

```{r}
## Mean Nearest Taxon Distance (MNTD)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_MNTD_PA <- mntd(composicao_especies_P, cophenetic(filogenia_aves), 
                           abundance.weighted = FALSE)

# Mostra os valores de MPD para cada comunidade.
resultados_MNTD_PA 
```

A comunidade 9 abriga a composi√ß√£o de esp√©cies com dist√¢ncia m√©dia do vizinho mais pr√≥ximo de 62,34 milh√µes de anos. Esse resultado indica que as esp√©cies terminais s√£o mais aparentada (e.g. esp√©cies do mesmo g√™nero) do que a composi√ß√£o de esp√©cies da comunidade 10 onde a dist√¢ncia m√©dia do vizinho mais pr√≥ximo √© 112,23 milh√µes de anos (e.g. esp√©cies de g√™neros diferentes).

Vamos refazer a an√°lise do MNTD, mas desta vez, considerando a abund√¢ncia das esp√©cies de aves nas comunidades.

```{r}
# An√°lise com dados de abund√¢ncia das esp√©cies nas comunidades.
resultados_MNTD_AB <- mntd(composicao_especies_P, cophenetic(filogenia_aves), 
                           abundance.weighted = TRUE)

# Mostra os valores de MPD para cada comunidade.
resultados_MNTD_AB 
```

Como nos resultados do MPD, pesar o comprimento do ramo pela abund√¢ncia das esp√©cies altera os valores do MNTD. Neste caso, ao inv√©s da comunidade 9, a comunidade 2 passa a ser a comunidade que abriga a composi√ß√£o de esp√©cies com a menor dist√¢ncia m√©dia do vizinho mais pr√≥ximo (53,02 milh√µes de anos). 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Perceba que ao determinar as an√°lises com base na incid√™ncia ou abund√¢ncia das esp√©cies, voc√™ pode tamb√©m alterar a interpreta√ß√£o dos padr√µes encontrados.
:::

**Phylogenetic Species Variability (PSV)**

Esta m√©trica estima a quantidade relativa dos comprimentos dos ramos n√£o compartilhados entre as comunidades. Quando todas as esp√©cies em uma amostra n√£o s√£o aparentadas (i.e. filogenia em estrela), o valor do PSV √© 1 (um), indicando m√°xima variabilidade. Quando as esp√©cies tornando-se mais aparentadas, o valor de PSV aproxima-se de 0 (zero), indicando reduzida variabilidade. Os valores esperados de PSV s√£o estatisticamente independentes da riqueza de esp√©cies [@helmus2007]. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Os valores de PSV s√£o id√™nticos ao MPD quando a filogenia √© ultram√©trica.
:::

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do PSV utilizando os dados das comunidades de aves.

```{r}
## Phylogenetic Species Variability (PSV)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_PSV <- psv(composicao_especies_P,filogenia_aves)

# Mostra os valores de PSV para cada comunidade.
resultados_PSV 
```

A comunidade 2 abriga o maior variabilidade filogen√©tica (0,69) enquanto a comunidade 9 abriga a menor variabilidade (0,62). Perceba que os valores de PSV n√£o s√£o correlacionados com n√∫mero de esp√©cies nas comunidades (r = 0,59, p = 0,07).

### Regularidade da diversidade alfa filogen√©tica

As m√©tricas de regularidade caracterizam a varia√ß√£o das dist√¢ncias entre as esp√©cies em uma comunidade [@tucker2016].

**Variance of Pairwise Distance (VPD)**

Esta m√©trica utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a vari√¢ncia do parentesco entre pares de esp√©cies em uma comunidade [@clarke2001].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do VPD utilizando os dados das comunidades de aves.

```{r}
## Variance of Pairwise Distance (VPD)
# Transformando data frame em matriz.
dados_matriz <- as.matrix(composicao_especies_P)

# Transformar os dados para o formato requerido pelo pacote pez.
dados <- comparative.comm(filogenia_aves, dados_matriz)

# An√°lise.
resultados_VPD <- .vpd(dados, cophenetic(filogenia_aves))

# Mostra os valores de VPD para cada comunidade.
resultados_VPD 
```

A comunidade 2 abriga a maior vari√¢ncia na dist√¢ncia filogen√©tica entre pares de esp√©cies dentro da comunidade (1828,19 milh√µes de anos) enquanto a comunidade 7 abriga a menor vari√¢ncia entre os pares de esp√©cies (825,53 m.a.). 

### Correla√ß√£o entre as m√©tricas de diversidade alfa filogen√©tica

Vamos avaliar a correla√ß√£o entre os valores das m√©tricas de diversidade alfa filogen√©tica. Vamos criar um data frame com os resultados das m√©tricas separados para as dimens√µes de riqueza e diverg√™ncia. N√£o iremos fazer para regularidade, pois s√≥ apresentamos uma m√©trica de diversidade filogen√©tica nesta dimens√£o (Figura \@ref(fig:fig-filo-alfa-cor-metricas-riq)).

```{r fig-filo-alfa-cor-metricas-riq, fig.cap="Correla√ß√£o entre as m√©tricas de riqueza da diversidade alfa filogen√©tica."}
## Data frame
# Vamos criar um data.frame com os resultados das m√©tricas da dimens√£o riqueza.
metricas_riqueza <- data.frame(riqueza = resultados_PD$SR,
                               PD = resultados_PD$PD,
                               PSR = resultados_PSR$PSR,
                               PE = resultados_PE)

## Gr√°fico
# Gr√°fico mostrando na parte:
# i) inferior a distribui√ß√£o dos pontos considerando as m√©tricas pareadas
# ii) superior o valor da correla√ß√£o de pearson
# iii) diagonal a curva de densidade
ggpairs(metricas_riqueza, upper = list(continuous = wrap("cor", size = 4))) +
    tema_livro()
```

Percebam que as tr√™s m√©tricas apresentam correla√ß√µes pareadas acima de 94%. Isso indica que as m√©tricas s√£o redundantes. Portanto, n√£o h√° necessidade de calcular mais de uma m√©trica dentro da dimens√£o da riqueza filogen√©tica. Al√©m disso, as tr√™s m√©tricas de diversidade alfa filogen√©tica tamb√©m apresentam alta correla√ß√£o com a riqueza de esp√©cies. Veja abaixo na se√ß√£o de modelos nulos como controlar o efeito da riqueza de esp√©cies nas m√©tricas de diversidade filogen√©tica.

Vamos avaliar a correla√ß√£o entre os valores das m√©tricas de diversidade alfa filog√©netica para a dimens√£o diverg√™ncia (Figura \@ref(fig:fig-filo-alfa-cor-metricas-div)).

```{r fig-filo-alfa-cor-metricas-div, fig.cap="Correla√ß√£o entre as m√©tricas de diverg√™ncia da diversidade alfa filogen√©tica."}
## Data frame
# Vamos criar um data.frame com os resultados das m√©tricas da dimens√£o diverg√™ncia.
metricas_divergencia <- data.frame(riqueza = resultados_PD$SR,
                                   MPD = resultados_MPD_PA,
                                   MPD_AB = resultados_MPD_AB,
                                   MNTD = resultados_MNTD_PA,
                                   MNTD_AB = resultados_MNTD_AB,
                                   PSV = resultados_PSV$PSVs)

## Gr√°fico
ggpairs(metricas_divergencia, upper = list(continuous = wrap("cor", size = 4))) +
    tema_livro()
```

Como mencionado, as m√©tricas MPD e PSV s√£o id√™nticas quando usamos uma filogenia ultram√©trica. Contudo, as m√©tricas de diverg√™ncia n√£o apresentam correla√ß√µes t√£o altas como as m√©tricas da dimens√£o riqueza, com exce√ß√£o do MNTD usando dados de incid√™ncia e abund√¢ncia que foram fortemente correlacionados (r = 0,9). Al√©m disso, estas m√©tricas n√£o s√£o t√£o afetadas pela riqueza de esp√©cies das comunidades como as m√©tricas da dimens√£o riqueza.

### Associa√ß√£o entre a diversidade alfa filogen√©tica e o ambiente

Vamos avaliar e plotar a rela√ß√£o entre os valores de algumas m√©trica de diversidade alfa filogen√©tica (vari√°vel resposta) e os valores de precipita√ß√£o (vari√°vel preditora) (Figura \@ref(fig:fig-filo-alfa-metricas-amb)).

```{r fig-filo-alfa-metricas-amb, fig.cap="Rela√ß√£o de algumas m√©trica de diversidade alfa filogen√©tica e valores de precipita√ß√£o."}
## Dados
# Vamos inserir os dados de precipita√ß√£o na planilha metrica_divergencia.
metricas_divergencia$precipitacao <- precipitacao_filogenetica$prec

## Gr√°ficos
MPD_PA_plot <- ggplot(metricas_divergencia, aes(precipitacao, MPD)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Mean Pairwise Distance\n (MPD - Aus√™ncia e Presen√ßa)") +
    tema_livro()

MPD_AB_plot <- ggplot(metricas_divergencia, aes(precipitacao, MPD_AB)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Mean Pairwise Distance\n (MPD - Abund√¢ncia)", size = 8) +
    tema_livro() 

MNTD_AP_plot <- ggplot(metricas_divergencia, aes(precipitacao, MNTD)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Mean Nearest Taxon Distance\n (MNTD - Aus√™ncia e Presen√ßa)", 
         size = 8) +
    tema_livro() 

MNTD_AB_plot <- ggplot(metricas_divergencia, aes(precipitacao, MNTD_AB)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Mean Nearest Taxon Distance\n (MNTD - Abund√¢ncia)", 
         size = 8) +
    tema_livro()

ggarrange(MPD_PA_plot, MPD_AB_plot, MNTD_AP_plot, MNTD_AB_plot,
          ncol = 2, nrow = 2)
```

O MPD, que avalia as rela√ß√µes de parentesco mais internas da filogenia (i.e. rela√ß√µes entre esp√©cies de fam√≠lias diferentes) n√£o apresentou associa√ß√£o com o gradiente de precipita√ß√£o. Por outro lado, o MNTD que avalia as rela√ß√µes mais terminais da filogenia (i.e. esp√©cies dentro do mesmo g√™nero) apresentou uma rela√ß√£o negativa com o gradiente de precipita√ß√£o. Interessante que a associa√ß√£o s√≥ foi significativa quando pesamos a an√°lise pela abund√¢ncia das esp√©cies nas comunidades. Esses resultados demonstram a import√¢ncia da sele√ß√£o das m√©tricas de diversidade filogen√©tica e tipos de dados (e.g. incid√™ncia ou abund√¢ncia) utilizados na interpreta√ß√£o dos padr√µes observados na natureza.

Vamos ver os gr√°ficos das m√©tricas da dimens√£o riqueza da diversidade alfa filogen√©tica (Figura \@ref(fig:fig-filo-alfa-metricas-riq-amb)).

```{r fig-filo-alfa-metricas-riq-amb, fig.cap="Rela√ß√£o de algumas m√©trica de diversidade alfa filogen√©tica e valores de precipita√ß√£o."}
## Dados
# Vamos inserir os dados de precipita√ß√£o na planilha metrica_riqueza.
metricas_riqueza$precipitacao <- precipitacao$prec

## Gr√°ficos
Riqueza_plot <- ggplot(metricas_riqueza, aes(precipitacao, riqueza)) +
    geom_point(size = 4, shape = 19, col = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") + 
    labs(x = "Precipita√ß√£o (mm)", y = "Riqueza de esp√©cies") +
    tema_livro() 

PD_plot <- ggplot(metricas_riqueza, aes(precipitacao, PD)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Diversidade Filogen√©tica\n (Faith)", size = 8) +
    tema_livro()

PSR_plot <- ggplot(metricas_riqueza, aes(precipitacao, PSR)) +
    geom_point(size = 4, shape = 19, col = "darkorange")  +
    geom_smooth(method = lm, se = FALSE, color = "black") + 
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Phylogenetic Species Richness\n (PSR)", 
         size = 8) +
    tema_livro()

PE_plot <- ggplot(metricas_riqueza, aes(precipitacao, PE)) +
    geom_point(size = 4, shape = 19, col = "darkorange")  +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Precipita√ß√£o (mm)", 
         y = "Phylogenetic Endemism\n (PE)", 
         size = 8) + 
    tema_livro() 

ggarrange(Riqueza_plot, PD_plot, PSR_plot, PE_plot, ncol = 2, nrow = 2)
```

As tr√™s m√©tricas de diversidade filogen√©tica foram relacionadas com o gradiente de precipita√ß√£o. Esse resultado indica que comunidades localizadas em √°reas com maior precipita√ß√£o anual abrigaram maior diversidade filogen√©tica do que comunidades localizadas em √°reas mais secas. Contudo, estas m√©tricas s√£o dependentes da riqueza de esp√©cies nas comunidades. Veja abaixo a se√ß√£o de modelos nulos para entender como lidar com essa depend√™ncia.

## M√©tricas de diversidade beta filogen√©tica

M√©tricas de diversidade beta filogen√©tica utilizam dados de presen√ßa e aus√™ncia ou abund√¢ncia das esp√©cies para determinar um valor que representa a diferen√ßa entre comunidades em rela√ß√£o a hist√≥ria evolutiva das linhagens (para detalhes de diversidade beta, consulte o Cap√≠tulo \@ref(cap12)).

### Diverg√™ncia da diversidade beta filogen√©tica

**Community Mean Pairwise Distance (COMDIST)**

Esta m√©trica √© uma extens√£o do MPD. COMDIST calcula a m√©dia da dist√¢ncia filogen√©tica entre as esp√©cies de duas comunidades [@webb2008]. COMDIST pode ser calculada usando dados de incid√™ncia (presen√ßa e aus√™ncia) ou abund√¢ncia das esp√©cies. Esta extens√£o do MPD tamb√©m √© conhecida na literatura como Dpw [@swenson2011; @swenson2014].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do COMDIST utilizando os dados das comunidades de aves.

```{r}
## Community Mean Pairwise Distance (COMDIST)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_Comdist_PA <- comdist(composicao_especies_P, 
                                 cophenetic(filogenia_aves), 
                                 abundance.weighted = FALSE)
resultados_Comdist_PA
```

As comunidades 8 e 10 apresentaram a menor m√©dia na dist√¢ncia filogen√©tica (130,06 m.a. - esp√©cies de linhagens mais pr√≥ximas) entre as esp√©cies presente em cada comunidade, enquanto as comunidades 2 e 4 apresentaram a maior m√©dia na dist√¢ncia filogen√©tica (153.29 m.a. - esp√©cies de linhagens mais distintas).

Vamos refazer a an√°lise do COMDIST, mas desta vez, considerando a abund√¢ncia das esp√©cies de aves nas comunidades.

```{r}
## Community Mean Pairwise Distance (COMDIST)
# An√°lise com dados de abund√¢ncia das esp√©cies nas comunidades.
resultados_Comdist_AB <- comdist(composicao_especies_P, 
                                 cophenetic(filogenia_aves), 
                                 abundance.weighted = TRUE)
```

Como no caso do MPD, pensar a abund√¢ncia das esp√©cies altera o padr√£o de distribui√ß√£o dos valores de COMDIST. Neste caso, ao inv√©s das comunidades 2 e 4, as comunidades 2 e 10 apresentam a maior m√©dia na dist√¢ncia filogen√©tica (155,85 m.a.).

**Community Mean Nearest Taxon Distance (COMDISTNT)**

Esta m√©trica √© uma extens√£o do MNTD. COMDISTNT calcula a m√©dia da dist√¢ncia filogen√©tica entre o t√°xon mais pr√≥ximo das esp√©cies de duas comunidades [@webb2008]. COMDISTNT pode ser calculada usando dados de incid√™ncia ou abund√¢ncia das esp√©cies. Esta extens√£o do MNTD tamb√©m √© conhecida na literatura como Dnn [@swenson2011].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do COMDISTNT utilizando os dados das comunidades de aves.

```{r}
## Community Mean Nearest Taxon Distance (COMDISTNT)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_Comdistnt_PA <- comdistnt(composicao_especies_P, 
                                     cophenetic(filogenia_aves), 
                                     abundance.weighted = FALSE)
resultados_Comdistnt_PA
```

As comunidades 8 e 9 apresentaram a menor m√©dia na dist√¢ncia do vizinho mais pr√≥ximo (10,69 m.a. - esp√©cies do mesmo g√™nero ou g√™neros irm√£os) entre as esp√©cies presente em cada comunidade, enquanto as comunidades 7 e 10 apresentaram a maior m√©dia na dist√¢ncia entre vizinhos (60,24 m.a. - esp√©cies de linhagens distintas).

Vamos refazer a an√°lise do COMDISTNT, mas desta vez, considerando a abund√¢ncia das esp√©cies de aves nas comunidades.

```{r}
## Community Mean Nearest Taxon Distance (COMDISTNT)
# An√°lise com dados de abund√¢ncia das esp√©cies nas comunidades.
resultados_Comdistnt_AB <- comdistnt(composicao_especies_P, 
                                     cophenetic(filogenia_aves), 
                                     abundance.weighted = TRUE)
```

As comunidades 8 e 10 apresentaram a menor m√©dia na dist√¢ncia do vizinho mais pr√≥ximo (5,64 m.a.) entre as esp√©cies presente em cada comunidade, enquanto as comunidades 6 e 10 apresentaram a maior m√©dia na dist√¢ncia entre vizinhos (82,62 m.a.).

### Correla√ß√£o entre as m√©tricas de diversidade beta filogen√©tica

Vamos avaliar a correla√ß√£o entre os valores das m√©tricas da diversidade beta filogen√©tica para a dimens√£o diverg√™ncia (Figura \@ref(fig:fig-filo-beta-cor-metricas-div)).

```{r fig-filo-beta-cor-metricas-div, fig.cap="Correla√ß√£o entre as m√©tricas de diverg√™ncia da diversidade beta filogen√©tica."}
## Dados
# Vamos criar um data frame com os resultados das m√©tricas da dimens√£o diverg√™ncia.
metricas_divergencia_beta <- data.frame(
    COMDIST_PA = as.numeric(resultados_Comdist_PA),
    COMDIST_AB = as.numeric(resultados_Comdist_AB),
    COMDISTNT_PA = as.numeric(resultados_Comdistnt_PA),
    COMDISTNT_AB = as.numeric(resultados_Comdistnt_AB))

## Gr√°fico
ggpairs(metricas_divergencia_beta,
        upper = list(continuous = wrap("cor", size = 4))) +
    tema_livro()
```

Os valores das m√©tricas de diverg√™ncia filogen√©tica beta apresentam correla√ß√µes mais baixas do que as m√©tricas da dimens√£o riqueza. Lembrem-se que COMDIST e COMDISTNT d√£o pesos diferentes para as rela√ß√µes de parentesco. COMDIST pesa as rela√ß√µes mais basais e internas da filogenia, enquanto COMDISTNT pesa as rela√ß√µes nas partes terminais da filogenia. Portanto, elas podem trazer informa√ß√µes complementares.

### Associa√ß√£o entre a diverg√™ncia da diversidade beta filogen√©tica e o ambiente

Vamos avaliar e plotar a rela√ß√£o entre os valores de algumas m√©tricas de diverg√™ncia da diversidade beta filogen√©tica (vari√°vel resposta) e os valores de precipita√ß√£o (vari√°vel preditora) (Figura \@ref(fig:fig-filo-beta-metricas-div-amb)).

```{r fig-filo-beta-metricas-div-amb, fig.cap="Rela√ß√£o de algumas m√©trica de diverg√™ncia diversidade beta filogen√©tica e valores de precipita√ß√£o."}
## Dados
# Precisamos calcular a dissimilaridade par a par da precipita√ß√£o entre as comunidades.
dis_prec <- vegdist(precipitacao, "euclidian")

# Vamos inserir estes dados na planilha metrica_divergencia_beta.
metricas_divergencia_beta$dis_prec <- as.numeric(dis_prec)

# Gr√°ficos.
COMDIST_PA_plot <- ggplot(metricas_divergencia_beta, 
                          aes(dis_prec, COMDIST_PA)) +
    geom_point(size = 4, shape = 19, col = "darkorange") +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = "COMDIST\n (Presen√ßa e Aus√™ncia)") + 
    tema_livro() 

COMDIST_AB_plot <- ggplot(metricas_divergencia_beta, 
                          aes(dis_prec, COMDIST_AB)) +
    geom_point(size = 4, shape = 19, col = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = "COMDIST\n (Abund√¢ncia)", size = 8) +
    tema_livro()

COMDISTNT_PA_plot <- ggplot(metricas_divergencia_beta, 
                            aes(dis_prec, COMDISTNT_PA)) +
    geom_point(size = 4, shape = 19, col = "darkorange") +
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = "COMDISTNT\n (Aus√™ncia e Presen√ßa)", 
         size = 8) + 
    tema_livro()

COMDISTNT_AB_plot <- ggplot(metricas_divergencia_beta, 
                            aes(dis_prec, COMDISTNT_AB)) +
    geom_point(size = 4, shape = 19, col = "darkorange") +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = " COMDISTNT\n (Abund√¢ncia)", 
         size = 8) +
    tema_livro() 

ggarrange(COMDIST_PA_plot, COMDIST_AB_plot, COMDISTNT_PA_plot, 
          COMDISTNT_AB_plot, ncol = 2, nrow = 2)
```

O COMDIST que avalia as rela√ß√µes de parentesco mais internas da filogenia (i.e. rela√ß√µes entre esp√©cies de fam√≠lias diferentes) apresentou associa√ß√£o com o gradiente de precipita√ß√£o quando avaliado pesado pela abund√¢ncia das esp√©cies. Por outro lado, o COMDISTNT que avalia as rela√ß√µes mais terminais da filogenia (i.e. esp√©cies dentro do mesmo g√™nero) apresentou uma rela√ß√£o negativa com o gradiente de precipita√ß√£o quando avaliado usando a incid√™ncia das esp√©cies.

### Riqueza da diversidade beta filogen√©tica

**Phylogenetic index of beta diversity (Phylosor)**

Phylosor √© uma m√©trica de similaridade e determina o comprimento total dos ramos da filogenia que √© compartilhado entre pares de comunidades [@bryant2008].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo do Phylosor utilizando os dados das comunidades de aves.

```{r}
## Phylogenetic index of beta diversity (Phylosor)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_Phylosor <- phylosor(composicao_especies_P, filogenia_aves)

# Mostra uma matriz triangular com a similaridade entre a fra√ß√£o dos ramos 
# compartilahdos entre duas comunidades
resultados_Phylosor 
```

As esp√©cies presentes nas comunidades 6 e 10 compartilham a menor por√ß√£o do comprimento dos ramos da filogenia (53% - menor similaridade entre os pares de comunidades), enquanto as esp√©cies presentes nas comunidades 8 e 10 compartilham grande parte dos comprimentos dos ramos da filogenia (91% - maior similaridade entre os pares de comunidades).

**Unique Fraction metric (UniFrac)**

UniFrac √© uma m√©trica de dissimilaridade e determina a fra√ß√£o √∫nica da filogenia contida em cada uma das duas comunidades [@lozupone2005].

Abaixo, demonstramos os c√≥digos no R para o c√°lculo da UniFrac utilizando os dados das comunidades de aves.

```{r}
## Unique Fraction metric (UniFrac)
# An√°lise com dados de presen√ßa e aus√™ncia das esp√©cies nas comunidades.
resultados_UniFrac <- unifrac(composicao_especies_P, filogenia_aves)
```

As esp√©cies presentes nas comunidades 6 e 10 apresentam a menor dissimilaridade  (16,4 % - maior fra√ß√£o √∫nica da filogenia em cada comunidade), enquanto as esp√©cies presentes nas comunidades 8 e 10 apresentam a maior dissimilaridade (63,36 % - maior compartilhamento de ramos da filogenia entre os pares de comunidades). 

### Correla√ß√£o entre Phylosor e Unifrac

Vamos calcula a correla√ß√£o entre as duas m√©tricas de Riqueza da diversidade beta filogen√©tica: Phylosor e Unifrac (Figura \@ref(fig:fig-filo-beta-cor-metricas-riq)).

```{r fig-filo-beta-cor-metricas-riq, fig.cap="Correla√ß√£o entre as m√©tricas de riqueza da diversidade beta filogen√©tica."}
## Dados
# Vamos criar um data.frame com os resultados das m√©tricas separados 
# para as dimens√µes de riqueza e diverg√™ncia.
metricas_riqueza_beta <- data.frame(Phylosor = as.numeric(resultados_Phylosor),
                                    UniFrac = as.numeric(resultados_UniFrac))

## Gr√°fico
ggpairs(metricas_riqueza_beta, upper=list(continuous = wrap("cor", size = 4))) +
    tema_livro()
```

Os valores de Phylosor e UniFrac apresenta 99% de correla√ß√£o entre eles. Portanto, essas duas m√©tricas identificam padr√µes id√™nticos e n√£o devem ser utilizadas simultaneamente.

### Associa√ß√£o entre a riqueza da diversidade beta filogen√©tica e o ambiente

Vamos avaliar e plotar a rela√ß√£o entre os valores de algumas m√©tricas de riqueza da diversidade beta filogen√©tica (vari√°vel resposta) e os valores de precipita√ß√£o (vari√°vel preditora) (Figura \@ref(fig:fig-filo-beta-metricas-riq-amb)).

```{r fig-filo-beta-metricas-riq-amb, fig.cap="Rela√ß√£o de algumas m√©trica de riqeuza diversidade beta filogen√©tica e valores de precipita√ß√£o."}
## Dados
# Vamos inserir os dados de precipita√ß√£o na planilha metrica_riqueza_beta.
metricas_riqueza_beta$dis_prec <- as.numeric(dis_prec)

## Gr√°ficos
# Phylosor.
plot_phylosor <- ggplot(metricas_riqueza_beta, aes(dis_prec, Phylosor)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    scale_y_continuous(limits = c(0, 1.0)) +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = "Phylosor", size = 8) +
    tema_livro()

# Unifrag.
plot_unifrac <- ggplot(metricas_riqueza_beta, aes(dis_prec, UniFrac)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    scale_y_continuous(limits = c(0, 1.0)) +
    labs(x = "Diferen√ßa na precipita√ß√£o (mm)", 
         y = "UniFrac", size = 8) +
    tema_livro()

ggarrange(plot_phylosor, plot_unifrac, ncol = 2)
```

Phylosor (similaridade) e UniFrac (dissimilaridade) foram relacionadas com o gradiente de precipita√ß√£o. Comunidades com quantidade de precipita√ß√£o parecidas abrigaram linhagens similares enquanto comunidades que recebem quantidade de precipita√ß√£o diferentes abrigam linhagens mais distintas.

### Parti√ß√£o da diversidade beta filogen√©tica

As m√©tricas, Phylosor e UniFrac, podem ser particionadas em dois componentes [@baselga2009; @leprieur2012]: i) substitui√ß√£o (do ingl√™s *turnover*) de esp√©cies entre as comunidades; e ii) componente de aninhamento (do ingl√™s *nestedness*) que representa a perda ou ganho de esp√©cies entre comunidades atribu√≠dos a diferen√ßa na riqueza de esp√©cies. A parti√ß√£o da diversidade beta nestes componentes permite avaliar diferentes hip√≥teses sobre os processos e mecanismos atuando na montagem de comunidades.

Abaixo, demonstramos os c√≥digos no R para o c√°lculo da parti√ß√£o da diversidade beta filogen√©tica utilizando os dados das comunidades de aves.

```{r}
## Parti√ß√£o
# Temos que transformar os dados para presen√ßa e aus√™ncia das esp√©cies nas comunidades.
dados_PA <- decostand(composicao_especies_P, "pa")

# Parti√ß√£o dos componentes do Phylosor.
resultados_Phylosor_particao <- phylo.beta.pair(dados_PA,
                                                filogenia_aves, 
                                                index.family = "sorensen")

```

Vamos refazer a an√°lise para UniFrac.

```{r}
# Parti√ß√£o dos componentes do UniFrac.
resultados_UniFrac_particao <- phylo.beta.pair(dados_PA,
                                               filogenia_aves, 
                                               index.family = "jaccard")
# Resultado tem tr√™s matrizes: 
# i) dissimilaridade total (phylo.beta.jac); 
# ii) componente substitui√ß√£o de esp√©cies (phylo.beta.jtu); e 
# iii) componente aninhamento (phylo.beta.jne).
# resultados_UniFrac_particao (para ver os resultados corra este comando)
```

Gr√°fico com os resultados dos componentes substitui√ß√£o e aninhamento da diversidade beta filogen√©tica - Phylosor (Figura \@ref(fig:fig-filo-beta-part-amb)).

```{r fig-filo-beta-part-amb, fig.cap="Rela√ß√£o dos componentes substitui√ß√£o e aninhamento da diversidade beta filogen√©tica - Phylosor e valores de precipita√ß√£o."}
## Dados
# Vamos preparar os dados para o gr√°fico.
particao_phylosor <- data.frame(
    substituicao = as.numeric(resultados_Phylosor_particao$phylo.beta.sim),
    aninhamento = as.numeric(resultados_Phylosor_particao$phylo.beta.sne),
    sorensen = as.numeric(resultados_Phylosor_particao$phylo.beta.sor),
    dis_prec = as.numeric(dis_prec))

## Gr√°ficos
sorensen_plot <- ggplot(particao_phylosor, 
                        aes(dis_prec, sorensen)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "", y = "Sorensen") +
    tema_livro()

subst_plot <- ggplot(particao_phylosor, 
                     aes(dis_prec, substituicao)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "Diferen√ßa na precipita√ß√£o\n (mm)", 
         y = "Componente Substitui√ß√£o", size = 8) +
    tema_livro()

aninha_plot <- ggplot(particao_phylosor, 
                      aes(dis_prec, aninhamento)) +
    geom_point(size = 4, shape = 19, col = "darkorange") + 
    geom_smooth(method = lm, se = FALSE, color = "black") +
    labs(x = "", y = "Componente aninhamento", size = 8) +
    tema_livro()

ggarrange(sorensen_plot, subst_plot, aninha_plot, 
          ncol = 3, nrow = 1)
```

Percebam que o componente substitui√ß√£o √© maior entre comunidades que apresentam diferen√ßas altas na quantidade de precipita√ß√£o, enquanto o componente aninhamento √© maior entre as comunidades que apresentam quantidade similar de precipita√ß√£o.

## Modelos Nulos

Em muitos casos, os valores de diversidade filogen√©tica s√£o correlacionados com a riqueza de esp√©cies nas comunidades. Por exemplo, se um pesquisador relata que duas comunidades apresentam diferentes valores de PD, √© imposs√≠vel saber se esta diferen√ßa √© simplesmente porque elas t√™m diferentes valores de riqueza de esp√©cies ou se h√° algum fator fundamental sobre a informa√ß√£o filogen√©tica que √© importante. Outra quest√£o abordada nos estudos de montagem das comunidades √© saber se os valores observados para as m√©tricas (e.g. MPD ou MNTD) relacionadas com a estrutura filogen√©tica das comunidades seriam diferentes se a coloniza√ß√£o das esp√©cies do *pool* regional fosse aleat√≥ria? Os modelos nulos respondem a estas perguntas. Contudo, a defini√ß√£o do *pool* regional n√£o √© uma tarefa trivial [@lessard2012; @carstensen2013].

Os modelos nulos s√£o constru√≠dos considerando processos ecol√≥gicos ou evolutivos de interesse. Eles geram padr√µes que s√£o baseados na aleatoriza√ß√£o dos dados ecol√≥gicos ou amostragens aleat√≥rias de uma distribui√ß√£o conhecida ou hip√≥tetica [@gotelli1996]. Neste caso, alguns elementos dos dados (como colunas ou linhas) s√£o mantidos constantes, e outros s√£o permitidos variar aleatoriamente para criar novos padr√µes. O principal motivo para a constru√ß√£o de modelos nulos √© produzir um padr√£o que seria esperado na aus√™ncia de um mecanismo ecol√≥gico espec√≠fico [@gotelli1996]. Contudo, ressaltamos que os modelos nulos podem revelar padr√µes n√£o comuns, mas eles n√£o podem determinar os mecanismos respons√°veis por gerar estes padr√µes [@gotelli1996].

Os modelos nulos empregados para contrapor os padr√µes observados pelas m√©tricas de diversidade filogen√©tica utilizam a aleatoriza√ß√£o dos dados de duas formas principais: i) aleatorizando o nome das esp√©cies na √°rvore filogen√©tica mantendo a estrutura e composi√ß√£o da matriz de co-ocorr√™ncia das esp√©cies e o comprimento dos ramos da √°rvore inalterados; e ii) aleatorizando as linhas e/ou colunas da matriz de co-ocorr√™ncia das esp√©cies [@gotelli2000; @ulrich2010]. De forma geral, nas an√°lises de diversidade filogen√©tica as aleatoriza√ß√µes s√£o repetidas 999 vezes (pode ser mais ou menos, a crit√©rio do pesquisador) e calcula-se a m√©dia e o desvio padr√£o dos valores gerados pelo modelos. Com estes dados, calcula-se o tamanho do efeito padronizado (do ingl√™s *Standardized Effect Size* - SES) utilizando a seguinte f√≥rmula:

- SES = (valor observado - m√©dia dos valores gerados na aleatoriza√ß√£o)/ desvio padr√£o dos valores gerados na aleatoriza√ß√£o

Os valores de SES s√£o utilizados para rejeitar ou n√£o a hip√≥tese nula de que o padr√£o observado difere do esperado ao acaso. Contudo, tenha em mente que a defini√ß√£o do esquema de aleatoriza√ß√£o dos modelos nulos n√£o √© meramente uma quest√£o t√©cnica [@g√∂tzenberger2011]. A defini√ß√£o do esquema de aleatoriza√ß√£o ir√° determinar quais os mecanismos ecol√≥gicos s√£o permitidos ou exclu√≠dos no modelo nulo [@g√∂tzenberger2011]. Consequentemente, ele estar√° avaliando diferentes hip√≥teses nulas.

Abaixo, demonstramos os c√≥digos no R para calcular os modelos nulos para as m√©tricas de diversidade filogen√©tica.

**Nearest Relative Index (NRI) ou Standardized Effect Size of MPD**

Esta m√©trica calcula o tamanho do efeito padronizado para a m√©trica MPD. Contudo, NRI √© calculado multiplicando os resultados do SES por -1. Valores positivos de NRI indicam agrupamento filogen√©tico e valores negativos de NRI indicam dispers√£o filogen√©tica [@webb2008].

Veja a ajuda desta fun√ß√£o usando `?ses.mpd()` para ver todas as possibilidades de modelos nulos dispon√≠veis.

```{r}
## NRI ou SES_MPD
resultados_SES_MPD <- ses.mpd(composicao_especies_P, cophenetic(filogenia_aves),
                              null.model = "taxa.labels", 
                              abundance.weighted = FALSE,
                              runs = 999) 

# Mostra a riqueza de esp√©ices, MPD observado, m√©dia e desvio padr√£o dos 
# valores de MPD das aleatoriza√ß√µes, SES e o valor de p.
head(resultados_SES_MPD)
```

Somente as comunidades 5 e 6 apresentaram valores de p < 0.05 indicando que os resultados observados de MPD s√£o menores que o esperado ao acaso (i.e. valores simulados). Neste caso, a composi√ß√£o de esp√©cies presentes nessas duas comunidades apresenta agrupamento filogen√©tico. Por outro lado, os valores de MPD observados para as outras comunidades s√£o similares aos valores obtidos para comunidades simuladas com a redistribui√ß√£o dos nomes das esp√©cies na filogenia.

**Nearest Taxon Index (NTI) ou Standardized Effect Size of MNTD**

Esta m√©trica calcula o tamanho do efeito padronizado para a m√©trica MNTD. Contudo, NTI √© calculado multiplicando os resultados do SES por -1. Valores positivos de NTI indicam agrupamento filogen√©tico e valores negativos de NTI indicam dispers√£o filogen√©tica [@webb2008].

```{r}
## NTI ou SES_MNTD
resultados_SES_MNTD <- ses.mntd(composicao_especies_P, cophenetic(filogenia_aves),
                                null.model = "taxa.labels", 
                                abundance.weighted = FALSE,
                                runs = 999) 

# Mostra a riqueza de esp√©ices,MNTD observado, m√©dia e desvio padr√£o dos 
# valores de MNTD das aleatoriza√ß√µes, SES e o valor de p.
head(resultados_SES_MNTD)
```

Somente a comunidade 9 apresentou valor de p < 0.05 indicando que o resultado observado de MNTD foi menor que o esperado ao acaso (i.e. valores simulados). Neste caso, a composi√ß√£o de esp√©cies presente nessa comunidade apresenta agrupamento filogen√©tico. Por outro lado, os valores de MNTD observados para as outras comunidades s√£o similares aos valores obtidos para comunidades simuladas com a redistribui√ß√£o dos nomes das esp√©cies na filogenia. 

**Standardized Effect Size of PD**

Esta m√©trica calcula o tamanho do efeito padronizado para a m√©trica PD [@webb2008].

```{r}
## SES_PD
resultados_SES_PD <- ses.pd(composicao_especies_P, filogenia_aves,
                            null.model = "independentswap", 
                            runs = 999) 

# Mostra a riqueza de esp√©ices,MNTD observado, m√©dia e desvio padr√£o dos 
# valores de PD das aleatoriza√ß√µes, SES e o valor de p.
head(resultados_SES_PD) 
```

Nenhuma comunidade apresentou valor de p < 0.05. Neste caso, os valores observados de PD  s√£o similares aos valores obtidos para comunidades simuladas com a redistribui√ß√£o dos nomes das esp√©cies na filogenia. 

**Standardized effect size do Phylosor**

N√£o h√° pacotes que calculam o SES para a m√©trica Phylosor. Assim, iremos usar a fun√ß√£o `phylosor.rnd()` para criar modelos nulos para o Physolor, e em seguida, iremos usar uma fun√ß√£o criada por Pedro Braga & Katherine H√©bert (diposn√≠vel em https://pedrohbraga.github.io/CommunityPhylogenetics-Workshop/CommunityPhylogenetics-Workshop.html) para calcular os valores de SES e os valores de P.

```{r}
## Standardized effect size do Phylosor
# Modelo nulo que rearranja o nome das esp√©cies na filogenia. 
modelos_nulo <- phylosor.rnd(composicao_especies_P, filogenia_aves, 
                             null.model = "taxa.labels", runs = 9)

# Fun√ß√£o para calcular o SES eo valor de P.
ses.physo <- function(obs, nulo_phylosor){
    nulo_phylosor <- t(as.data.frame(lapply
                                     (nulo_phylosor, as.vector)))
    physo.obs <- as.numeric(obs)
    physo.mean <- apply(nulo_phylosor, MARGIN = 2, 
                        FUN = mean, na.rm = TRUE)
    physo.sd <- apply(nulo_phylosor, MARGIN = 2, 
                      FUN = sd, na.rm = TRUE)
    physo.ses <- (physo.obs - physo.mean)/physo.sd
    physo.obs.rank <- apply(X = rbind(physo.obs, 
                                      nulo_phylosor), MARGIN = 2, 
                            FUN = rank)[1, ]
    physo.obs.rank <- ifelse(is.na(physo.mean), NA, 
                             physo.obs.rank)
    data.frame(physo.obs, physo.mean, physo.sd, 
               physo.obs.rank, physo.ses, 
               physo.obs.p = physo.obs.rank/
                   (dim(nulo_phylosor)[1] + 1))
}

## Resultados
resultados <- ses.physo (resultados_Phylosor, modelos_nulo)
head(resultados)
```

Nenhum valor de similaridade entre pares comunidade apresentou valor de p < 0.05. Neste caso, os valores de Phylosor observados s√£o similares aos valores obtidos para as comunidades simuladas  com a redistribui√ß√£o dos nomes das esp√©cies na filogenia. 

## Para se aprofundar

### Livros
-   Recomendamos aos interessados os livros: i) Swenson [-@swenson2014] Functional and Phylogenetic Ecology in R; ii) Paradis [-@paradis2012] Analysis of Phylogenetics and Evolution in R; iii) Cadotte & Davies [-@cadotte2016] Phylogenies in Ecology, iv) Gotelli & Graves [-@gotelli1996] Null Models in Ecology; e v) Magurran & McGill [-@magurran_biological_2011] Biological Diversity Frontiers in Measurement and Assessment.

### Links

O blog [Ferramentas filogen√©ticas para biologia comparada](http://blog.phytools.org/) do pesquisador Liam Revell √© uma ferramenta excelente para obter informa√ß√µes e aplica√ß√µes das an√°lises filogen√©ticas diretamente no R.  


## Exerc√≠cios

**13.1**
Carregue os dados - `anuros_composicao` (i.e., 211 esp√©cies de anuros coletados em 44 localidades na Mata Atl√¢ntica), `anuros_ambientais` (i.e., vari√°veis clim√°ticas, topogr√°ficas e coordenadas geogr√°ficas) e `filogenia_anuros` (filogenia das 211 esp√©cies) - que est√£o no pacote `ecodados`. Use a fun√ß√£o `varpart()` do pacote `vegan` para testar a import√¢ncia relativa dos efeitos da precipita√ß√£o anual, range altitudinal e temperatura anual na distribui√ß√£o espacial da diversidade filogen√©tica (PD) e Endemismo filogen√©tico (PE). Calcule o SES para verificar se os resultados da diversidade filogen√©tica (PD) diferem do esperado ao acaso devido ao n√∫mero de esp√©cies em cada comunidade. Qual a sua interpreta√ß√£o sobre os resultados?

**13.2**
Carregue os dados - `anuros_composicao` (i.e., 211 esp√©cies de anuros coletados em 44 localidades na Mata Atl√¢ntica), `anuros_ambientais` (i.e., vari√°veis clim√°ticas, topogr√°ficas e coordenadas geogr√°ficas) e `filogenia_anuros` (filogenia das 211 esp√©cies) - que est√£o no pacote ecodados. Use a fun√ß√£o `varpart()` do pacote `vegan` para testar a import√¢ncia relativa dos efeitos da precipita√ß√£o anual, range altitudinal e temperatura anual na distribui√ß√£o espacial do NRI e NTI. Qual a sua interpreta√ß√£o sobre os resultados?

**13.3**
Carregue os dados - `anuros_composicao` (i.e., 211 esp√©cies de anuros coletados em 44 localidades na Mata Atl√¢ntica), `anuros_ambientais` (i.e., vari√°veis clim√°ticas, topogr√°ficas e coordenadas geogr√°ficas) e `filogenia_anuros` (filogenia das 211 esp√©cies) - que est√£o no pacote ecodados. Use a fun√ß√£o `varpart()` do pacote `vegan` para testar a import√¢ncia relativa dos efeitos da precipita√ß√£o anual, range altitudinal e dist√¢ncia geogr√°fica na distribui√ß√£o espacial dos diferentes componentes da diversidade beta filogen√©tica (Phylosor). Qual a sua interpreta√ß√£o sobre os resultados?

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-13---diversidade-filogen%C3%A9tica.html).

<!--chapter:end:13_diversidade_filogenetica.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Diversidade Funcional {#cap14}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes, dados e fun√ß√µes que ser√£o utilizados nesse cap√≠tulo.

```{r message=FALSE, warning=FALSE}
## Pacotes 
library(FD)
library(ade4)
library(ecodados)
library(gridExtra)
library(ggplot2)
library(ggrepel)
library(tidyverse)
library(picante)
library(vegan)
library(SYNCSA)
library(GGally)
library(FD)
library(betapart)
library(nlme)
library(ape)
library(TPD)
library(cati)
library(kableExtra)

## Dados e fun√ß√µes
comun_fren_dat <- ecodados::fundiv_frenette2012a_comu
ambie_fren_dat <- ecodados::fundiv_frenette2012a_amb
trait_fren_dat <- ecodados::fundiv_frenette2012a_trait
trait_dat      <- ecodados::fundiv_barbaro2009a_trait
comun_dat      <- ecodados::fundiv_barbaro2009a_comu
ambie_dat      <- ecodados::fundiv_barbaro2009a_amb
trait_baselga  <- ecodados::trait_baselga
comm_baselga   <- ecodados::comm_baselga
anuros_comm    <- ecodados::anuros_comm
traits         <- ecodados::traits
env            <- ecodados::env
# ecodados::wITV # funtion: wITV
```

## Aspectos te√≥ricos

At√© a d√©cada de 1990, a teoria ecol√≥gica investigava basicamente quais processos determinavam a abund√¢ncia e riqueza de esp√©cies no espa√ßo e tempo. As d√©cadas de 1980 e 1990 foram marcadas por intensos debates sobre as regras de montagem de comunidades e como intera√ß√µes e filtros ambientais determinavam a coexist√™ncia de esp√©cies [@strong_ecological_1984]. Por√©m, a d√©cada de 2000 foi marcada pelo uso mais expl√≠cito da caracter√≠sticas das esp√©cies como uma vari√°vel fundamental tanto para explicar como a distribui√ß√£o dos organismos seria afetada pelo ambiente, quanto para entender como tais esp√©cies afetariam o ecossistema [@diaz_vive_2001; @mcgill_rebuilding_2006]. O primeiro estudo que utilizou o termo *Diversidade Funcional* foi publicado por Williams [-@anderson1967], que comparou esp√©cies de na√∫plios filogen√©ticamente relacionadas e demonstrou que elas possuem alta plasticidade funcional que favorecem ampla varia√ß√£o de comportamentos e, desse modo, permitem que sejam esp√©cies generalistas em ambientes em contante mudan√ßa. A unidade b√°sica desses estudos, o atributo funcional (do ingl√™s "*functional trait*"), √© definido como uma propriedade mensur√°vel dos organismos (geralmente em n√≠vel individual) que represente caracter√≠sticas morfol√≥gicas, fisiol√≥gicas ou fenol√≥gicas que afetam a aptid√£o alterando aspectos do crescimento, reprodu√ß√£o e sobreviv√™ncia [@violle_let_2007]. Mais especificamente, o atributo funcional pode ser divido em atributo efeito (i.e., atributos do organismo que afetam condi√ß√µes ambientais ou propriedades do ecossistema) e resposta (i.e., atributos do organismo que variam em resposta a condi√ß√µes ambientais) [@violle_let_2007].

Dessa forma, as medidas de diversidade passaram a ser representadas n√£o somente por diferen√ßas no n√∫mero e na quantidade de esp√©cies, mas pelas diferen√ßas e/ou semelhan√ßas dos atributos funcionais das esp√©cies dentro e entre localidades. Assim, a varia√ß√£o no grau de express√£o de diferentes atributos funcionais entre diferentes popula√ß√µes, comunidades ou ecossistemas √© definida como *Diversidade Funcional* [*sensu* @garnier_plant_2015]. Por√©m, a diversidade funcional n√£o deve ser usada como medida √∫nica, uma vez que tais diferen√ßas entre os atributos funcionais pode ser medida a partir da abund√¢ncia relativa, riqueza e varia√ß√£o dos atributos funcionais. Desse modo, podemos dividir a diversidade funcional em tr√™s diferentes medidas: i) riqueza funcional, ii) diverg√™ncia funcional, e iii) regularidade funcional [@villeger_new_2008]. Existem dezenas de m√©tricas que calculam cada uma dessas *dimens√µes* da diversidadade funcional, mas se destacam aquelas baseadas em dendrograma [e.g., FD: @petchey_functional_2002] ou em medidas de dist√¢ncia [e.g., @villeger_new_2008]. Assim como a diversidade taxon√¥mica (Cap√≠tulo \@ref(cap12)), a diversidade funcional pode ser medida em componentes alfa e beta. A seguir, apresentamos diferentes maneiras de calcular a dist√¢ncia entre localidades tendo como base os atributos funcionais das esp√©cies e, al√©m disso, demonstramos como calcular algumas das m√©tricas de diversidade (alfa e beta) funcional mais usadas em Ecologia. A parte final deste cap√≠tulo apresenta dois exemplos de como podemos testar hip√≥teses ecol√≥gicas comparando a diversidade funcional alfa e beta.

## Definindo a dis(similaridade) entre esp√©cies

Definir o qu√£o diferente ou semelhante s√£o duas esp√©cies que ocorrem em uma determinada localidade √© a base para calcular a diversidade alfa e beta funcional. Para isso, √© fundamental ter em mente que os atributos funcionais podem ser de v√°rios tipos como, por exemplo, cont√≠nuos (e.g., tamanho corporal em cent√≠metro), categ√≥ricos (e.g., guilda: frug√≠voro, detrit√≠voro, etc.), ordinais (e.g., 1 para organismo at√© 5 cm, 2 para organismos entre 5 e 30 cm, e 3 para organismos maiores do que 30 cm), bin√°rios (e.g., presen√ßa ou aus√™ncia de espinho), entre outros [veja a Figura \@ref(fig:fig-statistical-thinking) no Cap√≠tulo \@ref(cap2)]. Por este motivo, a decis√£o do m√©todo de dist√¢ncia s√≥ ser√° poss√≠vel ap√≥s o reconhecimento dos tipos de atributos funcionais escolhidos. Em linhas gerais, para vari√°veis cont√≠nuas a dist√¢ncia euclideana √© a melhor op√ß√£o, enquanto para os outros tipos de vari√°veis ou para conjuntos de atributos com mais de um tipo de vari√°vel, a dist√¢ncia de Gower geralmente deve ser a melhor op√ß√£o  [@pavoine_challenge_2009].

**Exemplo pr√°tico**

**Exemplo1: vari√°veis cont√≠nuas**

Vamos utilizar um conjunto de dados com atributos cont√≠nuos (e.g., √°rea foliar espec√≠fica e massa foliar seca) de 34 esp√©cies de plantas em um gradiente de aridez [@frenette-dussault_functional_2012]. Diversas an√°lises funcionais podem ser afetadas por valores extremos ou pela diferen√ßa de unidade/escala entre as vari√°veis utilizadas. Por este motivo, √© importante padronizar a matriz de atributos com m√©dia 0 e desvio padr√£o 1. Esta padroniza√ß√£o √© necess√°ria tanto para fazer uma PCA como para PCoA (veja Cap√≠tulo \@ref(cap9)).

**Pergunta**

Quais s√£o as esp√©cies de plantas mais semelhantes? (Neste caso, sem predi√ß√£o, pois representa uma avalia√ß√£o explorat√≥ria com as caracter√≠sticas funcionais das esp√©cies).

**Vari√°veis**

- Dependentes: atributos funcionais (matriz de atributos cont√≠nuos por esp√©cie: `trait_fren_dat`)

**An√°lises**

Aqui realizamos os passos para uma ordena√ß√£o usando os atributos funcionais cont√≠nuos (Figura \@ref(fig:fig-func-pcoa-cont)).

```{r fig-func-pcoa-cont, fig.cap="Ordena√ß√£o usando os atributos funcionais cont√≠nuos."}
## PCoA dos atributos cont√≠nuos

# 1. Padroniza√ß√£o dos dados
trait_pad <- decostand(trait_fren_dat, "standardize")
euclid_dis <- vegdist(trait_pad, "euclidean")

# 2. PCoA
# Resultados s√£o id√™nticos aos resultados de uma PCA.
pcoa_traits_cont <- pcoa(euclid_dis, correction = "cailliez") 

# 3. Exportandos dados para gr√°fico
# Ao usar '[,1:2]' voc√™ ir√° selecionar os dois primeiros eixos.
eixos_cont <- as.data.frame(pcoa_traits_cont$vectors[, 1:2]) 

# 4. Gr√°fico de ordena√ß√£o 
plot_trait_cont <- ggplot(eixos_cont, aes(x = Axis.1, y = Axis.2)) + 
    geom_point(pch = 21, size = 4, color = "black", alpha = 0.7, fill = "red2") + 
    geom_text_repel(aes(Axis.1, Axis.2, label = rownames(eixos_cont))) +
    geom_hline(yintercept = 0, linetype = 2) + 
    geom_vline(xintercept = 0, linetype = 2) +
    labs(x = "PCO 1", y = "PCO 2", title = "Dados cont√≠nuos") + 
    tema_livro()
plot_trait_cont
```

**Exemplo 2: vari√°veis categ√≥ricas**

Ao contr√°rio dos dados cont√≠nuos, para dados categ√≥ricos n√£o √© poss√≠vel utilizar PCA. No pr√≥ximo exemplo, utilizamos atributos funcionais de besouros distribu√≠dos na Europa [@barbaro_linking_2009]. Esses dados s√£o categ√≥ricos e incluem atributos como per√≠odo de atividade (noturno, diurno, dioturno), tend√™ncia da popula√ß√£o na europa (est√°vel, aumentando, diminu√≠ndo) entre outros.

**Pergunta**

Quais s√£o as esp√©cies de besouros mais semelhantes? (Neste caso, sem predi√ß√£o, pois representa uma avalia√ß√£o explorat√≥ria com as caracter√≠sticas funcionais das esp√©cies).

**Vari√°veis**

- Dependentes: atributos funcionais (matriz de atributos categ√≥ricos por esp√©cie: `trait_dat`)

**An√°lises**

Aqui realizamos os passos para uma ordena√ß√£o usando os atributos funcionais categ√≥ricos (Figura \@ref(fig:fig-func-pcoa-cat)).

```{r fig-func-pcoa-cat, fig.cap="Ordena√ß√£o usando os atributos funcionais categ√≥ricos."}
## PCoA dos atributos categ√≥ricos

# 1. Selecionar somente os atributos categ√≥ricos
trait_cat <- trait_dat %>% 
    dplyr::select_if(is.character)

# 2. Calcular a dist√¢ncia de Gower
dist_categ <- gowdis(trait_cat)

# 3. PCoA da matriz de dist√¢ncia funcional (Gower)
pcoa_traits_cat <- pcoa(dist_categ, correction = "cailliez")

# 4. Exportar dados (escores) para ggplot
eixos_cat <- as.data.frame(pcoa_traits_cat$vectors[,1:2]) # Selecionar os dois primeiros eixos

# 5. Gr√°fico de ordena√ß√£o
plot_trait_cat <- ggplot(eixos_cat, aes(x = Axis.1, y = Axis.2)) + 
    geom_point(pch = 21, size = 4, alpha = 0.7, color = "black", fill = "cyan4") + 
    geom_text_repel(aes(Axis.1, Axis.2, label = rownames(eixos_cat))) +
    geom_hline(yintercept = 0, linetype = 2) + 
    geom_vline(xintercept = 0, linetype = 2) +
    labs(x = "PCO 1", y = "PCO 2", title = "Dados categ√≥ricos") + 
    tema_livro()
plot_trait_cat
```

**Exemplo 3: vari√°veis mistas**

Em casos mais complexos, a pesquisa inclui diversos atributos funcionais com naturezas diferentes, como atributos cont√≠nuos, categ√≥ricos, ordinais, circulares, entre outros. Desse modo, √© poss√≠vel utilizar medidas como Gower (`gowdis()`). Por√©m, existe uma alternativa mais apropriada que generalizou o coeficiente de Gower para tratar cada conjunto de vari√°veis de acordo com sua natureza [@pavoine_challenge_2009]. Vamos usar o mesmo conjunto de dados que foram considerados no exemplo anterior. Por√©m, ao inv√©s de utilizar somente as vari√°veis categ√≥ricas, usaremos todas elas. O primeiro passo √© identificar para o programa as classes apropriadas para cada tipo de vari√°vel e, al√©m disso, preparar os dados para a fun√ß√£o `dist.ktab()`.

**Pergunta**

Quais s√£o as esp√©cies de besouros mais semelhantes? (Neste caso, sem predi√ß√£o, pois representa uma avalia√ß√£o explorat√≥ria com as caracter√≠sticas funcionais das esp√©cies)

**Vari√°veis**

- Dependentes: atributos funcionais (matriz de atributos cont√≠nuos e categ√≥ricos por esp√©cie: `trait_dat`)

**An√°lises**

Aqui realizamos os passos para uma ordena√ß√£o usando os atributos funcionais de diversas naturezas (Figura \@ref(fig:fig-func-pcoa-mistos)).

```{r fig-func-pcoa-mistos, fig.cap="Ordena√ß√£o usando os atributos funcionais de dados mistos."}
## PCoA dos atributos mistos

## 1. Verifique a classe de todos os traits e veja se est√£o de acordo com sua expectativa
trait_dat %>% 
    dplyr::summarise_all(class) %>% 
    tidyr::gather(variable, class)

## 2. Neste exemplo, algumas vari√°veis que s√£o ordinais (regio e body) 
# foram reconhecidas como num√©ricas ou categ√≥ricas. 
trait_dat$regio <- as.ordered(trait_dat$regio)
trait_dat$body <- as.ordered(trait_dat$body)

## 3. Combinar cada conjunto de atributos de acordo com sua natureza em um 
# data.frame separado.
# 3.1. Categ√≥ricos.
trait_categ <- cbind.data.frame(
    trend = trait_dat$trend, 
    redlist = trait_dat$redlist, 
    biog = trait_dat$biog, 
    activ = trait_dat$activ,  
    diet = trait_dat$diet, 
    winter = trait_dat$winter,
    color = trait_dat$color, 
    breed = trait_dat$breed,
    wing = trait_dat$wing, 
    period = trait_dat$period)

# 3.2 Ordinais.
trait_ord <- cbind.data.frame(regio = trait_dat$regio, 
                              body = trait_dat$body)
rownames(trait_categ) <- rownames(trait_dat)
rownames(trait_ord) <- rownames(trait_dat)

# Agora, combinar os dois data.frames em uma lista chamada "ktab".
ktab_list <- ktab.list.df(list(trait_categ, trait_ord))

# Por fim, calcular a dist√¢ncia funcional entre as esp√©cies.
# Em "type", a letra "N" indica vari√°vel categ√≥rica (ou nominal), 
# enquanto a letra "O" indica vari√°vel ordinal.
dist_mist <- dist.ktab(ktab_list, type = c("N", "O"))

## Visualize os dados com uma PCoA
pcoa_traits_mist <- pcoa(dist_mist, correction = "cailliez")
eixos_mist <- as.data.frame(pcoa_traits_mist$vectors[,1:2]) 

plot_trait_mist <- ggplot(eixos_mist, aes(x = Axis.1, y = Axis.2)) + 
    geom_point(pch = 21, size = 4, alpha = 0.7, 
               color = "black", fill = "darkorange") + 
    geom_text_repel(aes(Axis.1, Axis.2, label = rownames(eixos_mist)))+
    geom_hline(yintercept = 0, linetype = 2) + 
    geom_vline(xintercept = 0, linetype = 2) + 
    labs(x = "PCO 1", y = "PCO 2", title = "Dados mistos") + 
    tema_livro()
plot_trait_mist
```

Podemos combinar os dois gr√°ficos (baseado em vari√°veis categ√≥ricas e em vari√°veis mistas) para comparar as duas medidas de dist√¢ncia, uma somente com dados categ√≥ricos (`gower()`) e uma com dados categ√≥ricos e ordinais (`dist.ktab()`) (Figura \@ref(fig:fig-func-pcoa-cat-mistos)).

```{r fig-func-pcoa-cat-mistos, fig.cap="Ordena√ß√µes usando os atributos funcionais categ√≥ricos e de dados mistos."}
## Gr√°ficos
grid.arrange(plot_trait_cat, plot_trait_mist, ncol = 2)
```

## M√©tricas de diversidade funcional (alfa)

### Riqueza funcional

A riqueza funcional mede a quantidade de espa√ßo funcional preenchido pela esp√©cies de uma comunidade [@mason_functional_2013]. A estimativa desse espa√ßo pode ser calculada usando dengrogramas [@petchey_functional_2002] ou atrav√©s do m√©todo **Convex Hull** [@cornwell_trait-based_2006] que d√£o origem, respectivamente, √†s duas m√©tricas mais usadas: i) Diversidade Funcional (FD) e ii) Riqueza Funcional (FRic). Os √≠ndices de riqueza funcional geralmente s√£o usados como indicadores do espa√ßo de nicho que √© potencialmente usado ou n√£o [@schleuter_users_2010].

**Exemplo pr√°tico**

**Explica√ß√£o dos dados**

Os dados utilizados neste exemplo s√£o os mesmos do exemplo com dados mistos, i.e., categ√≥ricos e cont√≠nuos (objeto `dist_mist`). 

**Pergunta**

Qual a rela√ß√£o entre riqueza de esp√©cies e diversidade funcional? Todos os √≠ndices s√£o correlacionados com a riqueza?

**Vari√°veis**

- Dependentes: atributos funcionais e composi√ß√£o de esp√©cies para c√°lculo da diversidade funcional e riqueza em cada parcela

**An√°lises**

```{r message=FALSE, warning=FALSE}
## Estrutura dos dados
# matriz de dist√¢ncia: dist√¢ncia entre as seis primeiras esp√©cies
as.matrix(dist_mist)[1:6, 1:6]

# composi√ß√£o de esp√©cies: seis primeiras esp√©cies nas seis primeiras localidades
head(comun_dat)[1:6, 1:6]

## Antes de calcular as m√©tricas de diversidade funcional, vamos calcular 
# a riqueza de esp√©cies com intuito de compara√ß√£o entre m√©tricas.
richness <- dbFD(dist_mist, comun_dat)$nbsp 
head(richness)

## √â preciso definir uma dist√¢ncia apropriada (veja descri√ß√£o anterior) para os c√°lculos abaixo

# O √≠ndice "Functional Richness" s√≥ funciona para comunidades com 3 ou mais esp√©cies.
# Caso voc√™ tenha comunidades com 1 ou 2 esp√©cies, o valor ser√° NA.
fric <- dbFD(dist_mist, comun_dat)$FRic
head(fric)

## Functional Diversity 
# Passo 1: an√°lise de agrupamento para criar o dendrograma. 
dend <- hclust(dist_mist, "average")

# Passo 2: transformar o dengrograma em um arquivo da classe phylo.
tree_dend <- as.phylo(dend)

# Passo 3: calcular o valor da diversidade funcional. 
FD <- pd(comun_dat, tree_dend)$PD
head(FD)
```

Os valores da Riqueza Funcional (FRic) variam entre 0 e +‚àû, sendo o valor m√°ximo limitado pelo n√∫mero de esp√©cies em uma comunidade. Desse modo, os valores de FRic basicamente s√£o uma representa√ß√£o da riqueza de esp√©cies (e seus atributos funcionais) de uma comunidade [@villeger_new_2008]. Ou seja, quanto maior o n√∫mero de esp√©cies, maior ser√° o espa√ßo funcional ocupado por essas esp√©cies. No pacote ‚ÄòdbFD‚Äô o valor de FRic √© dividido pelo valor de FRic global (ou seja, pela riqueza funcional de todas as comunidades combinadas). Como resultado, ele limita a varia√ß√£o entre 0 e 1, onde valores pr√≥ximos a 1 indicam que uma determinada comunidade tem riqueza funcional t√£o alta quanto a riqueza funcional de todas as comunidades juntas. Neste exemplo, as localidades 21 e 89 possuem, respectivamente, a maior e menor Riqueza Funcional. 

### Diverg√™ncia funcional

A diverg√™ncia funcional √© uma medida que descreve a irregularidade na distribui√ß√£o dos valores dos atributos no volume do espa√ßo funcional ocupado por todas as esp√©cies de uma certa comunidade [@garnier_plant_2015]. Para obter os valores de diverg√™ncia, o espa√ßo funcional √© calculado atrav√©s do m√©todo *Convex Hull* (Functional Divergence) ou do espa√ßo multidimensional calculado com um PCoA (Functional Dispersion). Nos dois casos, o valor da m√©trica representa a dist√¢ncia m√©dia das esp√©cies para o centro de gravidade ou centroide do espa√ßo funcional, ponderado pela abund√¢ncia relativa das esp√©cies [@villeger_new_2008; @laliberte_distance-based_2010]. Desse modo, a diverg√™ncia funcional √© uma medida que calcula o grau de diferencia√ß√£o em que a distribui√ß√£o da abund√¢ncia maximiza a diverg√™ncia entre entre os atributos funcionais [@mason_functional_2013]. Em geral, estudos que usam esses √≠ndices buscam entender o grau de diferencia√ß√£o de recursos de esp√©cies que coexistem em uma comunidade [@garnier_plant_2015].

```{r message=FALSE, warning=FALSE}

## Aqui, iremos utilizar a matriz de dist√¢ncia obtida dos dados 
# trait_dat (vari√°veis categ√≥ricas e ordinais) e nomeada como dist_mist.

## O √≠ndice "Functional Divergence" s√≥ √© calculado para comunidades com 3 ou mais esp√©cies
# Caso voc√™ tenha comunidades com 1 ou 2 esp√©cies, a an√°lise ir√° retornar o valor "NA"
fdiv <- dbFD(dist_mist, comun_dat)$FDiv
head(fdiv)

# O √≠ndice "Functional Dispersion" atribui valor 0 para comunidades com 1 ou 2 esp√©cies
fdis <- dbFD(dist_mist, comun_dat)$FDis
head(fdis)
```

Os valores da Diverg√™ncia Funcional (FDiv) variam entre 0 e 1. Valores que se aproximam de zero indicam que a esp√©cie mais abundante est√° muito pr√≥xima do valor do atributo m√©dio da comunidade, ao passo que valores pr√≥ximos a 1 indicam que a esp√©cie mais abundante est√° muito distante (ou seja, √© muito diferente) do valor m√©dio da comunidade [@villeger_new_2008]. Neste exemplo, as localidades 159 e 6 possuem, respectivamente, a maior e menor Diverg√™ncia Funcional.

### Regularidade funcional

A regularidade funcional (do ingl√™s *Functional Evenness*) mede o qu√£o regular √© a distribui√ß√£o da abund√¢ncia dos valores dos atributos funcionais no espa√ßo funcional. Diferente dos outros m√©todos, a vers√£o multidimensional deste √≠ndice utiliza um m√©todo chamado *Minimum Spanning Tree* (MST) para conectar todas esp√©cies no espa√ßo funcional. A dist√¢ncia par apar das esp√©cies na MST √© ponderada pela abund√¢ncia relativa das esp√©cies e, desse modo, o valor final da regularidade funcional (FEve) vai variar de 0 (m√°xima irregularidade da distribui√ß√£o da abund√¢ncia ou dist√¢ncia funcional das esp√©cies) a 1 (m√°xima regularidade).

```{r message=FALSE, warning=FALSE}

## Aqui, iremos utilizar a matriz de dist√¢ncia obtida dos dados trait_dat (vari√°veis categ√≥ricas e ordinais) e nomeada como dist_mist

## O √≠ndice "Functional evenness" s√≥ funciona para comunidades com 3 ou mais esp√©cies
# Caso voc√™ tenha comunidades com 1 ou 2 esp√©cies, a an√°lise ir√° retornar o valor NA
feve <- dbFD(dist_mist, comun_dat)$FEve
head(feve)
```

Os valores da Regularidade Funcional (FEve) variam entre 0 e 1 (m√°xima regularidade ou regularidade perfeita). A diminui√ß√£o do valor de FEve em dire√ß√£o a zero indica que uma redu√ß√£o da regularidade da distribui√ß√£o da abund√¢ncia ou dist√¢ncia funcional entre as esp√©cies [@villeger_new_2008]. Neste exemplo, as localidades 197 e 175 possuem, respectivamente, a maior e menor Regularidade Funcional. 

### Correla√ß√£o entre as m√©tricas de diversidade funcional (alfa)

Aqui vamos fazer a correla√ß√£o entre as m√©tricas de diversidade funcional (alfa) (Figura \@ref(fig:fig-func-alfa-cor)).

```{r fig-func-alfa-cor, fig.cap="Correla√ß√£o entre as m√©tricas de diversidade funcional (alfa)."}
## Gr√°ficos
## Voc√™ pode criar uma tabela com os resultados de todas as m√©tricas
metricas <- data.frame(richness = richness,
                       FD_gp = FD,
                       fric = fric,
                       fdiv = fdiv,
                       fdis = fdis,
                       feve = feve)
head(metricas)

## Gr√°fico para comparar o comportamento das m√©tricas
ggpairs(metricas) + tema_livro()
```

Os resultados indicam que a Diversidade Funcional de Petchey & Gaston [-@petchey_functional_2002] (*r* = 0.985) e a riqueza funcional (*r* = 0.813) s√£o altamente correlacionadas com a riqueza de esp√©cies. Por√©m, a diverg√™ncia funcional, regularidade funcional e dispers√£o funcional n√£o est√£o correlacionadas com a riqueza de esp√©cies.

A figura obtida com o c√≥digo `ggpairs(metricas)` representa uma matriz de correla√ß√£o comparando cada par de vari√°veis (neste caso, os √≠ndices de diversidade). No lado esquerdo da figura (abaixo da diagonal) s√£o representados *scatter plots* (veja Cap√≠tulo \@ref(cap6)), a no lado direito (acima da diagonal) pode-se encontrar os valores das correla√ß√µes (*r*) entre os pares comparados. No caso das correla√ß√µes, quanto mais pr√≥ximo de +1 ou -1, mais forte √© a rela√ß√£o entre essas vari√°veis do par comparado. O gr√°fico de linhas na diagonal demonstra a densidade de cada vari√°veis individualmente (veja Cap√≠tulo \@ref(cap7)).  

## M√©tricas de diversidade funcional (beta)

Assim como na diversidade beta taxon√¥mica Cap√≠tulo \@ref(cap12) e na diversidade beta filogen√©tica \@ref(cap13), a diversidade beta funcional √© uma medida que compara a composi√ß√£o (e a varia√ß√£o na composi√ß√£o) de atributos funcionais das esp√©cies entre duas ou mais localidades. Por√©m, assim como na medida tradicional taxon√¥mica (como Jaccard ou S√∏rensen), diferen√ßas na diversidade beta podem ser geradas pela **mudan√ßa na identidade das esp√©cies (ou do atributo)** ou na **riqueza de esp√©cies (ou de atributos)** entre duas localidades (Figura \@ref(fig:fig-func)). Desse modo, √© poss√≠vel particionar a diversidade beta funcional em aninhamento (do ingl√™s *nestedness*) e substitui√ß√£o (do ingl√™s *turnover*) (veja Cap√≠tulo \@ref(cap12)). Al√©m disso, os c√°lculos da diversidade beta funcional podem ser realizados par a par (`functional.beta.pair()`) ou para a compara√ß√µes de m√∫ltiplas localidades (`funcional.beta.multi()`).

```{r fig-func, fig.cap="Parti√ß√£o da diversidade beta taxon√¥mica (A) e funcional (B). Os tr√™s cen√°rios apresentados tanto para a diversidade beta taxon√¥mica como funcional representam, respectivamente, diversidade beta explicada somente por substitui√ß√£o, aninhamento e uma combina√ß√£o dos dois."}
knitr::include_graphics(path = "img/cap14_fig01.svg")
```

**Exemplo 4**

Os dados no exemplo a seguir utilizam somente a informa√ß√£o de presen√ßa (1) ou aus√™ncia (0) das esp√©cies nas localidades. Neste exemplo hipot√©tico criado por Baselga et al. [-@baselga_2021], foram amostradas 11 esp√©cies (sp1-sp11) em quatro localidades (A-D). Para cada esp√©cie, criamos dois atributos cont√≠nuos hipot√©ticos (trait1 e trait2).

**Pergunta**

Qual a contribui√ß√£o relativa do aninhamento e substitui√ß√£o para a diversidade beta?

**Vari√°veis**

- Dependentes: atributos funcionais e composi√ß√£o de esp√©cies.

**An√°lises**

Vamos fazer a an√°lise da parti√ß√£o da diversidade beta funcional e comparar seus componentes (Figura \@ref(fig:fig-func-beta-comp)).

```{r fig-func-beta-comp, fig.cap="Rela√ß√£o entre os componentes parti√ß√£o da diversidade funcional (beta)."}
## Parti√ß√£o da Diversidade beta (M√©todo Baselga)
fun_beta_multi <- functional.beta.multi(x = comm_baselga,
                                        trait = trait_baselga, index = "jaccard") 
fun_beta_multi

## Parti√ß√£o da Diversidade beta (M√©todo Baselga)
fun_beta <- functional.beta.pair(x = comm_baselga, 
                                 trait = trait_baselga, index = "jaccard") 

# Os c√≥digos abaixo permitem extrair a matriz de dist√¢ncia (par a par) com a parti√ß√£o em substitui√ß√£o e nestedness
fun_turnover <- fun_beta$funct.beta.jne
fun_nestedness <- fun_beta$funct.beta.jtu
fun_jaccard <- fun_beta$funct.beta.jac

## Gr√°fico de compara√ß√£o do substitui√ß√£o e aninhamento
dat_betapart <- data.frame(turnover = as.numeric(fun_turnover), 
                           nested = as.numeric(fun_nestedness))

## Gr√°fico
plot_betapart <- ggplot(dat_betapart, aes(x = turnover, y = nested)) + 
    geom_point(pch = 21, size = 4, alpha = 0.7, color = "black", fill = "#525252") + 
    labs(x = "Beta Diveristy (Substitui√ß√£o)", y = "Beta Diveristy (Aninhamento)") +
    tema_livro()
plot_betapart
```

Os resultados da an√°lise de parti√ß√£o (`fun_beta_multi()`) indicam que 82,5% (0,710/0,861) da varia√ß√£o na diversidade beta √© explicada pelo componente substitui√ß√£o, enquanto 17,5% (0,151/0,861) pelo componente aninhamento. As matrizes de dist√¢ncia obtidas na an√°lise par a par pode ser utilizadas para testar, *a posteriori*, a rela√ß√£o entre gradientes ambientais e diversidade beta funcional (mais detalhes abaixo).

## Composi√ß√£o Funcional (*Community Wegihed Means* - CWM)

As medidas de diversidade beta funcional apresentadas acima fornecem matrizes de dist√¢ncia com compara√ß√µes par a par de localidades em termos da composi√ß√£o de atributos funcionais. Por√©m, muitas vezes o pesquisador quer medir o "atributo m√©dio" da comunidade para investigar, por exemplo, se um determinado gradiente ambiental afeta a express√£o (em termos de abund√¢ncia ou densidade) de dado atributo funcional. Em geral, a medida utilizada √© o CWM (do ingl√™s *Community Wegihed Means*). O CWM √© basicamente uma m√©dia ponderada de um determinado atributo (coluna *m* na matriz T) em rela√ß√£o a abund√¢ncia de todas as esp√©cies que ocorrem na localidade (linha  *n* na matrix X). O c√°lculo no R √© feito pela fun√ß√£o `functcomp()` e usa somente as duas matrizes (T e X). Os leitores que pretendem usar essas m√©tricas devem ler cr√≠ticas em Peres-Neto et al. [-@peres-neto_linking_2017].

```{r}
## Matriz T
head(trait_baselga)

## Matriz X
head(comm_baselga)

## Fun√ß√£o functcomp calcula o cwm para combinar as matrizes T e X
cwm_ex <- functcomp(trait_baselga, as.matrix(comm_baselga))
cwm_ex
```

A matriz resultante `cwm_es` √© formada pelas localidades (linhas) e os atributos "m√©dios" (colunas) nestas localidades. Essa matriz pode ser utilizada em diversas an√°lises como dbRDA, RDA ou RDA parcial (veja Cap√≠tulo \@ref(cap9)). Na sequ√™ncia, vamos utilizar testes de hip√≥teses para entender como podemos calcular as diversidades funcional alfa e beta com outros testes estat√≠sticos apresentados neste livro.

**Exemplo 5**

Neste exemplo, usaremos novamente os dados de 34 esp√©cies de plantas [@frenette-dussault_functional_2012], mas agora vamos testar o efeito de um gradiente de aridez sobre a diversidade alfa funcional.

**Pergunta**

O gradiente de aridez influencia a diverg√™ncia e regularidade funcional de plantas?

**Predi√ß√µes**

- *Predi√ß√£o 1*: locais mais √°ridos possuem menor diverg√™ncia funcional de plantas (m√©trica escolhida: FDis)

- *Predi√ß√£o 2*: locais mais √∫midos possuem menor regularidade funcional de plantas (m√©trica escolhida: FEve)

**Vari√°veis**

- Preditora: gradiente de aridez (matriz de vari√°veis ambientais por localidade: `ambie_fren_dat`)

- Dependentes: composi√ß√£o de esp√©cies (matriz de esp√©cies por localidade: `comun_fren_dat`) e atributos funcionais (matriz de atributos cont√≠nuos por esp√©cie: `trait_fren_dat`)

**An√°lises**

Vamos calcular primeiramente as matrizes de Diverg√™ncia funcional (FDis) e Regularidade Funcional (FEve), depois ajustar modelos lineares, fazer o diagn√≥stico dos mesmo e por fim plotar os resultados (Figura \@ref(fig:fig-func-comp-model)).

```{r fig-func-comp-model, fig.cap="Rela√ß√£o entre a composi√ß√£o funcional e o gradiente de aridez, ajustado por modelos lineares com seus diagn√≥sticos."}
## Passo 1: calcular a dist√¢ncia funcional
trait_pad <- decostand(trait_fren_dat, "standardize")
euclid_dis <- vegdist(trait_pad, "euclidean")

## Passo 2: calcular a Diverg√™ncia funcional (FDis) e Regularidade Funcional (FEve)
fdis <- dbFD(euclid_dis, comun_fren_dat)$FDis # Fdis=0 em locais com somente uma esp√©cie
feve <- dbFD(euclid_dis, comun_fren_dat)$FEve

## Passo 3: Utilizar um modelo linear para comparar o efeito da aridez sobre FDis (predi√ß√£o 1) e FEve (predi√ß√£o 2)
# Combinar dados em um data.frame.
lm_dat <- data.frame(aridez = ambie_fren_dat$Aridity, fdis = fdis, feve = feve)

# Modelo 1
mod1 <- lm(fdis ~ aridez, data = lm_dat)

# Conclus√£o: a aridez n√£o tem efeito sobre a diverg√™ncia funcional
anova(mod1) 

# Modelo 2
mod2 <- lm(feve ~ aridez, data = lm_dat)

# Conclus√£o: a aridez n√£o tem efeito sobre a regularidade funcional
anova(mod2) 

## Passo 4: gr√°fico para visualizar os dois resultados  
# Gr√°fico modelo 1.
plot_pred1 <- ggplot(lm_dat, aes(x = aridez, y = fdis)) + 
    geom_point(pch = 21, size = 4, alpha = 0.7, color = "black", fill="darkorange") +
    labs(x = "Aridez", y = "Diverg√™ncia Funcional (FDis)") +
    tema_livro()

# Gr√°fico modelo 2.
plot_pred2 <- ggplot(lm_dat, aes(x = aridez, y = feve)) + 
    geom_point(pch=21, size=4, alpha = 0.7, color = "black", fill="cyan4") + 
    labs(x = "Aridez", y = "Regularidade Funcional (FEve)") + 
    tema_livro()

## Visualiza√ß√£o dos dois gr√°ficos em um √∫nica janela
grid.arrange(plot_pred1, plot_pred2, ncol = 2)
```

Os resultados dos modelos `anova(mod1)` e `anova(mod2)` indicam que o gradiente de aridez n√£o afeta a dispers√£o e regularidade funcional. Os detalhes para conferir os pressupostos das an√°lise foram descritos no Cap√≠tulo \@ref(cap7).

**Exemplo 6**

Agora, vamos utilizar novamente os dados de 34 esp√©cies de plantas [@frenette-dussault_functional_2012], mas agora para testar o efeito do pastejo sobre a diversidade beta funcional.

**Pergunta**

O pastejo determina a ocorr√™ncia de esp√©cies de plantas com diferentes atributos funcionais?

**Predi√ß√£o** 

- A composi√ß√£o funcional de plantas √© diferente entre √°reas com e sem pastejo?

**Vari√°veis**

- Preditora: √°reas com e sem pastejo de gado (vari√°vel categ√≥rica com dois n√≠veis: *grazed* e *ungrazed*: `ambie_fren_dat`)

- Dependentes: composi√ß√£o de esp√©cies (matriz de esp√©cies por localidade: `comun_fren_dat`) e atributos funcionais (matriz de atributos cont√≠nuos por esp√©cie: `trait_fren_dat`)

**An√°lises**

Nesse exemplo vamos calcular a CWM e depois usar uma PERMANOVA (\@ref(cap9)) para comparar o efeito da √°reas com e sem pastejo sobre a diversidade funcional (Figura \@ref(fig:fig-func-cwm-model)).

```{r fig-func-cwm-model, fig.cap="Rela√ß√£o do pastejo sobre a composi√ß√£o funcional."}
## Passo 1: CWM
cwm_fren <- functcomp(trait_pad, as.matrix(comun_fren_dat))
head(cwm_fren)

## Passo 2: calcular a dist√¢ncia funcional
cwm_dis <- vegdist(cwm_fren, "euclidean")

## Passo 3: testar se a composi√ß√£o funcional varia entre as √°reas com uma PERMANOVA
perman_fren <- adonis(cwm_fren ~ Grazing, data = ambie_fren_dat)
perman_fren

## Passo 4: comparar a varia√ß√£o dentro de cada grupo com Betadisper 
betad_fren <- betadisper(cwm_dis, ambie_fren_dat$Grazing)
permutest(betad_fren)

## Passo 5: PCoA

cwm_pcoa <- pcoa(D = cwm_dis, correction = "cailliez")
pcoa_eixos <- cwm_pcoa$vectors[, 1:2]
pcoa_dat <- data.frame(pastagem = ambie_fren_dat$Grazing, pcoa_eixos)

## Passo 6: definir os grupos ("HULL") para serem categorizados no gr√°fico 

grp.Grazed <- pcoa_dat[pcoa_dat$pastagem == "Grazed", ][chull(pcoa_dat[pcoa_dat$pastagem == "Grazed", c("Axis.1", "Axis.2")]), ]
grp.Ungrazed <- pcoa_dat[pcoa_dat$pastagem == "Ungrazed", ][chull(pcoa_dat[pcoa_dat$pastagem == "Ungrazed", c("Axis.1", "Axis.2")]), ]
hull_cwm <- rbind(grp.Grazed, grp.Ungrazed) 

## Passo 7: Gr√°fico biplot

100 * (cwm_pcoa$values[, 1]/cwm_pcoa$trace)[1] # % de explica√ß√£o do eixo 1
100 * (cwm_pcoa$values[, 1]/cwm_pcoa$trace)[2] # % de explica√ß√£o do eixo 2

ggplot(pcoa_dat, aes(x = Axis.1, y = Axis.2, color = pastagem, shape = pastagem)) + 
  geom_point(size = 4, alpha = 0.7) + 
  geom_polygon(data = hull_cwm, aes(fill = pastagem, group = pastagem), alpha = 0.3) + 
  scale_color_manual(values = c("darkorange", "cyan4")) +
  scale_fill_manual(values = c("darkorange", "cyan4")) +
  labs(x = "PCO 1 (53.6%)", y = "PCO 2 (24.6%)") + 
  tema_livro()


```

Neste exemplo, os resultados `perman_fren` demonstram que a composi√ß√£o funcional de plantas n√£o √© afetada pelo pastejo (P \> 0,05) e que a dispers√£o da composi√ß√£o [uma medida potencial de diversidade beta: @anderson_multivariate_2006] de esp√©cies tamb√©m n√£o muda entre √°reas com ou sem pastejo (`permutest(betad_fren)`). A fun√ß√£o `betadisper()` deve ser sempre utilizada em conjunto com a PERMANOVA (`adonis()`) para poder interpretar quais as fontes de varia√ß√£o na composi√ß√£o de esp√©cies. Sendo assim, esta an√°lise representa um m√©todo fundamental para comparar se o potencial efeito (quando houver) √© fruto de diferen√ßa na composi√ß√£o de esp√©cies (i.e., diferen√ßa na posi√ß√£o dos centr√≥ides entre dois ou mais grupos) ou na varia√ß√£o da composi√ß√£o de esp√©cies entre os grupos (i.e., diferen√ßa na dispers√£o dos dados em rela√ß√£o aos centr√≥ides, ver mais no Cap√≠tulo \@ref(cap9)). Esta √∫ltima informa√ß√£o, a dispers√£o, √© geralmente interpretada como uma analogia a homogeneidade de vari√¢ncias de uma ANOVA (i.e., Teste de Levene). A hip√≥tese nula do `betadisper()` √© que a dispers√£o dos grupos √© homog√™nea (ou seja, o valor de probabilidade nos casos que existem dispers√µes homog√™neas ser√° maior do que 0,05). Por√©m, se esse valor de p for menor do que 0,05, voc√™ deve rejeitar a hip√≥tese nula e concluir que as dispers√µes s√£o heterog√™neas. 

Os gr√°ficos de PCoA s√£o uma ferramenta poderosa para interpretar os resultados da PERMANOVA + Betadisper. Quanto mais diferente a composi√ß√£o de esp√©cies entre dois ou mais grupos, mais distante devem ser os centroides desses grupos. Al√©m disso, se as √°reas dos pol√≠gonos que conectam todas as r√©plicas de cada grupo forem diferentes em tamanho (hip√≥tese que ser√° testada com o Betadisper), √© poss√≠vel tamb√©m visualizar esta diferen√ßa. Em conclus√£o, para testar se diferen√ßas de composi√ß√£o funcional existem entre dois ou mais grupos, ser√° fundamental: i) comparar a varia√ß√£o da posi√ß√£o dos centr√≥ides (fun√ß√£o `adonis()`) e ii) a varia√ß√£o da dispers√£o da composi√ß√£o funcional entre os grupos (fun√ß√£o `betadisper()`).

##  Varia√ß√£o Intraspec√≠fica

Os m√©todos discutidos anteriormente utilizam valores m√©dios dos atributos das esp√©cies para descrever a estrutura funcional da comunidade e interpretar as rela√ß√µes entre determinadas vari√°veis preditoras (como clima, por exemplo) com a diverisdade funcional. Por√©m, ao utilizar atributos m√©dios estamos desconsiderando que a varia√ß√£o deste atributo dentro da esp√©cie seja determinante para a resposta da esp√©cie ao ambiente ou seu efeito sobre o ecossistema [@bolnick_why_2011 ; @violle_return_2012]. Os estudos que usam dados m√©dios para testar hip√≥teses em ecologia funcional argumentam que a varia√ß√£o dentro da esp√©cie √© menor do que a varia√ß√£o entre esp√©cies e, desse modo, o ru√≠do causado ao desconsiderar a vari√¢ncia do atributo dentro da esp√©cies √© desprez√≠vel [@siefert_global_2015]. Por√©m, diversos estudos t√™m mostrado que esse argumento √© fr√°gil e que a inclus√£o da varia√ß√£o intraespec√≠fica melhora nossa capacidade preditiva em ecologia funcional [@violle_return_2012; @siefert_global_2015]. Um abordagem geralmente utilizada √© a decomposi√ß√£o da vari√¢ncia do atributo em diferentes n√≠veis de organiza√ß√£o: i) varia√ß√£o dentro da popula√ß√£o da mesma esp√©cie em uma mesma unidade amostral, ii) varia√ß√£o dentro das popula√ß√µes (independente da esp√©cie) de uma comunidade em uma mesma unidade amostral, e iii) varia√ß√£o entre popula√ß√µes. Conhecida como estat√≠stica T, esta abordagem permite entender as fontes (intra ou interespec√≠fica) de varia√ß√£o no atributos em diferentes escalas [@violle_return_2012]. Outro m√©todo que quantifica a vari√¢ncia explicada pela variabilidade intraespec√≠fica, interespec√≠fica e a covari√¢ncia entre elas foi proposto por Leps et al. [-@leps_community_2011]. Este m√©todo permite calcular a contribui√ß√£o da varia√ß√£o intraespec√≠fica dentro e entre comunidades. Agora, vamos entender a contribui√ß√£o da varia√ß√£o de um atributo dentro da esp√©cie comparada √† varia√ß√£o entre esp√©cies.

**Exemplo 7**

Vamos utilizar os dados de 11 esp√©cies de anuros associados com 26 po√ßas no Parque Nacional Lagoa do Peixe [@dalmolin_turnover_2020]. Atributos morfol√≥gicos foram coletados em todos os indiv√≠duos coletados em cada po√ßa. Desse modo, √© poss√≠vel comparar a varia√ß√£o morfol√≥gica entre indiv√≠duos da mesma esp√©cie e entre esp√©cies diferentes. Al√©m disso, √© poss√≠vel quantificar a contribui√ß√£o da varia√ß√£o dentro e entre diferentes po√ßas. No exemplo abaixo, criamos cinco atributos com nomes diferentes daqueles usados no artigo de Dalmolin et al. [-@dalmolin_turnover_2020]. Em cada po√ßa, os autores coletaram os seguintes dados das po√ßas: i) profundidade, ii) area, iii) dist√¢ncia entre po√ßas, e iv) dist√¢ncia da po√ßa para a floresta mais pr√≥xima.

**Pergunta 1**

Qual a contribui√ß√£o da varia√ß√£o intraespec√≠fica para a varia√ß√£o total dos atributos morfol√≥gicos de anuros?

**Predi√ß√£o** 

- A alta plasticidade fenot√≠pica de anuros indica alta contribui√ß√£o da varia√ß√£o intraespec√≠fica comparada a interespec√≠fica

**Vari√°veis**

- Preditora: esp√©cies (categ√≥rica)
- Dependente: varia√ß√£o dos atributos morfol√≥gicos

**An√°lises**

Aqui vamos realizar o passo a passo das an√°lises para comparar a contribui√ß√£o da varia√ß√£o intraespec√≠fica para a varia√ß√£o total dos atributos morfol√≥gicos.

```{r}
## Dados necess√°rios
# Matriz de traits.
head(traits)

## Parti√ß√£o da varia√ß√£o intra e interespec√≠fica
## Passo 1: Tamanho corporal
mod_body_size <- aov(body_size~Species, data = traits)
summary(mod_body_size)

# Contribui√ß√£o da varia√ß√£o intra-espec√≠fica para o tamanho corporal.
itv_BS <- 100 * (73.35/(95.92 + 73.35))
itv_BS

## Passo 2: Biomassa
mod_biomass <- aov(biomass~Species, data = traits)
summary(mod_biomass)

# Contribui√ß√£o da varia√ß√£o intra-espec√≠fica para a biomassa.
itv_biomass <- 100 * (96.22/(118.17 + 96.22))
itv_biomass

## Passo 3: Tamanho do olho
mod_eye_size <- aov(eye_size ~ Species, data = traits)
summary(mod_eye_size)

# Contribui√ß√£o da varia√ß√£o intra-espec√≠fica para o tamanho do olho.
itv_eye_size <- 100 * (78.39/(203.09 + 78.39))
itv_eye_size

## Passo 4: Achatamento dorso-ventral
mod_flatness <- aov(flatness~Species, data = traits)
summary(mod_flatness)

# Contribui√ß√£o da varia√ß√£o intra-espec√≠fica para o achatamento dorso-ventral.
itv_flatness <- 100 * (22.13/(104.48 + 22.13))
itv_flatness

## Passo 5: Combinar os valores de cada trait em um vetor
valores <- c(itv_BS, itv_biomass, itv_eye_size, itv_flatness)

# Passo 6: Combinar valores e traits em um data.frame.
itv_results <- data.frame(trait = c("body_size", "biomass", "eye_size", "flatness"),
                          itv_explic = valores)

## Tabela com resultados da explica√ß√£o atribuida para a varia√ß√£o intraespec√≠fica
itv_results %>%
    mutate("explained intraspecific variance" = round(itv_explic, 2)) %>% 
    dplyr::select(trait, "explained intraspecific variance")
```

**Pergunta 2**

Qual a contribui√ß√£o da varia√ß√£o entre po√ßas para a varia√ß√£o total dos atributos morfol√≥gicos de anuros?

**Predi√ß√£o**

- A varia√ß√£o morfol√≥gica de anuros √© afetada por mudan√ßas dentro das esp√©cies e entre diferentes esp√©cies de po√ßas distintas

**Vari√°veis**

- Preditoras: po√ßas e esp√©cies (ambas categ√≥ricas)
- Dependente: varia√ß√£o dos atributos morfol√≥gicos

**An√°lises**

Aqui vamos realizar o teste para comparar a contribui√ß√£o da varia√ß√£o entre po√ßas para a varia√ß√£o total dos atributos morfol√≥gicos (Figura \@ref(fig:fig-func-intra)).

```{r fig-func-intra, fig.cap="Gr√°fico de barras mostrando a contribui√ß√£o da varia√ß√£o entre po√ßas para a varia√ß√£o total dos atributos morfol√≥gicos."}
## Dados necess√°rios
# Matriz de traits sem nomes de esp√©cies ou localidades
trait_m <- traits[, c("body_size", "biomass", "eye_size", "leg_size", "flatness")]
head(trait_m)
trait_decomp <- decompCTRE(traits = trait_m, sp = traits$Species, 
                           ind.plot = traits$pond, print = FALSE)
barplot.decompCTRE(trait_decomp)
```

**Pergunta 3**

Caracter√≠sticas ambientais das po√ßas afetam a varia√ß√£o intraespec√≠fica?

**Predi√ß√£o** 

- A profunidade e √°rea da po√ßa aumentam a contribui√ß√£o da varia√ß√£o intraespec√≠fica em rela√ß√£o a varia√ß√£o interespec√≠fica.

**Vari√°veis**

- Preditora: caracter√≠sticas das po√ßas
- Dependentes: varia√ß√£o dos atributos morfol√≥gicos e contribui√ß√£o da varia√ß√£o intraespec√≠fica

**An√°lises**

Para calcular a contribui√ß√£o relativa da varia√ß√£o intraespec√≠fica em rela√ß√£o √† varia√ß√£o interespec√≠fica dentro de uma comunidade, por exemplo, Siefert et al. [-@siefert_global_2015] sugeriram uma m√©trica chamada de wITV (*within-community Intraspecific Trait Variation*). A wITV representa a raz√£o da varia√ß√£o intraespec√≠fica em rela√ß√£o a varia√ß√£o total dentro de uma comunidade (e.g., parcela, po√ßa) que inclui: i) a abund√¢ncia relativa de cada esp√©cie *j* ocorrendo na comunidade *i*, ii) o valor m√©dio do atributo da esp√©cie *j* na comunidade *i*, e iii) o valor do atributo *k* de cada indiv√≠duo da esp√©cie *j* que ocorre na comunidade *i*. Como esta medida √© feita por unidade amostral (ou seja, sua comunidade de interesse), √© poss√≠vel testar hip√≥teses ecol√≥gicas que tentem explicar processos que aumentem ou diminuam a varia√ß√£o de um determinado atributo dentro ou entre esp√©cies diferentes. A fun√ß√£o wITV foi adaptada para a linguagem R por de Bello et al. [-@de_bello_handbook_2021]. Para facilitar o c√°lculo do wITV para cada comunidade, de Bello et al. [-@de_bello_handbook_2021] executaram os c√≥digos com a fun√ß√£o `for()` que repete iterativamente a an√°lise para gerar os valores de todas as comunidades em uma forma din√¢mica. Ap√≥s executar as an√°lises com o `for()`, a fun√ß√£o salva os resultados dentro do objeto `wITVResults`. Ap√≥s obter esses resultados, √© poss√≠vel utilizar modelos lineares para testar quais vari√°veis preditoras (em nosso exemplo, caracter√≠sticas das po√ßas) afetam o aumento ou diminui√ß√£o da contribui√ß√£o relativa da varia√ß√£o intraespec√≠fica (Figura \@ref(fig:fig-func-intra)).

```{r fig-func-witv, fig.cap="Gr√°ficos diagn√≥sticos do modelo linear ajustado para iWTV em fun√ß√£o de caracter√≠sticas das po√ßas."}
## Dados necess√°rios
# Matriz de traits.
head(traits)

# Matriz de comunidades e padroniza√ß√£o para abund√¢ncia relativa
head(anuros_comm)
anuros_comm_rel <- decostand(anuros_comm, "total")

# Vari√°veis ambientais.
head(env)

## Preara√ß√£o da matriz para receber os resultados do `for`
wITVResults <- data.frame(ITV = matrix(ncol = 1, nrow = length(unique(traits$pond))))
rownames(wITVResults) <- unique(traits$pond)

for(i in 1:length(unique(traits$pond))){
    commAux <- subset(traits, traits$pond == unique(traits$pond)[i])
    commAux$Species <- droplevels(factor(commAux$Species))
    spNames <- unique(commAux$Species)
    relAbund <- anuros_comm_rel[i, as.character(spNames)] 
    traitsVector <- commAux$body_size
    spVector <- commAux$Species
    wITVResults[i, 1] <-  wITV(spIDs = spVector, traitVals = traitsVector, relAbund = relAbund)
}

wITVResults$ITV
env$wITV <- wITVResults$ITV # NaN = locais com uma √∫nica esp√©cie

## Remover NAs para executar o modelo linear
env2 <- na.omit(env)
head(env2)  

## Modelo linear 
mod_itv <- lm(wITV ~ depth + area + dits_bt_pond + dist_for, data = env)

## Testar pressuposto da an√°lise
par(mfrow = c(2, 2))
plot(mod_itv)

## Resultado
summary(mod_itv)
```

Combinando os resultados das tr√™s an√°lises √© poss√≠vel compreender que existem diferen√ßas morfol√≥gicas entre as esp√©cies de po√ßas diferentes (componente substitui√ß√£o). Por√©m, √© evidente que a varia√ß√£o dentro da esp√©cie √© bastante relevante para compreender a diversidade funcional de anuros. Na primeira an√°lise, os resultados dessas quatro an√°lises indicaram que a varia√ß√£o intraspecifica explica de 17% a 45% da varia√ß√£o morfol√≥gica nas metacomunidades de anuros. A segunda, por sua vez, demonstra que a varia√ß√£o morfol√≥gica entre esp√©cies de po√ßas diferentes representa o principal componente de varia√ß√£o, mas que a varia√ß√£o intraespec√≠fica n√£o pode ser ignorada. Por fim, ao combinar a m√©trica wITV com modelos lineares, percebe-se que as caracter√≠sticas das po√ßas n√£o determinam a contribui√ß√£o da varia√ß√£o intraespec√≠fica. Al√©m disso, existe uma varia√ß√£o muito grande entre po√ßas. Ao passo que em algumas po√ßas a varia√ß√£o intraespec√≠fica n√£o contribui para a varia√ß√£o total (wITV = 0), em outras, este componente representou 100% da varia√ß√£o (wITV = 1). Os resultados obtidos nas an√°lises das perguntas 1 a 3 indicam que utilizar somente a m√©dia dos atributos morfol√≥gicos pode refletir em interpreta√ß√µes incorretas em estudos que compararam a diversidade funcional no espa√ßo/tempo [veja discuss√£o em @dalmolin_turnover_2020].

## Para se aprofundar 

### Livros 
Recomendamos a leitura de dois livros: Garnier et al. [-@garnier_plant_2016] e de Bello et al. [-@de_bello_handbook_2021]. Os dois livros oferecem excelente oportunidade para se aprofundar no campo te√≥rico da diversidade funcional e, al√©m disso, o livro liderado pelo pesquisador Francesco de Bello fornece diversas aplica√ß√µes anal√≠ticas na linguagem R. Outro recurso excelente foi publicado por Mammola et al. [-@mammola_concepts_2021] e serve para se aprofundar nas diferentes medidas da diversidade funcional.

### Links

Um passo importante nos estudos de Diversidade Funcional √© encontrar atributos funcionais dos organismos estudados. Abaixo indicamos uma lista de potenciais bases de dados:

- [COMADRE - Animal Matrix Database](https://compadre-db.org/)
- [COMPADRE - Plant Matrix Database](https://compadre-db.org/)
- [Elton Traits 1.0](https://esajournals.onlinelibrary.wiley.com/doi/10.1890/13-1917.1)
- [TetraDENSITY - Density estimates in terrestrial vertebrates](https://figshare.com/articles/dataset/TetraDENSITY_Population_Density_dataset/5371633?file=11358218)
- [TRY - Plant Trait Database](https://www.try-db.org/TryWeb/Home.php)
- [World Spider Trait](https://spidertraits.sci.muni.cz/)
 
## Exerc√≠cios

**14.1**
Utilize os dados `aviurba` do pacote `ade4` para testar o efeito de vari√°veis ambientais na dispers√£o (FDis) e regularidade funcional (FEve). Utilize modelos lineares (LM, veja Cap√≠tulo \@ref(cap7)) para testar quais vari√°veis ambientais s√£o as mais importantes para a dispers√£o e regularidade funcional. Al√©m disso, fa√ßa um boxplot (veja Cap√≠tulo \@ref(cap6)) comparando os valores de FDis e FEve entre as categorias das vari√°veis ambientais mais relevantes. 

**14.2**
Utilize os dados `mafragh` do pacote `ade4` para teste o efeito da das vari√°veis `conductivity`, `silt` e `K2O` na diversidade funcional (m√©todo de Petchey e Gaston). Utilize modelos lineares (regress√£o m√∫ltipla, veja Cap√≠tulo \@ref(cap7)) para testar a rela√ß√£o entre essas vari√°veis e discuta: (a) qual vari√°vel mais importante (se houver) e (b) se as conclus√µes s√£o coerentes tendo como base os pressupostos dos modelos lineares. Al√©m disso, caso exista alguma rela√ß√£o significativa, fa√ßa um gr√°fico (scatterplot, veja Cap√≠tulo \@ref(cap6)) da rela√ß√£o da vari√°vel mais importante e a diversidade funcional.

**14.3**
Utilize os dados `mafragh` do pacote `ade4` para comparar a composi√ß√£o filogen√©tica e funcional em √°reas com alta e baixa concentra√ß√£o de pot√°ssio. Para fazer esta compara√ß√£o ser√° necess√°rio transformar a matriz de atributos funcionais e a √°rvore filogen√©tica em matrizes de dist√¢ncia e, depois, utilizar o CWM para criar uma matriz de localidades por composi√ß√£o funcional ou filogen√©tica. Depois, voc√™ poder√° usar a matriz CWM para testar potenciais diferen√ßas entre concentra√ß√µes com PERMANOVA e para visualizar com PCoA.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-14---diversidade-filogen%C3%A9tica.html).

<!--chapter:end:14_diversidade_funcional.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Dados geoespaciais no R {#cap15}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(ecodados)
library(here)
library(tidyverse)
library(sf) 
library(raster) 
library(rgdal) 
library(spData)
library(rnaturalearth)
library(geobr)
library(ggplot2)
library(ggspatial)
library(tmap)
library(tmaptools)
library(grid)
library(mapview)
library(leaflet)
library(viridis)
library(knitr)
library(sidrar)
library(landscapetools)

## Dados
# world <- world
# volcano <- volcano
# geo_anfibios_locais <- ecodados::geo_anfibios_locais
# geo_anfibios_especies <- ecodados::geo_anfibios_especies
# geo_vetor_nascentes <- ecodados::geo_vetor_nascentes
# geo_vetor_hidrografia <- ecodados::geo_vetor_hidrografia
# geo_vetor_cobertura <- ecodados::geo_vetor_cobertura
# geo_vetor_rio_claro <- ecodados::geo_vetor_rio_claro
# geo_vetor_brasil <- ecodados::geo_vetor_brasil
# geo_vetor_brasil_anos <- ecodados::geo_vetor_brasil_anos
# geo_vetor_am_sul <- ecodados::geo_vetor_am_sul
# geo_vetor_biomas <- ecodados::geo_vetor_biomas
# geo_vetor_mata_atlantica <- ecodados::geo_vetor_mata_atlantica
# geo_raster_srtm <- ecodados::geo_raster_srtm
# geo_raster_bioclim <- ecodados::geo_raster_bioclim
# geo_raster_globcover_mata_atlantica <- ecodados::geo_raster_globcover_mata_atlantica
```

## Contextualiza√ß√£o

Nesta se√ß√£o, vamos fazer uma breve introdu√ß√£o aos principais conceitos sobre a manipula√ß√£o e visualiza√ß√£o de dados geoespaciais no R. Iremos abordar temas de forma te√≥rica e pr√°tica, utilizando a linguagem R, focando em: i) formatos de dados vetoriais e dados raster, ii) Sistemas de Refer√™ncias de Coordenadas e unidades (geogr√°ficas e projetadas), iii) fontes de dados, iv) importar e exportar dados, v) descri√ß√£o de objetos geoespaciais e vi) principais opera√ß√µes (atributos, espaciais e geom√©tricas). Num segundo momento, criaremos mapas com seus principais elementos como mapas principal e secund√°rio, t√≠tulo, legenda, barra de escala, indicador de orienta√ß√£o (Norte), gride de coordenadas, descri√ß√£o do Sistema de Refer√™ncia de Coordenadas e informa√ß√µes de origem dos dados. Por fim, apresentaremos exemplos de aplica√ß√µes de an√°lises geoespaciais para dados ecol√≥gicos, focadas em: i) agregar informa√ß√µes sobre a biodiversidade, ii) preparar dados para compor vari√°veis preditoras, e iii) como fazer predi√ß√µes espaciais de distribui√ß√£o de uma esp√©cie e riqueza de esp√©cies.

Esse cap√≠tulo segue parte da estrutura organizada por Lovelace et al. [-@lovelace2019], principalmente os Cap√≠tulos 2 a 8, sendo adaptado para atender aos principais requisitos que julgamos necess√°rios a estudos ecol√≥gicos. Entretanto, n√£o foi poss√≠vel cobrir todos os assuntos sobre o uso de dados geoespaciais no R, sendo um tema muito extenso que requer a leitura de livros especializados na √°rea como: i) Mas et al. [-@mas2019] [An√°lise espacial com R](https://bit.ly/2KpSI7C), ii) Wegmann, Leutner & Dech [-@wegmann2016] Remote Sensing and GIS for Ecologists: Using Open Source Software, iii) Wegmann, Schwalb-Willmann & Dech [-@wegmann2020] An Introduction to Spatial Data Analysis Remote Sensing and GIS with Open Source Software, e iv) Fletcher & Fortin [-@fletcher2018] Spatial ecology and conservation modeling: Applications with R. Outros livros sobre a an√°lise geoespacial no R podem ser consultados no Cap√≠tulo [11 - Geospatial](https://www.bigbookofr.com/geospatial.html) do [Big Book of R](https://www.bigbookofr.com/index.html).

## Vetor

Dados vetoriais s√£o usados para mapear fen√¥menos ou objetos espacialmente expl√≠citos que possuem localiza√ß√£o ou dimens√µes bem definidas, representado a partir de formas geom√©tricas (como pontos, linhas e pol√≠gonos) e possuem a possibilidade de ter associado a eles informa√ß√µes tabulares. A tabela de atributos √© uma tabela que inclui dados geoespaciais e dados alfanum√©ricos. Os dados geoespaciais s√£o representados por fei√ß√µes geolocalizada espacialmente (ponto, linha ou pol√≠gono), e os dados alfanum√©ricos (tabela de dados). Dessa forma, a tabela de atributos re√∫ne informa√ß√µes sobre cada fei√ß√£o e pode ser utilizada para realizar de filtros ou agrega√ß√µes dos dados de cada fei√ß√£o (Figura \@ref(fig:fig-vetor-tipos)).

```{r fig-vetor-tipos, echo=FALSE, fig.cap="Representa√ß√£o das geometrias de ponto, linha e pol√≠gono e atributos. Adaptado de: Olaya [-@olaya2020]."}
knitr::include_graphics("img/cap15_fig01.png")
```

### sf: principal pacote no R para dados vetoriais

Atualmente o principal pacote para trabalhar com dados vetoriais no R √© o [`sf`](https://r-spatial.github.io/sf/), que implementou o *Simple Feature* [@sf2018]. Entretanto, outro pacote pode ser t√£o vers√°til quanto o `sf`, no caso o [`terra`](https://rspatial.org/terra/index.html), com algumas mudan√ßas na sintaxe que n√£o abordaremos nesse livro por quest√µes de redu√ß√£o de espa√ßo.

Os tipos de geometrias apresentadas s√£o representadas por diferentes classes: `POINT`, `LINESTRING` e `POLYGON` para apenas uma fei√ß√£o de cada tipo de geometria; `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON` para v√°rias fei√ß√µes de cada tipo de geometria e; `GEOMETRYCOLLECTION` para v√°rias fei√ß√µes e tipos de geometrias e classes.

Ao olharmos as informa√ß√µes de um objeto da classe `sf`, podemos notar diversas informa√ß√µes que descrevem o mesmo, numa esp√©cie de cabe√ßalho:

-   **resumo do vetor**: indica o n√∫mero de fei√ß√µes (linhas) e campos (colunas)
-   **tipo da geometria**: umas das sete classes (ou mais outras) listadas anteriormente
-   **dimens√£o**: n√∫mero de dimens√µes, geralmente duas (XY)
-   **bbox (bordas)**: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   **informa√ß√£o do CRS**: `epsg` ou `proj4string` indicando o CRS (*Coordinate Reference System*)
-   **tibble**: tabela de atributos, com destaque para a coluna `geom` ou `geometry` que representa cada fei√ß√£o ou geometria

```{r}
## Dados vetoriais de pol√≠gonos do mundo
data(world)
world
```

Podemos fazer um mapa simples utilizando a fun√ß√£o `plot()` desse objeto. Para facilitar, escolheremos apenas a primeira coluna `[1]` (Figura \@ref(fig:fig-vetor-mundo)). Caso n√£o escolhermos apenas uma coluna, um mapa para cada coluna ser√° plotado.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Faremos mapas mais elaborados na se√ß√£o de visualiza√ß√£o de dados geoespaciais deste cap√≠tulo.
:::

```{r fig-vetor-mundo, fig.cap="Mapa vetorial do mundo."}
## Plot dos pol√≠gonos do mundo
plot(world[1], col = viridis::viridis(100), main = "Mapa do mundo")
```

## Raster

Os dados no formato raster consistem em uma matriz (com linhas e colunas) em que os elementos representam c√©lulas, geralmente igualmente espa√ßadas (pixels; Figura \@ref(fig:fig-raster)). As c√©lulas dos dados raster possuem duas informa√ß√µes: i) identifica√ß√£o das c√©lulas (IDs das c√©lulas) para especificar sua posi√ß√£o na matriz (Figura \@ref(fig:fig-raster) A) e; ii) valores das c√©lulas (Figura \@ref(fig:fig-raster) B), que geralmente s√£o coloridos para facilitar a interpreta√ß√£o da varia√ß√£o dos valores no espa√ßo (Figura \@ref(fig:fig-raster) C). Al√©m disso, valores ausentes ou n√£o amostrados s√£o representados por `NA`, ou seja, *not available* (Figura \@ref(fig:fig-raster) B e C).

```{r fig-raster, echo=FALSE, fig.cap="Raster: (A) IDs das c√©lulas, (B) valores das c√©lulas, (C) c√©lulas coloridas. Adaptado de: Lovelace et al. [-@lovelace2019]."}
library(gridExtra)

# Dados
set.seed(42)
small_ras <- raster(matrix(1:16, 4, 4, byrow = TRUE))
small_ras_val <- raster(matrix(sample.int(100, 16), 4, 4, byrow = TRUE))
small_ras_val[c(10, 15)] <- NA
polys <- rasterToPolygons(small_ras, na.rm = FALSE)

# ids das c√©lulas
p_1 <- spplot(small_ras, colorkey = FALSE, col.regions = "white",
              main = "A. IDs das c√©lulas",
              sp.layout = list(
                  list("sp.polygons", polys, first = FALSE),
                  list("sp.text", xyFromCell(small_ras_val, 1:ncell(small_ras)),
                       1:ncell(small_ras))
              )
)

# valor das c√©lulas
p_2 <- spplot(small_ras_val, colorkey = FALSE, col.regions = "white",
              main = "B. Valores das c√©luas",
              sp.layout = list(
                  list("sp.polygons", polys, first = FALSE),
                  list("sp.text", xyFromCell(small_ras_val,
                                             1:ncell(small_ras_val)),
                       values(small_ras_val))
              )
)

# mapa colorido
p_3 <- spplot(small_ras_val, 
              col.regions = viridis::viridis(16),
              colorkey = FALSE,
              main = "C. Valores coloridos")

grid.arrange(p_1, p_2, p_3, ncol = 3)
```

Pode ainda fazer uma compara√ß√£o com as representa√ß√µes de dados vetoriais vistos na Figura \@ref(fig:fig-vetor-tipos), mas agora no formato raster (Figura \@ref(fig:fig-raster-tipos)).

```{r fig-raster-tipos, echo=FALSE, fig.cap="Representa√ß√£o das geometrias de ponto, linha e pol√≠gono no formato raster. Adaptado de: Olaya [-@olaya2020]."}
knitr::include_graphics("img/cap15_fig02.png")
```

### raster: principal pacote no R para dados raster

Atualmente, o principal pacote para trabalhar com dados raster √© o [*raster*](https://rspatial.org/raster/index.html), apesar de existir outros dois: [*terra*](https://rspatial.org/terra/index.html) e [*stars*](https://r-spatial.github.io/stars/), com algumas mudan√ßas na sintaxe que n√£o abordaremos neste livro.

O pacote `raster` fornece uma ampla gama de fun√ß√µes para criar, importar, exportar, manipular e processar dados raster no R. O objeto raster criado √† partir do pacote `raster` pode assumir tr√™s classes: `RasterLayer`, `RasterStack` e `RasterBrick`.

A classe `RasterLayer` representa apenas uma camada raster. Para criar ou importar um raster no R podemos utilizar a fun√ß√£o `raster::raster()`. Observando essa classe, podemos notar as seguintes informa√ß√µes:

-   **class**: classe raster do objeto raster
-   **dimensions**: n√∫mero de linhas, colunas e c√©lulas
-   **resolution**: largura e altura da c√©lula
-   **extent**: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   **crs**: Sistema de Refer√™ncia de Coordenadas (*CRS*)
-   **source**: fonte dos dados (mem√≥ria ou disco)
-   **names**: nome das camadas
-   **values**: valores m√°ximos e m√≠nimos das c√©lulas

Vamos utilizar os dados `volcano`, que possui informa√ß√µes topogr√°ficas (eleva√ß√£o) do vulc√£o Maunga Whau de Auckland na Nova Zel√¢ndia.

```{r}
## Dados de altitude de um vulc√£o
volcano[1:5, 1:5]
```

Vamos transformar essa matriz de dados em um raster com a fun√ß√£o `raster::raster()`.

```{r}
## Rasterlayer
raster_layer <- raster::raster(volcano)
raster_layer
```

Um mapa simples do objeto raster pode ser obtido utilizando a fun√ß√£o `plot()`, do pr√≥prio pacote `raster` (Figura \@ref(fig:fig-raster-layer)).

```{r fig-raster-layer, fig.cap="Mapa simples de um `RasterLayer`."}
## Plot raster layers
plot(raster_layer, col = viridis::viridis(n = 100))
```

Al√©m da classe `RasterLayer`, h√° mais duas classes que trabalham com m√∫ltiplas camadas: `RasterBrick` e `RasterStack`. Elas diferem em rela√ß√£o ao n√∫mero de formatos de arquivo suportados, tipo de representa√ß√£o interna e velocidade de processamento.

A classe `RasterBrick` geralmente corresponde √† importa√ß√£o de um √∫nico arquivo de imagem de sat√©lite multiespectral (multicamadas) ou a um √∫nico objeto com v√°rias camadas na mem√≥ria. A fun√ß√£o `raster::brick()` cria um objeto `RasterBrick`.

```{r}
## Raster layers
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

## Raster brick
raster_brick <- raster::brick(raster_layer1, raster_layer2, 
                              raster_layer3, raster_layer4)
raster_brick
```

Ao utilizarmos a fun√ß√£o `plot()` do pacote `raster`, podemos visualizar os raster contidos no objeto `RasterBrick` (Figura \@ref(fig:fig-raster-brick)).

```{r fig-raster-brick, fig.cap="Mapas simples de um raster RasterBrick."}
## Plot raster brick
plot(raster_brick, col = viridis::viridis(n = 25), main = "")
```

J√° a classe `RasterStack` permite conectar v√°rios objetos raster armazenados em arquivos diferentes ou v√°rios objetos no ambiente do R. Um `RasterStack` √© uma lista de objetos `RasterLayer` com a mesma extens√£o, resolu√ß√£o e CRS. Uma maneira de cri√°-lo √© com a jun√ß√£o de v√°rios objetos geoespaciais j√° existentes no ambiente do R ou listar v√°rios arquivos raster em um diret√≥rio armazenado no disco. A fun√ß√£o `raster::stack()` cria um objeto `RasterStack`.

Outra diferen√ßa √© que o tempo de processamento, para objetos `RasterBrick` geralmente √© menor do que para objetos `RasterStack`. A decis√£o sobre qual classe `Raster` deve ser usada depende principalmente do car√°ter dos dados de entrada.

```{r}
## Raster layers
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

## Raster stack
raster_stack <- raster::stack(raster_layer1, raster_layer2, 
                              raster_layer3, raster_layer4)
raster_stack
```

Da mesma forma, ao utilizar a fun√ß√£o `plot()` do pacote `raster`, podemos visualizar os raster contidos no objeto `RasterStack` (Figura \@ref(fig:fig-raster-stack)).

```{r fig-raster-stack, fig.cap="Mapas simples de um raster RasterStack."}
## Plot raster stack
plot(raster_stack, col = viridis::viridis(n = 25), main = "")
```

## Sistema de Refer√™ncia de Coordenadas e Unidades

Os dados geoespaciais (vetor e raster) possuem ainda um outro componente fundamental que √© o Sistema de Refer√™ncia de Coordenadas, ou do ingl√™s *Coordinate Reference System (CRS)*. Esse componente define a refer√™ncia espacial dos elementos geoespaciais (vetor e raster) na superf√≠cie da Terra. Esse componente √© composto por dois principais conceitos: primeiro, que tipo de unidades est√£o sendo utilizadas para a representa√ß√£o geogr√°fica, podendo assumir dois tipos - √¢ngulos ou metros, que definem o Sistema de Coordenadas Geogr√°ficas e o Sistema de Coordenadas Projetadas, respectivamente. O segundo componente √© o datum, que √© a rela√ß√£o do sistema de coordenadas (geogr√°fica ou projetada) com a superf√≠cie da Terra. Esse √∫ltimo componente faz parte de uma √°rea da Cartografia denominada Geod√©sia que estuda a forma e dimens√µes da Terra, campo gravitacional e a localiza√ß√£o de pontos fixos e sistemas de coordenadas. O livro de Lapaine & Usery [-@lapaine2017] √© um excelente material para se aprofundar nesse assunto.

### Sistema de Coordenadas Geogr√°ficas

O Sistema de Coordenadas Geogr√°ficas utiliza √¢ngulos (graus) para representar fei√ß√µes na superf√≠cie da Terra atrav√©s de dois valores: longitude e latitude. A longitude representa o eixo Leste-Oeste e a latitudeo eixo Norte-Sul. Nesse sistema, a superf√≠cie da Terra √© representada geralmente por uma superf√≠cie elipsoidal, pois a Terra √© ligeiramente achatada nos polos devido ao seu movimento no entorno do seu eixo.

### Sistema de Coordenadas Projetadas

O Sistema de Coordenadas Projetadas utiliza um Sistema Cartesiano de Coordenadas em uma superf√≠cie plana. Dessa forma, a partir de uma origem tra√ßam-se eixos X e Y e uma unidade linear √© utilizada, como o metro. Todos as proje√ß√µes feitas de sistemas geoespaciais convertem uma superf√≠cie tridimensional em uma superf√≠cie plana bidimensional. Sendo assim, essa convers√£o traz consigo algum tipo de distor√ß√£o em rela√ß√£o √† por√ß√£o real, podendo ser distor√ß√µes em: i) formas locais, ii) √°reas, iii) dist√¢ncias, iv) flex√£o ou curvatura, v) assimetria ou vi) lacunas de continuidade. Dessa forma, um sistema de coordenadas projetadas pode preservar somente uma ou duas dessas propriedades.

Existem tr√™s grandes grupos de proje√ß√µes: i) cil√≠ndricos, ii) c√¥nicos e iii) planares. Na proje√ß√£o cil√≠ndrica, a superf√≠cie da Terra √© mapeada em um cilindro, criada tocando a superf√≠cie da Terra ao longo de uma ou duas linhas de tang√™ncia, sendo utilizada com mais frequ√™ncia para mapear todo o globo tendo como exemplo mais conhecido a Proje√ß√£o Universal Transversa de Mercator (UTM). Na proje√ß√£o c√¥nica, a superf√≠cie da Terra √© projetada em um cone ao longo de uma linha ou duas linhas de tang√™ncia, de modo que as distor√ß√µes s√£o minimizadas ao longo das linhas e aumentam com a dist√¢ncia das mesmas, sendo portanto, mais adequada para mapear √°reas de latitudes m√©dias, tendo como exemplo mais conhecido a Proje√ß√£o C√¥nica Equivalente de Albers e a Proje√ß√£o C√¥nica Conforme de Lambert. E na proje√ß√£o plana, tamb√©m denominada Proje√ß√£o Azimutal, o mapeamento toca o globo em um ponto ou ao longo de uma linha de tang√™ncia, sendo normalmente utilizado no mapeamento de regi√µes polares, sendo a mais comum a Proje√ß√£o Azimutal Equidistante, a mesma utilizada na bandeira da ONU.

### Datum

Como dito anteriormente, o datum √© a rela√ß√£o do sistema de coordenadas com a superf√≠cie da Terra. Ele representa o ponto de intersec√ß√£o do elipsoide de refer√™ncia com a superf√≠cie da Terra (geoide, a forma verdadeira da Terra), compensando as diferen√ßas do campo gravitacional da Terra. Existem dois tipos de datum: i) local e ii) geoc√™ntrico. Em um datum local, como o SAD69 - *South American Datum 1969*, o elipsoide de refer√™ncia √© deslocado para se alinhar com a superf√≠cie em um determinado local, por exemplo, na Am√©rica do Sul. J√° em um datum geoc√™ntrico, como WGS84 - *World Geodetic System 1984*, o centro do elipsoide √© o centro de gravidade da Terra e a precis√£o das proje√ß√µes n√£o √© otimizada para um local espec√≠fico do globo.

No Brasil, desde 2015, o [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)](https://www.ibge.gov.br/) ajudou a desenvolver e reafirmou o uso do datum SIRGAS2000 - *Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000* para todos os mapeamentos realizados no Brasil, um esfor√ßo conjunto para adotar o mesmo datum em toda a Am√©rica. Mais sobre esse datum pode ser lido aqui: [SIRGAS2000](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/).

### Sistema de Refer√™ncia de Coordenadas (CRS) no R

No R, h√° duas formas principais de representar um Sistema de Refer√™ncia de Coordenadas: i) c√≥digo `epsg` e ii) `proj4string`. O c√≥digo EPSG (*European Petroleum Survey Group*) √© uma sequ√™ncia de n√∫meros curta, referindo-se apenas a um CRS. O site [epsg.io](http://epsg.io/) permite consultar diversas informa√ß√µes sobre um c√≥digo, como procurar por um c√≥digo, representa√ß√£o de mapas e fazer transforma√ß√µes de CRS.

J√° o `proj4string` permite mais flexibilidade para especificar diferentes par√¢metros, como o tipo de proje√ß√£o, datum e elipsoide. Dessa forma, √© poss√≠vel especificar muitas proje√ß√µes, ou mesmo modificar as proje√ß√µes existentes, tornando a representa√ß√£o `proj4string` mais complexa e flex√≠vel.

Al√©m disso, ainda √© poss√≠vel consultar uma extensa lista de CRSs no site [spatialreference.org](https://spatialreference.org/), que fornece descri√ß√µes em diversos formatos, baseados em GDAL e Proj.4. Essa abordagem permite consultar uma URL que pode produzir uma refer√™ncia espacial em um formato que seu software SIG ou o R pode utilizar como refer√™ncia.

Os pacotes (geo)espaciais no R suportam uma ampla variedade de CRSs e usam a biblioteca [PROJ](https://proj.org/index.html#). A fun√ß√£o `rgdal::make_EPSG()` retorna um `data frame` das proje√ß√µes dispon√≠veis, com informa√ß√µes dos c√≥digos `epsg` e `proj4string` numa mesma tabela, facilitando a busca e uso de CRSs (Tabela \@ref(tab:tab-epsg)).

```{r eval=FALSE}
## Listagem dos Sistemas de Refer√™ncias de Coordenadas no R
crs_data <- rgdal::make_EPSG()
head(crs_data)
```

```{r tab-epsg, echo=FALSE}
knitr::kable(
    head(rgdal::make_EPSG()),
    caption = "Listagem de Sistemas de Refer√™ncias de Coordenadas dispon√≠veis no R, com informa√ß√µes dos c√≥digos `epsg` e `proj4string`"
)
```

## Principais fontes de dados geoespaciais

Existem diversas fontes de dados geoespaciais em diferentes bases de dados dispon√≠veis gratuitamente. Geralmente essas bases de dados s√£o disponibilizadas separadamente em apenas dados vetoriais e dados raster. Para dados vetoriais, grande parte dos dados disponibilizados s√£o utilizados em mapas como limites pol√≠ticos, limites de biomas ou distribui√ß√£o de esp√©cies para pol√≠gonos; estradas e rios para dados lineares, ou ainda pontos de ocorr√™ncia de esp√©cies ou comunidades, ou medidas tomadas em campo sobre condi√ß√µes naturais como clima ou relevo, como pontos. Entretanto, √© sempre recomendado o uso de bases oficiais, principalmente em rela√ß√£o a dados vetoriais de limites pol√≠ticos. Para tanto, √© fundamental buscar as bases oficiais de cada pa√≠s, entretanto, h√° bases que podem ser utilizadas globalmente, como veremos.

Sobre as bases de dados raster, h√° uma infinidade de dados para diferentes objetivos, mas grande parte deles s√£o relativos a condi√ß√µes ambientais, representando uma vari√°vel de interesse de forma cont√≠nua no espa√ßo, como temperatura, precipita√ß√£o, eleva√ß√£o, etc.

H√° uma compila√ß√£o de dados geoespaciais vetoriais e raster feita por Marcus Vin√≠cius Alves de Carvalho e Angelica Carvalho Di Maio, chamada [GeoLISTA](http://www.clickgeo.com.br/wp-content/uploads/2018/05/GeoLISTA.pdf). Entretanto, como as bases de dados tendem a ser muito din√¢micas, √© poss√≠vel que muitas bases tenham surgido e desaparecido desde a listagem realizada.

Al√©m das bases de dados, h√° pacotes espec√≠ficos no R que fazem o download de dados vetoriais e rasters, facilitando a aquisi√ß√£o e reprodutibilidade. Para conferir uma listagem completa de pacotes para diversas an√°lises espaciais, veja [CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html).

### Vetor

Dentre as bases vetoriais, destacamos as seguintes na Tabela \@ref(tab:tab-vetor-bases).

```{r tab-vetor-bases, echo=FALSE}
knitr::kable(
    tibble(
        `Bases de dados` = c("[IBGE](https://www.ibge.gov.br/geociencias/downloads-geociencias.html)",
                             "[FBDS](http://geo.fbds.org.br/)",
                             "[GeoBank](http://geosgb.cprm.gov.br/)",
                             "[Pastagem.org](http://maps.lapig.iesa.ufg.br)",
                             "[CanaSat](http://www.dsr.inpe.br/laf/canasat/)",
                             "[CSR Maps](http://maps.csr.ufmg.br)",
                             "[Ecoregions](https://ecoregions2017.appspot.com/)",
                             "[UN Biodiversity Lab](https://www.unbiodiversitylab.org/)",
                             "[Biodiversity Hotspots](https://zenodo.org/record/3261807#.YA8lpPv0nOY)",
                             "[IUCN Red List of Threatened Species](https://www.iucnredlist.org/resources/spatial-data-download)",
                             "[Map of Life (MOL)](https://mol.org/)",
                             "[Key Biodiversity Areas](http://www.keybiodiversityareas.org/kba-data/request)",
                             "[HydroSHEDS](https://www.hydrosheds.org/)",
                             "[Global Roads Inventory Project (GRIP)](https://www.globio.info/download-grip-dataset)",
                             "[Database of Global Administrative Areas (GADM)](https://gadm.org/)",
                             "[Natural Earth](https://www.naturaleatoriorthdata.com/)",
                             "[Protected Planet](https://www.protectedplanet.net)", 
                             "[Global Biological Information Facility (GBIF)](http://www.gbif.org)",
                             "[Species Link](http://www.splink.cria.org.br)",
                             "[Global Invasive Species Information Network (GISIN)](http://www.gisin.org)"),
        Descri√ß√£o = c("Limites territoriais e censit√°rios do Brasil", 
                      "Uso da terra, APP e hidrografia - Mata Atl√¢ntica e Cerrado",
                      "Dados geol√≥gicos do Brasil",
                      "Dados de pastagens e gado para o Brasil",
                      "Dados de cana-de-a√ß√∫car para o Brasil",
                      "Diversos dados vetoriais e raster para o Brasil",
                      "Dados de biorregi√µes e geo_vetor_biomas do mundo",
                      "Diversas bases de dados para o mundo",
                      "Dados dos limites dos Hotspots de Biodiversidade",
                      "Dados dos limites das distribui√ß√µes das esp√©cies para o mundo",
                      "Dados da distribui√ß√£o de esp√©cies e outros dados para o mundo",
                      "Dados dos limites das Key Biodiversity Areas",
                      "Informa√ß√µes hidrol√≥gicas do mundo",
                      "Dados de estradas do mundo todo",
                      "Limites de √°reas administrativas do mundo",
                      "Diversos limites para o mundo",
                      "Limites de √°reas protegidas para o mundo",
                      "Dados de ocorr√™ncias de esp√©cies para o mundo",
                      "Dados de ocorr√™ncias de esp√©cies para o Brasil",
                      "Dados de ocorr√™ncias de esp√©cies invasoras para o Mundo")),
    caption = "Principais bases de dados vetoriais para o Brasil e o Mundo.",
    booktabs = TRUE
)
```

### Raster

Dentre as bases raster, destacamos as seguintes na Tabela \@ref(tab:tab-raster-bases).

```{r tab-raster-bases, echo=FALSE}
knitr::kable(tibble(
    `Bases de dados` = c("[Mapgeo_vetor_biomas](https://mapgeo_vetor_biomas.org/)",
                         "[Bahlu](ftp://madeira.dea.ufv.br/bdados/bhalu/)",
                         "[USGS](https://www.usgs.gov/)",
                         "[SRTM](http://srtm.csi.cgiar.org/)",
                         "[Geoservice Maps](https://geoservice.dlr.de/web/maps)",
                         "[Global Forest Watch](https://www.globalforestwatch.org/)",
                         "[GlobCover](http://due.esrin.esa.int/page_globcover.php)",
                         "[Landcover](https://www.earthenv.org/landcover)",
                         "[Global Human Footprint](https://wcshumanfootprint.org/)",
                         "[GHSL - Global Human Settlement Layer](https://ghsl.jrc.ec.europa.eu/download.php)",
                         "[Land-Use Harmonization (LUH2)](https://luh.umd.edu/)",
                         "[ESA Climate Change Initiative](https://climate.esa.int/en/odp/#/dashboard)",
                         "[WorldClim](https://www.worldclim.org/)",
                         "[CHELSA](https://chelsa-climate.org/)",
                         "[EarthEnv](https://www.earthenv.org/)",
                         "[SoilGrids](https://soilgrids.org/)",
                         "[Global Wetlands](https://www2.cifor.org/global-wetlands/)",
                         "[Global Surface Water Explorer](https://global-surface-water.appspot.com/#)",
                         "[MARSPEC](http://www.marspec.org/)",
                         "[Bio-ORACLE](http://www.oracle.ugent.be/)"), 
    Descri√ß√£o = c("Uso e cobertura da terra para o Brasil, Panamazonia Legal e Chaco, de 1985 a 2019", 
                  "Distribui√ß√µes hist√≥ricas de terras agr√≠colas e pastagens para todo o Brasil de 1940 a 2012", 
                  "Dados de diversos sat√©lites livres para o mundo",
                  "Dados de eleva√ß√£o para o mundo",
                  "Dados de eleva√ß√£o e florestas para o mundo",
                  "Dados de florestas para o mundo",
                  "Dados de uso e cobertura da terra para todo o planeta",
                  "Dados de uso e cobertura da terra para todo o planeta",
                  "Dados de pegada ecol√≥gica para o mundo",
                  "Dados e ferramentas abertos e gratuitos para avaliar a presen√ßa humana no planeta",
                  "Dados atuais e previs√µes de uso da terra",
                  "Arquivos globais de observa√ß√£o da Terra nos √∫ltimos 30 anos da Ag√™ncia Espacial Europeia (ESA)",
                  "Dados clim√°ticos para o mundo",
                  "Dados clim√°ticos para o mundo",
                  "Dados de cobertura da terra, nuvens, relevo e hidrografia",
                  "Dados de solo para o mundo",
                  "Dados de √°reas √∫midas para o mundo",
                  "Dados de √°guas superficiais para o mundo",
                  "Dados de condi√ß√µes do oceano para o mundo",
                  "Dados de condi√ß√µes do oceano para o mundo")), 
    caption = "Principais bases de dados raster para o Brasil e o Mundo.",
    booktabs = TRUE
)
```

### Pacotes do R

Dentre os pacotes no R para download de dados geoespaciais, destacamos os seguintes na Tabela \@ref(tab:tab-packages-bases).

```{r tab-packages-bases, echo=FALSE}
knitr::kable(
    tibble(
        Pacotes = c("[geobr](https://cran.r-project.org/web/packages/geobr/index.html)",
                    "[rnaturalearth](https://cran.r-project.org/web/packages/rnaturalearth/index.html)",
                    "[rworldmap](https://cran.r-project.org/web/packages/rworldmap/index.html)",
                    "[spData](https://cran.r-project.org/web/packages/spData/index.html)",
                    "[OpenStreetMap](https://cran.r-project.org/web/packages/OpenStreetMap/index.html)",
                    "[osmdata](https://cran.r-project.org/web/packages/osmdata/index.html)",
                    "[geonames](https://cran.r-project.org/web/packages/geonames/index.html)",
                    "[rgbif](https://cran.r-project.org/web/packages/rgbif/index.html)",
                    "[maptools](https://cran.r-project.org/web/packages/maptools/index.html)",
                    "[marmap](https://cran.r-project.org/web/packages/marmap/index.html)",
                    "[oce](https://cran.r-project.org/web/packages/oce/index.html)",
                    "[envirem](https://cran.r-project.org/web/packages/envirem/index.html)",
                    "[sdmpredictors](https://cran.r-project.org/web/packages/sdmpredictors/index.html)",
                    "[metScanR](https://cran.r-project.org/web/packages/metScanR/index.html)",
                    "[ClimDown](https://cran.r-project.org/web/packages/ClimDown/index.html)",
                    "[rWBclimate](https://cran.r-project.org/web/packages/rWBclimate/index.html)",
                    "[rnoaa](https://cran.r-project.org/web/packages/rnoaa/index.html)",
                    "[RNCEP](https://cran.r-project.org/web/packages/RNCEP/index.html)",
                    "[smapr](https://cran.r-project.org/web/packages/smapr/index.html)"), 
        Descri√ß√£o = c("Carrega Shapefiles de Conjuntos de Dados Espaciais Oficiais do Brasil", 
                      "Dados do mapa mundial da Natural Earth", 
                      "Mapeando Dados Globais",
                      "Conjuntos de dados para an√°lise espacial",
                      "Acesso para abrir imagens raster de mapas de ruas",
                      "Baixe e importe dados do OpenStreetMap",
                      "Interface para o servi√ßo da Web de consulta espacial 'Geonames'",
                      "Interface para o Global 'Biodiversity' Information Facility API",
                      "Ferramentas para lidar com objetos geoespaciais",
                      "Importar, tra√ßar e analisar dados batim√©tricos e topogr√°ficos",
                      "Fonte e processamento de dados oceanogr√°ficos",
                      "Gera√ß√£o de Vari√°veis ENVIREM",
                      "Conjuntos de dados preditor de modelagem de distribui√ß√£o de esp√©cies",
                      "Encontre, Mapeie e Colete Dados e Metadados Ambientais",
                      "Biblioteca de redu√ß√£o de escala do clima para a produ√ß√£o di√°ria do modelo clim√°tico",
                      "Acessa dados clim√°ticos do Banco Mundial",
                      "Dados meteorol√≥gicos 'NOAA' de R",
                      "Obtenha, organize e visualize dados meteorol√≥gicos NCEP",
                      "Aquisi√ß√£o e processamento de dados ativos-passivos (SMAP) de umidade do solo da NASA")),
    caption = "Principais pacotes no R para download de dados vetoriais e raster.",
    booktabs = TRUE
)
```

## Importar e exportar dados geoespaciais

Agora que sabemos o que s√£o dados geoespaciais e em quais bases de dados podemos buscar e baixar esses dados, veremos seus principais formatos e como import√°-los e export√°-los do R.

### Principais formatos de arquivos geoespaciais

H√° diversos formatos de arquivos geoespaciais, alguns espec√≠ficos para dados vetoriais e raster, e outros no formato de banco de dados geoespaciais, como [PostGIS](https://postgis.net/), que podem armazenar ambos os formatos.

Entretanto, todos os formatos para serem importados para o R usam o [GDAL (*Geospatial Data Abstraction Library*)](https://gdal.org/), uma interface unificada para leitura e escrita de diversos formatos de arquivos geoespaciais, sendo utilizado tamb√©m por uma s√©rie de softwares de GIS como QGIS, GRASS GIS e ArcGIS.

Dentre esses formatos, destacamos os seguintes na Tabela \@ref(tab:tab-formatos).

```{r tab-formatos, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Nome = c("ESRI Shapefile", "GeoJSON", "KML", "GPX", "GeoTIFF", "Arc ASCII", "NetCDF", "BIL", "R-raster", "SQLite/SpatiaLite", "ESRI FileGDB", "GeoPackage"), 
        extens√£o = c(".shp (arquivo principal)", ".geojson", ".kml", ".gpx", ".tif/.tiff", ".asc", ".nc", ".bil/.hdr", ".gri/ .grd", ".sqlite", ".gdb", ".gpkg"),
        Descri√ß√£o = c("Formato popular que consiste em pelo menos quatro arquivos: .shp (fei√ß√£o), .dbf (tabela de atributos), .shx (liga√ß√£o entre .shp e .dbf) e .prj (proje√ß√£o)", "Estende o formato de troca JSON incluindo um subconjunto da representa√ß√£o de recurso simples", "Formato baseado em XML para visualiza√ß√£o espacial, desenvolvido para uso com o Google Earth. O arquivo KML compactado forma o formato KMZ", "Esquema XML criado para troca de dados de GPS", "Formato raster popular. Um arquivo TIFF contendo metadados espaciais adicionais.", "Formato de texto em que as primeiras seis linhas representam o cabe√ßalho raster, seguido pelos valores das c√©lulas raster organizadas em linhas e colunas", "NetCDF (Network Common Data Form) √© um conjunto de bibliotecas de software e formatos de dados independentes que suportam a cria√ß√£o, acesso e compartilhamento de dados cient√≠ficos orientados a arrays", "BIL (Banda intercalada por linha) s√£o m√©todos comuns de organiza√ß√£o para imagens multibanda, geralmente acompanhados por um arquivo .hdr, descrevendo atributos espec√≠ficos da imagem", "Formato raster nativo do raster do pacote R", "Banco de dados relacional aut√¥nomo", "objetos geoespaciais e n√£o espaciais criados pelo ArcGIS. Permite: v√°rias classes de recursos; topologia", "Cont√™iner de banco de dados leve baseado em SQLite permitindo uma troca f√°cil e independente de plataforma de geodados"),
        Tipo = c("Vetor", "Vetor", "Vetor", "Vetor", "Raster", "Raster", "Raster", "Raster", "Raster", "Vetor e raster", "Vetor e raster", "Vetor e raster"),
        Modelo = c("Parcialmente aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Propriet√°rio", "Aberto")), 
    caption = "Principais formatos de arquivos geoespaciais. Adaptado de: Lovelace et al. [-@lovelace2019]."
)
```

O formato mais comum para arquivos vetoriais √© o [ESRI Shapefile](https://doc.arcgis.com/en/arcgis-online/reference/shapefiles.htm); para arquivos raster √© o [GeoTIFF](https://gdal.org/drivers/raster/gtiff.html); e para dados clim√°ticos em m√∫ltiplas camadas, geralmente h√° a disponibiliza√ß√£o de dados no formato [NetCDF](https://www.unidata.ucar.edu/software/netcdf/). Entretanto, recentemente tivemos o surgimento do [GeoPackage](https://www.geopackage.org/), que possui diversas vantagens em rela√ß√£o aos formatos anteriores, podendo armazenar em apenas um arquivo, dados no formato vetorial, raster e tamb√©m dados n√£o-espaciais (e.g., tabelas), al√©m de possuir uma grande integra√ß√£o com diversos softwares e bancos de dados.

### Importar dados

As principais fun√ß√µes para importar dados no R s√£o: i) para vetores a fun√ß√£o `sf::st_read()`, e ii) para raster a fun√ß√£o `raster::raster()` e suas varia√ß√µes `raster::brick()` e `raster::stack()` para m√∫ltiplas camadas. Essas fun√ß√µes atribuem objetos ao seu espa√ßo de trabalho, armazenando-os na mem√≥ria RAM dispon√≠vel em seu hardware, sendo essa a maior limita√ß√£o para trabalhar com dados geoespaciais no R. Por exemplo, se um arquivo raster possui mais de 8 Gb de tamanho, e seu computador possui exatamente 8 Gb de RAM, √© muito prov√°vel que ele n√£o seja importado ou mesmo criado como um objeto dentro do ambiente R. Existem solu√ß√µes para esses problemas, mas n√£o as abordaremos neste cap√≠tulo.

**Vetor**

Como vimos, os arquivos vetoriais s√£o disponibilizados em diversos formatos. Para sabermos se um determinado formato pode ser importado ou exportado utilizando o pacote `sf`, podemos utilizar a fun√ß√£o `sf::st_drivers()`. Uma amostra desses formatos √© apresentado na Tabela \@ref(tab:tab-vetor-formatos).

```{r eval=FALSE}
## Formatos vetoriais importados e exportados pelo pacote sf
head(sf::st_drivers())
```

```{r tab-vetor-formatos, echo=FALSE}
da <- head(st_drivers())
rownames(da) <- NULL
knitr::kable(
    da,
    caption = "Alguns formatos vetoriais importados e exportados pelo pacote `sf`."
)
```

**Importar dados vetoriais existentes**

Para importar vetores existentes para o R, utilizaremos a fun√ß√£o `sf::st_read()`. A estrutura √© semelhante para todos os formatos descritos na Tabela \@ref(tab:tab-vetor-formatos), de modo que sempre preencheremos o argumento `dsn` (*data source name*) com o nome do arquivo a ser importado. Entretanto, para banco de dados, como *GeoPackage*, pode ser necess√°rio especificar a camada que se tem interesse com um segundo argumento chamado `layer`, com o nome da camada.

Para quase todas as opera√ß√µes vetoriais nesse cap√≠tulo, usaremos os dados dispon√≠veis para o munic√≠pio de Rio Claro/SP. Primeiramente, baixaremos esses dados da [FBDS (Funda√ß√£o Brasileira para o Desenvolvimento Sustent√°vel)](https://www.fbds.org.br/), atrav√©s desse [reposit√≥rio de dados](http://geo.fbds.org.br/). Em 2013, a FBDS deu in√≠cio ao Projeto de Mapeamento em Alta Resolu√ß√£o dos Biomas Brasileiros, mapeando a cobertura da terra, hidrografia (nascentes, rios e lagos) e √Åreas de Preserva√ß√£o Permanente (APPs). O mapeamento foi conclu√≠do para os munic√≠pios dos Biomas Mata Atl√¢ntica e Cerrado, e mais recentemente para os outros biomas. Para fazer o download dos arquivos de interesse, utilizaremos o R, atrav√©s da fun√ß√£o `download.file()`.

Primeiramente, criaremos um diret√≥rio com a fun√ß√£o `create.dir()`, usando a fun√ß√£o `here::here()` para indicar o reposit√≥rio (ver o Cap√≠tulo \@ref(cap5)).

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados"))
dir.create(here::here("dados", "vetor"))
```

Em seguida, vamos fazer o download de pontos de nascentes, linhas de hidrografia e pol√≠gonos de cobertura da terra para o munic√≠pio de Rio Claro/SP.

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
for(i in c(".dbf", ".prj", ".shp", ".shx")){
    
    # Pontos de nascentes
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_NASCENTES", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_NASCENTES", i)), mode = "wb")
    
    # Linhas de hidrografia
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_RIOS_SIMPLES", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_RIOS_SIMPLES", i)), mode = "wb")
    
    # Pol√≠gonos de cobertura da terra
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/USO/SP_3543907_USO", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_USO", i)), mode = "wb")
}
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_nascentes
ecodados::geo_vetor_hidrografia
ecodados::geo_vetor_cobertura
```

Agora podemos importar esses dados para o R. Primeiro vamos importar as nascentes (Figura \@ref(fig:fig-vetor-nascentes)).

```{r}
## Importar nascentes
geo_vetor_nascentes <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_NASCENTES.shp"), quiet = TRUE)
```

```{r fig-vetor-nascentes, fig.cap="Mapa de nascentes de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes[1], pch = 20, col = "blue", main = NA, 
     axes = TRUE, graticule = TRUE)
```

Agora vamos importar a hidrografia (Figura \@ref(fig:fig-vetor-hidrografia)).

```{r}
## Importar hidrografia
geo_vetor_hidrografia <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_RIOS_SIMPLES.shp"), quiet = TRUE)
```

```{r fig-vetor-hidrografia, fig.cap="Mapa da hidrografia de Rio Claro/SP."}
## Plot
plot(geo_vetor_hidrografia[1], col = "steelblue", main = NA, axes = TRUE, graticule = TRUE)
```

E por fim, vamos importar a cobertura da terra (Figura \@ref(fig:fig-vetor-cobertura)).

```{r}
## Importar cobertura da terra
geo_vetor_cobertura <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_USO.shp"), quiet = TRUE)
```

```{r fig-vetor-cobertura, fig.cap="Mapa de cobertura da terra de Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura[5], 
     col = c("blue", "orange", "gray30", "forestgreen", "green"), 
     main = NA, axes = TRUE, graticule = TRUE)
legend(x = .1, y = .3, pch = 15, cex = .7, pt.cex = 2.5, 
       legend = (geo_vetor_cobertura$CLASSE_USO), 
       col = c("blue", "orange", "gray30", "forestgreen", "green"))
```

**Importar utilizando pacotes**

Al√©m de dados existentes, podemos importar dados vetoriais de pacotes, como listado anteriormente na Tabela \@ref(tab:tab-packages-bases). Para o Brasil, o pacote mais interessante trata-se do [`geobr`](https://ipeagit.github.io/geobr/), do [Instituto de Pesquisa Econ√¥mica Aplicada (IPEA)](https://www.ipea.gov.br/portal/), que possui dados oficiais do [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)](https://www.ibge.gov.br/).

√â poss√≠vel listar todos os dados dispon√≠veis no pacote atrav√©s da fun√ß√£o `geobr::list_geobr()`. Na Tabela \@ref(tab:tab-vetor-dados-geobr) √© poss√≠vel ver alguns desses dados.

```{r eval=FALSE}
## Listar todos os dados do geobr
geobr::list_geobr()
```

```{r tab-vetor-dados-geobr, echo=FALSE}
knitr::kable(
    head(geobr::list_geobr()),
    caption = "Alguns dados dispon√≠veis no pacote `geobr`."
)
```

Como exemplo, vamos fazer o download o limite do munic√≠pio de Rio Claro/SP, utilizando o c√≥digo do munic√≠pio (3543907) (Figura \@ref(fig:fig-vetor-rio-claro)).

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para saber todos os c√≥digos dos munic√≠pios do Brasil, recomendamos a verifica√ß√£o no [site do IBGE](https://www.ibge.gov.br/explica/codigos-dos-municipios.php).
:::

```{r}
## Pol√≠gono do limite do munic√≠pio de Rio Claro
geo_vetor_rio_claro <- geobr::read_municipality(code_muni = 3543907, 
                                                year = 2020, showProgress = FALSE)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_rio_claro
```

```{r fig-vetor-rio-claro, fig.cap="Limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

J√° para o mundo, o pacote mais interessante trata-se do [`rnaturalearth`](https://docs.ropensci.org/rnaturalearth/), que faz o download de dados do [Natural Earth](https://www.naturaleatoriorthdata.com/). Vamos fazer o download do limite do Brasil (Figura \@ref(fig:fig-vetor-brasil)).

```{r}
## Pol√≠gono do limite do Brasil
geo_vetor_brasil <- rnaturalearth::ne_countries(scale = "large", 
                                                country = "Brazil", returnclass = "sf")
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_brasil
```

```{r fig-vetor-brasil, fig.cap="Limite do Brasil."}
## Plot
plot(geo_vetor_brasil[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

**Criar um objeto espacial de uma tabela de coordenadas**

√â muito comum em coletas de campo ou bases de dados, ter coordenadas de locais de estudo ou de ocorr√™ncias de esp√©cies organizadas em tabelas. Essas tabelas devem possuir duas colunas: longitude e latitude, ou X e Y para dados UTM, por exemplo. Ao import√°-las para o R, o formato que assumem pode ser de uma das classes: `matrix`, `data frame` ou `tibble`, ou seja, ainda n√£o s√£o da classe vetorial `sf`. Nesta se√ß√£o iremos ver como fazer essa convers√£o.

Para tanto, vamos usar os dados de comunidades de anf√≠bios da Mata Atl√¢ntica (Atlantic Amphibians, Vancine et al. [-@vancine2018]). Faremos o download diretamente do site da fonte dos dados. Antes vamos criar um diret√≥rio.

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados", "tabelas"))
```

Em seguida, vamos fazer o download de um arquivo `.zip` e vamos extrair usando a fun√ß√£o `unzip()` nesse mesmo diret√≥rio.

```{r eval=FALSE}
## Download
download.file(url = "https://esajournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fecy.2392&file=ecy2392-sup-0001-DataS1.zip",
              destfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"),
      exdir = here::here("dados", "tabelas"))
```

Agora podemos importar a tabela de dados com a fun√ß√£o `readr::read_csv()`.

```{r}
## Importar tabela de locais
geo_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    locale = readr::locale(encoding = "latin1")
)
geo_anfibios_locais
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_anfibios_locais
```

Por fim, podemos facilmente criar um objeto espacial do tipo `MULTIPOINT` utilizando a fun√ß√£o `sf::st_as_sf()`. Podemos ver essas coordenadas plotadas no mapa simples da Figura \@ref(fig:fig-vetor-pontos-atlantic-amphibians).

√â necess√°rio antes se ater ao argumento `coords` que deve indicar as colunas de longitude e latitude, nessa ordem; e tamb√©m ao argumento `crs` para indicar o CRS correspondente dessas coordenadas, que aqui sabemos se tratar de coordenadas geogr√°ficas e datum WGS84. Ent√£o podemos facilmente utilizar o c√≥digo EPSG 4326. Entretanto, se as coordenadas estiverem em metros, por exemplo, teremos de nos ater a qual CRS as mesmas foram coletadas, ou seja, se forem coordenadas de GPS, √© preciso saber como o GPS estava configurado (proje√ß√£o e datum).

```{r}
## Converter dados tabulares para sf
geo_anfibios_locais_vetor <- geo_anfibios_locais %>% 
    sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
geo_anfibios_locais_vetor
```

```{r fig-vetor-pontos-atlantic-amphibians, fig.cap="Coordenadas das comunidades do Atlantic Amphibians [@vancine2018]."}
## Plot
plot(geo_anfibios_locais_vetor[1], pch = 20, col = "black", 
     main = NA, axes = TRUE, graticule = TRUE)
```

**Converter dados espaciais sp para sf**

O pacote `sf` √© mais recente e mais f√°cil de manipular objetos vetoriais no R. Seu predecessor, o pacote `sp` possui uma classe pr√≥pria e hom√¥nima. Entretanto, muitos pacotes de an√°lises espaciais ainda utilizam essa classe em suas fun√ß√µes, apesar dessa migra√ß√£o ter ocorrido rapidamente recentemente. Dessa forma, a convers√£o entre essas classes pode ser necess√°ria em alguns momentos.

Abaixo, veremos como podemos fazer essa convers√£o facilmente. Primeiramente, vamos importar dados `sp`.

```{r}
## Pol√≠gonos pa√≠ses sp
co110_sp <- rnaturalearth::countries110
class(co110_sp)
```

Agora, podemos converter facilmente com a fun√ß√£o `sf::st_as_sf()`.

```{r}
## Pol√≠gonos pa√≠ses sf
co110_sf <- sf::st_as_sf(co110_sp)
class(co110_sf)
```

Podemos facilmente converter esse objeto novamente para a classe `sp` com a fun√ß√£o `sf::as_Spatial()`.

```{r}
## Pol√≠gonos pa√≠ses sp
co110_sp <- sf::as_Spatial(co110_sf)
class(co110_sp)
```

**Raster**

Para importar dados raster no R, utilizaremos a fun√ß√£o `raster::raster()`, `raster::brick()` ou `raster::stack()`. Para apenas uma camada raster, usaremos a fun√ß√£o `raster::raster()`, com o argumento `x` sendo o nome do arquivo. J√° para mais camadas, usaremos `raster::brick()` para um arquivo que possua m√∫ltiplas camadas, ou ainda a fun√ß√£o `raster::stack()` para v√°rios arquivos em diferentes camadas tamb√©m no argumento `x`, sendo necess√°rio listar os arquivos no diret√≥rio, geralmente utilizando a fun√ß√£o `dir()` ou `list.files()`. Entretanto, para especificar uma camada, podemos utilizar o argumento `band` ou `layer` e o nome dessa camada.

**Raster Layer**

Primeiramente, vamos criar um diret√≥rio para os dados raster que fazeremos o download.

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados", "raster"))
```

Em seguida, vamos fazer o download de dados de eleva√ß√£o, na verdade dados de Modelo Digital de Eleva√ß√£o (*Digital Elevation Model* - DEM), localizados tamb√©m para o munic√≠pio de Rio Claro. Utilizaremos os dados do [*Shuttle Radar Topography Mission - SRTM*](https://srtm.csi.cgiar.org/). Para saber mais sobre esses dados, recomendamos a leitura do artigo de Farr et al. [-@farr_shuttle_2007].

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
download.file(url = "https://srtm.csi.cgiar.org/wp-content/uploads/files/srtm_5x5/TIFF/srtm_27_17.zip",
              destfile = here::here("dados", "raster", "srtm_27_17.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "raster", "srtm_27_17.zip"),
      exdir = here::here("dados", "raster"))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_srtm
```

Agora podemos importar essa camada para o R, e visualiz√°-la em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-dem)).

```{r}
## Importar raster de altitude
geo_raster_srtm <- raster::raster(here::here("dados", "raster", "srtm_27_17.tif"))
geo_raster_srtm
```

```{r fig-raster-dem, fig.cap="Camada raster do DEM em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Raster Stack**

Al√©m dos dados de eleva√ß√£o, dados de temperatura e precipita√ß√£o podem ser obtidos do [WorldClim](https://www.worldclim.org/). Para saber mais sobre esses dados, recomendamos a leitura do artigo Fick & Hijmans [-@fick_worldclim_2017].

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
download.file(url = "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_10m_bio.zip",
              destfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"),
      exdir = here::here("dados", "raster"))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_bioclim
```

Para importar essa s√©rie de camadas, primeiramente listaremos os arquivos e depois importar no formato `RasterStack` (Figura \@ref(fig:fig-raster-wc)).

```{r}
## Listar arquivos
arquivos_raster <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
    grep(".tif", ., value = TRUE)
arquivos_raster

## Importar v√°rios rasters como stack
geo_raster_bioclim <- raster::stack(here::here("dados", "raster", arquivos_raster))
geo_raster_bioclim
```

```{r fig-raster-wc, fig.cap="Camadas rasters do WorldClim (BIO01 e BIO12) para o mundo."}
## Plot
plot(geo_raster_bioclim[[c(1, 4)]], col = viridis::viridis(10))
```

### Exportar dados

Saber a melhor forma de exportar dados geoespaciais de objetos rec√©m-criados no R √© fundamental, principalmente porque essa a√ß√£o depender√° do tipo de dado (vetor ou raster), classe do objeto (por exemplo, `MULTIPOINT` ou `RasterLayer`) e tipo e quantidade de informa√ß√µes armazenadas (por exemplo, tamanho do objeto, intervalo de valores, etc.).

**Vetor**

Para dados vetoriais, a principal fun√ß√£o utilizada √© a `sf::st_write()`. Essa fun√ß√£o permite gravar objetos `sf` em v√°rios formatos de arquivos vetoriais, como `.shp`, `.gpkg` ou `.geojson`. O formato a ser exportado vai influenciar na velocidade do processo de grava√ß√£o.

Os argumentos dessa fun√ß√£o ser√° o `obj` que √© o objeto `sf` criado no ambiente R, e o `dsn` (*data source name*), ou seja, o nome que o arquivo ter√° ao ser exportado do R, de modo que o complemento `.shp` no nome de sa√≠da, por exemplo, definir√° que o arquivo ter√° a extens√£o `ESRI Shapefile`. Entretanto, essa extens√£o pode ser definida tamb√©m utilizando o argumento `driver`, com as possibilidades listadas nesse [site](https://gdal.org/drivers/vector/index.html).

```{r eval=FALSE}
## Exportar o pol√≠gono de Rio Claro na extens√£o ESRI Shapefile
sf::st_write(obj = geo_vetor_rio_claro, 
             dsn = here::here("dados", "vetor", "geo_vetor_rio_claro.shp"))
```

Ou podemos ainda exportar o objeto vetorial na extens√£o `GeoPackage`. Entretanto, aqui √© interessante acrescentar um argumento chamado `layer` para definir o nome das camadas a serem exportadas no mesmo arquivo `GeoPackage`, por exemplo.

```{r eval=FALSE}
## Exportar o pol√≠gono de Rio Claro na extens√£o Geopackage
sf::st_write(obj = geo_vetor_rio_claro, 
             dsn = here::here("dados", "vetor", "vetores.gpkg"), 
             layer = "rio_claro")
```

Ainda sobre o formato `GeoPackage`, h√° algo muito interessante que podemos fazer: podemos acrescentar outros arquivos vetoriais ao mesmo arquivo j√° criado. Como exemplo, exportaremos o limite do Brasil para o mesmo arquivo.

```{r eval=FALSE}
## Exportar o pol√≠gono do Brasil na extens√£o Geopackage
sf::st_write(obj = geo_vetor_brasil, 
             dsn = here::here("dados", "vetor", "vetores.gpkg"), 
             layer = "brasil")
```

**Raster**

Para exportar dados raster utilizamos geralmente a fun√ß√£o `raster::writeRaster()`. Exportar dados raster √© um pouco mais complexo que exportar dados vetoriais. Teremos de definir se exportaremos arquivos em uma ou v√°rias camadas, quantidade de informa√ß√µes por pixel, e ainda diferentes extens√µes de sa√≠da. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Arquivos raster escritos em discos geralmente ocupam bastante espa√ßo, e dessa forma, h√° par√¢metros espec√≠ficos para certos tipos de dados, que detalharemos a seguir para contornar esse problema e comprimir os arquivos.
:::

Na fun√ß√£o `raster::writeRaster()`, o argumento `x` diz respeito ao objeto raster no ambiente R. O argumento `filename` √© nome do arquivo que ser√° exportado do R, podendo ou n√£o possuir a extens√£o que se pretende que o arquivo tenha. O argumento `format` √© o formato do arquivo, sendo as principais possibilidades resumidas na Tabela \@ref(tab:tab-raster-formatos), e para saber das possibilidades suportadas, use a fun√ß√£o `raster::writeFormats()`. O argumento `bylayer` diz se m√∫ltiplas camadas ser√£o exportada em arquivos diferentes ou em apenas um arquivo.

```{r tab-raster-formatos, echo=FALSE}
knitr::kable(
    tibble(
        `Tipo de arquivo` = c("raster", "ascii", "SAGA", "IDRISI", "CDF", "GTiff", "ENVI", "EHdr", "HFA"), 
        `Nome longo` = c("Formato pacote raster", "ESRI Ascii", "SAGA GIS", "IDRISI", "netCDF (requer ncdf4)", "GeoTiff (requer rgdal)", "ENVI .hdr", "ESRI .hdr", "Erdas imagem (.img)"),
        Extens√£o = c(".grd", ".asc", ".sdat", ".rst", ".nc", ".tif", ".envi", ".bil", ".img"),
        `Suporte a m√∫ltiplas camadas` = c("Sim", "N√£o", "N√£o", "N√£o", "Sim", "Sim", "Sim", "Sim", "Sim")), 
    caption = "Principais formatos de arquivos raster exportados do R.")
```

Dentre os argumentos adicionais, temos ainda o `datatype`, que faz refer√™ncia a um dos nove tipos de formato de dados detalhados na Tabela \@ref(tab:tab-raster-tipos), sendo que o tipo de dado determina a representa√ß√£o em bits (quantidade de informa√ß√£o) na c√©lula do objeto raster exportado e depende da faixa de valores do objeto raster em cada pixel. Quanto mais valores um tipo de dado puder representar, maior ser√° o arquivo exportado no disco. Dessa forma, √© interessante utilizar um tipo de dado que diminua o tamanho do arquivo a ser exportado, dependendo do tipo de dado em cada pixel. Para a fun√ß√£o `raster::writeRaster()`, o default √© `FLT4S`, o que pode ocupar mais espa√ßo em disco do que o necess√°rio.

```{r tab-raster-tipos, echo=FALSE}
knitr::kable(
    tibble(
        `Tipo de dado` = c("LOG1S", "INT1S", "INT1U", "INT2S", "INT2U", "INT4S", "INT4U", "FLT4S", "FLT8S"), 
        `Valor m√≠nimo` = c("FALSE (0)",	"-127",	"0", "-32.767", "0", "-2.147.483.647", "0", "-3,4e+38", "-1,7e+308"),
        `Valor m√°ximo` = c("TRUE (1)",	"127",	"255", "32.767", "65534", "2.147.483.647", "42.94.967.296", "3,4e+38", "1,7e+308")), 
    caption = "Tipos de dados suportados pelo pacote `raster`."
)
```

Outros argumentos de suporte s√£o: `overwrite` para sobrescrever um arquivo que j√° exista, `progress` para mostrar uma barra de progresso da exporta√ß√£o como "text" ou "window", e `options` que permite op√ß√µes do GDAL. Para esse √∫ltimo , quando exportar especificamente na extens√£o `GeoTIFF`, podemos utilizar `options = c("COMPRESS=DEFLATE", "TFW=YES")` para que haja compress√£o do arquivo, diminuindo consideravelmente seu tamanho (cerca de um ter√ßo), aliado √† cria√ß√£o de um arquivo auxiliar `.tfw`, para ser carregado em softwares espec√≠ficos de SIG, como o ArcGIS.

Para exportar apenas uma camada `RasterLayer`, podemos utilizar a fun√ß√£o `raster::writeRaster()` em um formato mais simples.

```{r eval=FALSE}
## Criar diret√≥rio
dir.create(here::here("dados", "raster", "exportados"))

## Exportar raster layer
raster::writeRaster(geo_raster_srtm, 
                    filename = here::here("dados", "raster", "exportados", "elevation"),
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=DEFLATE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

Para mais de uma camada `RasterBrick` ou `RasterStack`, podemos utilizar a fun√ß√£o `raster::writeRaster()` com mais s, como o `bylayer = TRUE`.

```{r eval=FALSE}
## Exportar raster stack
raster::writeRaster(x = geo_raster_bioclim, 
                    filename = here::here("dados", "raster", "exportados", names(geo_raster_bioclim)),
                    bylayer = TRUE, 
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=DEFLATE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

## Descri√ß√£o de objetos geoespaciais

Muitas vezes precisaremos verificar as informa√ß√µes dos objetos geoespaciais importados para o R. Apesar de chamar o objeto trazer grande parte das informa√ß√µes que precisamos consultar, existem fun√ß√µes espec√≠ficas que nos auxiliam nesse processo de descri√ß√£o dos objetos.

### Vetor

Podemos acessar as informa√ß√µes geoespaciais e a tabela de atributos de um objeto importado como vetor simplesmente chamando o nome do objeto no R.

```{r}
## Munic√≠pio de Rio Claro
geo_vetor_rio_claro
```

Mas tamb√©m podemos acessar informa√ß√µes geoespaciais com fun√ß√µes espec√≠ficas, como tipo de geometria, limites geoespaciais do vetor (extens√£o), sistema de refer√™ncia de coordenadas (CRS), e a tabela de atributos.

```{r}
## Tipo de geometria
sf::st_geometry_type(geo_vetor_rio_claro)

## Extens√£o
sf::st_bbox(geo_vetor_rio_claro)

## CRS
sf::st_crs(geo_vetor_rio_claro)

## Acessar a tabela de atributos
geo_vetor_rio_claro_tab <- sf::st_drop_geometry(geo_vetor_rio_claro)
geo_vetor_rio_claro_tab
```

### Raster

Da mesma forma, podemos acessar as informa√ß√µes objetos raster chamando o nome do objeto.

```{r}
## Raster layer
geo_raster_srtm
```

Al√©m disso, podemos selecionar informa√ß√µes desse objeto com fun√ß√µes espec√≠ficas, tanto para `RasterLayer`, quanto para `RasterBrick` ou `RasterStack` como: classe, dimens√µes (n√∫mero de linhas, colunas e camadas), n√∫mero de camadas, n√∫mero de linhas, n√∫mero de colunas, n√∫mero de c√©lulas, resolu√ß√£o (largura e altura do tamanho do pixel), extens√£o (limites geoespaciais), sistema de refer√™ncia de coordenadas (CRS), nome das camadas e extrair os valores de todos os pixels.

```{r}
## Classe
class(geo_raster_srtm)

## Dimens√µes
dim(geo_raster_srtm)

## N√∫mero de camadas
nlayers(geo_raster_srtm)

## N√∫mero de linhas
nrow(geo_raster_srtm)

## N√∫mero de colunas
ncol(geo_raster_srtm)

## N√∫mero de c√©lulas
ncell(geo_raster_srtm)

## Resolu√ß√£o
res(geo_raster_srtm)

## Extens√£o
extent(geo_raster_srtm)

## Proje√ß√£o ou CRS
projection(geo_raster_srtm)

## Nomes
names(geo_raster_srtm)

## Valores
getValues(geo_raster_srtm) %>% head
values(geo_raster_srtm) %>% head
geo_raster_srtm[] %>% head
```

## Reproje√ß√£o de dados geoespaciais

Em algumas situa√ß√µes √© necess√°rio alterar o CRS de um objeto espacial para um novo CRS. A reproje√ß√£o √© justamente a transforma√ß√£o de coordenadas de um CRS para outro: geoespaciais ('lon/lat', com unidades em graus de longitude e latitude) e projetados (normalmente com unidades de metros a partir de um datum).

Geralmente precisaremos fazer essa opera√ß√£o para transformar camadas vetoriais ou rasters para o mesmo CRS, de modo que possam ser exibidas conjuntamente, ou ainda que as camadas possuem CRS projetado para realizar alguma opera√ß√£o espacial entre camadas, ou quando precisamos calcular √°reas, formatos ou dist√¢ncias, como m√©tricas de paisagem, por exemplo. Existe uma infinidade de proje√ß√µes e um excelente material de consulta √© o livro de Lapaine & Usery [-@lapaine2017].

Podemos verificar o CRS de uma camada atrav√©s da fun√ß√£o `sf::st_crs()` ou `raster::projection()` e `raster::crs()`, ou ainda, saber se a mesma possui um CRS geogr√°fico ou n√£o, com a fun√ß√£o `sf::st_is_longlat()`.

J√° para reprojetar um objeto `sf` usamos a fun√ß√£o `sf::st_transform()` e para um objeto `raster` usamos a fun√ß√£o `raster::projectRaster()`.

```{r}
## Proje√ß√£o de vetores
sf::st_crs(geo_vetor_rio_claro)

## Proje√ß√£o de raster
raster::projection(geo_raster_srtm)
raster::crs(geo_raster_srtm)

## Verificar se o CRS √© geogr√°fico
sf::st_is_longlat(geo_vetor_rio_claro)
```

As fun√ß√µes `sf::st_transform()` e `raster::projectRaster()` possuem dois argumentos importantes: `x` que √© o objeto a ser reprojetado e o `crs` que √© o CRS alvo. O argumento `crs` pode ser especificado de quatro maneiras: i) c√≥digo EPSG (por exemplo, 4326), ii) string PROJ4 (por exemplo, `+ proj = longlat + datum = WGS84 + no_defs`), iii) string WKT, ou iv) objeto `crs` de outra camada, conforme retornado por `sf::st_crs()` ou `raster::crs()`. Esas informa√ß√µes de EPSG, PROJ4 e WKT podem ser acessadas nas bases: [epsg.io](http://epsg.io/) e [spatialreference.org](https://spatialreference.org/).

Dentre os poss√≠veis CRSs a serem utilizados, alguns s√£o mais comuns para CRSs geoespaciais e projetados. Para CRSs geoespaciais, o mais comum para o mundo √© o World Geodetic System 1984 (WGS84), ou seja, geogr√°fico com datum WGS84. Para o Brasil, o CRS adotado √© o [Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/), ou seja, geogr√°fico com datum SIRGAS2000.

Para CRSs projetados, essa escolha vai depender da extens√£o e localiza√ß√£o da √°rea de interesse no globo terrestre. Aqui destacaremos os principais, para tr√™s escalas: global, regional e local. Para a escala global, geralmente usa-se umas dessas proje√ß√µes, dependendo do objetivo: i) Proje√ß√£o de Mollweide, ii) Proje√ß√£o de Winkel Tripel, iii) Proje√ß√£o de Eckert IV, iv) Proje√ß√£o Azimutal de Lambert. Para a escala regional, como um hemisf√©rio, geralmente usa-se a Proje√ß√£o C√¥nica de Albers. Por fim, para a escala local, usa-se geralmente a Proje√ß√£o Universal Transverse Mercator (UTM), um conjunto de CRSs que divide a Terra em 60 cunhas longitudinais e 20 segmentos latitudinais, como pode ser visto neste [link](http://www.dmap.co.uk/utmworld.htm).

Os principais CRSs s√£o descritos na Tabela \@ref(tab:tab-crs).

```{r tab-crs, echo=FALSE}
knitr::kable(
    tibble(
        CRS = c("World Geodetic System 1984 (WGS84)", 
                "Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)",
                "Proje√ß√£o de Mollweide", 
                "Proje√ß√£o de Winkel Tripel", 
                "Proje√ß√£o de Eckert IV", 
                "Proje√ß√£o Azimutal de Lambert",
                "Proje√ß√£o C√¥nica de Albers",
                "Proje√ß√£o Universal Transverse Mercator (UTM)"),
        `Tipo de CRS` = c("Geogr√°fico", 
                          "Geogr√°fico", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado"),
        Descri√ß√£o = c("CRS geogr√°fico mais comum para o mundo", 
                      "CRS geogr√°fico oficial para o Brasil", 
                      "CRS projetado que  preserva as rela√ß√µes de √°rea", 
                      "CRS projetado com m√≠nimo de distor√ß√£o para √°rea, dire√ß√£o e dist√¢ncia", 
                      "CRS projetado que preserva a √°rea e com meridianos el√≠pticos", 
                      "CRS projetado que preserva os tamanhos relativos e senso de dire√ß√£o a partir do centro", 
                      "CRS projetado para escala regional, mantendo a √°rea constante em toda sua superf√≠cie", 
                      "CRS projetado para escala local, distorcendo √°reas e dist√¢ncias com gravidade crescente com a dist√¢ncia do centro da zona UTM"),
        epsg.io = c("[EPSG:4326](http://epsg.io/4326)", 
                    "[EPSG:4674](http://epsg.io/4674)",
                    "[ESRI:54009](https://epsg.io/54009)", 
                    NA, 
                    "[EPSG:54012](https://epsg.io/54012)", 
                    NA, 
                    NA, 
                    "[EPSG:31983](https://epsg.io/31983)"),
        spatialreference.org = c("[EPSG:4326](https://spatialreference.org/ref/epsg/4326/)",
                                 "[EPSG:4674](https://spatialreference.org/ref/epsg/4674/)",
                                 "[SR-ORG:7099](https://spatialreference.org/ref/sr-org/7099/)",
                                 "[SR-ORG:7291](https://spatialreference.org/ref/sr-org/7291/)",
                                 "[ESRI:54012](https://spatialreference.org/ref/esri/54012/)",                      
                                 NA,
                                 "[SR-ORG:7823](https://spatialreference.org/ref/sr-org/7823/)",
                                 "[EPSG:31983](https://spatialreference.org/ref/epsg/31983/)")), 
    caption = "Principais CRSs utilizados."
)
```

### Vetor

Como dissemos, para reprojetar um vetor, utilizamos a fun√ß√£o `sf::st_transform()`, observando os argumentos `x` que √© a camada a ser reprojetada, e o `crs` que √© o CRS alvo.

Vamos reprojetar o limite do munic√≠pio de Rio Claro/SP do CRS SIRGAS2000/geogr√°fico para o CRS projetado SIRGAS2000/UTM23S, com os efeitos da transforma√ß√£o podendo ser notados na Figura \@ref(fig:fig-vetor-crs-trans).

```{r}
## Converter CRS
geo_vetor_rio_claro_sirgas2000_utm23s <- sf::st_transform(x = geo_vetor_rio_claro, 
                                                          crs = 31983)
```

```{r fig-vetor-crs-trans, echo=FALSE, fig.cap="Limites do munic√≠pio de Rio Claro/SP com CRS SIRGAS2000/geogr√°fico e com CRS SIRGAS2000/UTM23S."}
p1 <- ggplot() +
    geom_sf(data = geo_vetor_rio_claro) +
    coord_sf(datum = sf::st_crs(4674)) +
    labs(x = "Longitude", y = "Latitude", title = "SIRGAS2000/Geogr√°fico") + 
    theme_bw() +
    theme(axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
          panel.grid = element_line(size = .3, color = "black", linetype = 2))

p2 <- ggplot() +
    geom_sf(data = geo_vetor_rio_claro) +
    coord_sf(datum = sf::st_crs(31983)) +
    labs(x = "X", y = "Y", title = "SIRGAS2000/UTM23S") + 
    theme_bw() +
    theme(axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
          panel.grid = element_line(size = .3, color = "black", linetype = 2))

gridExtra::grid.arrange(p1, p2, nrow = 1)
```

Podemos ainda utilizar o formato `proj4string` no argumento `crs` para fazer a transforma√ß√£o. Vamos primeiramente plotar o mundo em WGS84/Geogr√°fico (Figura \@ref(fig:fig-vetor-mundo-wgs84)).

```{r fig-vetor-mundo-wgs84, fig.cap="Camada BIO01 para o mundo com CRS geogr√°fico e datum WGS84."}
## Plot
plot(co110_sf[1], col = "gray",  main = "WGS84/Geogr√°fio", graticule = TRUE)
```

Agora, reprojetaremos utilizando a Proje√ß√£o de Mollweide (Figura \@ref(fig:fig-vetor-mundo-moll)).

```{r}
## Proje√ß√£o de Mollweide 
co110_sf_moll <- sf::st_transform(x = co110_sf, crs = "+proj=moll")
```

```{r fig-vetor-mundo-moll, fig.cap="Camada BIO01 para o mundo com CRS Proje√ß√£o de Mollweide."}
## Plot
plot(co110_sf_moll[1], col = "gray", main = "Proje√ß√£o de Mollweide", graticule = TRUE)
```

Ou ainda podemos utilizar a Proje√ß√£o Azimutal de Lambert com alguns par√¢metros ajustados para centralizar a proje√ß√£o no Brasil (\@ref(fig:fig-vetor-mundo-laea)).

```{r}
## Proje√ß√£o Azimutal de Lambert
co110_sf_laea <- sf::st_transform(x = co110_sf, 
                                  crs = "+proj=laea +x_0=0 +y_0=0 +lon_0=-50 +lat_0=0")
```

```{r fig-vetor-mundo-laea, fig.cap="amada BIO01 para o mundo com CRS Proje√ß√£o Azimutal de Lambert centrado no Brasil."}
## Plot
plot(co110_sf_laea[1], col = "gray", main = "Proje√ß√£o Azimutal de Lambert", graticule = TRUE)
```

### Raster

A reproje√ß√£o de objetos raster n√£o √© uma tarefa t√£o simples quanto a reproje√ß√£o de vetores. Em vetores, a reproje√ß√£o altera as coordenadas de cada v√©rtice. Entretanto, como rasters s√£o compostos de c√©lulas retangulares do mesmo tamanho, a reproje√ß√£o do raster envolve a cria√ß√£o de um novo objeto raster, envolvendo duas opera√ß√µes espaciais separadas: i) reproje√ß√£o vetorial dos centroides celulares para outro CRS (i.e., muda a posi√ß√£o e tamanho do pixel) e, ii) c√°lculo de novos valores do pixel por meio de reamostragem (i.e., muda o valor do pixel).

A fun√ß√£o `raster::projectRaster()` possui alguns par√¢metros que necessitam de algumas especifica√ß√µes. O argumento `from` que √© o objeto raster de entrada que sofre a reproje√ß√£o. O argumento `to` √© um objeto raster do qual todas as propriedades dos CRSs, como extens√£o e resolu√ß√£o ser√£o associadas ao objeto raster indicado no argumento `from`. O argumento `res` permite ajustar a resolu√ß√£o do pixel de sa√≠da do objeto raster reprojetado.

O argumento `crs` aceita apenas as defini√ß√µes de `proj4string` extensas de um CRS em vez de c√≥digos EPSG concisos. Contudo, √© poss√≠vel usar um c√≥digo `EPSG` em uma defini√ß√£o de `proj4string` com `+init=epsg:EPSG`. Por exemplo, pode-se usar a defini√ß√£o `+init=epsg:4326` para definir CRS para WGS84 (c√≥digo EPSG de 4326). A biblioteca `PROJ` adiciona automaticamente o resto dos par√¢metros e os converte em `+init=epsg:4326 +proj=longlat +datum=WGS84 + no_defs + ellps=WGS84 + towgs84=0,0,0`.

O argumento `method` permite escolher entre os m√©todos `ngb` (vizinho mais pr√≥ximo) ou `biliniar` (interpola√ß√£o bilinear), sendo o primeiro mais indicado para reproje√ß√£o de rasters categ√≥ricos, pois os valores estimados devem ser iguais aos do raster original. O m√©todo `ngb` define cada novo valor de c√©lula para o valor da c√©lula mais pr√≥xima (centro) do raster de entrada. J√° o m√©todo `biliniar` √© indicado para raster cont√≠nuos e calcula o valor da c√©lula de sa√≠da com base nas quatro c√©lulas mais pr√≥ximas no raster original, sendo a m√©dia ponderada da dist√¢ncia dos valores dessas quatro c√©lulas. Existem outras formas de interpola√ß√£o, mas n√£o as abordaremos aqui.

Aqui, vamos reprojetar os dados de eleva√ß√£o para Rio Claro/SP. Para que esse processo seja mais r√°pido, iremos antes ajustar a extens√£o do raster para o limite do munic√≠pio usando a fun√ß√£o `raster::crop()` (Figura \@ref(fig:fig-raster-crop)). Essa fun√ß√£o √© melhor explicada na se√ß√£o de cortes e m√°scaras, mais adiante.

```{r}
## Ajuste do limite
geo_raster_srtm_rio_claro <- raster::crop(x = geo_raster_srtm, 
                                          y = geo_vetor_rio_claro)
geo_raster_srtm_rio_claro
```

```{r fig-raster-crop, fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Primeiramente, vamos reprojetar indicando uma proje√ß√£o e sem especificar o tamanho da c√©lula. Note que o tamanho da c√©lula vai se ajustar para valores diferentes, sendo portanto, pixels retangulares e n√£o quadrados.

```{r}
## Reproje√ß√£o
geo_raster_srtm_rio_claro_sirgas2000_utm23s <- raster::projectRaster(
    from = geo_raster_srtm_rio_claro, 
    crs = "+init=epsg:31983", 
    method = "bilinear")
geo_raster_srtm_rio_claro_sirgas2000_utm23s
```

Agora vamos reprojetar especificando o tamanho da c√©lula (Figura \@ref(fig:fig-raster-reproj)). Dessa forma, todas as c√©lulas ter√£o o mesmo, i.e., quadrados de 90 metros.

```{r}
## Reproje√ß√£o
geo_raster_srtm_rio_claro_sirgas2000_utm23s <- raster::projectRaster(
    from = geo_raster_srtm_rio_claro, 
    crs = "+init=epsg:31983", 
    method = "bilinear", 
    res = 90)
geo_raster_srtm_rio_claro_sirgas2000_utm23s
```

```{r fig-raster-reproj, fig.cap="Reproje√ß√£o do raster de eleva√ß√£o para SIRGAS2000/UTM23S especificado por um objeto e informando o tamanho da c√©lula."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s, 
     col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom,
     col = NA, border = "red", lwd = 2, add = TRUE)
```

Vamos tamb√©m reprojetar uma camada mundial da m√©dia de temperatura anual (BIO01), indicando o tamanho da c√©lula para 25.000 m (Figura \@ref(fig:fig-raster-reproj-celula-mundo)).

```{r}
## Reproje√ß√£o
geo_raster_bioclim_moll <- raster::projectRaster(
    from = geo_raster_bioclim[[1]], 
    crs = "+proj=moll",
    res = 25000, 
    method = "bilinear")
geo_raster_bioclim_moll
```

```{r fig-raster-reproj-celula-mundo, fig.cap="Reproje√ß√£o do raster de m√©dia de temperatura anual (BIO01) para Proje√ß√£o de Mollweide informando o tamanho da c√©lula."}
## Plot
plot(geo_raster_bioclim_moll, col = viridis::viridis(10))
plot(co110_sf_moll[1], col = NA, add = TRUE)
```

## Principais opera√ß√µes com dados geoespaciais

Nesta se√ß√£o veremos as principais fun√ß√µes para realizar opera√ß√µes com dados geoespaciais. Essas opera√ß√µes s√£o separadas conforme Lovelace et al. [-@lovelace2019] em: **Opera√ß√µes de atributos**, **Opera√ß√µes espaciais**, e **Opera√ß√µes geom√©tricas**.

### Opera√ß√µes de atributos

S√£o modifica√ß√£o de objetos geoespaciais baseado em informa√ß√µes n√£o espaciais associadas a dados geoespaciais, como a tabela de atributos ou valores das c√©lulas e nome das camadas dos rasters.

**Vetor**

As principais opera√ß√µes de atributos vetoriais s√£o com respeito √† tabela de atributos, sendo as principais: i) filtro, ii) jun√ß√£o, iii) agrega√ß√£o e iv) manipula√ß√£o da tabela de atributos. A lista de poss√≠veis opera√ß√µes √© longa, dessa forma, apresentaremos algumas opera√ß√µes utilizando as principais fun√ß√µes e listamos as demais fun√ß√µes e suas opera√ß√µes, que depender√£o de objetivos espec√≠ficos.

Quase todas as opera√ß√µes ser√£o as mesmas realizadas pelo pacote `dplyr` em uma tabela de dados (ver o Cap√≠tulo \@ref(cap5)), sendo algumas opera√ß√µes espec√≠ficas para alterar apenas campos da tabela de atributos e outras que refletem opera√ß√µes nas fei√ß√µes, ou seja, alterar√£o atrav√©s da tabela de atributos as caracter√≠sticas das fei√ß√µes. Essas fun√ß√µes e suas opera√ß√µes s√£o descritas com detalhes na Tabela (\@ref(tab:tab-vetor-operacoes-atributos)).

```{r tab-vetor-operacoes-atributos, echo=FALSE}
knitr::kable(
    tibble(
        Fun√ß√µes = c("`filter()`", 
                    "`slice()`", 
                    "`n_sample()`", 
                    "`group_by()`", 
                    "`summarise()`", 
                    "`select()`", 
                    "`pull()`", 
                    "`rename()`", 
                    "`mutate()`", 
                    "`*_join()`"),
        `Onde atua` = c("Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Atributos",
                        "Atributos",
                        "Atributos",
                        "Atributos",
                        "Atributos"),
        Descri√ß√£o = c("Selecionar fei√ß√µes por valores",
                      "Selecionar fei√ß√µes pela posi√ß√£o na tabela de atributos",
                      "Amostrar fei√ß√µes na tabela de atributos",
                      "Agrupar fei√ß√µes por valores da tabela de atributos",
                      "Opera√ß√µes com valores das fei√ß√µes na tabela de atributos, que acabam por dissolver as fei√ß√µes",
                      "Selecionar colunas da tabela de atributos",
                      "Selecionar uma coluna da tabela de atributos como vetor",
                      "Renomear uma coluna da tabela de atributos",
                      "Criar uma coluna ou alterar os valores da tabela de atributos",
                      "Diversas fun√ß√µes para juntar dados de outras tabelas de dados √† tabela de atributos")), 
    caption = "Principais fun√ß√µes para realizar opera√ß√µes de atributos e suas descri√ß√µes."
)
```

Para exemplificar as opera√ß√µes de atributos, vamos utilizar os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Filtro**

Vamos iniciar as opera√ß√µes fazendo o filtro de fei√ß√µes pela tabela de atributos, que permite selecionar fei√ß√µes pelos seus valores atribu√≠dos, utilizando a fun√ß√£o `dplyr::filter()`. Aqui vamos selecionar as fei√ß√µes de floresta do mapa de cobertura da terra para Rio Claro/SP (Figura \@ref(fig:fig-vetor-opat-filtro)).

```{r}
## Filtro
geo_vetor_cobertura_floresta <- geo_vetor_cobertura %>% 
    dplyr::filter(CLASSE_USO == "forma√ß√£o florestal")
```

```{r fig-vetor-opat-filtro, fig.cap="Filtro da classe floresta para o mapeamento de cobertura da terra para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
```

**Jun√ß√£o**

Uma das fun√ß√µes mais √∫teis de opera√ß√µes de atributos √© a jun√ß√£o, referida em ingl√™s como *join*, realizada atrav√©s das fun√ß√µes `dplyr::*_join()` (ver detalhes do Cap√≠tulo \@ref(cap5)). Nela, usamos uma coluna identificadora para atribuir dados de outra tabela de dados. Como exemplo, vamos criar uma tabela de dados com novos nomes das classes de cobertura da terra e atribuir esses novos nomes √† tabela de atributos do objeto vetorial. √â fundamental destacar que para que essa fun√ß√£o funcione, precisamos de uma coluna identificadora dos valores para que a jun√ß√£o seja poss√≠vel.

```{r}
## Dados
dados_classes <- tibble::tibble(
    CLASSE_USO = geo_vetor_cobertura$CLASSE_USO, 
    classe = c("agua", "antropico", "edificado", "floresta", "silvicultura"))
dados_classes
```

```{r}
## Jun√ß√£o
geo_vetor_cobertura_classes <- dplyr::left_join(
    x = geo_vetor_cobertura, 
    y = dados_classes, 
    by = "CLASSE_USO") %>% 
    sf::st_drop_geometry()
geo_vetor_cobertura_classes
```

**Agrega√ß√£o**

Outra fun√ß√£o bastante √∫til √© a agrega√ß√£o de atributos. Apesar de existir uma fun√ß√£o que realiza a uni√£o de fei√ß√µes que veremos na pr√≥xima se√ß√£o, o uso conjunto das fun√ß√µes `dplyr::group_by()` e `dplyr::summarise()` realizam uma tarefa semelhante. Aqui vamos agregar as nascentes para Rio Claro/SP, i.e., juntar cada ponto que estava numa linha da tabela de atributos de modo que todos fiquem numa mesma linha, com o valor da quantidade de nascentes (Figura \@ref(fig:fig-vetor-opat-agregar)).

```{r}
## Agregar
geo_vetor_nascentes_n <- geo_vetor_nascentes %>% 
    dplyr::group_by(MUNICIPIO, HIDRO) %>% 
    dplyr::summarise(n = n())
geo_vetor_nascentes_n
```

```{r fig-vetor-opat-agregar, fig.cap="Agrega√ß√£o e contagem das nascentes para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_nascentes_n$geometry, pch = 20, 
     col = "blue", add = TRUE)
```

**Manipula√ß√£o da tabela de atributos**

Por fim, √© muito comum em an√°lises de softwares SIG a cria√ß√£o ou atualiza√ß√£o dos valores de colunas na tabela de atributos. Aqui, podemos utilizar a fun√ß√£o `dplyr::mutate()` para criar essas novas colunas, assim como atualizar os valores de colunas existentes. Em nosso exemplo, fazeremos uma composi√ß√£o das colunas `CLASSE_USO` e `AREA_HA` numa nova coluna chamada `classe_area`.

```{r}
## Criar coluna
geo_vetor_cobertura_cob_col_area <- geo_vetor_cobertura %>% 
    dplyr::mutate(classe_area = paste0(CLASSE_USO, " (", AREA_HA, " ha)")) %>% 
    sf::st_drop_geometry()
geo_vetor_cobertura_cob_col_area
```

Duas fun√ß√µes s√£o bastante interessantes de serem integradas junto √† manipula√ß√£o de tabelas de atributos. Elas calculam propriedades geom√©tricas num√©ricas dos vetores de linhas (comprimento) e pol√≠gonos (√°rea): `sf::st_length()` e `sf::st_area()`. Essas fun√ß√µes calculam essas propriedades em metros para comprimento e em metros quadrados para √°rea, independentemente do CRS. Para tanto, vamos utilizar as linhas de hidrografia e os pol√≠gonos de cobertura da terra para Rio Claro/SP, e atribuir esses valores √† tabela de atributos de ambos os objetos geoespaciais, utilizando em conjunto a fun√ß√£o `dplyr::mutate()`.

```{r}
## Comprimento das linhas
geo_vetor_hidrografia_comp <- geo_vetor_hidrografia %>% 
    dplyr::mutate(comprimento = sf::st_length(.))
geo_vetor_hidrografia_comp
```

```{r}
## √Årea dos pol√≠gonos
geo_vetor_cobertura_area <- geo_vetor_cobertura %>% 
    dplyr::mutate(area_m2 = sf::st_area(.))
geo_vetor_cobertura_area
```

**Raster**

Devido √† estrutura espacial do raster ser formada por uma ou mais superf√≠cies cont√≠nuas, as manipula√ß√µes como subconjunto e outras opera√ß√µes em objetos raster funcionam de uma maneira diferente do que em objetos vetoriais. Veremos aqui as tr√™s principais: i) subconjunto de c√©lulas usando o operador `[]` ou subconjunto de camadas `RasterStack` ou `RasterBrick` utilizando os operadores `[[]]` e `$`, ii) renomear nomes das camadas, e iii) resumir informa√ß√µes de todos os pixels.

**Subconjunto**

Podemos fazer um subconjunto de c√©lulas utilizando dentro dos operadores `[]` valores para indicar a posi√ß√£o da linha e da coluna de um raster, ou ainda a posi√ß√£o de uma c√©lula utilizando apenas um n√∫mero. Essas opera√ß√µes resultar√£o em valores diferentes para `RasterLayer` e `RasterBrick` ou `RasterStack`.

```{r}
## Raster - linha 1 e columna 1
geo_raster_srtm[1, 1]

## Raster - c√©lula 1
geo_raster_srtm[1]

## Stack - linha 1 e columna 1
geo_raster_bioclim[1, 1]

## Stack - c√©lula 1
geo_raster_bioclim[1]
```

Para selecionar uma camada de um `RasterBrick` ou `RasterStack`, podemos utilizar as fun√ß√µes `raster::subset()` ou `raster::raster()` com o argumento `layer` indicando a ordem ou o nome da camada, al√©m dos operadores `[[]]` e `$` (Figura \@ref(fig:fig-raster-stack-subset)).

```{r}
## Sele√ß√£o de camada num objeto stack utilizando a fun√ß√£o subset
geo_raster_bioclim_bio01 <- raster::subset(geo_raster_bioclim, "wc2.1_10m_bio_1")
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando a fun√ß√£o raster
geo_raster_bioclim_bio01 <- raster::raster(geo_raster_bioclim, layer = 1)
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando os operadores [[]] e o nome
geo_raster_bioclim_bio01 <- geo_raster_bioclim[["wc2.1_10m_bio_1"]]
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando os operadores [[]] e a posicao
geo_raster_bioclim_bio01 <- geo_raster_bioclim[[1]]
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando o operador $
geo_raster_bioclim_bio01 <- geo_raster_bioclim$wc2.1_10m_bio_1
geo_raster_bioclim_bio01
```

```{r fig-raster-stack-subset, fig.cap="Camada BIO01 selecionada pelas opera√ß√µes de subconjunto."}
# Plot
plot(geo_raster_bioclim_bio01, col = viridis::viridis(10))
```

**Renomear**

Podemos ainda renomear camadas dos raster `RasterLayer` utilizando a fun√ß√£o `names()`.

```{r}
## Raster - nomes
names(geo_raster_srtm_rio_claro)

## Raster - renomear
names(geo_raster_srtm_rio_claro) <- "elevacao"

## Raster - nomes
names(geo_raster_srtm_rio_claro)
```

E essa opera√ß√£o tamb√©m funciona para `RasterBrick` e `RasterStack`.

```{r}
## Stack - nomes
names(geo_raster_bioclim)

## Stack - renomear
names(geo_raster_bioclim) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))

## Stack - nomes
names(geo_raster_bioclim)
```

**Resumir**

Muitas vezes queremos fazer c√°lculos para todos as c√©lulas de um raster. Podemos resumir informa√ß√µes de todos os pixels fazendo c√°lculos simples com todos os pixels de cada camada com a fun√ß√£o `raster::cellStats()`, sendo `x` o argumento do objeto raster e `stat` o nome da fun√ß√£o resumo, como "mean" ou "sum".

```{r}
## Raster - m√©dia de todas as c√©lulas de altitude
raster::cellStats(x = geo_raster_srtm_rio_claro, stat = mean)

## Stack - m√©dia de todas as c√©lulas de cada camada bioclim√°tica
raster::cellStats(x = geo_raster_bioclim, stat = mean)
```

Ou ainda, podemos analisar a frequ√™ncia com que cada valor dos pixels ocorre, utilizando a fun√ß√£o `raster::freq()`.

```{r}
## Raster - frequ√™ncia das c√©lulas
raster::freq(x = geo_raster_srtm_rio_claro) %>% head()

## Stack - frequ√™ncia das c√©lulas
raster::freq(x = geo_raster_bioclim[[1]]) %>% head()
```

### Opera√ß√µes espaciais

As opera√ß√µes espaciais s√£o modifica√ß√µes de objetos geoespaciais baseado em informa√ß√µes espaciais, como localiza√ß√£o e formato. Seria quase imposs√≠vel abordar todas as opera√ß√µes realiz√°veis nesse cap√≠tulo, ent√£o demonstraremos as principais para dados vetoriais e raster.

**Vetor**

As principais opera√ß√µes espaciais para dados vetoriais s√£o: i) filtro espacial, ii) jun√ß√£o espacial, iii) agrega√ß√£o espacial e iv) dist√¢ncia espacial. Apresentaremos essas opera√ß√µes utilizando as principais fun√ß√µes utilizando os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Filtro espacial**

Filtros espaciais s√£o opera√ß√µes que realizam sele√ß√£o de fei√ß√µes espaciais entre dois objetos geoespaciais (x e y). Existe uma grande quantidade de fun√ß√µes para realizar filtros espaciais no R, como podemos ver na Tabela (\@ref(tab:tab-filtro-espacial)). Essas fun√ß√µes verificam se cada fei√ß√£o em x mant√©m sua rela√ß√£o em y. Ao especificar o par√¢metro `sparse = FALSE`, as fun√ß√µes retornam uma matriz l√≥gica (composta por `TRUE` e `FALSE`).

```{r tab-filtro-espacial, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Fun√ß√£o = c("`sf::st_contains()`", 
                   "`sf::st_contains_properly()`", 
                   "`sf::st_covers()`", 
                   "`sf::st_covered_by()`", 
                   "`sf::st_crosses()`", 
                   "`sf::st_disjoint()`", 
                   "`sf::st_equals()`", 
                   "`sf::st_equals_exact()`", 
                   "`sf::st_intersects()`", 
                   "`sf::st_is_within_distance()`", 
                   "`sf::st_within()`", 
                   "`sf::st_touches()`", 
                   "`sf::st_overlaps()`", 
                   "`sf::st_relate()`"), 
        Descri√ß√£o = c("Nenhum dos pontos de x est√° fora de y", 
                      "x cont√©m y, e y n√£o tem pontos em comum com a fronteira de x", 
                      "Nenhum ponto de y se encontra no exterior de x", 
                      "Inverso de `sf::st_covers()`", 
                      "x e y t√™m alguns, mas n√£o todos os pontos internos em comum", 
                      "x e y n√£o t√™m pontos em comum", 
                      "x e y s√£o geometricamente iguais; o n√∫mero de pedido dos n√≥s pode ser diferente", 
                      "x e y s√£o geometricamente iguais e t√™m ordem de n√≥ id√™ntica", 
                      "x e y n√£o s√£o separados", 
                      "x est√° mais perto de y do que uma determinada dist√¢ncia", 
                      "Nenhum dos pontos de y est√° fora de x", 
                      "x e y t√™m pelo menos um ponto limite em comum, mas nenhum ponto interno", 
                      "x e y t√™m alguns pontos em comum; a dimens√£o destes √© id√™ntica √† de x e y", 
                      "Dado um padr√£o, retorna se x e y aderem a este padr√£o"),
        `Fun√ß√£o inversa` = c("`st_within`", 
                             NA,
                             "`st_covered_by`", 
                             NA, 
                             NA, 
                             "`st_intersects`", 
                             NA, 
                             NA, 
                             "`st_disjoint`", 
                             NA, 
                             "`st_contains`", 
                             NA, 
                             NA, 
                             NA)),
    caption = "Principais pacotes para composi√ß√£o de mapas no R."
)
```

Em nosso exemplo, utilizaremos a fun√ß√£o `sf::intersects()` para filtrar as nascentes dentro de floresta para Rio Claro/SP. Essa fun√ß√£o vai retornar a resposta bin√°ria se as nascentes est√£o (1) ou n√£o (empty) dentro dos pol√≠gonos de floresta.

```{r}
## Filtro espacial
sf::st_intersects(x = geo_vetor_nascentes, y = geo_vetor_cobertura_floresta)
```

Podemos usar essa mesma fun√ß√£o em conjunto com a fun√ß√£o `dplyr::filter()` para filtrar as nascentes dentro de florestas, mas agora com o argumento `sparse = FALSE` para valores l√≥gicos funcionarem com o filtro.

```{r}
## Filtro espacial - interno
geo_vetor_nascentes_floresta_int <- geo_vetor_nascentes %>% 
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_cobertura_floresta, sparse = FALSE))
```

Ou ainda podemos utilizar o operador `[]` para realizar esse filtro, como podemos notar na Figura \@ref(fig:fig-vetor-filtro-espacial-interno).

```{r}
## Filtro espacial com [] - interno
geo_vetor_nascentes_floresta_int <- geo_vetor_nascentes[geo_vetor_cobertura_floresta, ]
```

```{r fig-vetor-filtro-espacial-interno, fig.cap="Nascentes dentro de florestas no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
plot(geo_vetor_nascentes_floresta_int$geometry, col = "blue", pch = 20, cex = 1, add = TRUE)
```

Entretanto, muitas vezes queremos fazer o filtro de fei√ß√µes que est√£o fora de fei√ß√µes de outro objeto espacial. Para isso, podemos usar a fun√ß√£o `sf::st_disjoint()` ou ainda utilizando o operador `[]`, mas com o argumento `op`, nesse caso utilizando a mesma fun√ß√£o `sf::st_disjoint()` como opera√ß√£o (Figura \@ref(fig:fig-vetor-filtro-espacial-externo)). Atentar o segundo vazio nesse filtro.

```{r}
## Filtro espacial - externo
geo_vetor_nascentes_floresta_ext <- geo_vetor_nascentes %>% 
    dplyr::filter(sf::st_disjoint(x = ., y = geo_vetor_cobertura_floresta, sparse = FALSE))

## Filtro espacial com [] - externo
geo_vetor_nascentes_floresta_ext <- geo_vetor_nascentes[geo_vetor_cobertura_floresta, , op = st_disjoint]
```

```{r fig-vetor-filtro-espacial-externo, fig.cap="Nascentes fora de florestas no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
plot(geo_vetor_nascentes_floresta_ext$geometry, col = "steelblue", pch = 20, cex = 1, add = TRUE)
```

**Jun√ß√£o espacial**

Outra opera√ß√£o muito usada dentro de an√°lises espaciais √© a jun√ß√£o espacial ou do ingl√™s *spatial join*. A ideia base √© muito semelhante com a jun√ß√£o baseada em atributos, mas aqui atribuiremos o valor da tabela de atributos das fei√ß√µes de um objeto espacial y √†s fei√ß√µes que fazem intersec√ß√£o com um objeto espacial x, de modo que esses valores sejam armazenados na tabela de atributos do primeiro objeto espacial.

Para exemplificar, vamos atribuir os valores dos pol√≠gonos de cobertura da terra aos pontos de nascentes para Rio Claro/SP, fazendo um agrupamento pela tabela de atributos para permitir criar o mapa da Figura \@ref(fig:fig-vetor-juncao-espacial).

```{r}
## Jun√ß√£o espacial
geo_vetor_nascentes_cob_jun <- geo_vetor_nascentes %>% 
    sf::st_join(x = ., y = geo_vetor_cobertura) %>% 
    dplyr::group_by(CLASSE_USO) %>% 
    dplyr::summarise(n = n())
```

```{r fig-vetor-juncao-espacial, fig.cap="Jun√ß√£o espacial da cobertura da terra para as nascentes no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_nascentes_cob_jun[1], col = c("blue", "orange", "gray30", "forestgreen", "green"),
     pch = 20, add = TRUE)
legend(x = 209000, y = 7520000, pch = 15, cex = .7, pt.cex = 2.5, 
       legend = (geo_vetor_nascentes_cob_jun$CLASSE_USO), 
       col = c("blue", "orange", "gray30", "forestgreen", "green"))
```

**Agrega√ß√£o espacial**

Muitas vezes queremos contabilizar quantas fei√ß√µes ou agregar valores de fei√ß√µes para pol√≠gonos. Podemos realizar essa opera√ß√£o usando as fun√ß√µes `dplyr::group_by()` e `dplyr::summarise`, ou utilizar a fun√ß√£o `aggregate()`. Nesse exemplo, vamos contabilizar quantas nascentes h√° por pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

```{r}
## Agrega√ß√£o espacial
geo_vetor_cobertura_nas_agre <- geo_vetor_nascentes %>% 
    aggregate(x = ., by = geo_vetor_cobertura, FUN = length)
```

```{r fig-vetor-agregacao-espacial, fig.cap="Agrega√ß√£o espacial contabilizando o n√∫mero de nascentes para cada classe de cobertura da terra no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura_nas_agre[1], axes = TRUE, graticule = TRUE, main = NA)
```

**Dist√¢ncia espacial**

A dist√¢ncia espacial √© a dist√¢ncia calculada em duas dimens√µes (2D) entre um objeto espacial x e y baseado no CRS e para cada fei√ß√£o dos objetos geoespaciais. Para realizar esse c√°lculo, utilizamos a fun√ß√£o `sf::st_distance()`. Em nosso exemplo, vamos calcular a dist√¢ncia das nascentes at√© a floresta mais pr√≥xima, e adicionando essa informa√ß√£o para cada ponto na tabela de atributos com a fun√ß√£o `dplyr::mutate()`, para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-distancia-espacial)).

```{r}
## Dist√¢ncia espacial
geo_vetor_nascentes_dist_flo <- geo_vetor_nascentes %>% 
    dplyr::mutate(dist_flo = sf::st_distance(geo_vetor_nascentes, geo_vetor_cobertura_floresta))
```

```{r fig-vetor-distancia-espacial, fig.cap="Dist√¢ncia espacial das nascentes at√© o fragmento de floresta mais pr√≥xima no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_dist_flo[7], pch = 20, axes = TRUE, graticule = TRUE, main = NA)
```

**Raster**

As principais opera√ß√µes espaciais para dados raster podem ser classificas, segundo Lovelace et al. [-@lovelace2019], em: i) opera√ß√µes locais (por c√©lula), ii) opera√ß√µes focais (por bloco de m√∫ltiplas c√©lulas regulares - e.g. 3x3), iii) opera√ß√µes zonais (por bloco de m√∫ltiplas c√©lulas irregulares) e iv) opera√ß√µes globais (por um ou v√°rios rasters inteiros). Cada uma delas √© aplicada para objetivos e escalas espaciais espec√≠ficas. Para os exemplos desta se√ß√£o, utilizaremos o dado raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP.

**Opera√ß√µes locais**

As opera√ß√µes locais contemplam todas as opera√ß√µes realizadas c√©lula a c√©lula em uma ou v√°rias camadas de um objeto raster. A √°lgebra de raster √© uma das mais comuns, simples e poderosas opera√ß√µes no R envolvendo rasters. Com ela podemos fazer opera√ß√µes simples atrav√©s de operadores aritm√©ticos (soma, subtra√ß√£o, multiplica√ß√£o, divis√£o ou potencia√ß√£o) entre dois ou mais objetos raster, ou utilizar fun√ß√µes para alterar todos os valores dos pixels como, por exemplo, as fun√ß√µes `lo10()` ou `sqrt()`, ou ainda a fun√ß√£o `raster::scale()` para padronizar ou centralizar os valores dos rasters (Figura \@ref(fig:fig-raster-local-aritmetico)).

```{r}
## Soma
geo_raster_srtm_rio_claro2 <- geo_raster_srtm_rio_claro + geo_raster_srtm_rio_claro

## Log10
geo_raster_srtm_rio_claro_log10 <- log10(geo_raster_srtm_rio_claro)
```

```{r fig-raster-local-aritmetico, fig.cap="Rasters de soma e log10 do mapa de eleva√ß√£o para Rio Claro/SP."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_raster_srtm_rio_claro2, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_raster_srtm_rio_claro_log10, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

Al√©m das opera√ß√µes aritm√©ticas, a √°lgebra de rasters tamb√©m permite opera√ß√µes l√≥gicas, como criar um raster (bin√°rio - composto por 1 quando a opera√ß√£o l√≥gica √© verdadeira, e 0 quanto √© falsa). Em nosso caso, buscamos todos os pixels acima de 600 metros para o raster de eleva√ß√£o de Rio Claro/SP (Figura \@ref(fig:fig-raster-local-logico)).

```{r}
## Acima de 600
geo_raster_srtm_rio_claro_acima_600 <- geo_raster_srtm_rio_claro > 600
```

```{r fig-raster-local-logico, fig.cap="Opera√ß√£o local l√≥gica mostrando todos os pixels acima de 600 metros de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_acima_600, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Al√©m dos operadores aritm√©ticos, tamb√©m podemos usar as fun√ß√µes `raster::calc()` (uma camada) e `raster::overlay()` (duas ou mais camadas) para realizar opera√ß√µes em todas as c√©lulas. Elas funcionam com a cria√ß√£o de uma fun√ß√£o espec√≠fica atrav√©s da fun√ß√£o `function()` (Cap√≠tulo \@ref(cap4)), para que esta seja aplicada em todas as c√©lulas do raster. Essas fun√ß√µes s√£o muito eficientes, portanto, s√£o prefer√≠veis para grandes conjuntos de dados raster. Exemplificaremos essa opera√ß√£o calculando o produto de todos os pixels por eles mesmos do raster de eleva√ß√£o de Rio Claro/SP (Figura \@ref(fig:fig-raster-local-calc)).

```{r}
## Produto dos pixel - calc
geo_raster_srtm_rio_claro_prod <- raster::calc(x = geo_raster_srtm_rio_claro, fun = function(x){x * x})
geo_raster_srtm_rio_claro_prod 
```

```{r fig-raster-local-calc, fig.cap="Opera√ß√£o local de multiplica√ß√£o de todos os pixels por eles mesmos do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_prod, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A predi√ß√£o de objetos raster (utilizando a fun√ß√£o `raster::predict()`) √© outra aplica√ß√£o extremamente √∫til em opera√ß√µes locais, n√≥s a veremos mais √† frente nesse cap√≠tulo. Essa fun√ß√£o possui basicamente dois argumentos: `object` que √© os rasters preditores e `model` com o modelo ajustado para o qual os valores ser√£o preditos com base nos valores dos rasters. A partir da rela√ß√£o entre vari√°veis respostas (e.g, pontos no espa√ßo, como ocorr√™ncia ou riqueza de esp√©cies), e vari√°veis preditoras (rasters cont√≠nuos de eleva√ß√£o, pH, precipita√ß√£o, temperatura, cobertura da terra ou classe de solo), criamos modelos usando fun√ß√µes como `lm()`, `glm()`, `gam()` ou uma t√©cnica de aprendizado de m√°quina, e fazemos predi√ß√µes espaciais aplicando os coeficientes estimados aos valores dos raster preditores (consulte od Cap√≠tulod \@ref(cap7) e \@ref(cap8)).

Por fim, a reclassifica√ß√£o de rasters √© outra opera√ß√£o muito comum quando trabalhamos com rasters. Nela √© realizada a classifica√ß√£o de intervalos de valores num√©ricos em grupos, e.g. agrupar um modelo digital de eleva√ß√£o em classes de valores. A fun√ß√£o que faz essa opera√ß√£o √© a `raster::reclassify()`. Ela possui dois argumentos: `x` que √© o raster a ser reclassificado, e o segundo `rcl` para o qual devemos construir uma matriz de reclassifica√ß√£o, onde a primeira coluna √© a extremidade inferior, a segunda coluna √© a extremidade superior, e a terceira coluna representa o novo valor para os intervalos das colunas um e dois. Vamos reclassificar o raster de eleva√ß√£o de Rio Claro/SP para os intervalos 400--600, 600--800 e 800--1000 que s√£o reclassificados para os valores 1, 2 e 3, respectivamente (Figura \@ref(fig:fig-raster-local-reclassificacao)).

```{r}
## Matriz de reclassifica√ß√£o
rcl  <- matrix(c(400,600,1, 
                 600,800,2, 
                 800,1000,3), 
               ncol = 3, byrow = TRUE)

## Reclassifi√ß√£o
geo_raster_srtm_rio_claro_rcl <- raster::reclassify(x = geo_raster_srtm_rio_claro, rcl = rcl)
```

```{r fig-raster-local-reclassificacao, fig.cap="Opera√ß√£o local de reclassifica√ß√£o para tr√™s classes de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_rcl, col = viridis::viridis(3))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Opera√ß√µes focais**

As opera√ß√µes focais levam em considera√ß√£o uma c√©lula central e seus vizinhos. A vizinhan√ßa (tamb√©m chamada de janela m√≥vel - *moving window*) tipicamente √© composta de c√©lulas de 3 por 3 (c√©lula central e seus oito vizinhos), mas pode assumir outra forma. A opera√ß√£o focal aplica uma fun√ß√£o de agrega√ß√£o a todas as c√©lulas dentro da vizinhan√ßa especificada, e usa a sa√≠da correspondente como o novo valor para a c√©lula central, e segue para a pr√≥xima c√©lula central e seus vizinhos. Essa opera√ß√£o √© realizada atrav√©s da fun√ß√£o `raster::focal()`. O par√¢metro `x` especifica o raster de entrada, o par√¢metro `w` define a janela m√≥vel por uma matriz cujos valores correspondem a pesos, e por fim, o par√¢metro `fun` especifica a fun√ß√£o que desejamos aplicar √†s c√©lulas, como `min()`, `max()`, `sum()`, `mean()`, `sd()` ou `var()`. Existem diversas aplica√ß√µes dessa opera√ß√£o para dados raster, como no processamento de imagens de sat√©lite (ver mais em Wegmann et al. [-@wegmann2016]). Outra utilidade √© para o c√°lculo de caracter√≠sticas topogr√°ficas, como declividade, aspecto e dire√ß√µes de fluxo. Para calcular essas m√©tricas espec√≠ficas, podemos utilizar a fun√ß√£o `raster::terrain()`.

Para nosso exemplo, vamos realizar o c√°lculo do desvio padr√£o da eleva√ß√£o e a m√©trica de aspecto (orienta√ß√£o da vertente) para o raster de eleva√ß√£o em Rio Claro/SP (Figura \@ref(fig:fig-raster-focal)).

```{r}
## Janela m√≥vel - moving window
geo_raster_srtm_rio_claro_focal_sd <- raster::focal(
    x = geo_raster_srtm_rio_claro, 
    w = matrix(data = 1, nrow = 3, ncol = 3), 
    fun = sd)

## Declividade
geo_raster_srtm_rio_claro_asp <- raster::terrain(x = geo_raster_srtm_rio_claro, opt = "aspect")
```

```{r fig-raster-focal, fig.cap="C√°lculo do desvio padr√£o da eleva√ß√£o para uma janela de 3x3 e do aspecto para Rio Claro/SP."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_raster_srtm_rio_claro_focal_sd, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_raster_srtm_rio_claro_asp, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

**Opera√ß√µes zonais**

As opera√ß√µes zonais aplicam uma fun√ß√£o de agrega√ß√£o para v√°rias c√©lulas de um raster. Geralmente usa-se um segundo raster categ√≥rico para definir as zonas, de modo que as c√©lulas raster que definem a zona n√£o precisam ser vizinhas, como na opera√ß√£o focal. O resultado de uma opera√ß√£o zonal √© uma tabela de resumo agrupada por zona, explicando porque essa opera√ß√£o tamb√©m √© conhecida como estat√≠stica zonal. Isso √© um contraste com as opera√ß√µes focais que retornam um objeto raster.

A opera√ß√£o zonal √© realizada atrav√©s da fun√ß√£o `raster::zonal()`, que recebe de entrada no `x` o raster cont√≠nuo, em `z` o raster categ√≥rico, e em `fun` a fun√ß√£o que resumir√° as c√©lulas. Em nosso exemplo, vamos calcular diversas medidas resumo da eleva√ß√£o com a fun√ß√£o `summary()` para cada classe de eleva√ß√£o que criamos anteriormente.

```{r}
## Estat√≠stica zonal
geo_raster_srtm_rio_claro_zonal <- data.frame(raster::zonal(geo_raster_srtm_rio_claro, geo_raster_srtm_rio_claro_rcl, fun = "summary"))
colnames(geo_raster_srtm_rio_claro_zonal) <- c("zona", "min", "1qt", "mediana", "media", "3qt", "max")
geo_raster_srtm_rio_claro_zonal
```

**Opera√ß√µes globais**

As opera√ß√µes globais usam todo o conjunto de dados raster representando uma √∫nica zona. As opera√ß√µes globais mais comuns s√£o estat√≠sticas descritivas para todos os pixels do raster, utilizando a fun√ß√£o `raster::cellStats()` ou `raster::freq()`, j√° vistas. Al√©m das estat√≠sticas descritivas, podemos gerar rasters de dist√¢ncia, que calcula a dist√¢ncia de cada c√©lula a uma ou um grupo c√©lulas-alvo espec√≠fica, utilizando a fun√ß√£o `raster::distance()`.

Em nosso exemplo, vamos selecionar os pixels abaixo de 500 m do raster de eleva√ß√£o e calcular a Dist√¢ncia Euclidiana (Figura \@ref(fig:fig-raster-global)).

```{r}
## Dist√¢ncia euclidiana
geo_raster_srtm_rio_claro_abaixo_500 <- raster::calc(
    x = geo_raster_srtm_rio_claro, 
    fun = function(x) ifelse(x < 500, 1, NA))
geo_raster_srtm_rio_claro_global_dist <- raster::distance(geo_raster_srtm_rio_claro_abaixo_500)
```

```{r fig-raster-global, fig.cap="Raster de dist√¢ncia Euclidiana dos pixels abaixo de 500 m de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_global_dist, col = viridis::viridis(10))
plot(geo_raster_srtm_rio_claro_abaixo_500, add = TRUE, col = "white", legend = FALSE)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

### Opera√ß√µes geom√©tricas

As opera√ß√µes geom√©tricas realizam modifica√ß√µes em objetos geoespaciais baseado na geometria do vetor ou do raster e na intera√ß√£o e convers√£o entre vetor-raster. As opera√ß√µes geom√©tricas vetoriais podem ser un√°rias (funcionam em uma √∫nica geometria) ou bin√°rias (modificam uma geometria com base na forma de outra geometria). Ainda podemos fazer transforma√ß√µes para alterar os tipos vetores, que refletir√° se as fei√ß√µes s√£o √∫nicas ou m√∫ltiplas, inclusive na tabela de atributos. As opera√ß√µes geom√©tricas em rasters envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels subjacentes e atribuir-lhes novos valores. Por fim, podemos ainda fazer opera√ß√µes de intera√ß√µes e convers√µes entre raster-vetor para ajustar rasters a vetores, assim como converter um objeto espacial vetorial para raster e vice-versa.

**Vetor**

Como dissemos, as opera√ß√µes geom√©tricas em vetores criar√£o ou alterar a geometria de objetos da classe `sf`, podendo fazer altera√ß√µes em √∫nica geometria (un√°rias): i) simplifica√ß√£o, ii) centroides, iii) pontos aleat√≥rios, iv) buffers, v) pol√≠gono convexo, vi) pol√≠gonos de Voronoi, vii) quadr√≠culas e hex√°gonos; ou modificar uma geometria com base na forma de outra geometria (bin√°rias), viii) uni√£o e ix) recortes; ou ainda fazer transforma√ß√µes de tipo de geometrias.

Para exemplificar as opera√ß√µes geom√©tricas com vetores, vamos utilizar os dados do limite, nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Simplifica√ß√£o**

A simplifica√ß√£o possui o intuito de generalizar linhas ou pol√≠gonos, diminuindo assim suas complexidades em rela√ß√£o ao n√∫mero de v√©rtices. √â utilizada para representa√ß√£o em mapas menores ou mapas interativos ou ainda quando um objeto vetorial √© muito grande. A fun√ß√£o utilizada √© a `sf::st_simplify()`, que usa o argumento `x` para uma geometria de entrada e `dTolerance` para controlar o n√≠vel de generaliza√ß√£o nas unidades do mapa. Em nosso exemplo, simplificaremos a hidrografia de Rio Claro/SP (Figura \@ref(fig:fig-vetor-simplificacao)).

```{r}
## Simplifica√ß√£o
geo_vetor_hidrografia_simplificado <- sf::st_simplify(x = geo_vetor_hidrografia, dTolerance = 1000)
```

```{r fig-vetor-simplificacao, fig.cap="Simplifica√ß√£o da hidrografia para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_hidrografia$geometry, col = "steelblue", lwd = 2, add = TRUE)
plot(geo_vetor_hidrografia_simplificado$geometry, col = adjustcolor("black", .7), add = TRUE)
```

**Centroides**

A opera√ß√£o de centroides identifica o centro de objetos geoespaciais, geralmente o centro de massa das fei√ß√µes. √â utilizado para gerar um ponto simples para representa√ß√µes complexas ou para estimar a dist√¢ncia entre pol√≠gonos utilizando esse centroide. Podemos calcul√°-los com a fun√ß√£o `sf::st_centroids()` ou com a fun√ß√£o `sf::st_point_on_surface()` para garantir que esses centroides caiam dentro das geometrias. Aqui calcularemos o centroide do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-centroide)).

```{r}
## Centroides
geo_vetor_rio_claro_sirgas2000_utm23s_cent <- sf::st_centroid(geo_vetor_rio_claro_sirgas2000_utm23s)
```

```{r fig-vetor-centroide, fig.cap="Centroide do limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_cent$geom, cex = 3, pch = 20, add = TRUE)
```

**Pontos aleat√≥rios**

Por vezes precisamos criar algum padr√£o aleat√≥rio dentro de um contexto espacial. Isso pode ser realizado de diversas formas. Uma delas √© a cria√ß√£o de pontos aleat√≥rios dentro de um pol√≠gono. Podemos realizar essa opera√ß√£o com a fun√ß√£o `sf::st_sample()`. Para essa fun√ß√£o, dois argumentos s√£o utilizados: `x` uma geometria de entrada e o `size` indicando o n√∫mero de pontos √† seres criados. Outro argumento bastante interessante √© o `type`, indicando o tipo de amostragem espacial (aleat√≥rio, regular ou triangular). Para nosso exemplo, vamos fixar a amostragem utilizando a fun√ß√£o `set.seed()` e sortear 30 pontos para o limite do munic√≠pio de Rio Claro/SP (\@ref(fig:fig-vetor-pontos-aleatorios)). Para mais detalhes da fun√ß√£o `set.seed()`, consultar o Cap√≠tulo \@ref(cap4).

```{r}
## Fixar amostragem
set.seed(42)

## Pontos aleat√≥rios
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios <- sf::st_sample(geo_vetor_rio_claro_sirgas2000_utm23s, size = 30)
```

```{r fig-vetor-pontos-aleatorios, fig.cap="Sorteio de 30 pontos aleat√≥rio para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, add = TRUE)
```

**Buffer**

Buffers s√£o pol√≠gonos que representam a √°rea dentro de uma determinada dist√¢ncia de um elemento geom√©trico, independentemente de ser um ponto, linha ou pol√≠gono. O buffer √© comumente utilizado para an√°lise de dados geoespaciais, geralmente sendo entendio como uma unidade amostral, delimitando uma por√ß√£o no entorno de algum elemento ou evento, como as condi√ß√µes clim√°ticas ou da estrutura da paisagem para uma amostragem, ou as caracter√≠sticas de cobertura da terra ao longo de um corpo d'√°gua, e.g., √Åreas de Preserva√ß√£o Permanente (APPs).

A fun√ß√£o utilizada para criar buffers √© a `sf::st_buffer()`, que requer pelo menos dois argumentos: `x` uma geometria de entrada e o `dist` uma dist√¢ncia para o buffer, fornecido nas unidades do CRS da geometria de entrada. Em nosso exemplo, vamos criar buffers circulares de 1000 metros para os 30 pontos aleat√≥rios criados anteriormente para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-buffer)).

```{r}
## Buffer
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer <- sf::st_buffer(
    x = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, dist = 1000)
```

```{r fig-vetor-buffer, fig.cap="Buffers de 1000 metros para os 30 pontos aleat√≥rios no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

Podemos ainda criar buffers quadrados acrescentando o argumento `uendCapStyle = "SQUARE"` (Figura \@ref(fig:fig-vetor-buffer-quad)).

```{r}
## Buffer
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_quad <- sf::st_buffer(
    x = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, dist = 1000, endCapStyle = "SQUARE")
```

```{r fig-vetor-buffer-quad, fig.cap="Buffers quadrados de 1000 metros para os 30 pontos aleat√≥rios no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_quad, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```


**Pol√≠gono convexo**

Uma an√°lise bastante comum, principalmente realizada pela IUCN, √© a cria√ß√£o de pol√≠gonos convexos, para definir a extens√£o de ocorr√™ncia de uma esp√©cie (*Extent of occurrence* - EOO). Nesse sentido, essa opera√ß√£o ligar√° os pontos externos de um conjunto de pontos e cria um pol√≠gono a partir deles. Podemos criar esse pol√≠gono com a fun√ß√£o `sf::st_convex_hull()`. Um √∫nico passo que precisamos adiantar √© utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto `sf` `MULTIPOINT`, j√° iremos explicar com mais detalhes adiante. Vamos utilizar os pontos aleat√≥rios que criamos anteriormente para criar o pol√≠gono convexo (Figura \@ref(fig:fig-vetor-convexo)).

```{r}
## Pol√≠gono convexo
geo_vetor_rio_claro_sirgas2000_utm23s_convexo <- geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios %>% 
    sf::st_union() %>% 
    sf::st_convex_hull()
```

```{r fig-vetor-convexo, fig.cap="Pol√≠gono convexo para os 30 pontos criados aleatoriamente para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_convexo, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

**Pol√≠gonos de Voronoi**

Uma outra forma de criar pol√≠gonos para resumir dados espaciais √© atrav√©s dos Pol√≠gonos de Voronoi ou Diagrama de Voronoi. Nele, pol√≠gonos irregulares s√£o criados a partir da proximidade de pontos, de modo a estimar uma √°rea de abrang√™ncia no entorno dos mesmos [@okabe_spatial_2000]. Esses pol√≠gonos podem ser criados com a fun√ß√£o `sf::st_voronoi()`, mas precisamos novamente utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto `sf` do tipo `MULTIPOINT`. Vamos utilizar os pontos aleat√≥rios que criamos anteriormente para criar o pol√≠gono de Voronoi (Figura \@ref(fig:fig-vetor-voronoi)).

```{r}
## Pol√≠gonos de Voronoi
geo_vetor_rio_claro_sirgas2000_utm23s_voronoi <- geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios %>% 
    sf::st_union() %>% 
    sf::st_voronoi()
```

```{r fig-vetor-voronoi, fig.cap="Pol√≠gonos de Voronoi para os 30 pontos criados aleatoriamente para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_voronoi, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

**Quadr√≠culas e hex√°gonos**

Muitas vezes precisamos criar unidades espaciais id√™nticas e igualmente espa√ßadas para resumir informa√ß√µes dispersas por toda a nossa √°rea de estudo. Uma pr√°tica muito comum √© a cria√ß√£o de um gride de pontos ou quadr√≠culas em toda a √°rea de estudo, e depois utilizar essas geometrias para associar ou resumir informa√ß√µes espacializadas, como a IUCN utiliza para a an√°lise de √°rea de ocupa√ß√£o (*Are of occupancy* - AOO). Al√©m das quadr√≠culas, uma outra geometria que se tornou bastante comum para as finalidades descritas, √© a cria√ß√£o de hex√°gonos, que al√©m de serem mais esteticamente atraentes, possuem uma explica√ß√£o matem√°tica de sua melhor funcionalidade para an√°lises espaciais em Ecologia [@birch_rectangular_2007].

A fun√ß√£o utilizada para criar esses grides √© a `sf::st_make_grid()`, que requer pelo menos dois argumentos: `x` uma geometria de entrada e o `cellsize` indicando o tamanho do gride a ser criado, fornecido nas unidades do CRS da geometria de entrada. H√° diversos outros argumentos, mas os mais importantes s√£o o `square` que definir√° se o gride ser√° de quadriculas ou de hex√°gonos, e o `what` que definir√° se geraremos pol√≠gonos, cantos ou centroides.

Em nosso exemplo, vamos criar quadr√≠culas e hex√°gonos de 2000 metros (i.e. 4000000 metros quadrados) para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-quad) e Figura \@ref(fig:fig-vetor-hex)). Podemos ainda utilizar as fun√ß√µes de filtros espaciais (Tabela \@ref(tab:tab-filtro-espacial)) para definir como selecionaremos esses elementos para a √°rea de estudo. Aqui utilizamos a fun√ß√£o `sf::st_intersects()`.

```{r}
## Quadr√≠culas
geo_vetor_rio_claro_sirgas2000_utm23s_grid <- sf::st_make_grid(
    x = geo_vetor_rio_claro_sirgas2000_utm23s, cellsize = 2000, what = "polygons") %>%
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_rio_claro_sirgas2000_utm23s, sparse = FALSE))

## Centroides das quadr√≠culas
geo_vetor_rio_claro_sirgas2000_utm23s_grid_cent <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, what = "centers") %>%
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., y = sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_grid), sparse = FALSE))
```

```{r fig-vetor-quad, fig.cap="Quadr√≠culas de 2000 metros de arestas e centroides para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_grid, col = NA, border = "red", lwd = 2, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_grid_cent, pch = 20, add = TRUE)
```

```{r}
## Hex√°gonos
geo_vetor_rio_claro_sirgas2000_utm23s_hex <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, square = FALSE) %>% 
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., 
                                    y = geo_vetor_rio_claro_sirgas2000_utm23s, 
                                    sparse = FALSE))

## Centroides de hex√°gonos
geo_vetor_rio_claro_sirgas2000_utm23s_hex_cent <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, square = FALSE, what = "centers") %>% 
    sf::st_as_sf() %>% 
    dplyr::filter(sf::st_intersects(x = ., 
                                    y = sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_hex),
                                    sparse = FALSE))
```

```{r fig-vetor-hex, fig.cap="Hex√°gonos equivalentes a quadr√≠culas de 2000 metros de arestas e centroides para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex, col = NA, border = "red", lwd = 2, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex_cent, pch = 20, add = TRUE)
```

**Uni√£o ("dissolver")**

Como vimos, na agrega√ß√£o por atributos podemos dissolver as geometrias de pol√≠gonos do mesmo grupo pelos valores da tabela de atributos, onde, naquele exemplo, contabilizamos quantas nascentes haviam por pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

Nesta se√ß√£o, vamos utilizar a fun√ß√£o `sf::st_union()` para unir diversas fei√ß√µes em uma s√≥, dissolvendo os limites entre elas. Vamos utilizar de exemplo os buffers que criamos a partir dos 30 pontos aleat√≥rios (Figura \@ref(fig:fig-vetor-uniao)).

```{r}
## Uni√£o
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao <- sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer)
```

```{r fig-vetor-uniao, fig.cap="Uni√£o - dissolu√ß√£o - dos buffers criados a partir de pontos aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
```

**Recorte e apagar ("clipar" e "erase")**

O recorte realiza um subconjunto espacial envolvendo dois objetos geoespaciais. O recorte √© aplicado somente a linhas e pol√≠gonos, ou seja, usaremos linhas e pol√≠gonos para recortar linhas ou pol√≠gonos. Esse recorte pode ser realizado de tr√™s formas: i) intersec√ß√£o (subconjunto das geometrias sobrepostas entre os dois objetos), ii) diferen√ßa (subconjunto das geometrias do primeiro objeto sem sobreposi√ß√£o com o segundo objeto), e iii) diferen√ßa sim√©trica (apenas as geometrias n√£o sobrepostas entre os dois objetos). Respectivamente para cada uma dessas opera√ß√µes temos fun√ß√µes espec√≠ficas: `sf::st_intersection()`, `sf::st_difference()` e `sf::st_sym_difference()`.

Para nosso exemplo, faremos o recorte da hidrografia em rela√ß√£o aos buffers criados e unidos para os 30 pontos aleat√≥rios em Rio Claro/SP. Primeiramente, fazeremos o recorte para dentro dos buffers com a fun√ß√£o `sf::st_intersection()` (Figura \@ref(fig:fig-vetor-interseccao)).

```{r}
## Recorte - intersec√ß√£o
geo_vetor_hidrografia_interseccao <- sf::st_intersection(x = geo_vetor_hidrografia, y = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig-vetor-interseccao, fig.cap="Recorte da hidrografia para dentro dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(geo_vetor_hidrografia_interseccao$geometry, col = "blue", add = TRUE)
```

Para nosso segundo exemplo, realizamos o recorte da hidrografia em rela√ß√£o aos buffers, mas agora para fora dos buffers utilizando a fun√ß√£o `sf::st_difference()` (Figura \@ref(fig:fig-vetor-difereca)), que seria semelhando a opera√ß√£o de apagar ("erase").

```{r}
## Recorte - diferen√ßa
geo_vetor_hidrografia_diferenca <- sf::st_difference(x = geo_vetor_hidrografia, y = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig-vetor-difereca, fig.cap="Recorte da hidrografia para fora dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(geo_vetor_hidrografia_diferenca$geometry, col = "blue", add = TRUE)
```

**Transforma√ß√µes de tipo**

Esse t√≥pico possui muitas funcionalidades, que s√£o exploradas no t√≥pico "5.2.7 Type transformations" de Lovelace et al. [-@lovelace2019]. Aqui, nosso interesse principal √© em rela√ß√£o √† transforma√ß√£o dos tipos de objetos geoespaciais da classe `sf`: `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`, para `POINT`, `LINESTRING` e `POLYGON`. Muitas vezes as fei√ß√µes de nossos objetos, i.e., as linhas da tabela de atributos est√£o agrupadas em apenas uma linha da tabela. Quando o objeto espacial est√° nesse formato, geralmente em alguma classe dessas (`MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`), n√£o temos como realizar opera√ß√µes espaciais ou geom√©tricas para cada fei√ß√£o, e precisamos separ√°-las em linhas diferentes para que opera√ß√µes como o c√°lculo de comprimento ou √°rea seja poss√≠vel para cada fei√ß√£o.

Dessa forma, podemos utilizar a fun√ß√£o `sf::st_cast()` para fazer essas transforma√ß√µes e atribuir cada fei√ß√£o a uma linha da tabela de atributos. Como exemplo, vamos separar os fragmentos de floresta e calcular a √°rea para cada fei√ß√£o em hectares (Figura \@ref(fig:fig-vetor-tipo)).

```{r}
## Transforma√ß√£o de tipo
geo_vetor_cobertura_floresta_polygon <- geo_vetor_cobertura_floresta %>% 
    sf::st_cast("POLYGON") %>% 
    dplyr::mutate(area_ha = sf::st_area(.)/1e4 %>% round(2))
```

```{r fig-vetor-tipo, fig.cap="Transforma√ß√£o do vetor de florestas em `POLYGON` e c√°lculo da √°rea para cada fei√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta_polygon["area_ha"], col = viridis::viridis(100),  add = TRUE)
```

**Raster**

As opera√ß√µes geom√©tricas em rasters envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels e atribuir novos valores, geralmente aumentando ou diminuindo o tamanho desses pixels. Essas opera√ß√µes permitem alinhar rasters de diversas fontes, fazendo com que compartilhem uma correspond√™ncia entre seus pixels, permitindo que eles sejam processados todos juntos, ou simplesmente permite a realiza√ß√£o de an√°lises que demorariam muito, caso os rasters possuam um tamanho de pixel muito pequeno.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essas opera√ß√µes funcionam para as tr√™s classes dos objetos raster: `RasterLayer`, `RasterBrick` e `RasterStack`.
:::

Para exemplificar as opera√ß√µes geom√©tricas com rasters, vamos utilizar os dados de eleva√ß√£o para o munic√≠pio de Rio Claro/SP e bioclim√°ticos para o mundo.

**Agrega√ß√£o**

Na agrega√ß√£o de rasters, aumentaremos o tamanho dos pixels (diminuindo a resolu√ß√£o), agregando os valores dos pixels em um pixel maior. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::aggregate()`, que possui tr√™s argumentos: `x` corresponde ao objeto raster de entrada, `fact` √© o fator de agrega√ß√£o e corresponde ao n√∫mero que definir√° o novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de agrega√ß√£o de 10 far√° com o novo raster tenha a resolu√ß√£o de 900 m), e `fun` √© a fun√ß√£o utilizada para realizar a agrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-agregacao)).

Em nosso exemplo, vamos aumentar o tamanho dos pixels para 900 metros do raster de eleva√ß√£o para Rio Claro/SP.

```{r}
## Agrega√ß√£o - aumentar o tamanho do pixel
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media <- raster::aggregate(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, fact = 10, fun = "mean")
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media
```

```{r fig-raster-agregacao, fig.cap="Agrega√ß√£o (aumento do pixel para 900 metros) utilizando a m√©dia para o raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Desagrega√ß√£o**

De modo contr√°rio, na desagrega√ß√£o de rasters, diminuiremos o tamanho dos pixels (aumentando a resolu√ß√£o), preenchendo com novos valores. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::desaggregate()`, que assim como a fun√ß√£o anterior, possui tr√™s argumentos: `x` corresponde ao objeto raster de entrada, `fact` √© o fator de desagrega√ß√£o e corresponde ao n√∫mero que definir√° o novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de desagrega√ß√£o de 2 far√° com que o novo raster tenha a resolu√ß√£o de 45 m), e `method` √© a fun√ß√£o utilizada para realizar a desagrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-desagregacao)).

Nesse exemplo, vamos diminuir o tamanho dos pixels para 45 metros do raster de eleva√ß√£o para Rio Claro/SP.

```{r}
## Desagrega√ß√£o - diminuir o tamanho do pixel
geo_raster_srtm_rio_claro_desg_bil <- raster::disaggregate(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, fact = 2, method = "bilinear")
geo_raster_srtm_rio_claro_desg_bil
```

```{r fig-raster-desagregacao, fig.cap="Desagrega√ß√£o (diminui√ß√£o do pixel para 45 metros) utilizando o m√©todo bilinear para o raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_desg_bil, col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Alinhamento de rasters**

Muitas vezes queremos ir al√©m de ajustar o tamanho do pixel, ajustando tamb√©m a extens√£o, n√∫mero e origem dos pixels para v√°rias camadas rasters, principalmente se precisamos criar objetos das classes `RasterBrick` ou `RasterStack`. Dessa forma, podemos utilizar a fun√ß√£o `raster::compareRaster()` para comparar os rasters em rela√ß√£o a extens√£o, n√∫mero de linhas e colunas, proje√ß√£o, resolu√ß√£o e origem (ou um subconjunto dessas compara√ß√µes).

Podemos utilizar a fun√ß√£o `raster::resample()` para fazer esse alinhamento, ou ainda a fun√ß√£o `gdalUtils::align_rasters()`. Para a primeira fun√ß√£o, os argumentos s√£o `x` para o raster de entrada, `y` para o raster de alinhamento e `method` para o m√©todo utilizado no alinhamento. Para nosso exemplo, vamos ajustar uma camada bioclim√°tica (BIO01) √† camada de eleva√ß√£o para Rio Claro/SP (Figura \@ref(fig:fig-raster-reamostragem)).

```{r}
## Reamostragem
geo_raster_bioclim_rc <- raster::resample(x = geo_raster_bioclim$bio01, 
                                          y = geo_raster_srtm_rio_claro, 
                                          method = "bilinear")
geo_raster_bioclim_rc
```

```{r fig-raster-reamostragem, fig.cap="Reamostragem (alinhamento dos rasters) utilizando o m√©todo bilinear para alinhar o raster bioclim√°tico (BIO01) ao de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_bioclim, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Intera√ß√µes raster-vetor**

Podemos fazer opera√ß√µes da intera√ß√£o entre objetos vetoriais e raster, como ajustes da extens√£o e limite do raster para vetores (corte e m√°scara), extra√ß√£o dos valores dos pixels para vetores (pontos, linhas e pol√≠gonos), e estat√≠sticas zonais dos valores dos pixels dos raster para um vetor (pol√≠gonos).

**Cortes e m√°scaras**

Muitas vezes precisamos ajustar o tamanho de um objeto raster a uma √°rea menor de interesse, geralmente definido por um objeto vetorial. Para realizar essa opera√ß√£o, dispomos de duas fun√ß√µes: `raster::crop()` e `raster::mask()`.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
√â fundamental que ambos os objetos raster a ser reduzido e o vetor como molde precisam estar no mesmo CRS.
:::

A fun√ß√£o `raster::crop()` ajusta o raster √† extens√£o do vetor. Como exemplo, vamos retomar o raster de eleva√ß√£o original baixado e importado anteriormente (Figura \@ref(fig:fig-raster-dem)). Primeiramente, vamos usar a fun√ß√£o `raster::crop()` para ajustar esse raster √† extens√£o do limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte)).

```{r}
## Crop - adjuste da extens√£o
geo_raster_srtm_rio_claro_crop <- raster::crop(geo_raster_srtm, geo_vetor_rio_claro)
```

```{r fig-raster-corte, fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para a extens√£o de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster ao limite do munic√≠pio de Rio Claro/SP, vamos usar a fun√ß√£o `raster::mask()`. √â importante notar que essa fun√ß√£o preenche com `NAs` os pixels que est√£o fora do limite do pol√≠gono e n√£o ajusta a extens√£o (Figura \@ref(fig:fig-raster-corte)).

```{r}
## Mask - adjuste ao limite
geo_raster_srtm_rio_claro_mask <- raster::mask(geo_raster_srtm, geo_vetor_rio_claro)
```

```{r fig-raster-mascara, fig.cap="Ajuste do raster de eleva√ß√£o para o limite de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_mask, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster √† extens√£o e ao limite do munic√≠pio de Rio Claro/SP, precisamos utilizar conjuntamente as fun√ß√µes `raster::crop()` e `raster::mask()` (Figura \@ref(fig:fig-raster-corte-mascara)).

```{r}
## Crop e mask - ajuste da extens√£o e do limite
geo_raster_srtm_rio_claro_crop_mask <- geo_raster_srtm %>% 
    raster::crop(geo_vetor_rio_claro) %>% 
    raster::mask(geo_vetor_rio_claro)
```

```{r fig-raster-corte-mascara, fig.cap="Ajuste da extens√£o e do limite do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop_mask, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A fun√ß√£o `raster::mask()` possui ainda um argumento chamado `inverse`, que cria uma m√°scara inversa ao limite, preenchendo com `NA` o pixels internos ao limite do pol√≠gono, como podemos ver para o raster de eleva√ß√£o e o limite de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte-mascara-inverso)).

```{r}
## Crop e mask inversa - ajuste da extens√£o e do limite inverso
geo_raster_srtm_rio_claro_crop_mask_inv <- geo_raster_srtm %>% 
    raster::crop(geo_vetor_rio_claro) %>% 
    raster::mask(geo_vetor_rio_claro, inverse = TRUE)
```

```{r fig-raster-corte-mascara-inverso, fig.cap="Ajuste da extens√£o e do limite externo do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop_mask_inv, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Extra√ß√£o**

A intera√ß√£o entre raster-vetor de extra√ß√£o √© o processo que identifica e retorna valores associados de pixels de um raster com base em um objeto vetorial. √â uma opera√ß√£o extremamente comum em an√°lises espaciais, principalmente para associar valores de raster ambientais (cont√≠nuos ou categ√≥ricos) a pontos de ocorr√™ncia ou amostragem. Os valores retornados depender√£o do tipo vetor (pontos, linhas ou pol√≠gonos) e de argumentos da fun√ß√£o `raster::extract()` que alteram o funcionamento da extra√ß√£o.

Em nosso exemplo, vamos extrair os valores do raster de eleva√ß√£o para as nascentes do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-extracao)).

```{r}
## Extra√ß√£o
geo_vetor_nascentes_ele <- geo_vetor_nascentes %>% 
    dplyr::mutate(elev = raster::extract(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, y = .))
```

```{r fig-raster-extracao, fig.cap="Extra√ß√£o dos valores de eleva√ß√£o para as nascentes de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_ele["elev"], 
     pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

Al√©m da extra√ß√£o dos valores totais, podemos resumir os valores dos pixels com a mesma opera√ß√£o de extra√ß√£o, utilizando ainda a fun√ß√£o `raster::extract()`, mas utilizando uma outra fun√ß√£o para resumir os valores dos pixels para um pol√≠gono, opera√ß√£o tamb√©m denominada de estat√≠stica zonal (agora para vetores). J√° vimos que ela pode ser realizada entre rasters na se√ß√£o de opera√ß√µes zonais, mas aqui a realizaremos para rasters e vetores.

Para o exemplo, vamos calcular a eleva√ß√£o m√©dia dos valores para os hex√°gonos que criamos para o limite de Rio Claro/SP( Figura \@ref(fig:fig-raster-zonas)).

```{r}
## Extra√ß√£o - estat√≠stica por zonas
geo_vetor_rio_claro_sirgas2000_utm23s_hex_alt <- geo_vetor_rio_claro_sirgas2000_utm23s_hex %>% 
    dplyr::mutate(elev_mean = raster::extract(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, 
                                              y = geo_vetor_rio_claro_sirgas2000_utm23s_hex, 
                                              fun = mean, 
                                              na.rm = TRUE))
```

```{r fig-raster-zonas, fig.cap="Extra√ß√£o dos valores de eleva√ß√£o e resumo pela m√©dia para os hex√°gonos de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex_alt["elev_mean"], 
     pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

**Convers√µes raster-vetor**

Por fim, podemos ainda fazer opera√ß√µes de convers√£o entre objetos vetoriais para raster e vice-versa. Nessas opera√ß√µes, podemos resumir ou transformar objetos vetoriais (pontos, linhas ou pol√≠gonos) para rasters, escolhendo um raster previamente existente, processo denominado rasteriza√ß√£o. Tamb√©m podemos realizar o processo inverso, i.e., transformar o raster em um vetor, podendo esse vetor ser um gride pontos, linhas ou pol√≠gonos, opera√ß√£o chamada de vetoriza√ß√£o.

**Rasteriza√ß√£o**

A convers√£o de vetor para raster pode ser realizada de pontos, linhas ou pol√≠gonos para rasters. Nesse processo, podemos utilizar uma fun√ß√£o para resumir os dados pontuais para os pixels do raster que criaremos. Para essa opera√ß√£o, podemos utilizar a fun√ß√£o `raster::rasterize()`, com o argumento `x` sendo o vetor de pontos de entrada, `y` o raster base, `field` a coluna ou campo da tabela de atributos do objeto vetorial para os quais os valores ser√£o utilizados e `fun` a fun√ß√£o utilizada para agrega√ß√£o dos dados.

Aqui, vamos contabilizar a quantidade de nascentes por pixel, utilizando como base o raster para o qual mudamos a resolu√ß√£o para 900 metros (\@ref(fig:fig-raster-rasterizacao-pontos)).

```{r}
## Rasterizar pontos
geo_vetor_nascentes_rasterizacao <- raster::rasterize(x = geo_vetor_nascentes, y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-pontos, fig.cap="Rasteriza√ß√£o das nascentes, com a opera√ß√£o de contabiliza√ß√£o de pontos para Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_nascentes$geometry, pch = 20, cex = .5, col = adjustcolor("gray", .5), add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Al√©m de pontos, podemos tamb√©m rasterizar linhas. Aqui vamos contabilizar as linhas da hidrografia simplificada para Rio Claro/SP (Figura \@ref(fig:fig-raster-rasterizacao-linhas)).

```{r}
## Rasterizar linhas
geo_vetor_hidrografia_rasterizacao <- raster::rasterize(
    x = geo_vetor_hidrografia_simplificado,
    y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media,
    field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-linhas, fig.cap="Rasteriza√ß√£o da hidrografia, com a opera√ß√£o de contabiliza√ß√£o de linhas para Rio Claro/SP."}
## Plot
plot(geo_vetor_hidrografia_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_hidrografia_simplificado$geom, col = "gray", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Podemos ainda rasterizar pol√≠gonos, de modo que cada pixel do raster a ser criado receber√°o valor da tabela de atributos, ou uma an√°lise pelo vizinho mais pr√≥ximo no caso de um campo categ√≥rico, como a cobertura da terra, que tamb√©m vai depender da resolu√ß√£o do raster base e do tamanho da fei√ß√£o do pol√≠gono. Para nosso exemplo, antes de criar o raster vamos transforma a coluna de classe de cobertura da terra em `factor` (Figura \@ref(fig:fig-raster-rasterizacao-poligonos)). Entretanto, essa opera√ß√£o de rasteriza√ß√£o tende a demorar muito no caso de pol√≠gonos muito detalhados ou um raster com pixels muito pequenos, sendo que dois pacotes aceleram esse processamento (`fasterize` e `gdalUtils`), com suas respectivas fun√ß√µes: `fasterize::fasterize()` e `gdalUtils::gdal_rasterize()`.

```{r}
## Rasterizar pol√≠gonos
geo_vetor_cobertura_rasterizacao <- geo_vetor_cobertura %>% 
    dplyr::mutate(classe = as.factor(CLASSE_USO)) %>% 
    raster::rasterize(x = ., y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, field = "classe")
```

```{r fig-raster-rasterizacao-poligonos, fig.cap="Rasteriza√ß√£o da cobertura da terra para Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura$geom, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Vetoriza√ß√£o**

A opera√ß√£o inversa √† rasteriza√ß√£o √© a vetoriza√ß√£o, na qual convertemos um raster em um vetor, sendo que esse vetor receber√° os valores dos pixels. O vetor em quest√£o pode ser pontos (geralmente um gride de pontos), linhas (geralmente isolinhas ou linhas de contorno), ou pol√≠gonos (podendo esses pol√≠gonos ser ou n√£o dissolvidos pelos valores dos pixels). Existem fun√ß√µes espec√≠ficas para cada uma dessas convers√µes, sendo elas: `raster::rasterToPoints()`, `raster::rasterToContour()` e `raster::rasterToPolygons()`, respectivamente. Para a √∫ltima fun√ß√£o, ainda dispomos de uma alternativa mais veloz `spex::polygonize()`.

Em nosso exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP, criando um gride de pontos, sendo os pontos os centroides de cada pixels (Figura \@ref(fig:fig-raster-vetorizacao-pontos)).

```{r}
## Vetoriza√ß√£o de pontos
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_pontos <- raster::rasterToPoints(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, spatial = TRUE) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-pontos, fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando um gride de pontos para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, 
     col = viridis::viridis(10, alpha = .8))
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_pontos, 
     pch = 20, cex = .7, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, 
     border = "red", lwd = 2, add = TRUE)
```

Nesse outro exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP novamente, mas agora criando isolinhas \@ref(fig:fig-raster-vetorizacao-linhas)).

```{r}
## Vetoriza√ß√£o de linhas
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_linhas <- raster::rasterToContour(
    x = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-linhas, fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando isolinhas para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media,
     col = viridis::viridis(10, alpha = .8))
contour(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, 
        labcex = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)
```

Por fim, vamos vetorizar o raster de cobertura da terra criado anteriormente para Rio Claro/SP, criando pol√≠gonos n√£o dissolvendo e dissolvidos \@ref(fig:fig-raster-vetorizacao-poligonos)).

```{r}
## Vetoriza√ß√£o de pol√≠gonos
geo_vetor_cobertura_rasterizacao_poligonos <- raster::rasterToPolygons(geo_vetor_cobertura_rasterizacao) %>%
    sf::st_as_sf()

## Vetoriza√ß√£o de pol√≠gonos dissolvendo
geo_vetor_cobertura_rasterizacao_poligonos_dissolvidos <- raster::rasterToPolygons(geo_vetor_cobertura_rasterizacao, dissolve = TRUE) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-poligonos, fig.cap="Vetoriza√ß√£o do raster de cobertura da terra para Rio Claro/SP, n√£o dissolvendo e dissolvendos os pol√≠gonos gerados."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura_rasterizacao_poligonos$geometry, 
     col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura_rasterizacao_poligonos_dissolvidos$geometry, 
     col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

## Visualiza√ß√£o de dados geoespaciais

Um dos pontos finais de toda a an√°lise envolvendo a manipula√ß√£o de dados geoespaciais ser√° a apresenta√ß√£o de um mapa com as informa√ß√µes de interesse geoespacializadas. Mas antes, √© necess√°rio ter conhecimento de alguns dos elementos principais para a composi√ß√£o de um mapa relativamente bem informativo. Al√©m disso, o R nos permite criar tipos diferentes de mapas: est√°ticos, animados e interativos. Os mais comuns s√£o os est√°ticos, mas podemos por vezes melhorar a apresenta√ß√£o dos dados geoespaciais criando mapas animados e/ou interativos, com o aux√≠lio de p√°ginas web. Por fim, veremos as melhores formas de exportar mapas para diferentes formatos.

### Principais elementos de um mapa

Um mapa pode ser composto de v√°rios elementos, tendo estes o intuito de auxiliar a visualiza√ß√£o e entendimento de seu conte√∫do. Apesar disso, nem todos os elementos necessitam estar presentes em todos os *layouts* de mapas, sendo que os mesmos devem atendem √† necessidade das representa√ß√µes, podendo ser muitas vezes omitidos ou outros podem ser acrescentados.

Os principais elementos de um mapa geralmente s√£o compostos por:

1.  Mapa principal (ocupando quase toda a √°rea da figura)
2.  Mapa secund√°rio (geralmente muito menor que o mapa principal e com o intuito de mostrar a localiza√ß√£o do mapa principal num contexto mais amplo, como pa√≠s ou continente)
3.  T√≠tulo (para resumir o intuito do mapa)
4.  Legenda (apresentando as informa√ß√µes detalhadas das classes ou escala de valores, geralmente identificando as cores e/ou texturas),
5.  Barra de escala (representando quantas unidades do mapa representam do mundo real)
6.  Indicador de orienta√ß√£o (Norte) (indicando o norte geogr√°fico, podendo ser representado por uma flecha, b√∫ssola ou compasso)
7.  Gride de coordenadas (coordenadas presentes nas laterais)
8.  Descri√ß√£o do CRS (indicando qual o CRS)
9.  Informa√ß√µes de origem (informa√ß√µes sobre a fonte dos dados representados no mapa)
10. Al√©m de outros elementos auxiliares (como elementos textuais e figuras extras)

Podemos visualizar todos esses elementos resumidos na Figura \@ref(fig:fig-mapa-elementos).

```{r fig-mapa-elementos, echo=FALSE, fig.cap="Principais elementos de um mapa."}
tmap::tmap_mode(mode = "plot")

geo_vetor_am_sul <- rnaturalearth::ne_countries(continent = "South America")
geo_vetor_brasil <- rnaturalearth::ne_countries(country = "Brazil")
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro")

mapa_am_sul <- tm_shape(geo_vetor_am_sul) +
    tm_polygons() +
    tm_shape(geo_vetor_brasil) +
    tm_polygons(col = "gray50")

tm_shape(geo_vetor_biomas, bbox = c(-74, -35, -27, 10)) +
    tm_polygons(col = "name_biome",
                pal = c("darkgreen", "orange", "orange4", 
                        "forestgreen", "yellow", "yellow3"),
                border.col = "black",
                title = "Legenda") +
    tm_compass() +
    tm_scale_bar(text.size = .6) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
    tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
    tm_layout(title = "Biomas do Brasil",
              title.position = c(.25, .95),
              title.size = 1.8,
              title.fontface = "bold",
              legend.frame = TRUE,
              legend.position = c("left", "bottom"),
              legend.title.fontface = "bold")
print(mapa_am_sul, vp = grid::viewport(.815, .875, wi = .2, he = .2))
```

### Principais pacotes para a composi√ß√£o de mapas

H√° uma grande quantidade de pacotes para a composi√ß√£o de mapas no R. Aqui listamos os principais (Tabela \@ref(tab:tab-mapa-pacotes)).

```{r tab-mapa-pacotes, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Pacote = c("[`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html)", 
                   "[`ggspatial`](https://cran.r-project.org/web/packages/ggspatial/index.html)", 
                   "[`ggmap`](https://cran.r-project.org/web/packages/ggmap/index.html)", 
                   "[`tmap`](https://cran.r-project.org/web/packages/tmap/index.html)", 
                   "[`leaflet`](https://cran.r-project.org/web/packages/leaflet/index.html)",
                   "[`plotly`](https://cran.r-project.org/web/packages/plotly/index.html)",
                   "[`cartography`](https://cran.r-project.org/web/packages/cartography/index.html)",
                   "[`googleway`](https://cran.r-project.org/web/packages/googleway/index.html)",
                   "[`mapview`](https://cran.r-project.org/web/packages/mapview/index.html)",
                   "[`rasterVis`](https://cran.r-project.org/web/packages/rasterVis/index.html)",
                   "[`cartogram`](https://cran.r-project.org/web/packages/cartogram/index.html)",
                   "[`mapsf`](https://cran.r-project.org/web/packages/mapsf/index.html)",
                   "[`geogrid`](https://cran.r-project.org/web/packages/geogrid/index.html)",
                   "[`geofacet`](https://cran.r-project.org/web/packages/geofacet/index.html)",
                   "[`globe`](https://cran.r-project.org/web/packages/globe/index.html)",
                   "[`linemap`](https://cran.r-project.org/web/packages/linemap/index.html)"), 
        Descri√ß√£o = c("Cria visualiza√ß√µes de dados elegantes usando a gram√°tica de gr√°ficos",
                      "Estrutura de dados espaciais para ggplot2",
                      "Visualiza√ß√£o espacial com ggplot2",
                      "Mapas tem√°ticos",
                      "Cria mapas da web interativos com a biblioteca JavaScript 'Leaflet'",
                      "Cria gr√°ficos interativos da Web por meio de 'plotly.js'",
                      "Cartografia tem√°tica",
                      "Cartografia tem√°tica",
                      "Acessa APIs do Google Maps para recuperar dados e mapas de plotagem",
                      "Visualiza√ß√£o interativa de dados espaciais em R",
                      "M√©todos de visualiza√ß√£o para dados raster",
                      "Crie cartogramas com R",
                      "Transforme pol√≠gonos geoespaciais em grades regulares ou hexagonais",
                      "'ggplot2' Utilit√°rios de faceta√ß√£o para dados geoespaciais",
                      "Plot 2D and 3D Views of the Earth, Including Major Coastline",
                      "Line Maps")),
    caption = "Principais pacotes para composi√ß√£o de mapas no R."
)
```

### Mapas est√°ticos

Mapas est√°ticos s√£o mapas simples e fixos para visualiza√ß√£o de dados, sendo o tipo mais comum de sa√≠da visual. No in√≠cio da composi√ß√£o de mapas no R, esse era o √∫nico tipo de mapa que a linguagem permitia produzir, principalmente utilizando o pacote `sp` [@pebesma_roger_2005]. No entanto, com o advento de ferramentas de visualiza√ß√£o din√¢micas no R, como componentes HTML, os mapas puderam ser compostos de forma din√¢mica (animados e interativos).

Neste t√≥pico abordaremos fun√ß√µes simples para composi√ß√£o de mapas est√°ticos, como o `plot()`, al√©m de pacotes para composi√ß√£o de mapas mais elaborados, como os pacotes `ggplot2` [@R-ggplot2] e `tmap` [@R-tmap].

**Fun√ß√£o `plot()`**

A fun√ß√£o gen√©rica `plot()` √© a maneira mais r√°pida de compor mapas est√°ticos utilizando objetos geoespaciais vetoriais e raster, funcionando para ambos os pacotes que apresentamos anteriormente (`sf` e `raster`). Apesar da simplicidade, essa fun√ß√£o geralmente tende a criar mapas com relativa velocidade, nos auxiliando principalmente em fases iniciais de desenvolvimento de um projeto. Essa fun√ß√£o oferece dezenas de argumentos em Base R, permitindo alguns ajustes limitados, com resultados bastante interessantes.

Como dito anteriormente, a fun√ß√£o `plot()` vai funcionar diferentemente dependendo da classe do objeto geoespacial. Para objetos geoespaciais `sf`, a fun√ß√£o vai plotar um mapa para cada coluna da tabela de atributos. Vamos usar de exemplo nosso mapa de biomas mostrado com os principais elementos de um mapa, podendo inclusive selecionar apenas a coluna de caracter√≠sticas geoespaciais (`geom`).

Primeiramente, vamos fazer o download dos dados de limites de biomas, retirando os sistemas costeiros, usando o pacote `geobr` [@R-geobr].

```{r}
## Download de pol√≠gonos dos geo_vetor_biomas Brasileiros
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro") %>% 
    dplyr::rename(nome_bioma = name_biome,
                  codigo_bioma = code_biome,
                  ano = year)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_biomas
```

Agora, quando utilizamos a fun√ß√£o `plot()` para um objeto da classe `sf`, temos os tr√™s mapas, cada um indicando uma coluna da tabela de atritos (Figura \@ref(fig:fig-vetor-map-plot)).

```{r fig-vetor-map-plot, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto `sf` para os Biomas do Brasil."}
## Plot
plot(geo_vetor_biomas)
```

Selecionando as colunas desse objeto, podemos escolher a informa√ß√£o que queremos plotar, por exemplo, apenas a geometria `geom`. Al√©m disso, podemos acrescentar os argumentos `col` para colorir e `main` para o t√≠tulo, al√©m dos argumentos `axes` e `graticule` para adicionar as coordenadas e quadr√≠culas, respectivamente. A legenda pode ser adicionada com a fun√ß√£o `legend()` (Figura \@ref(fig:fig-vetor-map-plot-selecao)).

```{r fig-vetor-map-plot-selecao, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto vetor."}
## Plot
plot(geo_vetor_biomas$geom, 
     col = c("darkgreen", "orange", "orange4", "forestgreen",
             "yellow", "yellow3"),
     main = "Biomas do Brasil", axes = TRUE, graticule = TRUE)
legend(x = -75, y = -20, pch = 15, cex = .7, pt.cex = 2.5,
       legend = geo_vetor_biomas$nome_bioma, 
       col = c("darkgreen", "orange", "orange4", "forestgreen", 
               "yellow", "yellow3"))
```

Para a classe dos objetos geoespaciais raster, a fun√ß√£o `plot()` vai plotar um mapa para o tipo `RasterLayer` e quantos mapas houverem no objeto e couberem no espa√ßo de plot para `RasterBrick` e `RasterStack`. Al√©m disso, para essas classes do objeto raster, essa fun√ß√£o prov√™ tamb√©m uma legenda e uma escala de cores autom√°tica (`terrain`). Vamos fazer o mapa da camada raster de eleva√ß√£o para o limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-layer-mapa)).

```{r fig-raster-layer-mapa, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster com uma camada."}
## Plot
plot(geo_raster_srtm_rio_claro)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Agora vamos plotar objetos da classe `RasterStack`, alterando a cor para `viridis`, usando a fun√ß√£o `viridis::viridis()` do pacote hom√¥nimo. Vamos fazer o mapa de duas camadas raster bioclim√°ticas para o mundo (Figura \@ref(fig:fig-raster-stack-mapa)).

```{r fig-raster-stack-mapa, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster com v√°rias camadas."}
## Plot
plot(geo_raster_bioclim[[1:2]], col = viridis::viridis(10))
```

Para exportar esses mapas podemos utilizar as fun√ß√µes `png()` ou `pdf()`, indicando os argumentos para ter as configura√ß√µes que desejamos, e finalizando com a fun√ß√£o `dev.off()`. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura (mais detalhes no Cap√≠tulo \@ref(cap6)).

```{r eval=FALSE}
## Criar diret√≥rio
dir.create(here::here("dados", "mapas"))

## Exportar mapa
png(filename = here::here("dados", "mapas", "elev_rc.png"), 
    width = 20, height = 20, units = "cm", res = 300)
plot(geo_raster_srtm_rio_claro)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
dev.off()
```

**Pacotes ggplot2 e ggspatial**

Como discutimos no Cap√≠tulo \@ref(cap6) sobre gr√°ficos, o pacote `ggplot2` utiliza a gram√°tica de gr√°ficos para composi√ß√£o de figuras no R [@wilkinson2005; @wickham2016]. Para cada classe de objeto geogr√°fico h√° fun√ß√µes espec√≠ficas para os dados: para objetos sf `geom_sf()` e para objetos raster `geom_raster()` e `geom_tile()`.

Al√©m do pacote `ggplot2`, podemos utilizar o pacote `ggspatial` para acrescentar elementos geoespaciais como a barra de escala e o indicador de orienta√ß√£o (Norte), atrav√©s das fun√ß√µes `annotation_scale()` e `annotation_north_arrow()`, respectivamente, al√©m de outras fun√ß√µes espec√≠ficas que n√£o abordaremos nesta se√ß√£o.

A estrutura de composi√ß√£o das fun√ß√µes do pacote `ggplot2` vai funcionar parecido com a estrutura√ß√£o de gr√°ficos j√° vista no Cap√≠tulo \@ref(cap6), de modo que a cada fun√ß√£o iremos utilizando o sinal de `+` para acrescentar outra camada. Indicaremos os dados com a fun√ß√£o `ggplot()` e a coluna da tabela de atributos que queremos representar com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_sf()` para indicar que trata-se de um objeto `sf`.

Al√©m dessas fun√ß√µes, podemos ainda fazer altera√ß√µes nos mapas atrav√©s das fun√ß√µes: `scale_*()` que vai alterar as caracter√≠sticas indicadas em `aes()`, `coord_*()` que vai alterar constru√ß√£o do mapa em rela√ß√£o √†s coordenadas, `facet_*()` que altera a disposi√ß√£o de v√°rios mapas, e `theme_*()` e `theme()` que alterar√£o caracter√≠sticas relacionadas ao tema, como cores de fundo, fontes e legenda. Podemos ainda utilizar as fun√ß√µes `annotate()` para adicionar textos e `labs()` para alterar o texto do t√≠tulo, legenda e eixos.

Vamos demonstrar esse funcionamento para compor o mapa de geo_vetor_biomas, apresentado no in√≠cio desta se√ß√£o (Figura \@ref(fig:fig-vetor-mapa-ggplot2)).

```{r fig-vetor-mapa-ggplot2, fig.cap="Mapa de Biomas do Brasil com o pacote `ggplot2`."}
## Plot
mapa_vetor_biomas_ggplot2 <- ggplot(data = geo_vetor_biomas) +
    aes(fill = nome_bioma) +
    geom_sf(color = "black") +
    scale_fill_manual(values = c("darkgreen", "orange", "orange4", 
                                 "forestgreen", "yellow", "yellow3")) +
    annotation_scale(location = "br") +
    annotation_north_arrow(location = "br", which_north = "true",
                           pad_x = unit(0, "cm"), pad_y = unit(.5, "cm"),
                           style = north_arrow_fancy_orienteering) +
    annotate(geom = "text", label = "CRS: SIRGAS2000/Geo", x = -38, y = -31, size = 2.5) +
    annotate(geom = "text", label = "Fonte: IBGE (2019)", x = -39, y = -32.5, size = 2.5) +
    labs(title = "Biomas do Brasil", fill = "Legenda", x = "Longitude", y = "Latitude") +
    theme_bw() +
    theme(title = element_text(size = 15, face = "bold"),
          legend.title = element_text(size = 10, face = "bold"),
          legend.position = c(.15, .25),
          legend.background = element_rect(colour = "black"),
          axis.title = element_text(size = 10, face = "plain"))
mapa_vetor_biomas_ggplot2
```

Para objetos raster, o uso do pacote `ggplot2` para compor mapas requer um passo preliminar. Primeiramente, vamos criar um `data frame` com os dados do raster, com as linhas sendo os pixels e as colunas sendo as coordenadas centrais da longitude e latitude, al√©m dos valores de cada camada em cada coluna. Esse passo pode ser realizado com a fun√ß√£o `raster::rasterToPoints()`.

Uma vez que temos esses dados organizados, podemos utilizar as fun√ß√µes `ggplot()` para indicar o `data frame`, e as colunas com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_raster()` para indicar que trata-se de um objeto raster. Al√©m dessas fun√ß√µes, podemos ainda utilizar as demais fun√ß√µes para alterar as caracter√≠sticas do mapa, como comentamos acima. Entretanto, devemos nos atentar para a fun√ß√£o `coord_*()` e escolher aquela que vai fazer a constru√ß√£o do mapa em rela√ß√£o √† coordenadas e resolu√ß√£o das c√©lulas.

Como exemplo, vamos compor o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-ggplot2)).

```{r fig-raster-mapa-ggplot2, fig.cap="Mapa raster com o pacote `ggplot2`."}
## Dados
geo_raster_srtm_rio_claro_dados <- raster::rasterToPoints(geo_raster_srtm_rio_claro) %>% 
    tibble::as_tibble()
head(geo_raster_srtm_rio_claro_dados)

## Mapa
mapa_srtm_rio_claro_ggplot2 <- ggplot() +
    geom_raster(data = geo_raster_srtm_rio_claro_dados, aes(x = x, y = y, fill = elevacao)) +
    geom_sf(data = geo_vetor_rio_claro, color = "red", fill = NA, size = 1.3) +
    scale_fill_viridis_c() +
    coord_sf() +
    annotation_scale(location = "br",
                     pad_x = unit(.5, "cm"), pad_y = unit(.7, "cm"),) +
    annotation_north_arrow(location = "br", which_north = "true",
                           pad_x = unit(.4, "cm"), pad_y = unit(1.3, "cm"),
                           style = north_arrow_fancy_orienteering) +
    annotate(geom = "text", label = "CRS: WGS84/Geo", 
             x = -47.51, y = -22.53, size = 3) +
    labs(title = "Eleva√ß√£o de Rio Claro/SP", fill = "Eleva√ß√£o (m)", 
         x = "Longitude", y = "Latitude") +
    theme_bw() +
    theme(title = element_text(size = 15, face = "bold"),
          legend.title = element_text(size = 10, face = "bold"),
          legend.position = c(.2, .25),
          legend.background = element_rect(colour = "black"),
          axis.title = element_text(size = 10, face = "plain"),
          axis.text.y = element_text(angle = 90, hjust = .4))
mapa_srtm_rio_claro_ggplot2
```

Para exportar mapas criados com o pacote `ggplot2`, podemos utilizar a fun√ß√£o `ggplot2::ggsave()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura.

```{r eval=FALSE}
## Exportar mapa ggplot2
ggsave(filename = here::here("dados", "mapas", "srtm_rio_claro_ggplot2.png"),
       plot = mapa_srtm_rio_claro_ggplot2, width = 20, height = 20, units = "cm", dpi = 300)
```

**Pacote tmap**

O pacote `tmap` √© um pacote direcionado √† cria√ß√£o de mapas tem√°ticos, com uma sintaxe concisa que permite a cria√ß√£o de mapas com o m√≠nimo de c√≥digos, mas muito similar √† sintaxe do pacote `ggplot2` [@tmap2018]. Ele tamb√©m pode gerar mapas est√°ticos ou interativos usando o mesmo c√≥digo, apenas mudando a forma de visualiza√ß√£o com a fun√ß√£o `tmap_mode()`, com o argumento `mode` igual a "plot" para est√°tico e "view" para interativo. Por fim, o pacote `tmap` aceita diversas classes espaciais, incluindo objetos raster, de forma bastante simples. Mais sobre o pacote pode ser lido [aqui](https://mtennekes.github.io/tmap/). 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Atentar para a instala√ß√£o extra em Sistemas Operacionais [GNU/Linux](https://geocompr.github.io/post/2020/installing-r-spatial-ubuntu/) e [MacOS](http://www.kyngchaos.com).
:::

Todas as fun√ß√µes do pacote `tmap` iniciam-se com `tm_*`, facilitando seu uso. A cada fun√ß√£o iremos utilizar o sinal de `+` para acrescentar outra camada, da mesma forma que o pacote `ggplot2`. A principal fun√ß√£o, em que todos os objetos geoespaciais s√£o dados de entrada, √© `tm_shape()`. A partir dela, podemos seguir com fun√ß√µes espec√≠ficas para vizualiza√ß√£o de objetos `sf`, como `tm_polygons()`, `tm_borders()`, `tm_fill()`, `tm_lines()`, `tm_dots()` ou `tm_bubbles()`, ou com fun√ß√µes para objetos raster como `tm_raster()`. Ainda h√° fun√ß√µes como `tm_text()` para representa√ß√£o de textos das colunas da tabela de atributos, e `tm_scale_bar()`, `tm_compass()` e `tm_graticules()`, para adicionar barra de escala, indicador de orienta√ß√£o (Norte) e gride de coordenadas, respectivamente. Por fim, a fun√ß√£o `tm_credits()` adiciona um texto descritivo e a fun√ß√£o `tm_layout()` faz diversas mudan√ßas nos detalhes e apresenta√ß√£o do mapa.

Uma funcionalidade muito interessante do pacote `tmap` √© o uso da fun√ß√£o `tmaptools::palette_explorer()` para escolher as paletas de cores dispon√≠veis. Essa fun√ß√£o requer que os pacotes `shiny` e `shinyjs` estejam instalados, e quando executada, retorna uma aba onde √© poss√≠vel editar e escolher algumas paletas de cores nativas do `tmap`.

Diversos par√¢metros podem ser acrescentados √†s fun√ß√µes de composi√ß√£o do tmap, mas n√£o as detalharemos aqui, pois todas s√£o descritas nos vignettes do pacote: [tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) e [tmap: version changes](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes.html).

Vamos seguir com a composi√ß√£o do mapa de biomas para o Brasil apresentado no in√≠cio dessa se√ß√£o (Figura \@ref(fig:fig-vetor-mapa-tmap)).

```{r fig-vetor-mapa-tmap, fig.cap="Mapa de Biomas do Brasil com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
mapa_vetor_biomas_tmap <- tm_shape(geo_vetor_biomas, bbox = c(-74, -35, -27, 10)) +
    tm_polygons(col = "nome_bioma",
                pal = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"),
                border.col = "black",
                title = "Legenda") +
    tm_compass() +
    tm_scale_bar(text.size = .6) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
    tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
    tm_layout(title = "Biomas do Brasil",
              title.position = c(.25, .95),
              title.size = 1.8,
              title.fontface = "bold",
              legend.frame = TRUE,
              legend.position = c("left", "bottom"),
              legend.title.fontface = "bold")
mapa_vetor_biomas_tmap
```

Al√©m disso, o pacote `tmap` nos permite adicionar de forma simples um mapa secund√°rio, provendo uma localiza√ß√£o regional de interesse (Figura \@ref(fig:fig-vetor-mapa-sec-tmap)).

```{r}
## Dados
geo_vetor_am_sul <- rnaturalearth::ne_countries(continent = "South America")
geo_vetor_brasil <- rnaturalearth::ne_countries(country = "Brazil")
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro")
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_am_sul
ecodados::geo_vetor_brasil
ecodados::geo_vetor_biomas
```

```{r fig-vetor-mapa-sec-tmap, fig.cap="Mapa vetorial prim√°rio e secund√°rio com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa secund√°rio
mapa_am_sul <- tm_shape(geo_vetor_am_sul) +
    tm_polygons() +
    tm_shape(geo_vetor_brasil) +
    tm_polygons(col = "gray50")

## Juntando os mapas
mapa_vetor_biomas_tmap
print(mapa_am_sul, vp = grid::viewport(.815, .875, wi = .2, he = .2))
```

Como exemplo de mapa raster, vamos compor novamente o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-tmap)).

```{r fig-raster-mapa-tmap, fig.cap="Mapa raster de eleva√ß√£o com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
mapa_srtm_rio_claro_tmap <- tm_shape(geo_raster_srtm_rio_claro) +
    tm_raster(pal = "viridis", title = "Eleva√ß√£o (m)") +
    tm_shape(geo_vetor_rio_claro) +
    tm_borders(col = "red", lwd = 2) +
    tm_compass(position = c(.9, .08)) +
    tm_scale_bar(text.size = .6, position = c(.67, 0)) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: WGS84/Geo", position = c(.67, .06)) +
    tm_layout(title = "Eleva√ß√£o Rio Claro/SP",
              title.size = 1,
              title.fontface = "bold",
              legend.title.size = .7,
              legend.text.size = .6,
              legend.frame = TRUE,
              legend.position = c(.01, .01),
              legend.title.fontface = "bold")
mapa_srtm_rio_claro_tmap
```

Para exportar mapas criados com o pacote `tmap` podemos utilizar a fun√ß√£o `tmap::tmap_save()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura.

```{r eval=FALSE}
## Exportar mapa tmap
tmap::tmap_save(tm = mapa_srtm_rio_claro_tmap, 
                filename = here::here("dados", "mapas", "srtm_rio_claro_tmap.png"),
                width = 20, height = 20, units = "cm", dpi = 300)
```

### Mapas animados

Podemos montar mapas facetados para mostrar como padr√µes espaciais variam ao longo do tempo, como por exemplo, os limites do Brasil ao longo dos anos (Figura \@ref(fig:fig-vetor-brasil-tmap-facted)). Entretanto, essa abordagem possui algumas desvantagens, de modo que as facetas podem ficar muito pequenas quando h√° muitas delas.

```{r}
## Dados
geo_vetor_brasil_anos <- NULL
for(i in c(1872, 1900, 1911, 1920, 1933, 1940, 1950, 1960, 1970,
           1980, 1991, 2001, 2010, 2019)){
    geo_vetor_brasil_anos <- geobr::read_state(code_state = "all",
                                               year = i, showProgress = FALSE) %>% 
        sf::st_geometry() %>% 
        sf::st_as_sf() %>%
        dplyr::mutate(year = i) %>% 
        dplyr::bind_rows(geo_vetor_brasil_anos, .)
}
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_brasil_anos
```

```{r fig-vetor-brasil-tmap-facted, fig.cap="Mapa vetor facetado dos estados brasileiros ao longo do tempo com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa facetado
mapa_brasil_tmap <- tm_shape(geo_vetor_brasil_anos) + 
    tm_polygons() + 
    tm_facets(by = "year", nrow = 4)
mapa_brasil_tmap
```

Uma solu√ß√£o √© a composi√ß√£o de mapas animados. Apesar de dependerem da publica√ß√£o digital, os mapas animados podem aprimorar relat√≥rios f√≠sicos √† medida que o v√≠nculo a uma p√°gina da web contendo a vers√£o animada torna-se simples. Existem v√°rias maneiras de gerar anima√ß√µes em R, e uma forma √© com o pacote `gganimate` e `ggplot2`. Entretanto, aqui veremos a cria√ß√£o de mapas animados com `tmap`.

Podemos criar mapas animados alterando dois argumentos da fun√ß√£o `tm_facets()`:

-   trocando o `by = year` por `along = year`
-   indicando o `free.coords = FALSE`

Por fim, podemos exportar o mapa animado no formato de `.gif` utilizando a fun√ß√£o `tmap::tmap_animation()`, indicando a taxa de atualiza√ß√£o com o argumento `delay` (Figura \@ref(fig:fig-vetor-brasil-tmap-animated)). Alguns pacotes extras s√£o requeridos dependendo do sistema operacional utilizado.

```{r eval=FALSE}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa animado
mapa_brasil_tmap_ani <- tm_shape(geo_vetor_brasil_anos) + 
    tm_polygons() + 
    tm_facets(along = "year", free.coords = FALSE)

## Exportar mapa tmap animado
tmap::tmap_animation(tm = mapa_brasil_tmap_ani, 
                     filename = here::here("dados", "mapas",
                                           "srtm_rio_claro_tmap_ani.gif"), 
                     delay = 30)
```

```{r fig-vetor-brasil-tmap-animated, echo=FALSE, fig.cap="Mapa vetorial animado mostrando os estados brasileiros ao longo do tempo com o pacote `tmap`."}
knitr::include_graphics("img/cap15_fig75.gif")
```

### Mapas interativos

Mapas interativos podem assumir muitas formas, sendo que a mais comum e √∫til √© a capacidade de deslocar e ampliar qualquer parte de um conjunto de dados geoespaciais sobreposto em um "mapa da web". Diversos pacotes nos permitem criar esse tipo de mapa, sendo os mais comuns o `tmap`, `mapview` e `leaflet`.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Destacamos que esses mapas ir√£o ser compostos numa janela especial de "Viewer".
:::

**pacote tmap**

Um recurso exclusivo do `tmap` √© sua capacidade de criar mapas est√°ticos e interativos usando o mesmo c√≥digo. Os mapas podem ser visualizados interativamente em qualquer ponto mudando para o modo de visualiza√ß√£o, usando a fun√ß√£o `tmap::tmap_mode(mode = "view")` (Figura \@ref(fig:fig-raster-mapa-tmap-int)).

```{r}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "view")

## Atribuir novo mapa interativo
mapa_srtm_rio_claro_tmap_int <- mapa_srtm_rio_claro_tmap
```

```{r fig-raster-mapa-tmap-int, echo=FALSE, fig.cap="Mapa vetorial interativo com o pacote `tmap`."}
#knitr::include_url("img/cap15_fig76.html")
```

Para exportar mapas interativos criados com o pacote `tmap`, podemos utilizar novamente a fun√ß√£o `tmap::tmap_save()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa tmap interativo
tmap::tmap_save(tm = mapa_srtm_rio_claro_tmap_int, 
                filename = here::here("dados", "mapas", "srtm_rio_claro_tmap_int.html"))
```

**Pacote mapview**

O pacote `mapview` cria rapidamente mapas interativos simples com a fun√ß√£o `mapvew::mapview()` (Figura \@ref(fig:fig-raster-mapa-mapview-int)). Entretanto, outras caracter√≠sticas podem ser mudadas para criar mapas mais elaborados, como pode ser visto atrav√©s do [site do pacote](https://r-spatial.github.io/mapview).

```{r}
## Mapa
mapa_srtm_rio_claro_mapview_int <- mapview::mapview(
    geo_raster_srtm_rio_claro, col.regions = viridis::viridis(100))
```

```{r fig-raster-mapa-mapview-int, echo=FALSE, fig.cap="Mapa vetorial interativo com o pacote `mapview`."}
#knitr::include_url("img/cap15_fig77.html")
```

Para exportar mapas interativos criados com o pacote `mapview`, podemos utilizar a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa mapview interativo
mapview::mapshot(x = mapa_srtm_rio_claro_mapview_int, 
                 url = here::here("dados", "mapas", "srtm_rio_claro_mapview_int.html"))
```

**Pacote leaflet**

O `leaflet` √© um dos pacotes de mapeamento interativo mais utilizados e completos em R. Esse pacote fornece uma interface utilizando a biblioteca JavaScript e muitos argumentos podem ser compreendidos lendo a documenta√ß√£o da [biblioteca original](leafletjs.com).

Mapas interativos usando esse pacote s√£o criados utilizando a fun√ß√£o `leaflet::leaflet()`. O resultado dessa fun√ß√£o √© um objeto da classe leaflet, que pode ser alterado por outras fun√ß√µes deste mesmo pacote, permitindo que v√°rias camadas e configura√ß√µes de controle sejam adicionadas interativamente (Figura \@ref(fig:fig-raster-mapa-leaflet-int)).

Mais sobre o pacote `leaflet` pode ser consultado em seu [site](https://rstudio.github.io/leaflet/) e [CheatSheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/leaflet.pdf).

```{r}
## Paleta de cores
pal <- colorNumeric(viridis::viridis(10), raster::values(geo_raster_srtm_rio_claro))

## Mapa
mapa_srtm_rio_claro_leaflet_int <- leaflet() %>%
    addProviderTiles("CartoDB.Positron") %>% 
    addRasterImage(geo_raster_srtm_rio_claro, colors = pal, opacity = .8) %>%
    addLegend(pal = pal, values = raster::values(geo_raster_srtm_rio_claro), 
              title = "Eleva√ß√£o (m)") %>% 
    addPolygons(data = geo_vetor_rio_claro, col = "red", fill = NA)
```

```{r fig-raster-mapa-leaflet-int, fig.cap="Mapa vetorial interativo com o pacote *leaflet*."}
#knitr::include_url("img/cap15_fig78.html")
```

Para exportar mapas interativos criados com o pacote `leaflet`, podemos utilizar novamente a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa leaflet interativo
mapview::mapshot(x = mapa_srtm_rio_claro_leaflet_int, 
                 url = here::here("dados", "mapas", "srtm_rio_claro_leaflet_int.html"))
```

## Exemplos de aplica√ß√µes de an√°lises geoespaciais para dados ecol√≥gicos

Agora que vimos os principais conceitos e aplica√ß√µes do manejo e visualiza√ß√£o de dados geoespaciais, podemos avan√ßar para realizar quatro exemplos de aplica√ß√µes para dados ecol√≥gicos. Para isso, usaremos novamente os dados de comunidades de anf√≠bios da Mata Atl√¢ntica [@vancine2018]. Primeiramente, veremos como resumir informa√ß√µes de biodiversidade (n√∫mero de ocorr√™ncias e riqueza) para hex√°gonos. Num segundo momento, veremos como associar dados ambientais a coordenadas de esp√©cies ou comunidades. Depois, como resumir dados de rasters para buffers. Por fim, realizaremos predi√ß√µes espaciais cont√≠nuas de adequabilidade de habitat para uma esp√©cie e do n√∫mero de esp√©cies.

### Resumir informa√ß√µes de biodiversidade para unidades espaciais

Resumir informa√ß√µes para unidades espaciais √© um passo muito frequente em an√°lises de Macroecologia, Biogeografia ou Ecologia da Paisagem. Nesta se√ß√£o, contabilizaremos o n√∫mero de ocorr√™ncias e riqueza de anf√≠bios para hex√°gonos na Mata Atl√¢ntica.

Primeiramente, vamos importar e preparar os dados de biodiversidade que usaremos nesses exemplos. Vamos come√ßar importando os locais de amostragens de anf√≠bios na Mata Atl√¢ntica e selecionando apenas as colunas de interesse.

```{r}
## Importar locais
geo_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    col_types = cols()) %>%
    dplyr::select(id, longitude, latitude, species_number)
```

Agora vamos importar as esp√©cies das comunidades, selecionando apenas as esp√©cies com nomes v√°lidos e transformando a coluna de indiv√≠duos para 1, para compor posteriormente uma matriz de comunidade de esp√©cies.

```{r}
## Importar esp√©cies
geo_anfibios_especies <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_species.csv"), 
    col_types = cols()) %>%
    tidyr::drop_na(valid_name) %>% 
    dplyr::select(id, valid_name, individuals) %>% 
    dplyr::distinct(id, valid_name, .keep_all = TRUE) %>% 
    dplyr::mutate(individuals = tidyr::replace_na(individuals, 1),
                  individuals = ifelse(individuals > 0, 1, 1))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_anfibios_locais
ecodados::geo_anfibios_especies
```

Podemos agora juntar a tabela de locais, que possui as coordenadas √† tabela de esp√©cies. Em seguida convertemos essa √∫nica tabela na classe vetor `sf`.

```{r}
## Jun√ß√£o das coordenadas e convers√£o para classe sf
geo_anfibios_especies_locais_vetor <- geo_anfibios_especies %>% 
    dplyr::left_join(geo_anfibios_locais, by = "id") %>% 
    dplyr::relocate(longitude, latitude, .after = 1) %>% 
    dplyr::mutate(lon = longitude, lat = latitude) %>% 
    sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Agora vamos baixar o limite do Bioma da Mata Atl√¢ntica para o Brasil, converter o GCS para WGS84/Geo e ajustar sua extens√£o para remover as ilhas no Oceano Atl√¢ntico.

```{r warning=FALSE, message=FALSE}
## Download do Bioma da Mata Atl√¢ntica
geo_vetor_mata_atlantica <- geobr::read_biomes(year = 2019, showProgress = FALSE) %>% 
    dplyr::filter(name_biome == "Mata Atl√¢ntica") %>% 
    sf::st_transform(crs = 4326) %>% 
    sf::st_crop(xmin = -55, ymin = -30, xmax = -34, ymax = -5)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_mata_atlantica
```

Podemos verificar se as coordenadas e o limite do bioma est√£o todos corretos compondo um mapa preliminar, usando o pacote `tmap` (Figura \@ref(fig:fig-vetor-aa-ma)).

```{r fig-vetor-aa-ma, fig.cap="Mapa dos locais do Atlantic Amphibians e do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_anfibios_especies_locais_vetor) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor) +
    tm_dots(size = .1, col = "forestgreen")
```

Como o limite utilizado para reunir informa√ß√µes das comunidades de anf√≠bios foi o mais abrangente poss√≠vel [@muylaert2018; @vancine2018], selecionaremos apenas os locais que caem dentro do limite da Mata Atl√¢ntica que estamos utilizando aqui.

```{r}
## Selecionar os locais dentro do limite
geo_anfibios_especies_locais_vetor_mata_atlantica <- geo_anfibios_especies_locais_vetor[geo_vetor_mata_atlantica, ]
```

Podemos refazer o mapa mostrando as coordenadas retiradas em vermelho e as que ficaram em verde (Figura \@ref(fig:fig-vetor-aa-ma-sel)).

```{r fig-vetor-aa-ma-sel, fig.cap="Mapa dos locais do Atlantic Amphibians que caem dentro do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica,
         bbox = geo_anfibios_especies_locais_vetor) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor) +
    tm_bubbles(size = .1, col = "red") +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica) +
    tm_bubbles(size = .1, col = "forestgreen")
```

O pr√≥ximo passo √© criar um gride de hex√°gonos para o Bioma da Mata Atl√¢ntica. Usaremos a fun√ß√£o `sf::st_make_grid()` que pode criar quadr√≠culas ou hex√°gonos. Esses hex√°gonos ter√£o a √°rea equivalente √† quadr√≠culas de 1¬∫ de tamanho (aproximadamente 10000 km¬≤). Usaremos a fun√ß√£o `sf::st_area()` para calcular as √°reas dos hex√°gonos e a fun√ß√£o `tibble::rowid_to_column()` para criar uma identifica√ß√£o para cada fei√ß√£o.

```{r}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Criar hex√°gonos de ~110 km
geo_vetor_mata_atlantica_hex <- sf::st_make_grid(
    x = geo_vetor_mata_atlantica, cellsize = 1, square = FALSE) %>% 
    sf::st_as_sf() %>% 
    dplyr::mutate(areakm2 = sf::st_area(.)/1e6) %>% 
    tibble::rowid_to_column("id_hex")

## Selecionar os hex√°gonos dentro do limite da Mata Atl√¢ntica
geo_vetor_mata_atlantica_hex <- geo_vetor_mata_atlantica_hex[geo_vetor_mata_atlantica, ]
```

Podemos conferir os hex√°gonos criados fazendo um mapa preliminar (Figura \@ref(fig:fig-vetor-aa-ma-sel-hex)).

```{r fig-vetor-aa-ma-sel-hex, fig.cap="Mapa dos hex√°gonos para o limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_vetor_mata_atlantica_hex) +
    tm_polygons() +
    tm_shape(geo_vetor_mata_atlantica_hex) +
    tm_borders()
```

Podemos ser mais restritos e selecionar apenas os hex√°gonos dentro do limite do Bioma da Mata Atl√¢ntica utilizando o operador `st_within()` (Figura \@ref(fig:fig-vetor-aa-ma-sel-hex-total).

```{r}
## Selecionar os hex√°gonos totalmente dentro do limite da Mata Atl√¢ntica
geo_vetor_mata_atlantica_hex_total <- geo_vetor_mata_atlantica_hex[geo_vetor_mata_atlantica, , op = st_within]
```

```{r fig-vetor-aa-ma-sel-hex-total, fig.cap="Mapa dos hex√°gonos totalmente dentro do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_vetor_mata_atlantica_hex) +
    tm_polygons() +
    tm_shape(geo_vetor_mata_atlantica_hex_total) +
    tm_borders()
```

Podemos agora associar as esp√©cies aos hex√°gonos fazendo um "join" espacial, utilizando a fun√ß√£o `sf::st_join()`.

```{r}
## Jun√ß√£o espacial dos locais com os hex√°gonos
geo_vetor_mata_atlantica_hex_especies <- sf::st_join(
    x = geo_vetor_mata_atlantica_hex, 
    y = geo_anfibios_especies_locais_vetor_mata_atlantica,
    left = TRUE)
```

Por fim, podemos agregar os dados para ter o n√∫mero de ocorr√™ncias e de esp√©cies por hex√°gono.

```{r}
## Agregar dados de ocorr√™ncias e n√∫mero de esp√©cies por hex√°gono
geo_vetor_mata_atlantica_hex_especies_oco_riq <- geo_vetor_mata_atlantica_hex_especies %>% 
    dplyr::group_by(id_hex) %>% 
    dplyr::summarise(ocorrencias = length(valid_name[!is.na(valid_name)]),
                     riqueza = n_distinct(valid_name, na.rm = TRUE))
```

Finalmente podemos compor os mapas finais, mostrando os hex√°gonos com cores e valores do n√∫mero de ocorr√™ncias e de esp√©cies \@ref(fig:fig-vetor-aa-ma-sel-hex-oco-riq)).

```{r fig-vetor-aa-ma-sel-hex-oco-riq, fig.cap="Mapa com o n√∫mero de ocorr√™ncias e riqueza de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa de ocorr√™ncias
mapa_oco <- tm_shape(geo_vetor_mata_atlantica_hex_especies_oco_riq) +
    tm_polygons(title = "Ocorr√™ncia de anf√≠bios", col = "ocorrencias", 
                pal = "viridis", style = "pretty") +
    tm_text("ocorrencias", size = .4) +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Mapa de riqueza
mapa_riq <- tm_shape(geo_vetor_mata_atlantica_hex_especies_oco_riq) +
    tm_polygons(title = "Riqueza de anf√≠bios", col = "riqueza", 
                pal = "viridis", style = "pretty") +
    tm_text("riqueza", size = .4) +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Uni√£o dos mapas
#tmap_arrange(mapa_oco, mapa_riq)
```

### Extrair dados raster para pontos

Atribuir informa√ß√µes ambientais a ocorr√™ncias √© um passo fundamental para diversas an√°lises. Nesta se√ß√£o, atribuiremos os valores das vari√°veis bioclim√°ticas aos locais de amostragem de anf√≠bios na Mata Atl√¢ntica.

J√° realizamos o download das vari√°veis bioclim√°ticas na se√ß√£o de raster. Vamos importar novamente esses dados, primeiramente listando as camadas e depois importando com a fun√ß√£o `raster:stack()`.

```{r}
## Listar arquivos
arquivos_raster <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
    grep(".tif", ., value = TRUE)

## Importar rasters
geo_raster_bioclim <- raster::stack(here::here("dados", "raster", arquivos_raster))

## Renomear rasters
names(geo_raster_bioclim) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_bioclim
```

Da se√ß√£o anterior, j√° temos o objeto com a tabela de coordenadas dos locais de amostragem das comunidades de anf√≠bios. Vamos agora criar um objeto vetorial das coordenadas e em seguida selecionar os locais dentro do limite do bioma da Mata Atl√¢ntica.

```{r}
## Importar locais e converter em sf
geo_anfibios_locais_vetor <- geo_anfibios_locais %>% 
    dplyr::mutate(lon = longitude, lat = latitude) %>% 
    sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
geo_anfibios_locais_vetor
```

Usaremos agora a fun√ß√£o `raster::extract()` para extrair e associar os valores das vari√°veis bioclim√°ticas para os locais de amostragem.

```{r}
## Extrair valores das vari√°veis para os locais
geo_anfibios_locais_vetor_bioclim <- geo_anfibios_locais_vetor %>% 
    dplyr::mutate(raster::extract(geo_raster_bioclim, ., df = TRUE)) %>% 
    dplyr::select(-ID) %>% 
    dplyr::relocate(bio02:bio09, .after = bio01)
```

Podemos ver esses dados na Tabela \@ref(tab:tab-aa-var).

```{r tab-aa-var, echo=FALSE}
## Visualizar os dados
geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(id:bio05) %>% 
    dplyr::slice(1:6) %>% 
    knitr::kable(caption = "Dados extra√≠dos e atribu√≠dos aos locais
               de amostragens de comunidades de anf√≠bios na Mata Atl√¢ntica")
```

Podemos ainda fazer alguns mapas para espacializar essas vari√°veis (Figura \@ref(fig:fig-vetor-aa-var)).

```{r fig-vetor-aa-var, fig.cap="Mapa mostrando os valores das vari√°veis bioclim√°ticas (BIO01:BIO06) para os locais amostrados de comunidades de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
geo_anfibios_locais_vetor_bioclim %>% 
    dplyr::select(bio01:bio06) %>% 
    tidyr::gather(var, val, -geometry) %>% 
    tm_shape() +
    tm_bubbles(size = .1, col = "val", pal = "viridis") +
    tm_facets("var", free.scales = TRUE) +
    tm_layout(legend.outside = FALSE)
```

### Resumir dados de rasters para buffers

Muitas an√°lises requerem que fa√ßamos um resumo da composi√ß√£o da paisagem para buffers, sendo o buffer uma unidade de an√°lise espacial no entorno de um ponto de amostragem.

Aqui, usaremos os dados do [GlobCover v.2.3](http://due.esrin.esa.int/page_globcover.php) de 2009 [@arino2012] como raster de cobertura da terra. O arquivo √© grande (\~400 Mb) e pode demorar muito, dependendo da velocidade da sua internet.

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e5)

## Download dos dados do GlobCover
download.file(url = "http://due.esrin.esa.int/files/Globcover2009_V2.3_Global_.zip",
              destfile = here::here("dados", "raster", "Globcover2009_V2.3_Global.zip"), 
              mode = "wb", extra = "c")

## Unzip
unzip(zipfile = here::here("dados", "raster", "Globcover2009_V2.3_Global.zip"),
      exdir = here::here("dados", "raster"))
```

Depois de fazer o download, vamos importar e ajustar esse raster para o limite da Mata Atl√¢ntica (Figura \@ref(fig:fig-raster-globcover)).

```{r}
## Importar raster do GlobCover
geo_raster_globcover <- raster::raster(
    here::here("dados", "raster", "GLOBCOVER_L4_200901_200912_V2.3.tif"))

## Ajustar para o limite do bioma da Mata Atl√¢ntica
geo_raster_globcover_mata_atlantica <- geo_raster_globcover %>% 
    raster::crop(geo_vetor_mata_atlantica) %>% 
    raster::mask(geo_vetor_mata_atlantica)
geo_raster_globcover_mata_atlantica
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_globcover_mata_atlantica
```

```{r fig-raster-globcover, fig.cap="Camada raster do GlobCover 2.3 para o Bioma da Mata Atl√¢ntica."}
# Plot
plot(geo_raster_globcover_mata_atlantica, col = viridis::viridis(n = 200))
```

Vamos agora transformar a tabela de locais em vetor, selecionar aleatoriamente 50 amostragens das comunidades de anf√≠bios e criar buffers de \~10 km.

```{r}
## Fixar a amostragem
set.seed(42)

## Pontos
geo_anfibios_especies_locais_vetor_mata_atlantica <- geo_anfibios_locais %>% 
    sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_mata_atlantica, sparse = FALSE)) %>% 
    dplyr::slice_sample(n = 50)

## Buffers de ~1 km
geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km <-
    sf::st_buffer(geo_anfibios_especies_locais_vetor_mata_atlantica,
                  dist = 1000)
```

Podemos conferir no mapa da Figura \@ref(fig:fig-vetor-aa-ma-buffer).

```{r fig-vetor-aa-ma-buffer, fig.cap="Distribui√ß√£o de 50 localidades aleat√≥rios e buffers de ~1 km (fora de escala)."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km) +
    tm_bubbles(size = .3, border.col = "red", alpha = 0) +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica) +
    tm_dots(size = .01, col = "forestgreen")
```

Agora podemos utilizar a fun√ß√£o `raster::extract()` para fazer a contabiliza√ß√£o, j√° em porcentagem, de pixels de cada classe para cada buffer.

```{r}
## Estat√≠stica zonal 
geo_anfibios_locais_vetor_ma_buffer10km_ext <- raster::extract(
    x = geo_raster_globcover_mata_atlantica,
    y = geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km,
    df = TRUE, na.rm = TRUE) %>% 
    dplyr::rename(id = ID, classe = 2) %>% 
    tidyr::drop_na(classe) %>% 
    dplyr::mutate(classe = paste0("classe_", classe)) %>%
    dplyr::group_by(id, classe) %>% 
    dplyr::summarise(n = n()) %>% 
    tidyr::pivot_wider(id_cols = id, names_from = classe, values_from = n) %>% 
    dplyr::mutate(across(everything(), ~replace_na(.x, 0))) %>% 
    janitor::adorn_totals("col") %>% 
    janitor::adorn_percentages("row") %>% 
    janitor::adorn_pct_formatting(rounding = "half up", digits = 1)
head(geo_anfibios_locais_vetor_ma_buffer10km_ext)
```

Agora podemos combinar esses dados aos dados dos buffers.

```{r}
## Combina√ß√£o
geo_anfibios_locais_vetor_ma_buffer10km_ext_bind  <- dplyr::bind_cols(
    x = geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km,
    y = geo_anfibios_locais_vetor_ma_buffer10km_ext[, -1]) %>% 
    sf::st_drop_geometry()
geo_anfibios_locais_vetor_ma_buffer10km_ext_bind
```

### Predi√ß√µes espaciais de objetos raster

O pacote `raster` al√©m de permitir realizar a manipula√ß√£o e visualiza√ß√£o de dados raster no R, tamb√©m permite a extrapola√ß√£o do ajuste de an√°lises, como `LMs`, `GLMs`, `GAMs` dentre outras (Cap√≠tulos \@ref(cap7) e \@ref(cap8)). Aqui, faremos uma pequena demostra√ß√£o utilizando a fun√ß√£o `raster::predict()`, predizendo o resultado de dois ajustes de GLMs para a presen√ßa/aus√™ncia de uma esp√©cie de anuro e a extrapola√ß√£o do n√∫mero de esp√©cies de anf√≠bios para o Bioma da Mata Atl√¢ntica.

Para ajustar um GLM para dados de presen√ßa/aus√™ncia, podemos usar a tabela j√° criada anteriormente, com as esp√©cies e as coordenadas, e fazer uma jun√ß√£o com a √∫ltima tabela que criamos com os dados bioclim√°ticos.

```{r}
## Jun√ß√£o dos dados ambientais aos dados de esp√©cies
geo_anfibios_locais_especies_vetor_bioclim <- geo_anfibios_especies %>% 
    dplyr::left_join(., sf::st_drop_geometry(geo_anfibios_locais_vetor_bioclim), by = "id")
```

Agora, vamos selecionar ocorr√™ncias da esp√©cie *Haddadus binotatus*, atribuindo **1** quando ela ocorre e **0** quando ela n√£o ocorre. Essa esp√©cie √© relativamente comum na serrapilheira de fragmentos florestais da Mata Atl√¢ntica, e recebe esse nome em homenagem a um grande pesquisador de anf√≠bios da Mata Atl√¢ntica, o **Prof. C√©lio Fernando Baptista Haddad**.

```{r}
## Sele√ß√£o da esp√©cie Haddadus binotatus
geo_anfibios_locais_especies_vetor_bioclim_hb <- geo_anfibios_locais_especies_vetor_bioclim %>% 
    dplyr::mutate(pa = ifelse(valid_name == "Haddadus binotatus", 1, 0), .after = individuals) %>% 
    dplyr::distinct(id, .keep_all = TRUE)
```

Vamos utilizar apenas as vari√°veis n√£o correlacionadas para o √≠ndice de correla√ß√£o de Pearson para r \< 0,7 (Cap√≠tulo \@ref(cap7)).

```{r message=FALSE, warning=FALSE}
## Correla√ß√£o entre as vari√°veis
corr <- geo_anfibios_locais_especies_vetor_bioclim_hb %>% 
    dplyr::select(bio01:bio19) %>% 
    cor() %>% 
    caret::findCorrelation(.7, names = TRUE)

## Sele√ß√£o das vari√°veis n√£o correlacionadas
geo_anfibios_locais_especies_vetor_bioclim_hb_cor <- geo_anfibios_locais_especies_vetor_bioclim_hb %>% 
    dplyr::select(pa, bio01:bio19) %>% 
    dplyr::select(-c(corr))
```

Agora sim, podemos ajustar um modelo simples da presen√ßa e aus√™ncia dessa esp√©cie, utilizando as vari√°veis n√£o correlacionadas, atrav√©s de um GLM para a fam√≠lia binomial. Nosso intuito n√£o analisar se o modelo atende √† todos os pressupostos, e sim exemplificar a predi√ß√£o espacial, para esses detalhes, consulte o Cap√≠tulo \@ref(cap8).

```{r}
## Ajustar um modelo GLM binomial
modelo_pa <- glm(formula = pa ~ ., 
                 data = geo_anfibios_locais_especies_vetor_bioclim_hb_cor, 
                 family = binomial("logit"))
```

Antes de fazermos a predi√ß√£o da distribui√ß√£o potencial da esp√©cie √© fundamental que o objeto raster esteja ajustado para o limite da Mata Atl√¢ntica. Para isso vamos utilizar as fun√ß√µes `raster::crop()` e `raster::mask()` para fazer esse ajuste \@ref(fig:fig-raster-bio-ajuste)).

```{r}
## Ajuste da extens√£o e limite
geo_raster_bioclim_mata_atlantica <- geo_raster_bioclim %>% 
    raster::crop(geo_vetor_mata_atlantica) %>% 
    raster::mask(geo_vetor_mata_atlantica)
```

```{r fig-raster-bio-ajuste, fig.cap="Mapa de dois rasters (BIO01 e BIO12) ajustados ao limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_raster_bioclim_mata_atlantica[[c(1, 4)]]) +
    tm_raster(pal = "viridis", title = c("bio01", "bio12")) +
    tm_facets(free.scales.raster = TRUE)
```

Agora podemos fazer a predi√ß√£o desse modelo para todo o Bioma da Mata Atl√¢ntica. Essa fun√ß√£o vai utilizar os coeficientes do modelo ajustado para gerar um raster de predi√ß√£o para todos os pixels da Mata Atl√¢ntica. Vamos usar o argumento `type = "response"` para que os valores da predi√ß√£o sejam ajustados a 0 a 1.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para que a predi√ß√£o funcione, os nomes das camadas raster `geo_raster_bioclim_mata_atlantica` devem possuir o mesmo nome das colunas das vari√°veis preditoras ajustadas no modelo `modelo_pa`.
:::

```{r}
## Predi√ß√µes
modelo_pa_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica, 
    model = modelo_pa,
    type = "response")
modelo_pa_pred
```

Por fim, no √∫ltimo passo podemos tornar esse modelo bin√°rio, ou seja, apenas com valores 0 ou 1. Para isso vamos adotar arbitrariamente o valor de 0,01 como ponto de corte. A partir desse valor consideraremos o pixels acima como 1 e abaixo como 0.

```{r}
## Sele√ß√£o dos pixels de presen√ßa/aus√™ncia potencial
modelo_pa_pred_corte <- modelo_pa_pred >= .01
```

Por fim, vamos produzir dois mapas mostrando os valores das predi√ß√µes, o mapa bin√°rio e as ocorr√™ncias da esp√©cie \@ref(fig:fig-raster-pred-modelo-bin)).

```{r fig-raster-pred-modelo-bin, fig.cap="Mapa da predi√ß√£o cont√≠nua e bin√°ria do modelo ajustado para a presen√ßa/aus√™ncia da esp√©cie *Haddadus binotatus* na Mata Atl√¢ntica e suas ocorr√™ncias."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa de predi√ß√£o cont√≠nua
mapa_pa_pred_cont <- tm_shape(modelo_pa_pred) +
    tm_raster(title = "Predi√ß√£o cont√≠nua", pal = "viridis") +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Mapa de predi√ß√£o bin√°ria
mapa_pa_pred_corte <- tm_shape(modelo_pa_pred_corte) +
    tm_raster(title = "Predi√ß√£o bin√°ria", pal = c("#440154", "#fde725"), 
              labels = c("Potencialmente ausente", "Potencialmente presente")) +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Uni√£o dos mapas
# tmap_arrange(mapa_pa_pred_cont, mapa_pa_pred_corte)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essa an√°lise foi realizada com o intuito de exemplificar o funcionamento da fun√ß√£o `raster::predict()`, para mais detalhes, consultar livros espec√≠ficos da √°rea de Modelagem de Distribui√ß√£o de Esp√©cies ou Modelagem de Nicho Ecol√≥gico [@franklin_mapping_2009; @peterson_ecological_2011; @guisan_habitat_2017 e @fletcher2018].
:::

Em nossa segunda an√°lise, vamos predizer os dados de riqueza para todo o bioma da Mata Atl√¢ntica. Para isso, temos de retirar novamente as vari√°veis correlacionadas.

```{r}
## Correla√ß√£o
corr <- geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(bio01:bio19) %>% 
    cor() %>% 
    caret::findCorrelation(.7, names = TRUE)

## Sele√ß√£o das vari√°veis n√£o correlacionadas
geo_anfibios_locais_bioclim_cor <- geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(species_number, bio01:bio19) %>% 
    dplyr::select(-c(corr))
```

Agora sim, podemos criar os GLMs com fam√≠lias de distribui√ß√£o apropriadas para dados de contagem como Poisson e Binomial Negativa. Nosso intuito n√£o analisar se o modelo atende √† todos os pressupostos, e sim exemplificar a predi√ß√£o espacial, para esses detalhes, consulte o Cap√≠tulo \@ref(cap8).

```{r}
## Modelo Poisson
modelo_riq_pois <- glm(
    formula = species_number ~ ., 
    data = geo_anfibios_locais_bioclim_cor, 
    family = poisson)

## Modelo Binomial Negativo
modelo_riq_nb <- MASS::glm.nb(
    formula = species_number ~ .,
    data = geo_anfibios_locais_bioclim_cor)
```

Com os modelos ajustados, podemos fazer as predi√ß√µes utilizando os objetos raster com as vari√°veis ambientais.

```{r}
## Predi√ß√£o do modelo Poisson
modelo_riq_pois_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica,
    model = modelo_riq_pois,
    type = "response")
modelo_riq_pois_pred

## Predi√ß√£o do modelo Binomial Negativo
modelo_riq_nb_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica,
    model = modelo_riq_nb,
    type = "response")
modelo_riq_nb_pred
```

Por fim, podemos compor os dois mapas de predi√ß√µes (Figura \@ref(fig:fig-raster-pred-modelo-riq)).

```{r fig-raster-pred-modelo-riq, fig.cap="Mapa da predi√ß√£o de riqueza utilizando o modelo Poisson e Binomial Negativa para a Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa da predi√ß√£o Poisson
mapa_pred_riq_pois <- tm_shape(modelo_riq_pois_pred) +
    tm_raster(title = "N√∫mero de esp√©cies (Poisson)", pal = "viridis") +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Mapa predi√ß√£o Binomial Negativo
mapa_pred_riq_nb <- tm_shape(modelo_riq_nb_pred) +
    tm_raster(title = "N√∫mero de esp√©cies (Binomial Negativa)", pal = "viridis") +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Uni√£o dos mapas
# tmap_arrange(mapa_pred_riq_pois, mapa_pred_riq_nb)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essa an√°lise foi realizada com o intuito de exemplificar o funcionamento da fun√ß√£o `raster::predict()`, para mais detalhes, consultar livros espec√≠ficos da √°rea de Ecologia Espacial [@fletcher2018].
:::

## Para se aprofundar

### Livros

Listamos aqui as principais refer√™ncias sobre manipula√ß√£o, visualiza√ß√£o de dados geoespaciais e an√°lises geoespaciais no R. Recomendamos aos interessados os livros: i) Lovelace, Nowosad & Muenchow [-@lovelace2019] [Geocomputation with R](https://geocompr.robinlovelace.net/), ii) Mas et al. [-@mas2019] [An√°lise espacial com R](https://bit.ly/2KpSI7C), iii) Olaya [-@olaya2020] [Sistemas de Informaci√≥n Geogr√°fica](http://volaya.github.io/libro-sig/), iv) Moraga [-@moraga_geospatial_2019] [Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/), v) Brunsdon & Comber [-@brunsdon_introduction_2015] [An Introduction to Spatial Analysis and Mapping in R](https://bookdown.org/lexcomber/brunsdoncomber2e/), vi) Wegmann, Leutner & Dech [-@wegmann2016] Remote Sensing and GIS for Ecologists: Using Open Source Software, vii)  Wegmann, Schwalb-Willmann & Dech [-@wegmann2020] An Introduction to Spatial Data Analysis Remote Sensing and GIS with Open Source Software, viii) Fletcher & Fortin [-@fletcher2018] Spatial ecology and conservation modeling: Applications with R, ix) Lapaine, Miljenko, Usery, E. Lynn [-@lapaine2017] Choosing a Map Projection.

### Links

[Awesome Geospatial](https://github.com/sacridini/Awesome-Geospatial#r)

[Spatial Data Science](https://keen-swartz-3146c4.netlify.app/)

[Intro to GIS and Spatial Analysis](https://mgimond.github.io/Spatial/index.html)

[Introduction to Spatial Data Programming with R](https://geobgu.xyz/r/)

[R for Geographic Data Science](https://sdesabbata.github.io/r-for-geographic-data-science)

[Spatial Data Science with R](https://rspatial.org/#)

[Spatial Modelling for Data Scientists](https://gdsl-ul.github.io/san/)

[Predictive Soil Mapping with R](https://soilmapper.org/)

## Exerc√≠cios

**15.1**
Importe o limite dos estados brasileiros no formato `sf` com o nome `br`. Para isso, use a fun√ß√£o `ne_states` do pacote `rnaturalearth`. Crie um mapa simples cinza utilizando a fun√ß√£o `plot()`, selecionando a coluna  `geometry` com o operador `$` e com os argumentos `axes` e `graticule` verdadeiros.

**15.2**
Dados vetoriais podem ser criados com diversos erros de topologia, e.g., sobreposi√ß√£o de linhas ou pol√≠gonos ou buracos. Algumas fun√ß√µes exigem que os objetos vetoriais aos quais s√£o atribu√≠dos esses dados n√£o possuam esses wrros para que o algoritmo funcione. Para verificar se h√° erros, podemos usar a fun√ß√£o `st_is_valid()` do pacote `sf`. H√° diversas forma de corre√ß√µes desses erros, mas vamos usar uma corre√ß√£o simples do R, com a fun√ß√£o `st_make_valid()`. Vamos fazer essa corre√ß√£o para o `br` importado anteriormente e atribuindo ao objeto `br_valid`. Podemos conferir para saber se h√° erros e fazer um plot.

**15.3**
Crie um objeto RasterLayer vazio chamado `ra` com resolu√ß√£o de 5¬∫ (~600 km). Atribua um sistema de refer√™ncia de coordendas com o c√≥digo `4326`. Atribua valores aleat√≥rios de uma distribui√ß√£o normal e plote o mesmo.

**15.4**
Reprojete o limite dos estados brasileiros do exerc√≠cio anterior para o CRS SIRGAS 2000/Brazil Polyconic, utilizando o c√≥digo EPSG:5880 e chamando de `br_poly`. Fa√ßa um mapa simples como no exerc√≠cio 1. Atente para as curvaturas das linhas.

**15.5**
Utilizando a fun√ß√£o `st_centroid` do pacote `sf`, crie um vetor chamado  `br_valid_cen` que armazenar√° o centroide de cada estado brasileiro do objeto `br_valid` do exerc√≠cio 2 e plot o resultado.

**15.6**
Ajuste o limite e m√°scara do objeto raster criado no exerc√≠cio 3 para o  limite do Brasil, atribuindo ao objeto `ra_br`. Depois reprojete esse raster para a mesma proje√ß√£o utilizada no exerc√≠cio 4 com o nome `ra_br_poly` e plote o mapa resultante.

**15.7**
Extraia os valores de cada pixel do raster criado no exerc√≠cio 6 para os centroides dos estados do Brasil criado no exerc√≠cio 5, atribuindo √† coluna `val` do objeto espacial chamado `br_valid_poly_cent_ra`. 

**15.8**
Crie um mapa final usando os resultados dos exerc√≠cios 4, 5 e 6. Utilize o pacote `tmap` e inclua todos os principais elementos de um mapa.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-14---diversidade-filogen%C3%A9tica.html).

<!--chapter:end:15_geoespacial.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Gloss√°rio {-}

Nesse gloss√°rio, resumimos os principais conceitos e defini√ß√µes dos termos utilizados no texto principal que possam ser desconhecidos ou pouco claros para alguns leitores(as).

- **Abundance-based Coverage Estimator (ACE)**: estimador de riqueza de esp√©cies baseado na abund√¢ncia de esp√©cies raras  
- **Agrega√ß√£o (raster)**: aumentar o tamanho dos pixels (diminuindo a resolu√ß√£o) de um raster, agregando os valores dos pixels em um pixel maior
- **Agrupamento filogen√©tico**: esp√©cies coexistindo nas comunidades s√£o mais aparentadas do que esperado pelo acaso
- **Alinhamento (raster)**: ajusta o tamanho do pixel, extens√£o, n√∫mero e origem dos pixels para v√°rias camadas rasters
- **Ambiente ou *Environment* (RStudio)**: por√ß√£o onde os objetos criados s√£o armazenados
- **Amostra**: subconjunto da popula√ß√£o, selecionados por um processo adequado de amostragem, utilizado para estimar caracter√≠sticas de toda a popula√ß√£o
- **An√°lise de covari√¢ncia (ANCOVA)**: √© uma extens√£o da ANOVA com a adi√ß√£o de uma covari√°vel medida em todas as unidades amostrais
- **An√°lise de vari√¢ncia (ANOVA)**: √© um teste estat√≠stico que avalia se h√° diferen√ßas entre as m√©dias de tr√™s ou mais grupos independentes. Existem uma variedade de delineamentos experimentais como - ANOVA de um fator, ANOVA de dois fatores, ANOVA em blocos aleatorizados, ANOVA de medidas repetidas e ANOVA *split-splot* - que diferem na maneira que o teste estat√≠stico e os graus de liberdade s√£o calculados
- **An√°lise param√©trica**:  assume que os dados foram amostrados de uma distribui√ß√£o de forma conhecida (e.g., gaussiana, poisson, etc) e estima os par√¢metros (e.g., m√©dia, desvio padr√£o, etc) da distribui√ß√£o a partir dos dados
- **An√°lise n√£o param√©trica**:  n√£o pressup√µe que os dados foram amostrados de uma distribui√ß√£o de forma conhecida (e.g., gaussiana, poisson, etc) 
- **Array**: classe de objetos que representa elementos de um √∫nico modo no formato de combina√ß√£o de tabelas, com linhas, colunas e dimens√µes
- **√Årvore filogen√©tica**: s√£o hip√≥teses que representam o rela√ß√£o de parentesco entre as esp√©cies (pode ser tamb√©m indiv√≠duos, genes, etc.) com informa√ß√µes sobre quais esp√©cies compartilham um ancestral comum e a dist√¢ncia (tempo, gen√©tica, ou diferen√ßas nos caracteres) que as separam
- **Atributo funcional**: uma propriedade mensur√°vel dos organismos (geralmente em n√≠vel individual) que representa caracter√≠sticas morfol√≥gicas, fisiol√≥gicas ou fenol√≥gicas que afetam a aptid√£o alterando aspectos do crescimento, reprodu√ß√£o e sobreviv√™ncia
- **Atributos dos objetos**: s√£o o modo (natureza) e a estrutura (organiza√ß√£o) dos elementos nos objetos
- **Autovalor(Eigenvalue)**: n√∫mero inteiro (escalar) que multiplica um vetor, sendo portanto m√∫ltiplo deste. Esses valores representam a vari√¢ncia dos eixos e, se convertidos em valores relativos, medem a porcentagem de vari√¢ncia contida em cada eixo.  
- **Autovetor (Eigenvector)**: vetor n√£o nulo que muda somente quando √© multiplicado por um escalar. O autovetor de uma matriz √© encontrado pelo resultado da
multiplica√ß√£o de um vetor pela matriz, que √© igual a *lambda* vezes o vetor. Esse vetor do resultado passa a ser o autovetor, e o *lambda* o seu respectivo autovalor
- **Bloco (ANOVA)**: √© uma √°rea ou per√≠odo de tempo dentro do qual as condi√ß√µes ambientais s√£o relativamente homog√™neas. O objetivo do uso dos blocos √© controlar fontes de varia√ß√µes indesejadas na vari√°vel dependente que n√£o s√£o de interesse do pesquisador
- **Bootstrap**: estimador de riqueza de esp√©cies que estima os par√¢metros de uma popula√ß√£o por reamostragens
- **Buffer (vetor)**: pol√≠gono que representam a √°rea dentro de uma determinada dist√¢ncia de um dado vetorial, podendo ser a partir de um ponto, linha ou pol√≠gono
- **Camada (vetor ou raster)**: termo geral, mas geralmente associada √† diferentes rasters reunidos num mesmo arquivo
- **Centroide (vetor ou raster)**: ponto central de uma fei√ß√£o vetorial ou o centro do pixel do raster
- **Centr√≥ide (multivariado)**: m√©dia ponderada de um conjunto multivariado, a menor dist√¢ncia m√©dia de todos os objetos num espa√ßo multivariado
- **Chao 1**: estimador de riqueza de esp√©cies baseado na abund√¢ncia das esp√©cies singleton e doubletons dentro de uma amostra 
- **Chao 2**: estimador de riqueza de esp√©cies baseado na incid√™ncia (presen√ßa e aus√™ncia) das esp√©cies singleton e doubletons dentro de uma amostra 
- **Clado**: um grupo de esp√©cies aparentadas descendendo de um √∫nico n√≥ na filogenia
- **Coeficiente de correla√ß√£o**: indica a for√ßa da rela√ß√£o linear entre as duas vari√°veis
- **Coer√ß√£o (linguagem R)**: transforma√ß√£o dos modos dos elementos seguindo uma hierarquia: character > double > integer > logical
- **Combina√ß√£o linear**: Combina√ß√£o de v√°rias vari√°veis (vetores) que s√£o multiplicadas por constantes e adicionadas a outras vari√°veis. Por exemplo: combina√ß√£o linear de x, y, z pode ser escrita como ax+by+cz.
- **Community Mean Nearest Taxon Distance (COMDISTNT)**: m√©trica de diversidade beta que calcula a m√©dia da dist√¢ncia filogen√©tica/funcional entre o t√°xon mais pr√≥ximo das esp√©cies de duas comunidades
- **Community Mean Pairwise Distance (COMDIST)**: m√©trica de diversidade beta que calcula a m√©dia da dist√¢ncia filogen√©tica/funcional entre as esp√©cies de duas comunidades
- **Console (RStudio)**: onde a vers√£o da linguagem R instalada √© carregada para executar os c√≥digos no RStudio
- **Convers√£o (linguagem R)**: transforma√ß√£o dos modos ou estrutura dos elementos de um objeto a partir de fun√ß√µes espec√≠ficas
- **Convers√µes raster-vetor**: transformar dados vetoriais em rasters (rasteriza√ß√£o) e transformar rasters em vetores (vetoriza√ß√£o)
- **Convex Hull**: medida multivariada derivada da computa√ß√£o geom√©trica que calcula o espa√ßo dos atributos de uma esp√©cie ou de v√°rias esp√©cies em uma comunidade
- **Correla√ß√£o**: √© um teste que mede a for√ßa relativa da rela√ß√£o linear entre duas vari√°veis cont√≠nuas. A an√°lise de correla√ß√£o n√£o assume que a vari√°vel X influencie a vari√°vel Y, ou que exista uma rela√ß√£o de causa e efeito entre elas
- **Cortes e m√°scaras (raster)**: ajusta o tamanho de um dado raster a uma √°rea menor de interesse, geralmente definido por um dado vetorial
- **Covari√°vel**: vari√°vel cont√≠nua que potencialmente afeta a vari√°vel resposta, mas n√£o √© necessariamente controlada ou manipulada pelo pesquisador 
- **Crit√©rio de Informa√ß√£o de Akaike (*Akaike Information Criterion* - AIC)**: √© uma m√©trica para sele√ß√£o de modelos. Ele √© usado para determinar qual entre os m√∫ltiplos modelos √© o mais prov√°vel de prever os dados observados, ponderando pelo n√∫mero de par√¢metros dos modelos. Os menores valores de AIC representam modelos com memlhores ajustes aos dados
- **Curva de domin√¢ncia**: veja Diagrama de Whittaker
- **Dados geoespaciais**: s√£o dados georreferenciados que express√£o informa√ß√µes espaciais, podendo ser no formato vetorial ou matricial (raster)
- **Dados matriciais (raster)**: consistem em uma matriz (com linhas e colunas) em que os elementos representam c√©lulas, geralmente igualmente espa√ßadas (pixels)
- **Dados tidy**: dados organizados, com foco na limpeza e organiza√ß√£o dos mesmos, de modo que os dados est√£o *tidy* quando: i) vari√°veis est√£o nas colunas, ii) observa√ß√µes est√£o nas linhas e iii) valores est√£o nas c√©lulas, sendo que para esse √∫ltimo, n√£o deve haver mais de um valor por c√©lula
- **Dados vetoriais**: s√£o representa√ß√µes geom√©tricas (pontos, linhas e pol√≠gonos) usadas para mapear fen√¥menos ou objetos espacialmente expl√≠citos que possuem localiza√ß√£o ou dimens√µes bem definidas, aos quais s√£o atribu√≠das informa√ß√µes tabulares
- **Data frame**: classe de objetos que representa dados no formato de tabela, com linhas e colunas, mas comportam mais de um modo em suas colunas
- **Data Science**: nova √°rea de conhecimento que vem se moldando a partir do desenvolvimento da sociedade em torno da era digital e da grande quantidade de dados gerados e dispon√≠veis pela internet
- **Datum**: simplificadamente √© a rela√ß√£o do sistema de coordenadas (geogr√°fica ou projetada) com a superf√≠cie da Terra
- **Dendrograma**: diagrama representando uma √°rvore que organiza elementos, objetos e vari√°veis por suas semelhan√ßas de maneira hier√°rquica ascendente. Desse modo, objetos mais pr√≥ximos compartilham maior semelhan√ßa do que objetos distantes no dendrograma. 
- **Desagrega√ß√£o (raster)**: diminui o tamanho dos pixels (aumentando a resolu√ß√£o) de um raster, preenchendo com novos valores que depende do tipo de fun√ß√£o de preenchimento utilizada
- **Deviance**: √© um termo estat√≠stico que mede o ajuste do modelo (*goodness of fit*). Quanto menor o valor de *deviance* melhor o modelo
- **Diagrama de Whittaker**: m√©todo que utiliza informa√ß√µes visuais ao plotar as esp√©cies ranqueadas no eixo X da mais abundante para a menos abundante, enquanto no eixo Y as abund√¢ncias relativas das esp√©cies s√£o plotadas em escala logar√≠tmica 
- **Diret√≥rio de trabalho**: endere√ßo da pasta (ou diret√≥rio) de onde o R importar√° ou exportar dados
- **Dispers√£o filogen√©tica**: esp√©cies coexistindo nas comunidades s√£o menos aparentadas do que esperado pelo acaso
- **Distribui√ß√£o de probabilidade**: √© uma fun√ß√£o estat√≠stica que descreve todos os valores e probabilidades poss√≠veis que uma vari√°vel aleat√≥ria pode assumir dentro de um determinado intervalo
- **Distribui√ß√£o Gaussiana**: veja distribui√ß√£o normal
- **Distribui√ß√£o normal**: √© uma distribui√ß√£o de probabilidade em formato de sino que √© sim√©trica em torno da m√©dia, mostrando que dados pr√≥ximos √† m√©dia s√£o mais frequentes que dados distantes da m√©dia. 
- **Diversidade alfa**: √© um conceito caracterizado pela diversidade dentro do habitat ou unidade amostral
- **Diversidade beta**: √© um conceito caracterizado pela varia√ß√£o na diversidade entre habitats ou unidades amostrais
- **Diversidade beta filogen√©tica**: engloba m√©tricas que utilizam dados de presen√ßa e aus√™ncia ou abund√¢ncia das esp√©cies para determinar um valor que representa a diferen√ßa entre comunidades em rela√ß√£o a hist√≥ria evolutiva das linhagens
- **Diversidade de esp√©cies**: √© um conceito que representa o n√∫mero de esp√©cies e a distribui√ß√£o de abund√¢ncia destas esp√©cies em uma comunidade 
- **Diversidade filogen√©tica**: engloba m√©tricas que capturam a ancestralidade compartilhada entre as esp√©cies em termos de quantidade da hist√≥ria evolutiva e o grau de parentesco entre as esp√©cies
- **Diversidade funcional**: √© um conceito que captura a varia√ß√£o no grau de express√£o de diferentes atributos funcionais entre diferentes popula√ß√µes, comunidades ou ecossistemas
- **Diversidade gama**: √© um conceito caracterizado pela combina√ß√£o da diversidade alfa e beta ou definido como a diversidade regional englobando todos os habitat ou unidades amostrais
- **Doubletons**: n√∫mero de esp√©cies observadas com abund√¢ncia de dois indiv√≠duos 
- **Duplicate**: n√∫mero de esp√©cies observadas em apenas duas amostras 
- **Equitabilidade de Pielou**: √© uma m√©trica que descreve o padr√£o de distribui√ß√£o da abund√¢ncia relativa das esp√©cies na comunidade
- **Erro do Tipo I**: rejeitar a hip√≥tese nula de um teste estat√≠stico quando ela √© verdadeira 
- **Erro do Tipo II**: aceitar a hip√≥tese nula de um teste estat√≠stico quando ela √© falsa 
- **Escalar**: n√∫mero inteiro com o qual geralmente se faz opera√ß√µes com matrizes (e.g., multiplica√ß√£o ou adi√ß√£o)
- **Escores**: posi√ß√£o das unidades amostrais ao longo de um eixo de ordena√ß√£o. Pode se referir tanto a objetvos quanto √† vari√°veis. Escores s√£o fornecidos pela substitui√ß√£o dos valores assumidos pelas vari√°veis originais nas combina√ß√µes lineares. S√£o utilizados para ordenar as unidades amostrais em um diagrama uni, bi ou tridimensional
- **ESRI Shapefile (vetor)**: principal formato de dados vetoriais, composto pelo menos de quatro arquivos: .shp (fei√ß√£o), .dbf (tabela de atributos), .shx (liga√ß√£o entre .shp e .dbf) e .prj (proje√ß√£o)
- **Estat√≠stica frequentista**: s√£o an√°lises param√©tricas que estimam probabilidades das frequ√™ncias observadas dos eventos e usam essas probabilidades como base para infer√™ncias. 
- **Estrutura dos objetos**: diz respeito √† organiza√ß√£o dos elementos, com rela√ß√£o aos modos e dimensionalidade da disposi√ß√£o desses elementos. De modo bem simples, os elementos podem ser estruturados em seis tipos: i) vetor, ii) fator, iii) matriz, iv) array, v) data frame e vi) listas
- **Extens√£o (vetor e raster)**: limites geogr√°ficos de dados geoespaciais (vetor e raster), composto por dois pares de coordenadas de longitude e de latitude
- **Extra√ß√£o (vetor e raster)**: identifica e retorna valores associados de pixels de um raster com base em um objeto vetorial (ponto, linha e pol√≠gono)
- **Extrapola√ß√£o**: √© o processo de estimar, al√©m do intervalo de observa√ß√£o original, o valor de uma vari√°vel com base em sua rela√ß√£o com outra vari√°vel
- **Fator**: classe de objetos que representa o encadeamento de elementos de um √∫nico modo (integer) numa sequ√™ncia unidimensional, representando medidas de uma vari√°vel categ√≥rica, podendo ser nominal ou ordinal
- **Fator aleat√≥rio**: pesquisador amostra aleatoriamente os n√≠veis de um fator na popula√ß√£o 
- **Fator fixo**: pesquisador controla todos os n√≠veis do fator sobre os quais as infer√™ncias devem ser feitas
- **Fator de infla√ß√£o da vari√¢ncia (VIF)**: √© um teste que quantifica quanto do erro padr√£o dos coeficientes estimados est√£o inflados devido √† multicolinearidade
- **Fei√ß√£o (vetor)**: um elemento do dado vetorial associado √† cada linha da tabela de atributos
- **Fen√¥meno**: Um evento, entidade ou rela√ß√£o observ√°vel
- **Fun√ß√µes**: classe de objetos que possui c√≥digos preparados para realizar uma tarefa espec√≠fica de modo simples, realizando opera√ß√µes em argumentos
- **Generalized Least Squares (GLS)**: √© um teste estat√≠stico utilizado para estimar coeficientes desconhecidos de um modelo de regress√£o linear quando a vari√°vel independente √© correlacionada com os res√≠duos 
- **GeoPackage (vetor e raster)**: banco de dados geoespacial que armazena em apenas um arquivo, dados no formato vetorial, raster e tamb√©m dados n√£o-espaciais (e.g., tabelas)
- **GeoTIFF (raster)**: principal formato para dados raster, composto geralmente de um arquivo TIFF contendo metadados geoespaciais adicionais
- **Goodness of fit**: refere-se a um teste estat√≠stico que determina qu√£o bem os dados da amostra se ajustam a uma distribui√ß√£o de uma popula√ß√£o 
- **Grau de liberdade**: √© o n√∫mero de observa√ß√µes nos dados que s√£o livres para variar quando estimamos os valores dos par√¢metros populacionais desconhecidos
- **Hip√≥tese**: Afirma√ß√£o test√°vel derivada ou representando v√°rios componentes de uma teoria
- **Hip√≥tese alternativa (H1)**: √© um conceito estat√≠stico que sugere que diferen√ßas entre grupos ou fen√¥menos medidos s√£o maiores do que o esperado devido a varia√ß√µes aleat√≥rias. A H1 √© o oposto da hip√≥tese nula. 
- **Hip√≥tese nula (H0)**: √© um conceito estat√≠stico que sugere que diferen√ßas entre grupos ou fen√¥menos medidos n√£o s√£o maiores do que o esperado devido a varia√ß√µes aleat√≥rias. Presume-se que a hip√≥tese nula √©  verdadeira at√© que evid√™ncias indiquem o contr√°rio.
- **Homocedasticidade**: √© um dos pressupostos dos testes param√©tricos como ANOVA, Teste T e regress√£o linear simples que a vari√¢ncia da vari√°vel dependente deve ser constante para os valores das vari√°veis preditoras. Sin√¥nimo de homogeneidade da vari√¢ncia
- **Homogeneidade da vari√¢ncia**: veja homocedasticidade
- **Independ√™ncia estat√≠stica**: dois eventos s√£o independentes se a ocorr√™ncia de um evento n√£o influenciar a probabilidade que o outro evento ir√° ou n√£o ocorrer
- **Indexa√ß√£o (linguagem R)**: acessa elementos de objetos por sua posi√ß√£o utilizando os operadores [] e [[]] ou por seu nome com o operador $ depois do nome do objeto
- **√çndice de diversidade**: m√©tricas que calculam a riqueza de esp√©cies e a distribui√ß√£o de abund√¢ncia para cada esp√©cie dentro das comunidades.
- **√çndice de Gini-Simpson**: m√©trica que quantifica a probabilidade de dois indiv√≠duos retirados ao acaso da comunidade pertencerem a esp√©cies diferentes. √â o inverso do √≠ndice de Simpson
- **√çndice de Margalef**: m√©trica que calcula a riqueza de esp√©cies ponderando a abund√¢ncia total dentro de cada comunidade
- **√çndice de Menhinick**: m√©trica que calcula a riqueza de esp√©cies ponderando a abund√¢ncia total dentro de cada comunidade
- **√çndice de Shannon-Wiener**: m√©trica de diversidade de esp√©cies que quantifica a incerteza associada em predizer a identidade de uma esp√©cie dado o n√∫mero de esp√©cies e a distribui√ß√£o de abund√¢ncia para cada esp√©cie
- **√çndice de Simpson**: m√©trica que quantifica a probabilidade de dois indiv√≠duos retirados ao acaso da comunidade pertencerem √† mesma esp√©cie
- **Inf (Infinito)**: √© um n√∫mero muito grande ou um limite matem√°tico
- **Intera√ß√£o raster-vetor**: opera√ß√µes derivadas da intera√ß√£o entre raster-vetor, como ajuste do tamanho do raster ou extra√ß√£o dos valores dos pixels para dados vetoriais (pontos, linhas e pol√≠gonos)
- **Interpola√ß√£o**: √© o processo de estimar, dentro um dom√≠nio de valores conhecidos, um valor desconhecido com base em sua rela√ß√£o com outra vari√°vel
- **Jackknife 1**: estimador de riqueza de esp√©cies baseado no n√∫mero de esp√©cies que ocorrem em somente uma amostra (*uniques*)
- **Jackknife 2**: estimador de riqueza de esp√©cies baseado no n√∫mero de esp√©cies que ocorrem em somente uma amostra (*uniques*) e no n√∫mero de esp√©cies ocorrem em exatamente duas amostras (*duplicates*)
- **Jun√ß√£o de tabelas**: combina√ß√£o de pares de conjunto de dados tabulares por uma ou mais colunas chaves
- **Likelihood-ratio test (LRT)**: √© um teste estat√≠stico que mede o grau do ajuste (*goodness-of-fit*) entre dois modelos aninhados. Um modelo relativamente mais complexo √© comparado a um modelo mais simples para ver se ele se ajusta significativamente melhor a um determinado conjunto de dados. Ele testa se h√° necessidade de se incluir uma vari√°vel extra no modelo para explicar os dados
- **Linguagem R**: ambiente de software livre para computa√ß√£o estat√≠stica e cria√ß√£o de gr√°ficos
- **Lista**: classe de objetos que √© tipo especial de vetor que aceita objetos como elementos
- **Loading**: Correla√ß√µes de Pearson entre cada vari√°vel original com cada eixo. Os valores ser√£o maiores (positiva ou negativamente) para aquelas vari√°veis que forem mais importantes na forma√ß√£o de um dado eixo. Desse modo, representam o peso de uma vari√°vel para a constru√ß√£o de um eixo e variam de -1 a 1.as
- **Loop for**: fun√ß√£o em que um bloco de c√≥digos √© repetido mudando um contador de uma lista de possibilidades
- **Mapa**: representa√ß√£o bidimensional de elementos geoespaciais em uma propor√ß√£o menor, podendo representar dados vetoriais ou raster, com diversos elementos visuais e textuais que facilitam a interpreta√ß√£o do elemento geoespacial mapeado
- **Mapas animados**: mapas que incorporam anima√ß√µes para expressar mudan√ßas nos padr√µes espaciais ou ao longo do tempo
- **Mapas est√°ticos**: mapas simples e fixos para visualiza√ß√£o de dados, sendo o tipo mais comum de sa√≠da visual
- **Mapas interativos**: mapas que incorporam a capacidade de deslocar e ampliar qualquer parte de um conjunto de dados geoespaciais sobreposto em um ‚Äúmapa da web‚Äù
- **Matriz**: classe de objetos que representa elementos de um √∫nico modo no formato de tabela, com linhas e colunas
- **M√°xima Verossimilhan√ßa**: √© um m√©todo que determina valores para os par√¢metros de um modelo. Os valores dos par√¢metros s√£o encontrados de tal forma que maximizam a probabilidade de que o processo descrito pelo modelo produza os dados que foram realmente observados
- **Mean Pairwise Distance (MPD)**: √© uma m√©trica que utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a dist√¢ncia m√©dia do parentesco entre pares de esp√©cies em uma comunidade
- **Mean Nearest Taxon Distance (MNTD)**: √© uma m√©trica que utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a m√©dia dos valores m√≠nimos de parentesco entre pares de esp√©cies em uma comunidade. Ou seja, qual o valor m√©dio da dist√¢ncia para o vizinho mais pr√≥ximo
- **Mecanismo**: Intera√ß√£o direta de uma rela√ß√£o causal que resulta em um fen√¥meno
- **Modo dos objetos**: diz respeito √† natureza dos elementos que comp√µem os dados e que foram atribu√≠dos aos objetos. Os modos geralmente s√£o**: num√©rico do tipo inteiro (integer), num√©rico do tipo flutuante (double), texto (character), l√≥gico (logical) ou complexo (complex)
- **Modelo misto**: pelo menos um fator no experimento √© fixo, e pelo menos um fator √© aleat√≥rio.
- **Modelo nulo**: √© um procedimento estat√≠stico que usa aleatoriza√ß√µes para gerar distribui√ß√µes de valores para uma determinada vari√°vel de interesse na aus√™ncia do processo causal em quest√£o
- **Multicolinearidade**: √© um conceito estat√≠stico onde vari√°veis independentes em um modelo s√£o correlacionadas
- **NA (Not Available)**: significa dado faltante ou indispon√≠vel
- **NaN (Not a Number)**: representa indefini√ß√µes matem√°ticas
- **Nearest Relative Index (NRI)**: m√©trica que calcula o tamanho do efeito padronizado para a m√©trica *Mean Pairwise Distance*.Valores positivos de NRI indicam agrupamento filogen√©tico enquanto valores negativos de NRI indicam dispers√£o filogen√©tica
- **Nearest Taxon Index (NTI)**: m√©trica que calcula o tamanho do efeito padronizado para a m√©trica *Mean Nearest Taxon Distance*.Valores positivos de NTI indicam agrupamento filogen√©tico enquanto valores negativos de NTI indicam dispers√£o filogen√©tica
- **NetCDF (raster)**: Network Common Data Form √© um conjunto de bibliotecas de software e formatos de dados independentes que suportam a cria√ß√£o, acesso e compartilhamento de dados cient√≠ficos orientados a arrays
- **N√≥**: o ponto onde uma linhagem d√° origem a duas ou mais linhagens descendentes
- **Normalidade dos res√≠duos**: √© um dos pressupostos dos testes param√©tricos como ANOVA, Teste T e regress√£o linear simples que dependem que os res√≠duos do modelo apresentem distribui√ß√£o normal ou gaussiana.
- **NULL (Nulo)**: representa um objeto nulo, sendo √∫til para preenchimento em aplica√ß√µes de programa√ß√£o
- **N√∫meros de Hill**: √© uma m√©trica que transforma a riqueza e a distribui√ß√£o da abund√¢ncia das esp√©cies em n√∫meros efetivos de esp√©cies ou diversidade verdadeira
- **N√∫mero efetivo de esp√©cies**: √© o n√∫mero de esp√©cies igualmente abundantes (i.e. todas as esp√©cies com a mesma abund√¢ncia) necess√°rias para produzir o valor observado para um determinado √≠ndice
- **Objetos**: palavras √†s quais s√£o atribu√≠dos dados atrav√©s da atribui√ß√£o. A cria√ß√£o de objetos possibilita a manipula√ß√£o de dados ou armazenar os resultados de an√°lises. Em outras linguagens de programa√ß√£o s√£o denominadas vari√°veis
- **Opera√ß√µes geoespaciais**: s√£o opera√ß√µes para acessar ou alterar as propriedades n√£o-espaciais, espaciais e geom√©tricas dos dados geoespaciais, divididas em**: opera√ß√µes de atributos, opera√ß√µes espaciais e opera√ß√µes geom√©tricas
- **Opera√ß√µes geoespaciais de atributos**: modifica√ß√£o de objetos geoespaciais baseado em informa√ß√µes n√£o espaciais associadas a dados geoespaciais, como a tabela de atributos ou valores das c√©lulas e nome das camadas dos rasters
- **Opera√ß√µes geoespaciais espaciais**: modifica√ß√µes de objetos geoespaciais baseado em informa√ß√µes espaciais, como localiza√ß√£o e formato
- **Opera√ß√µes geoespaciais geom√©tricas**: modifica√ß√µes em objetos geoespaciais baseado na geometria do vetor ou do raster e na intera√ß√£o e convers√£o entre vetor-raster
- **Operadores**: conjuntos de caracteres que realiza opera√ß√µes, agrupados em cinco tipos principais**: aritm√©ticos, relacionais, l√≥gicos, atribui√ß√£o e diversos
- **Pacotes (linguagem R)**: conjuntos extras de fun√ß√µes para executar tarefas espec√≠ficas
- **Padr√£o**: Eventos repetidos, entidades recorrentes ou rela√ß√µes replicadas no tempo ou no espa√ßo
- **Phylogenetic Diversity (PD)**: √© uma m√©trica definida pela soma do comprimento dos ramos conectando todas as esp√©cies na comunidade
- **Phylogenetic Endemism (PE)**: √© uma m√©trica que calcula a fra√ß√£o dos ramos restritos a regi√µes espec√≠ficas
- **Phylogenetic index of beta diversity (Phylosor)**: m√©trica de similaridade que determina o comprimento total dos ramos da filogenia que √© compartilhado entre pares de comunidades
- **Phylogenetic Species Richness (PSR)**: √© uma m√©trica diretamente compar√°vel ao n√∫mero de esp√©cies na comunidade, mas inclui o parentesco filogen√©tico entre as esp√©cies
- **Phylogenetic Species Variability (PSV)**: √© uma m√©trica que estima a quantidade relativa dos comprimentos dos ramos n√£o compartilhados entre as comunidades
- **Pipe (%>%)**: operador implementado por uma fun√ß√£o que faz com o que o resultado de uma fun√ß√£o seja o primeiro argumento da fun√ß√£o seguinte, permitindo o encadeamento de v√°rias fun√ß√µes eliminando a necessidade de criar objetos para armazenar resultados intermedi√°rios
- **Pivotagem de dados**: transporte de dados que est√£o em linhas para colunas e vice-versa, fazendo a refer√™ncia cruzada ou rotacionando os dados. Partirmos de dados no formato longo (long, muitas linhas e poucas colunas) e criamos dados no formato largo (wide, poucas linhas e muitas colunas) e vice-versa
- **Pixel (raster)**: tamb√©m chamado c√©lula, √© a unidade geoespacial do raster, representando o elemento da matriz de dados
- **Pol√≠gono convexo**: opera√ß√£o que liga os pontos externos de um conjunto de pontos e cria um pol√≠gono a partir deles
- **Pol√≠gono de Voronoi**: pol√≠gonos irregulares s√£o criados a partir da proximidade dos pontos, de modo a estimar uma √°rea de abrang√™ncia no entorno dos mesmos
- **Politomia**: tr√™s ou mais linhagens descendendo de um √∫nico n√≥
- **Popula√ß√£o**: √© um conjunto de indiv√≠duos ou elementos semelhantes que interessa para alguma pergunta ou hip√≥tese
- **Popula√ß√£o amostral**: √© um conjunto de indiv√≠duos ou elementos semelhantes que est√£o de fato acess√≠vel para serem amostrados
- **Predi√ß√£o espacial**: utiliza os coeficientes de um modelo ajustado para gerar um raster de predi√ß√£o para todos os pixels considerando os dados preditores de entrada do modelo, extrapolando a predi√ß√£o da resposta
- **Predi√ß√£o**: uma declara√ß√£o de expectativa deduzida da estrutura l√≥gica ou derivada da estrutura causal de uma teoria
- **Pressuposto**:	condi√ß√µes necess√°rias para sustentar uma hip√≥tese ou constru√ß√£o da teoria
- **Principais elementos de um mapa**: um mapa possui diversos elementos que facilitam sua interpreta√ß√£o, dentre eles: i) mapa principal, ii) mapa secund√°rio iii) t√≠tulo, iv) legenda (apresentando as informa√ß√µes detalhadas das classes ou escala de valores, v) barra de escala, vi) indicador de orienta√ß√£o (Norte), vii) gride de coordenadas e viii) descri√ß√£o do CRS
- **Processo**: um subconjunto de fen√¥menos em que os eventos seguem uns aos outros no tempo ou espa√ßo, que podem ou n√£o serem causalmente conectados. √â a causa, mecanismo ou limita√ß√£o explicando um padr√£o
- **Programa√ß√£o Funcional**: organiza√ß√£o do c√≥digo como fun√ß√µes e vari√°veis que trabalham de forma unificada para a resolu√ß√£o de um problema
- **Projeto do RStudio**: arquivo no formato .Rproj que facilita o trabalho com o RStudio, pois define o diret√≥rio automaticamente e permite o controle de vers√£o
- **Raiz**: representa o ancestral comum de todas as esp√©cies na filogenia
- **Ramo**: uma linha orientada ao longo de um eixo terminais-raiz que conecta os n√≥s na filogenia
- **Rarefa√ß√£o**: √© uma m√©trica usada para calcular o n√∫mero esperado de esp√©cies em cada comunidade tendo como base comparativa um valor em que todas as amostras ou n√∫mero de indiv√≠duos atinjam um tamanho padr√£o entre as comunidades
- **Rarefa√ß√£o baseada nas amostras (Sampled-based)**: as compara√ß√µes s√£o padronizadas pela comunidade com menor n√∫mero de amostragens
- **Rarefa√ß√£o baseada na cobertura (Coverage-based)**: √© uma medida que determina a propor√ß√£o de amostras ou do n√∫mero de indiv√≠duos da comunidade que representa as esp√©cies amostradas
- **Rarefa√ß√£o baseada nos indiv√≠duos (Individual-based)**: as compara√ß√µes s√£o feitas considerando a abund√¢ncia da comunidade padronizada pelo menor n√∫mero de indiv√≠duos
- **Rasteriza√ß√£o**: convers√£o de dados vetoriais para raster realizada de pontos, linhas ou pol√≠gonos para rasters
- **Regress√£o**: √© um teste usado para analisar a rela√ß√£o entre uma ou mais vari√°veis preditoras (Xn) e uma vari√°vel resposta (Y). A regress√£o assume uma rela√ß√£o de causa e efeito entre as vari√°veis
- **Reproje√ß√£o**: transforma√ß√£o do Sistema de Refer√™ncia de Coordenadas (CRS) de um dado geoespacial, alterando o CRS original para outro. Na reproje√ß√£o alteramos tanto a unidade do dado geoespacial mudando o Sistema de Coordenadas Geogr√°ficas (unidades em ‚Äòlongitude/latitude‚Äô) para Projetado (unidades de metros, e vice-versa), quando o Datum
- **Res√≠duo**: √© a diferen√ßa entre os valores predito e observado dos dados. S√£o tamb√©m chamados de erro
- **Resolu√ß√£o (raster)**: termo amplo que pode ser usado em diversos contextos. Para dados raster, √© geralmente associado ao tamanho (dimens√£o) do pixel (i.e., altura e largura)
- **RStudio**: ambiente de desenvolvimento integrado (IDE) para R. Inclui um console, editor de realce de sintaxe que suporta execu√ß√£o direta de c√≥digo, bem como ferramentas para plotagem, hist√≥rico, depura√ß√£o e gerenciamento de espa√ßo de trabalho
- **Script (RStudio)**: arquivos de texto simples, criados com a extens√£o (termina√ß√£o) .R onde os c√≥digos s√£o escritos e salvos
- **Sele√ß√£o de modelos**: √© um processo usado para comparar o valor relativo de diferentes modelos estat√≠sticos e determinar qual deles √© o mais adequado para os dados observados
- **S√©rie de Hill**: veja N√∫mero de Hill
- **Singleton**: n√∫mero de esp√©cies observadas com abund√¢ncia de um indiv√≠duo 
- **Sistema de Coordenadas**: composto por dois sistemas, o Sistema de Coordenadas Geogr√°ficas e o Sistema de Coordenadas Projetadas, que utilizam duas unidades √¢ngulos ou metros, respectivamente, para a representa√ß√£o geogr√°fica
- **Sistema de Refer√™ncia de Coordenadas (CRS)**: tamb√©m chamada proje√ß√£o, define a refer√™ncia geoespacial dos dados vetor e raster na superf√≠cie da Terra, composto pelo Sistema de Coordenadas e Datum
- **Tabela de atributos**: dado tabular que inclui dados geoespaciais e dados alfanum√©ricos, geralmente associada a dados vetoriais
- **Terminal (do ingl√™s tip)**: o final do ramo representando uma esp√©cie atual ou extinta (pode tamb√©m representar g√™neros, indiv√≠duos, genes, etc.)
- **Teste de Levene**: √© um teste estat√≠stico utilizado para verificar a homogeneidade da vari√¢ncia entre dois ou mais grupos
- **Teste de Shapiro-Wilk**: √© um teste estat√≠stico utilizado para verificar se os dados apresentam distribui√ß√£o normal
- **Teste T (de Student)**:  √© um teste estat√≠stico que segue uma distribui√ß√£o t de Student para rejeitar ou n√£o uma hip√≥tese nula de m√©dias iguais entre dois grupos.
- **Teste T pareado**:  √© um teste estat√≠stico que usa dados medidos duas vezes na mesma unidade amostral, resultando em pares de observa√ß√µes para cada amostra (amostras pareadas). Ele determina se a diferen√ßa da m√©dia entre duas observa√ß√µes √© zero..
- **Tibble**: classe de objetos que √© uma vers√£o aprimorada do data frame. √â a classe aconselhada para que as fun√ß√µes do *tidyverse* funcionem melhor sobre conjuntos de dados tabulares
- **tidyverse**: ‚Äúdialeto novo‚Äù para a linguagem R, onde tidy quer dizer organizado, arrumado, ordenado, e *verse* √© universo. Operacionalizado no R atrav√©s de uma cole√ß√£o de pacotes que atuam no fluxo de trabalho comum da ci√™ncia de dados: importa√ß√£o, manipula√ß√£o, explora√ß√£o, visualiza√ß√£o, an√°lise e comunica√ß√£o de dados e an√°lises. O principal objetivo do *tidyverse* √© aproximar a linguagem para melhorar a intera√ß√£o entre ser humano e computador sobre dados, de modo que os pacotes compartilham uma filosofia de design de alto n√≠vel e gram√°tica, al√©m da estrutura de dados de baixo n√≠vel
- **Ultram√©trica**: a dist√¢ncia de todos os terminais at√© a raiz s√£o id√™nticas. Caracter√≠stica requerida pela maioria dos √≠ndices de diversidade filogen√©tica
- **Unidade amostral**: √© o indiv√≠duo (ou elemento) da popula√ß√£o amostral sobre o qual a medida de interesse ser√° observada
- **Unique**: n√∫mero de esp√©cies observadas em apenas uma amostra
- **Unique Fraction metric (UniFrac)**: m√©trica de dissimilaridade que determina a fra√ß√£o √∫nica da filogenia contida em cada uma das duas comunidades
- **Valor de P**: probabilidade de um teste estat√≠stico ser igual ou maior que o observado, dado que a hip√≥tese nula √© verdadeira.
- **Valores faltantes e especiais**: valores reservados que representam dados faltantes, indefini√ß√µes matem√°ticas, infinitos e objetos nulos
- **Variance of Pairwise Distance (VPD)**: √© uma m√©trica que utiliza a matriz de dist√¢ncia filogen√©tica para quantificar a vari√¢ncia do parentesco entre pares de esp√©cies em uma comunidade
- **Vari√°vel categ√≥rica**: s√£o vari√°veis que n√£o possuem valores quantitativos e s√£o definidas por categorias ou grupos distintos
- **Vari√°vel cont√≠nua**: s√£o vari√°veis num√©ricas que t√™m um n√∫mero infinito de valores entre dois valores quaisquer. Neste caso, valores fracionais fazem sentido
- **Vari√°vel dependente**: √© uma vari√°vel mensurada ou observada de interesse do pesquisador que depende do valor de outra vari√°vel
- **Vari√°vel discreta**: √© uma vari√°vel num√©rica que t√™m um n√∫mero cont√°vel de valores inteiros. 
- **Vari√°vel explicativa**: ver vari√°vel independente
- **Vari√°vel independente**: vari√°vel mensurada ou observada pelo pesquisador que prev√™ ou afeta a vari√°vel dependente
- **Vari√°vel nominal**: s√£o vari√°veis categ√≥ricas que n√£o apresentam ordena√ß√£o dentre as categorias (e.g., preto, branco e rosa)
- **Vari√°vel ordinal**: s√£o vari√°veis categ√≥ricas com ordena√ß√£o entre as categorias (e.g., pequeno, m√©dio e grande) 
- **Vari√°vel preditora**: ver vari√°vel independente
- **Vari√°vel resposta**: ver vari√°vel dependente
- **Variograma**: √© uma descri√ß√£o da continuidade espacial dos dados. Ele mede a variabilidade entre pares de pontos em v√°rias dist√¢ncias
- **Vetor**: classe de objetos que representa o encadeamento de elementos de um √∫nico modo numa sequ√™ncia unidimensional
- **Vetor (Multivariada)**: coluna de uma matriz
- **Vetoriza√ß√£o (vetor)**: convers√£o de dados rasters para vetor, sendo que esse vetor receber√° os valores dos pixels do raster, podendo ser convertido em pontos, isolinhas ou pol√≠gonos


<!--chapter:end:98_glossario.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  bookdown.clean_book = TRUE,
  tinytex.verbose = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  out.height = "100%",
  fig.align = 'center',
  #fig.width = 6,
  #fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  tidy=FALSE,
  tidy.opts=list(width.cutoff=80)
)
```
# Refer√™ncias {-}

<!--chapter:end:99_referencias.Rmd-->

