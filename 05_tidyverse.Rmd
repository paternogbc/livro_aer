# Tidyverse {#cap5}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r eval=FALSE}
## Pacotes
library(tidyverse)
library(here)
library(ggplot2)
library(purrr)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(forcats)
library(palmerpenguins)
library(lubridate)

## Dados
penguins <- palmerpenguins::penguins
penguins_raw <- palmerpenguins::penguins_raw
tidy_anfibios_locais <- ecodados::tidy_anfibios_locais
```

## Contextualiza√ß√£o

Como todo idioma, a linguagem R vem passando por transforma√ß√µes nos √∫ltimos anos. Grande parte dessas mudan√ßas est√£o dentro do paradigma de Ci√™ncia de Dados (*Data Science*), uma nova √°rea de conhecimento que vem se moldando a partir do desenvolvimento da sociedade em torno da era digital e da grande quantidade de dados gerados e dispon√≠veis pela internet, de onde adv√©m os pilares das inova√ß√µes tecnol√≥gicas: *Big Data*, *Machine Learning* e *Internet of Things*. A grande necessidade de computa√ß√£o para desenvolver esse novo paradigma colocaram o [R](https://www.r-project.org/) e o [python](https://www.python.org/) como as principais linguagens de programa√ß√£o frente a esses novos desafios. Apesar de n√£o serem as √∫nicas ferramentas utilizadas para esse prop√≥sito, elas rapidamente se tornaram uma das melhores escolhas, dado v√°rios fatores como: ser de c√≥digo-aberto e gratuitas, possu√≠r grandes comunidades contribuidoras, ser linguagens de interpreta√ß√£o (orientadas a objeto) e relativamente f√°ceis de serem aprendidas e aplicadas.

Essas mudan√ßas e expan√ß√µes na utiliza√ß√£o da linguagem R para a Ci√™ncia de Dados come√ßaram a ser implementadas principalmente devido a um pesquisador: [Hadley Wickham](http://hadley.nz/), que iniciou sua contribui√ß√£o √† comunidade R com o desenvolvimento do j√° consagrado pacote `ggplot2` [@wickham2016] para a composi√ß√£o de gr√°ficos no R (ver mais no Cap√≠tulo \@ref(cap6)), baseado na gram√°tica de gr√°ficos [@wilkinson2005]. Depois disso, Wickham dedicou-se ao desenvolvimento do pensamento de uma nova abordagem dentro da manipula√ß√£o de dados, denominada **Tidy Data** (Dados organizados) [@wickham2014], na qual focou na limpeza e organiza√ß√£o dos mesmos. A ideia postula que dados est√£o `tidy` quando: i) vari√°veis est√£o nas colunas, ii) observa√ß√µes est√£o nas linhas e iii) valores est√£o nas c√©lulas, sendo que para esse √∫ltimo, n√£o deve haver mais de um valor por c√©lula (Figura \@ref(fig:fig-r-dados-tidy)).

A partir dessas ideias, o [*tidyverse*](https://www.tidyverse.org/) foi operacionalizado no R como uma cole√ß√£o de pacotes que atuam no fluxo de trabalho comum da ci√™ncia de dados: importa√ß√£o, manipula√ß√£o, explora√ß√£o, visualiza√ß√£o, an√°lise e comunica√ß√£o de dados e an√°lises [@tidyverse2019] (Figura \@ref(fig:fig-r-tidyverse)). O principal objetivo do *tidyverse* √© aproximar a linguagem para melhorar a intera√ß√£o entre ser humano e computador sobre dados, de modo que os pacotes compartilham uma filosofia de design de alto n√≠vel e gram√°tica, al√©m da estrutura de dados de baixo n√≠vel [@tidyverse2019]. As principais leituras sobre o tema no R s√£o os artigos "Tidy Data" [@wickham2014] e "Welcome to the Tidyverse" [@tidyverse2019], e o livro ["R for Data Science"](https://r4ds.had.co.nz/) [@wickham2017], al√©m do [Tidyverse](https://www.tidyverse.org/) que possui muito mais informa√ß√µes.

```{r fig-r-tidyverse, echo=FALSE, fig.cap="Modelo das ferramentas necess√°rias em um projeto t√≠pico de ci√™ncia de dados: importar, organizar, entender (transformar, visualizar, modelar) e comunicar, envolto √† essas ferramentas est√° a programa√ß√£o. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig01.png")
```

## *tidyverse*

Uma vez instalado e carregado, o pacote `tidyverse` disponibiliza um conjunto de ferramentas atrav√©s de v√°rios pacotes. Esses pacotes compartilham uma filosofia de design, gram√°tica e estruturas. Podemos entender o *tidyverse* como um "dialeto novo" para a linguagem R, onde *tidy* quer dizer organizado, arrumado, ordenado, e *verse* √© universo. A seguir, listamos os principais pacotes e suas funcionalidades.

- [`readr`](https://readr.tidyverse.org/): importa dados tabulares (e.g. `.csv` e `.txt`)
- [`tibble`](https://tibble.tidyverse.org/): implementa a classe `tibble`
- [`tidyr`](https://tidyr.tidyverse.org/): transforma√ß√£o de dados para `tidy`
- [`dplyr`](https://dplyr.tidyverse.org/): manipula√ß√£o de dados
- [`stringr`](https://github.com/tidyverse/stringr): manipula√ß√£o de caracteres
- [`forcats`](https://github.com/hadley/forcats): manipula√ß√£o de fatores
- [`ggplot2`](https://ggplot2.tidyverse.org/): possibilita a visualiza√ß√£o de dados
- [`purrr`](https://purrr.tidyverse.org/): disponibiliza ferramentas para programa√ß√£o funcional

Al√©m dos pacotes principais, fazemos tamb√©m men√ß√£o a outros pacotes que est√£o dentro dessa abordagem e que trataremos ainda neste cap√≠tulo, em outro momento do livro, ou que voc√™ leitor(a) deve se familiarizar. Alguns pacotes comp√µem o tidyverse outros s√£o mais gerais, entretanto, todos est√£o envolvidos de alguma forma com ci√™ncia de dados.

- [`readxl`](https://readxl.tidyverse.org/) e [`writexl`](https://cran.r-project.org/package=writexl): importa e exporta dados tabulares (.xlsx)
- [`janitor`](http://sfirke.github.io/janitor/): examinar e limpar dados sujos
- [`DBI`](https://github.com/rstats-db/DBI): interface de banco de dados R
- [`haven`](https://github.com/tidyverse/haven): importa e exporta dados do SPSS, Stata e SAS
- [`httr`](https://github.com/r-lib/httr): ferramentas para trabalhar com URLs e HTTP
- [`rvest`](https://github.com/tidyverse/rvest): coletar facilmente (raspe) p√°ginas da web
- [`xml2`](https://github.com/r-lib/xml2): trabalhar com arquivos XML
- [`jsonlite`](https://github.com/jeroen/jsonlite): um analisador e gerador JSON simples e robusto para R
- [`hms`](https://github.com/rstats-db/hms): hora do dia
- [`lubridate`](https://github.com/tidyverse/lubridate): facilita o tratamento de datas
- [`magrittr`](https://magrittr.tidyverse.org/): prov√™ os operadores pipe (`%>%`, `%$%`, `%<>%`)
- [`glue`](https://github.com/tidyverse/glue): facilita combinar dados e caracteres
- [`rmarkdown`](https://rmarkdown.rstudio.com/): cria documentos de an√°lise din√¢mica que combinam c√≥digo, sa√≠da renderizada (como figuras) e texto
- [`knitr`](https://yihui.org/knitr/): projetado para ser um mecanismo transparente para gera√ß√£o de relat√≥rios din√¢micos com R
- [`shiny`](https://shiny.rstudio.com/): framework de aplicativo Web para R
- [`flexdashboard`](https://rmarkdown.rstudio.com/flexdashboard/): pain√©is interativos para R
- [`here`](https://here.r-lib.org/): facilita a defini√ß√£o de diret√≥rios
- [`usethis`](https://usethis.r-lib.org/): automatiza tarefas durante a configura√ß√£o e desenvolvimento de projetos (Git, 'GitHub' e Projetos RStudio)
- [`data.table`](https://rdatatable.gitlab.io/data.table/): pacote que fornece uma vers√£o de alto desempenho do `data.frame` (importar, manipular e expotar)
- [`reticulate`](https://rstudio.github.io/reticulate/): pacote que fornece ferramentas para integrar Python e R
- [`sparklyr`](https://spark.rstudio.com/): interface R para Apache Spark
- [`broom`](https://github.com/tidymodels/broom): converte objetos estat√≠sticos em tibbles organizados
- [`modelr`](https://github.com/tidyverse/modelr): fun√ß√µes de modelagem que funcionam com o pipe
- [`tidymodels`](https://www.tidymodels.org/): cole√ß√£o de pacotes para modelagem e aprendizado de m√°quina usando os princ√≠pios do tidyverse

Destacamos a grande expans√£o e aplicabilidade dos pacotes [rmarkdown](https://rmarkdown.rstudio.com/), [knitr](https://yihui.org/knitr/) e [bookdown](https://bookdown.org/), que permitiram a escrita desse livro usando essas ferramentas e linguagem de marca√ß√£o, chamada [Markdown](https://daringfireball.net/projects/markdown/).

Para instalar os principais pacotes que integram o *tidyverse* podemos instalar o pacote `tidyverse`.

```{r eval=FALSE}
## Instalar o pacote tidyverse
install.packages("tidyverse")
```

Quando carregamos o pacote `tidyverse` podemos notar uma mensagem indicando quais pacotes foram carregados, suas respectivas vers√µes e os conflitos com outros pacotes.

```{r message=TRUE}
## Carregar o pacote tidyverse
library(tidyverse)
```

Podemos ainda listar todos os pacotes do *tidyverse* com a fun√ß√£o `tidyverse::tidyverse_packages()`.

```{r}
## Listar todos os pacotes do tidyverse 
tidyverse::tidyverse_packages()
```

Tamb√©m podemos verificar se os pacotes est√£o atualizados, sen√£o, podemos atualiz√°-los com a fun√ß√£o `tidyverse::tidyverse_update()`.

```{r eval=FALSE}
## Verificar e atualizar os pacotes do tidyverse 
tidyverse::tidyverse_update(repos = "http://cran.us.r-project.org")
```

Todas as fun√ß√µes dos pacotes tidyverse usam **fonte min√∫scula** e **`_` (*underscore*)** para separar os nomes internos das fun√ß√µes, seguindo a mesma sintaxe do Python ("Snake Case"). Neste sentido de padroniza√ß√£o, √© importante destacar ainda que existe um guia pr√≥prio para que os scripts sigam a recomenda√ß√£o de padroniza√ß√£o, o [The tidyverse style guide](https://style.tidyverse.org/), criado pelo pr√≥prio Hadley Wickham. Para pessoas que desenvolvem fun√ß√µes e pacotes existe o [Tidyverse design guide](https://design.tidyverse.org/) criado pelo *Tidyverse team*.

```{r eval=FALSE}
## Fun√ß√µes no formato snake case
read_csv()
read_tsv()
as_tibble()
left_join()
group_by()
```

Por fim, para evitar poss√≠veis conflitos de fun√ß√µes com o mesmo nome entre pacotes, recomendamos fortemente o h√°bito de usar as fun√ß√µes precedidas do operador `::` e o respectivo pacote. Assim, garante-se que a fun√ß√£o utilizada √© referente ao pacote daquela fun√ß√£o. Segue um exemplo com as fun√ß√µes apresentadas anteriormente.

```{r eval=FALSE}
## Fun√ß√µes seguidas de seus respectivos pacotes
readr::read_csv()
readr::read_tsv()
tibble::as_tibble()
dplyr::left_join()
dplyr::group_by()
```

Seguindo essas ideias do novo paradigma da **Ci√™ncia de Dados**, outro conjunto de pacotes foi desenvolvido, chamado de [`tidymodels`](https://www.tidymodels.org/) que atuam no fluxo de trabalho da an√°lise de dados em ci√™ncia de dados: separa√ß√£o e reamostragem, pr√©-processamento, ajuste de modelos e m√©tricas de performasse de ajustes. Por raz√µes de espa√ßo e especificidade, n√£o entraremos em detalhes desses pacotes.

Seguindo a estrutura da Figura \@ref(fig:fig-r-tidyverse), iremos ver nos itens das pr√≥ximas se√ß√µes como esses passos s√£o realizados com fun√ß√µes de cada pacote.

## here

Dentro do fluxo de trabalho do tidyverse, devemos sempre trabalhar com **Projetos do RStudio**. Junto com o projeto, tamb√©m podemos fazer uso do pacote `here`. Ele permite construir caminhos para os arquivos do projeto de forma mais simples e com maior reprodutibilidade.

Esse pacote cobre o ponto de mudarmos o diret√≥rio de trabalho que discutimos no cap√≠tulo \@ref(cap4), dado que muitas vezes mudar o diret√≥rio com a fun√ß√£o `setwd()` tende a ser demorado e tedioso, principalmente quando se trata de um script em que v√°rias pessoas est√£o trabalhando em diferentes computadores e sistemas operacionais. Al√©m disso, ele elimina a quest√£o da fragilidade dos scripts, pois geralmente um script est√° com os diret√≥rios conectados exatamente a um lugar e a um momento. Por fim, ele tamb√©m simplifica o trabalho com subdiret√≥rios, facilitando importar ou exportar arquivos para subpastas.

Seu uso √© relativamente simples: uma vez criado e aberto o RStudio pelo Projeto do RStudio, o diret√≥rio automaticamente √© definido para o diret√≥rio do projeto. Depois disso, podemos usar a fun√ß√£o `here::here()` para definir os subdiret√≥rios onde est√£o os dados. O exemplo da aplica√ß√£o fica para a se√ß√£o seguinte, quando iremos de fato importar um arquivo tabular para o R. Logo abaixo, mostramos como instalar e carregar o pacote `here`.

```{r eval=FALSE}
## Instalar
install.packages("here")

## Carregar
library(here)
```

## readr, readxl e writexl

Dado que possu√≠mos um conjunto de dados e que geralmente esse conjunto de dados estar√° no formato tabular com umas das extens√µes: .csv, .txt ou .xlsx, usaremos o pacote `readr` ou `readxl` para importar esses dados para o R. Esses pacotes leem e escrevem grandes arquivos de forma mais r√°pida, al√©m de fornecerem medidores de progresso de importa√ß√£o e exporta√ß√£o, e imprimir a informa√ß√£o dos modos das colunas no momento da importa√ß√£o. Outro ponto bastante positivo √© que tamb√©m classificam automaticamente o modo dos dados de cada coluna, i.e., se uma coluna possui dados num√©ricos ou apenas texto, essa informa√ß√£o ser√° considerada para classificar o modo da coluna toda. A classe do objeto atribu√≠do quando lido por esses pacotes √© automaticamente um `tibble`, que veremos melhor na se√ß√£o seguinte. Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://readr.tidyverse.org/reference/index.html) do pacote.

Usamos as fun√ß√µes `readr::read_csv()` e `readr::write_csv()` para importar e exportar arquivos .csv do R, respectivamente. Para dados com a extens√£o .txt, podemos utilizar as fun√ß√µes `readr::read_tsv()` ou ainda `readr::read_delim()`. Para arquivos tabulares com a extens√£o .xlsx, temos de instalar e carregar dois pacotes adicionais: `readxl` e `writexl`, dos quais usaremos as fun√ß√µes `readxl::read_excel()`, `readxl::read_xlsx()` ou `readxl::read_xls()` para importar dados, atentado para o fato de podermos indicar a aba com os dados com o argumento `sheet`, e `writexl::write_xlsx()` para exportar.

Se o arquivo .csv foi criado com separador de decimais sendo `.` e separador de colunas sendo `,`, usamos as fun√ß√µes listadas acima normalmente. Caso seja criado com separador de decimais sendo `,` e separador de colunas sendo `;`, devemos usar a fun√ß√£o `readr::read_csv2()` para importar e `readr::write_csv2()` para exportar nesse formato, que √© mais comum no Brasil.

Para exemplificar como essas fun√ß√µes funcionam, vamos importar novamente os dados de comunidades de anf√≠bios da Mata Atl√¢ntica [@vancine2018], que fizemos o download no Cap√≠tulo \@ref(cap4). Estamos usando a fun√ß√£o `readr::read_csv()`, indicando os diret√≥rios com a fun√ß√£o `here::here()`, e a classe do arquivo √© `tibble`. Devemos atentar para o argumento `locale = readr::locale(encoding = "latin1")`,que selecionamos aqui como `latin1` para corrigir um erro de caracteres, que o autor dos dados cometeu quando publicou esse data paper.

```{r message=TRUE}
## Importar locais
tidy_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    locale = readr::locale(encoding = "latin1")
)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
tidy_anfibios_locais <- ecodados::tidy_anfibios_locais
head(tidy_anfibios_locais)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [11 Data import](https://r4ds.had.co.nz/data-import.html) de Wickham & Grolemund [-@wickham2017].

## tibble

O `tibble` (`tbl_sf`) √© uma vers√£o aprimorada do data frame (`data.frame`). Ele √© a classe aconselhada para que as fun√ß√µes do tidyverse funcionem melhor sobre conjuntos de dados tabulares importados para o R.

Geralmente, quando utilizamos fun√ß√µes tidyverse para importar dados para o R, √© essa classe que os dados adquirem depois de serem importados. Al√©m da importa√ß√£o de dados, podemos criar um tibble no R usando a fun√ß√£o `tibble::tibble()`, semelhante ao uso da fun√ß√£o `data.frame()`. Podemos ainda converter um `data.frame` para um `tibble` usando a fun√ß√£o `tibble::as_tibble()`. Entretanto, em alguns momentos precisaremos da classe `data.frame` para algumas fun√ß√µes espec√≠ficas, e podemos converter um `tibble` para `data.frame` usando a fun√ß√£o `tibble::as_data_frame()`.

Existem duas diferen√ßas principais no uso do `tibble` e do `data.frame`: impress√£o e subconjunto. Objetos da classe `tibbles` possuem um m√©todo de impress√£o que mostra a contagem do n√∫mero de linhas e colunas, e apenas as primeiras 10 linhas e todas as colunas que cabem na tela no console, al√©m dos modos ou tipos das colunas. Dessa forma, cada coluna ou vari√°vel, pode ser do modo numbers (`int` ou `dbl`), character (`chr`), logical (`lgl`), factor (`fctr`), date + time (`dttm`) e date (`date`), al√©m de outras [in√∫meras possibilidades](https://tibble.tidyverse.org/articles/types.html).

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://tibble.tidyverse.org/reference/index.html) do pacote.

```{r}
## Tibble - impress√£o
tidy_anfibios_locais
```

Para o subconjunto, como vimos no Cap√≠tulo \@ref(cap4), para selecionar colunas e linhas de objetos bidimensionais podemos utilizar os operadores `[]` ou `[[]]`, associado com n√∫meros separados por v√≠rgulas ou o nome da coluna entre aspas, e o operador `$` para extrair uma coluna pelo seu nome. Comparando um `data.frame` a um `tibble`, o √∫ltimo √© mais r√≠gido na sele√ß√£o das colunas: eles nunca fazem correspond√™ncia parcial e geram um aviso se a coluna que voc√™ est√° tentando acessar n√£o existir.

```{r, error=TRUE, warning=TRUE}
## Tibble - subconjunto
tidy_anfibios_locais$ref
```

Por fim, podemos "espiar" os dados utilizando a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral de n√∫mero de linhas, colunas, e conte√∫do de todas as colunas. Essa √© fun√ß√£o *tidyverse* da fun√ß√£o R Base `str()`.

```{r}
## Espiar os dados
tibble::glimpse(tidy_anfibios_locais[, 1:10])
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [10 Tibbles](https://r4ds.had.co.nz/tibbles.html) de Wickham & Grolemund [-@wickham2017].

## magrittr (pipe - %>%)

O operador pipe `%>%` permite o encadeamento de v√°rias fun√ß√µes, eliminando a necessidade de criar objetos para armazenar resultados intermedi√°rios. Dessa forma, pipes s√£o uma ferramenta poderosa para expressar uma sequ√™ncia de m√∫ltiplas opera√ß√µes.

O operador pipe `%>%` vem do pacote `magrittr`, entretanto, todos os pacotes no tidyverse automaticamente tornam o pipe dispon√≠vel. Essa fun√ß√£o torna os c√≥digos em R mais simples, pois realizamos m√∫ltiplas opera√ß√µes em uma √∫nica linha. Ele captura o resultado de uma declara√ß√£o e o torna a primeira entrada da pr√≥xima declara√ß√£o, ent√£o podemos pensar como "EM SEGUIDA FA√áA" ao final de cada linha de c√≥digo.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://maggritr.tidyverse.org/reference/index.html) do pacote.

A principal vantagem do uso dos pipes √© facilitar a depura√ß√£o (*debugging* - achar erros) nos c√≥digos, porque seu uso torna a linguagem R mais pr√≥xima do que falamos e pensamos, uma vez que evita o uso de fun√ß√µes dentro de fun√ß√µes (fun√ß√µes compostas, lembra-se do fog e gof do ensino m√©dio? Evitamos eles aqui tamb√©m).

Digitar `%>%` √© um pouco chato, dessa forma, existe um atalho para sua inser√ß√£o nos scripts: `Ctrl + Shift + M`.

Para deixar esse t√≥pico menos estranho a quem possa ver essa opera√ß√£o pela primeira vez, vamos fazer alguns exemplos.

```{r}
## Base R - sem pipe
sqrt(sum(1:100))

## Tidyverse - com pipe
1:100 %>% 
    sum() %>% 
    sqrt()
```

Essas opera√ß√µes ainda est√£o simples, vamos torn√°-las mais complexas com v√°rias fun√ß√µes compostas. √â nesses casos que a propriedade organizacional do uso do pipe emerge: podemos facilmente ver o encadeamento de opera√ß√µes, onde cada fun√ß√£o √© disposta numa linha. Apenas um adendo: a fun√ß√£o `set.seed()` que fixa a amostragem de fun√ß√µes que geram valores aleat√≥rios, como √© o caso da fun√ß√£o `rpois()`.

```{r}
## Fixar amostragem
set.seed(42)

## Base R - sem pipe
ve <- sum(sqrt(sin(log10(rpois(100, 10)))))
ve

## Fixar amostragem
set.seed(42)

## Tidyverse - com pipe
ve <- rpois(100, 10) %>% 
    log10() %>%
    sin() %>% 
    sqrt() %>% 
    sum()
ve
```

O uso do pipe vai se tornar especialmente √∫til quando seguirmos para os pacotes das pr√≥ximas duas se√ß√µes: `tidyr` e `dplyr`. Com esses pacotes faremos opera√ß√µes em linhas e colunas de nossos dados tabulares, ent√£o podemos encadear uma s√©rie de fun√ß√µes para manipula√ß√£o, limpeza e an√°lise de dados.

H√° ainda tr√™s outras varia√ß√µes do pipe que podem ser √∫teis em alguns momentos, mas que para funcionar precisam que o pacote `magrittr` esteja carregado:

- `%T>%`: retorna o lado esquerdo em vez do lado direito da opera√ß√£o
- `%$%`: "explode" as vari√°veis em um quadro de dados
- `%<>%`: permite atribui√ß√£o usando pipes

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [18 Pipes](https://r4ds.had.co.nz/pipes.html) de Wickham & Grolemund [-@wickham2017].

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
A partir da vers√£o do R 4.1+ (18/05/2021), o operador pipe se tornou nativo do R. Entretanto, o operador foi atualizado para `|>`, podendo ser inserido com o mesmo atalho `Ctrl + Shift + M`, mas necessitando uma mudan√ßa de op√ß√£o em `Tools > Global Options > Code > [x] Use native pipe operator, |> (requires R 4.1+)`, necessitando que o RStudio esteja numa vers√£o igual ou superior a 1.4.17+.
:::

## tidyr

Os conjuntos de dados `tidy` (organizados) s√£o mais f√°ceis de manipular, modelar e visualizar. Um conjunto de dados est√° no formato `tidy` ou n√£o, dependendo de como linhas, colunas e c√©lulas s√£o combinadas com observa√ß√µes, vari√°veis e valores. Nos dados tidy, as vari√°veis est√£o nas colunas, observa√ß√µes est√£o nas linhas e valores est√£o nas c√©lulas, sendo que para esse √∫ltimo, n√£o deve haver mais de um valor por c√©lula (Figura \@ref(fig:fig-r-dados-tidy)).

1. Cada vari√°vel em uma coluna
2. Cada observa√ß√£o em uma linha
3. Cada valor como uma c√©lula

```{r fig-r-dados-tidy, echo=FALSE, fig.cap="As tr√™s regras que tornam um conjunto de dados *tidy*. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig02.png")
```

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://tidyr.tidyverse.org/reference/index.html) do pacote.

Para realizar diversas transforma√ß√µes nos dados, a fim de ajust√°-los ao formato `tidy` existe uma s√©rie de fun√ß√µes para: unir colunas, separar colunas, lidar com valores faltantes (`NA`), transformar a base de dados de formato longo para largo (ou vice-e-versa), al√©m de outras [fun√ß√µes espec√≠ficas](https://tidyr.tidyverse.org/reference/index.html).

- `unite()`: junta dados de m√∫ltiplas colunas em uma coluna
- `separate()`: separa caracteres em m√∫ltiplas colunas
- `separate_rows()`: separa caracteres em m√∫ltiplas colunas e linhas
- `drop_na()`: retira linhas com `NA` do conjunto de dados
- `replace_na()`: substitui `NA` do conjunto de dados
- `pivot_wider()`: transforma um conjunto de dados longo (*long*) para largo (*wide*)
- `pivot_longer()`: transforma um conjunto de dados largo (*wide*) para longo (*long*)

### palmerpenguins

Para exemplificar o funcionamento dessas fun√ß√µes, usaremos os dados de medidas de pinguins chamados [*palmerpenguins*](https://allisonhorst.github.io/palmerpenguins), dispon√≠veis no pacote `palmerpenguins`.

```{r eval=FALSE}
## Instalar o pacote
install.packages("palmerpenguins")
```

Esses dados foram coletados e disponibilizados pela [Dra. Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) e pela [Palmer Station, Antarctica LTER](https://pal.lternet.edu/), membro da Long Term Ecological Research Network.

O pacote `palmerpenguins` cont√©m dois conjuntos de dados. Um √© chamado de `penguins` e √© uma vers√£o simplificada dos dados brutos. O segundo conjunto de dados √© `penguins_raw` e cont√©m todas as vari√°veis e nomes originais baixados. Ambos os conjuntos de dados cont√™m dados para 344 pinguins, de tr√™s esp√©cies diferentes, coletados em tr√™s ilhas no arquip√©lago de Palmer, na Ant√°rtica. Destacamos tamb√©m a vers√£o traduzida desses dados para o portugu√™s, dispon√≠vel no pacote [`dados`](https://cienciadedatos.github.io/dados/).

Vamos utilizar principalmente o conjunto de dados `penguins_raw`, que √© a vers√£o dos dados brutos.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

Podemos ainda vericar os dados, pedindo uma ajuda de cada um dos objetos.

```{r eval=FALSE}
## Ajuda dos dados
?penguins
?penguins_raw
```

### glimpse()

Primeiramente, vamos observar os dados e utilizar a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral dos dados.

```{r}
## Visualizar os dados
penguins_raw

## Espiar os dados
dplyr::glimpse(penguins_raw)
```

### unite()

Primeiramente, vamos exemplificar como juntar e separar colunas. Vamos utilizar a fun√ß√£o `tidyr::unite()` para unir as colunas. H√° diversos par√¢metros para alterar como esta fun√ß√£o funciona, entretanto, √© importante destacar tr√™s deles: `col` nome da coluna que vai receber as colunas unidas, `sep` indicando o caracter separador das colunas unidas, e `remove` para uma resposta l√≥gica se as colunas unidas s√£o removidas ou n√£o. Vamos unir as colunas "Region" e "Island" na nova coluna "region_island".

```{r}
## Unir colunas
penguins_raw_unir <- tidyr::unite(data = penguins_raw, 
                                  col = "region_island",
                                  Region:Island, 
                                  sep = ", ",
                                  remove = FALSE)
head(penguins_raw_unir[, c("Region", "Island", "region_island")])
```

### separate()

De forma contr√°ria, podemos utilizar as fun√ß√µes `tidyr::separate()` e `tidyr::separate_rows()` para separar elementos de uma coluna em mais colunas. Respectivamente, a primeira fun√ß√£o separa uma coluna em novas colunas conforme a separa√ß√£o, e a segunda fun√ß√£o separa uma coluna, distribuindo os elementos nas linhas. Novamente, h√° diversos par√¢metros para mudar o comportamento dessas fun√ß√µes, mas destacaremos aqui quatro deles: `col` coluna a ser separada, `into` os nomes das novas colunas, `sep` indicando o caractere separador das colunas, e `remove` para uma resposta l√≥gica se as colunas separadas s√£o removidas ou n√£o. Vamos separar a coluna "Stage" nas colunas "stage" e "egg_stage".

```{r}
## Separar colunas
penguins_raw_separar <- tidyr::separate(data = penguins_raw, 
                                        col = Stage,
                                        into = c("stage", "egg_stage"), 
                                        sep = ", ",
                                        remove = FALSE)
head(penguins_raw_separar[, c("Stage", "stage", "egg_stage")])

## Separar colunas em novas linhas
penguins_raw_separar_linhas <- tidyr::separate_rows(data = penguins_raw,
                                                    Stage,
                                                    sep = ", ")
head(penguins_raw_separar_linhas[, c("studyName", "Sample Number", "Species", 
                                     "Region", "Island", "Stage")])
```

### drop_na() e replace_na()

*Valores faltantes* (`NA`) √© um tipo especial de elemento que discutimos no Cap√≠tulo \@ref(cap4) e s√£o relativamente comuns em conjuntos de dados. Em Base R, vimos algumas formas de lidar com esse tipo de elemento. No formato `tidyverse`, existem tamb√©m v√°rias formas de lidar com eles, mas aqui focaremos nas fun√ß√µes `tidyr::drop_na()` e `tidyr::replace_na()`, para retirar linhas e substituir esses valores, respectivamente.

```{r, cache=TRUE}
## Remover todas as linhas com NAs
penguins_raw_todas_na <- tidyr::drop_na(data = penguins_raw)
head(penguins_raw_todas_na)

## Remover linhas de colunas espec√≠ficas com NAs
penguins_raw_colunas_na <- tidyr::drop_na(data = penguins_raw,
                                          any_of("Comments"))
head(penguins_raw_colunas_na[, "Comments"])

## Substituir NAs por outro valor
penguins_raw_subs_na <- tidyr::replace_na(data = penguins_raw,
                                          list(Comments = "Unknown"))
head(penguins_raw_subs_na[, "Comments"])
```

### pivot_longer() e pivot_wider()

Por fim, trataremos da pivotagem ou remodelagem de dados. Veremos como mudar o formato do nosso conjunto de dados de longo (*long*) para largo (*wide*) e vice-versa. Primeiramente, vamos ver como partir de um dados longo (*long*) e criar um dados largo (*wide*). Essa √© uma opera√ß√£o semelhante √† "Tabela Din√¢mica" das planilhas eletr√¥nicas. Consiste em usar uma coluna para distribuir seus valores em outras colunas, de modo que os valores dos elementos s√£o preenchidos corretamente, reduzindo assim o n√∫mero de linhas e aumentando o n√∫mero de colunas. Essa opera√ß√£o √© bastante comum em Ecologia de Comunidades, quando queremos transformar uma lista de esp√©cies em uma matriz de comunidades, com v√°rias esp√©cies nas colunas. Para realizar essa opera√ß√£o, usarmos a fun√ß√£o `tidyr::pivot_wider()`. Dos diversos par√¢metros que podem compor essa fun√ß√£o, dois deles s√£o fundamentais: `names_from` que indica a coluna de onde os nomes ser√£o usados e `values_from` a coluna com os valores.

```{r}
## Selecionar colunas
penguins_raw_sel_col <- penguins_raw[, c(2, 3, 13)]
head(penguins_raw_sel_col)

## Pivotar para largo
penguins_raw_pivot_wider <- tidyr::pivot_wider(data = penguins_raw_sel_col, 
                                               names_from = Species, 
                                               values_from = `Body Mass (g)`)
head(penguins_raw_pivot_wider)
```

De modo oposto, podemos partir de um conjunto de dados largo (*wide*), ou seja, com v√°rias colunas, e queremos que essas colunas preencham uma √∫nica coluna, e que os valores antes espalhados nessas v√°rias colunas sejam adicionados um embaixo do outro, numa √∫nica coluna, no formato longo (*long*). Para essa opera√ß√£o, podemos utilizar a fun√ß√£o `tidyr::pivot_longer()`. Novamente, dos diversos par√¢metros que podem compor essa fun√ß√£o, tr√™s deles s√£o fundamentais: `cols` indicando as colunas que ser√£o usadas para serem pivotadas, `names_to` que indica a coluna de onde os nomes ser√£o usados e `values_to` a coluna com os valores.

```{r}
## Selecionar colunas
penguins_raw_sel_col <- penguins_raw[, c(2, 3, 10:13)]
head(penguins_raw_sel_col)

## Pivotar para largo
penguins_raw_pivot_longer <- tidyr::pivot_longer(data = penguins_raw_sel_col, 
                                                 cols = `Culmen Length (mm)`:`Body Mass (g)`,
                                                 names_to = "medidas", 
                                                 values_to = "valores")
head(penguins_raw_pivot_longer)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo 12 [Tidy data](https://r4ds.had.co.nz/tidy-data.html) de Wickham & Grolemund [-@wickham2017].

## dplyr

O `dplyr` √© um pacote que facilita a manipula√ß√£o de dados, com uma gram√°tica simples e flex√≠vel (por exemplo, como filtragem, reordenamento, sele√ß√£o, entre outras). Ele foi constru√≠do com o intuito de obter uma forma mais r√°pida e expressiva de manipular dados tabulares. O `tibble` √© a vers√£o de data frame mais conveniente para se usar com pacote `dplyr`.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://dplyr.tidyverse.org/reference/index.html) do pacote.

### Gram√°tica

Sua gram√°tica simples cont√©m fun√ß√µes verbais para manipula√ß√£o de dados, baseada em:

-   Verbos: `mutate()`, `select()`, `filter()`, `arrange()`, `summarise()`, `slice()`, `rename()`, etc.
-   Replica√ß√£o: `across()`, `if_any()`, `if_all()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, etc.
-   Agrupamento: `group_by()` e `ungroup()`
-   Jun√ß√µes: `inner_join()`, `full_join()`, `left_join()`, `right_join()`, etc.
-   Combina√ß√µes: `bind_rows()` e `bind_cols()`
-   Resumos, contagem e sele√ß√£o: `n()`, `n_distinct()`, `first()`, `last()`, `nth()`, etc.

Existe uma s√©rie de fun√ß√µes para realizar a manipula√ß√£o dos dados, com diversas finalidades: manipula√ß√£o de uma tabela, manipula√ß√£o de duas tabelas, replica√ß√£o, agrupamento, fun√ß√µes de vetores, al√©m de muitas outras [fun√ß√µes espec√≠ficas](https://dplyr.tidyverse.org/reference/index.html).

-   `relocate()`: muda a ordem das colunas
-   `rename()`: muda o nome das colunas
-   `select()`: seleciona colunas pelo nome ou posi√ß√£o
-   `pull()`: seleciona uma coluna como vetor
-   `mutate()`: adiciona novas colunas ou resultados em colunas existentes
-   `arrange()`: reordena as linhas com base nos valores de colunas
-   `filter()`: seleciona linhas com base em valores de colunas
-   `slice()`: seleciona linhas de diferente formas
-   `distinct()`: remove linhas com valores repetidos com base nos valores de colunas
-   `count()`: conta observa√ß√µes para um grupo
-   `group_by()`: agrupa linhas pelos valores das colunas
-   `summarise()`: resume os dados atrav√©s de fun√ß√µes considerando valores das colunas
-   `*_join()`: fun√ß√µes que juntam dados de duas tabelas atrav√©s de uma coluna chave

### Sintaxe

As fun√ß√µes do `dplyr` podem seguir uma mesma sintaxe: o `tibble` ser√° sempre o primeiro argumento dessas fun√ß√µes, seguido de um operador pipe (`%>%`) e pelo nome da fun√ß√£o que ir√° fazer a manipula√ß√£o nesses dados. Isso permite o encadeamento de v√°rias opera√ß√µes consecutivas mantendo a estrutura do dado original e acrescentando mudan√ßas num encadeamento l√≥gico.

Sendo assim, as fun√ß√µes verbais n√£o precisam modificar necessariamente o tibble original, sendo que as opera√ß√µes de manipula√ß√µes podem e devem ser atribu√≠das a um novo objeto.

```{r eval=FALSE}
## Sintaxe
tb_dplyr <- tb %>% 
    funcao_verbal1(argumento1, argumento2, ...) %>% 
    funcao_verbal2(argumento1, argumento2, ...) %>% 
    funcao_verbal3(argumento1, argumento2, ...)
```

Al√©m de `data.frames` e `tibbles`, a manipula√ß√£o pelo formato `dplyr` torna o trabalho com outros formatos de classes e dados acess√≠veis e eficientes como `data.table`, SQL e Apache Spark, para os quais existem pacotes espec√≠ficos.

-   [*dtplyr*](https://dtplyr.tidyverse.org/): manipular conjuntos de dados `data.table`
-   [*dbplyr*](https://dbplyr.tidyverse.org/): manipular conjuntos de dados SQL
-   [*sparklyr*](https://spark.rstudio.com/): manipular conjuntos de dados no Apache Spark

### palmerpenguins

Para nossos exemplos, vamos utilizar novamente os dados de pinguins [*palmerpenguins*](https://allisonhorst.github.io/palmerpenguins). Esses dados est√£o dispon√≠veis no pacote `palmerpenguins`. Vamos utilizar principalmente o conjunto de dados `penguins`, que √© a vers√£o simplificada dos dados brutos `penguins_raw`.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

### relocate()

Primeiramente, vamos reordenar as colunas com a fun√ß√£o `dplyr::relocate()`, onde simplesmente listamos as colunas que queremos mudar de posi√ß√£o e para onde elas devem ir. Para esse √∫ltimo passo h√° dois argumentos: `.before` que indica a coluna onde a coluna realocada deve se mover antes, e o argumento `.after` indicando onde deve se mover depois. Ambos podem ser informados com os nomes ou posi√ß√µes dessas colunas com n√∫meros.

```{r}
## Reordenar colunas - nome
penguins_relocate_col <- penguins %>% 
    dplyr::relocate(sex, year, .after = island)
head(penguins_relocate_col)

## Reordenar colunas - posi√ß√£o
penguins_relocate_ncol <- penguins %>% 
    dplyr::relocate(sex, year, .after = 2)
head(penguins_relocate_ncol)
```

### rename()

Podemos renomear colunas facilmente com a fun√ß√£o `dplyr::rename()`, onde primeiramente informamos o nome que queremos que a coluna tenha, seguido do operador `=` e a coluna do nosso dado ("nova_coluna = antiga_coluna"). Tamb√©m podemos utilizar a fun√ß√£o `dplyr::rename_with()`, que faz a mudan√ßa do nome em m√∫ltiplas colunas, que pode depender ou n√£o de resultados booleanos.

```{r}
## Renomear as colunas
penguins_rename <- penguins %>% 
    dplyr::rename(bill_length = bill_length_mm,
                  bill_depth = bill_depth_mm,
                  flipper_length = flipper_length_mm,
                  body_mass = body_mass_g)
head(penguins_rename)

## mudar o nome de todas as colunas
penguins_rename_with <- penguins %>% 
    dplyr::rename_with(toupper)
head(penguins_rename_with)
```

### select()

Outra opera√ß√£o bastante usual dentro da manipula√ß√£o de dados tabulares √© a sele√ß√£o de colunas. Podemos fazer essa opera√ß√£o com a fun√ß√£o `dplyr::select()`, que seleciona colunas pelo nome ou pela sua posi√ß√£o. Aqui h√° uma s√©rie de possibilidades de sele√ß√£o de colunas, desde utilizar operadores como `:` para selecionar intervalos de colunas, `!` para tomar o complemento (todas menos as listadas), al√©m de fun√ß√µes como `dplyr::starts_with()`, `dplyr::ends_with()`, `dplyr::contains()` para procurar colunas com um padr√£o de texto do nome da coluna.

```{r}
## Selecionar colunas por posi√ß√£o
penguins_select_position <- penguins %>% 
    dplyr::select(3:6)
head(penguins_select_position)

## Selecionar colunas por nomes
penguins_select_names <- penguins %>% 
    dplyr::select(bill_length_mm:body_mass_g)
head(penguins_select_names)

## Selecionar colunas por padr√£o
penguins_select_contains <- penguins %>% 
    dplyr::select(contains("_mm"))
head(penguins_select_contains)
```

### pull()

Quando usamos a fun√ß√£o `dplyr::select()`, mesmo que para apenas uma coluna, o retorno da fun√ß√£o √© sempre um `tibble`. Caso precisemos que essa coluna se torne um vetor dentro do encadeamento dos `pipes`, usamos a fun√ß√£o `dplyr::pull()`, que extrai uma √∫nica coluna como vetor.

```{r}
## Coluna como vetor
penguins_select_pull <- penguins %>% 
    dplyr::pull(bill_length_mm)
head(penguins_select_pull, 15)
```

### mutate()

Uma das opera√ß√µes mais √∫teis dentre as opera√ß√µes para colunas √© adicionar ou atualizar os valores de colunas. Para essa opera√ß√£o, usaremos a fun√ß√£o `dplyr::mutate()`. Podemos ainda usar os argumentos `.before` e `.after` para indicar onde a nova coluna deve ficar, al√©m do par√¢metro `.keep` com diversas possibilidades de manter colunas depois de usar a fun√ß√£o `dplyr::mutate()`. Por fim, √© fundamental destacar o uso das fun√ß√µes de replica√ß√£o: `dplyr::across()`, `dplyr::if_any()` e `dplyr::if_all()`, para os quais a fun√ß√£o far√° altera√ß√µes em m√∫ltiplas colunas de uma vez, dependendo de resultados booleanos.

```{r}
## Adicionar colunas
penguins_mutate <- penguins %>% 
    dplyr::mutate(body_mass_kg = body_mass_g/1e3, .before = sex)
head(penguins_mutate)

## Modificar v√°rias colunas
penguins_mutate_across <- penguins %>% 
    dplyr::mutate(across(where(is.factor), as.character))
head(penguins_mutate_across)
```

### arrange()

Al√©m de opera√ß√µes em colunas, podemos fazer opera√ß√µes em linhas. Vamos come√ßar com a reordena√ß√£o das linhas com base nos valores das colunas. Para essa opera√ß√£o, usamos a fun√ß√£o `dplyr::arrange()`. Podemos reordenar por uma ou mais colunas de forma crescente ou decrescente usando a fun√ß√£o `desc()` ou o operador `-` antes da coluna de interesse. Da mesma forma que na fun√ß√£o `dplyr::mutate()`, podemos usar as fun√ß√µes de replica√ß√£o para ordenar as linhas para v√°rias colunas de uma vez, dependendo de resultados booleanos.

```{r}
## Reordenar linhas - crescente
penguins_arrange <- penguins %>% 
    dplyr::arrange(body_mass_g)
head(penguins_arrange)

## Reordenar linhas - decrescente
penguins_arrange_desc <- penguins %>% 
    dplyr::arrange(desc(body_mass_g))
head(penguins_arrange_desc)

## Reordenar linhas - decrescente
penguins_arrange_desc_m <- penguins %>% 
    dplyr::arrange(-body_mass_g)
head(penguins_arrange_desc_m)

## Reordenar linhas - multiplas colunas
penguins_arrange_across <- penguins %>% 
    dplyr::arrange(across(where(is.numeric)))
head(penguins_arrange_across)
```

### filter()

Uma das principais e mais usuais opera√ß√µes que podemos realizar em linhas √© a sele√ß√£o de linhas atrav√©s do filtro por valores de uma ou mais colunas, utilizando a fun√ß√£o `dplyr::filter()`. Para realizar os filtros utilizaremos grande parte dos operadores relacionais e l√≥gicos que listamos na Tabela \@ref(tab:tab-operadores) no Cap√≠tulo \@ref(cap4), especialmente os l√≥gicos para combina√ß√µes de filtros em mais de uma coluna. Al√©m desses operadores, podemos utilizar a fun√ß√£o `is.na()` para filtros em elementos faltantes, e as fun√ß√µes `dplyr::between()` e `dplyr::near()` para filtros entre valores, e para valores pr√≥ximos com certa toler√¢ncia, respectivamente. Por fim, podemos usar as fun√ß√µes de replica√ß√£o para filtro das linhas para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Filtrar linhas
penguins_filter <- penguins %>% 
    dplyr::filter(species == "Adelie")
head(penguins_filter)

## Filtrar linhas
penguins_filter_two <- penguins %>% 
    dplyr::filter(species == "Adelie" & sex == "female")
head(penguins_filter_two)

## Filtrar linhas
penguins_filter_in <- penguins %>% 
    dplyr::filter(species %in% c("Adelie", "Gentoo"),
                  sex == "female")
head(penguins_filter_in)

## Filtrar linhas - NA
penguins_filter_na <- penguins %>% 
    dplyr::filter(!is.na(sex) == TRUE)
head(penguins_filter_na)

## Filtrar linhas - intervalos
penguins_filter_between <- penguins %>% 
    dplyr::filter(between(body_mass_g, 3000, 4000))
head(penguins_filter_between)

## Filtrar linhas por v√°rias colunas
penguins_filter_if <- penguins %>% 
    dplyr::filter(if_all(where(is.integer), ~ . > 200))
head(penguins_filter_if)
```

### slice()

Al√©m da sele√ß√£o de linhas por filtros, podemos fazer a sele√ß√£o das linhas por intervalos, indicando quais linhas desejamos, usando a fun√ß√£o `dplyr::slice()`, e informando o argumento `n` para o n√∫mero da linha ou intervalo das linhas. Essa fun√ß√£o possui varia√ß√µes no sufixo muito interessantes: `dplyr::slice_head()` e `dplyr::slice_tail()` seleciona as primeiras e √∫ltimas linhas, `dplyr::slice_min()` e `dplyr::slice_max()` seleciona linhas com os maiores e menores valores de uma coluna, e `dplyr::slice_sample()` seleciona linhas aleatoriamente.

```{r}
## Seleciona linhas
penguins_slice <- penguins %>% 
    dplyr::slice(n = c(1, 3, 300:n()))
head(penguins_slice)

## Seleciona linhas - head
penguins_slice_head <- penguins %>% 
    dplyr::slice_head(n = 5)
head(penguins_slice_head)

## Seleciona linhas - max
penguins_slice_max <- penguins %>% 
    dplyr::slice_max(body_mass_g, n = 5)
head(penguins_slice_max)

## Seleciona linhas - sample
penguins_slice_sample <- penguins %>% 
    dplyr::slice_sample(n = 30)
head(penguins_slice_sample)
```

### distinct()

A √∫ltima opera√ß√£o que apresentaremos para linhas √© a retirada de linhas com valores repetidos com base nos valores de uma ou mais colunas, utilizando a fun√ß√£o `dplyr::distinct()`. Essa fun√ß√£o por padr√£o retorna apenas a(s) coluna(s) utilizada(s) para retirar as linhas com valores repetidos, sendo necess√°rio acrescentar o argumento `.keep_all = TRUE` para retornar todas as colunas. Por fim, podemos usar as fun√ß√µes de replica√ß√£o para retirar linhas com valores repetidos para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Retirar linhas com valores repetidos
penguins_distinct <- penguins %>% 
    dplyr::distinct(body_mass_g)
head(penguins_distinct)

## Retirar linhas com valores repetidos - manter as outras colunas
penguins_distinct_keep_all <- penguins %>% 
    dplyr::distinct(body_mass_g, .keep_all = TRUE)
head(penguins_distinct_keep_all)

## Retirar linhas com valores repetidos para v√°rias colunas
penguins_distinct_keep_all_across <- penguins %>% 
    dplyr::distinct(across(where(is.integer)), .keep_all = TRUE)
head(penguins_distinct_keep_all_across)
```

### count()

Agora entraremos no assunto de resumo das observa√ß√µes. Podemos fazer contagens resumos dos nossos dados, utilizando para isso a fun√ß√£o `dplyr::count()`. Essa fun√ß√£o contar√° valores de uma ou mais colunas, geralmente para vari√°veis categ√≥ricas, semelhante √† fun√ß√£o Base R `table()`, mas num contexto *tidyverse*.

```{r}
## Contagens de valores para uma coluna
penguins_count <- penguins %>% 
    dplyr::count(species)
penguins_count

## Contagens de valores para mais de uma coluna
penguins_count_two <- penguins %>% 
    dplyr::count(species, island)
penguins_count_two
```

### group_by()

Uma grande parte das opera√ß√µes feitas nos dados s√£o realizadas em grupos definidos por valores de colunas com dados categ√≥ricas. A fun√ß√£o `dplyr::group_by()` transforma um `tibble` em um `tibble grouped`, onde as opera√ß√µes s√£o realizadas "por grupo". Essa fun√ß√£o √© utilizada geralmente junto com a fun√ß√£o `dplyr::summarise()`, que veremos logo em seguida. O agrupamento n√£o altera a apar√™ncia dos dados (al√©m de informar como est√£o agrupados). A fun√ß√£o `dplyr::ungroup()` remove o agrupamento. Podemos ainda usar fun√ß√µes de replica√ß√£o para fazer os agrupamentos para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Agrupamento
penguins_group_by <- penguins %>% 
    dplyr::group_by(species)
head(penguins_group_by)

## Agrupamento de v√°rias colunas
penguins_group_by_across <- penguins %>% 
    dplyr::group_by(across(where(is.factor)))
head(penguins_group_by_across)
```

### summarise()

Como dissemos, muitas vezes queremos resumir nossos dados, principalmente para ter uma no√ß√£o geral das vari√°veis (colunas) ou mesmo come√ßar a an√°lise explorat√≥ria resumindo vari√°veis cont√≠nuas por grupos de vari√°veis categ√≥ricas. Dessa forma, ao utilizar a fun√ß√£o `dplyr::summarise()` teremos um novo `tibble` com os dados resumidos, que √© a agrega√ß√£o ou resumo dos dados atrav√©s de fun√ß√µes. Da mesma forma que outras fun√ß√µes, podemos usar fun√ß√µes de replica√ß√£o para resumir valores para mais de uma coluna, dependendo de resultados booleanos.

```{r}
## Resumo
penguins_summarise <- penguins %>% 
    dplyr::group_by(species) %>% 
    dplyr::summarize(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),
                     body_mass_g_sd = sd(body_mass_g, na.rm = TRUE))
penguins_summarise

## Resumo para v√°rias colunas
penguins_summarise_across <- penguins %>% 
    dplyr::group_by(species) %>% 
    dplyr::summarize(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
penguins_summarise_across
```

### bind_rows() e bind_cols()

Muitas vezes teremos de combinar duas ou mais tabelas de dados. Podemos utilizar as fun√ß√µes Base R `rbind()` e `cbind()`, como vimos no Cap√≠tulo \@ref(cap4). Entretanto, pode ser interessante avan√ßar para as fun√ß√µes `dplyr::bind_rows()` e `dplyr::bind_cols()` do formato *tidyverse*. A ideia √© muito semelhante: a primeira fun√ß√£o combina dados por linhas e a segunda por colunas. Entretanto, h√° algumas vantagens no uso dessas fun√ß√µes, como a identifica√ß√£o das linhas pelo argumento `.id` para a primeira fun√ß√£o, e a confer√™ncia do nome das colunas pelo argumento `.name_repair` para a segunda fun√ß√£o.

```{r}
## Selecionar as linhas para dois tibbles
penguins_01 <- dplyr::slice(penguins, 1:5)
penguins_02 <- dplyr::slice(penguins, 51:55)

## Combinar as linhas
penguins_bind_rows <- dplyr::bind_rows(penguins_01, penguins_02, .id = "id")
head(penguins_bind_rows)

## Combinar as colunas
penguins_bind_cols <- dplyr::bind_cols(penguins_01, penguins_02, .name_repair = "unique")
head(penguins_bind_cols)
```

### *_join()

Finalmente, veremos o √∫ltimo conjunto de fun√ß√µes do pacote `dplyr`, a jun√ß√£o de tabelas. Nessa opera√ß√£o, fazemos a combina√ß√£o de pares de conjunto de dados tabulares por uma ou mais colunas chaves. H√° dois tipos de jun√ß√µes: jun√ß√£o de modifica√ß√£o e jun√ß√£o de filtragem. A jun√ß√£o de modifica√ß√£o primeiro combina as observa√ß√µes por suas chaves e, em seguida, copia as vari√°veis (colunas) de uma tabela para a outra. √â fundamental destacar a import√¢ncia da coluna chave, que √© indicada pelo argumento `by`. Essa coluna deve conter elementos que sejam comuns √†s duas tabelas para que haja a combina√ß√£o dos elementos.

Existem quatro tipos de jun√ß√µes de modifica√ß√µes, que s√£o realizadas pelas fun√ß√µes: `dplyr::inner_join()`, `dplyr::left_join()`, `dplyr::full_join()` e `dplyr::right_join()`, e que podem ser representadas na Figura \@ref(fig:fig-r-join).

```{r fig-r-join, echo=FALSE, fig.cap="Diferentes tipos de joins, representados com um diagrama de Venn. Adaptado de: Wickham & Grolemund [-@wickham2017]."}
knitr::include_graphics("img/cap05_fig03.png")
```

Considerando a nomenclatura de duas tabelas de dados por `x` e `y`, temos:

-   `inner_join(x, y)`: mant√©m apenas as observa√ß√µes em `x` e em `y`
-   `left_join(x, y)`: mant√©m todas as observa√ß√µes em `x`
-   `right_join(x, y)`: mant√©m todas as observa√ß√µes em `y`
-   `full_join(x, y)`: mant√©m todas as observa√ß√µes em `x` e em `y`

Aqui, vamos demostrar apenas a fun√ß√£o `dplyr::left_join()`, combinando um `tibble` de coordenadas geogr√°ficas das ilhas com o conjunto de dados do penguins.

```{r}
## Adicionar uma coluna chave de ids
penguin_islands <- tibble(
    island = c("Torgersen", "Biscoe", "Dream", "Alpha"),
    longitude = c(-64.083333, -63.775636, -64.233333, -63),
    latitude = c(-64.766667, -64.818569, -64.733333, -64.316667))

## Jun√ß√£o - left
penguins_left_join <- dplyr::left_join(penguins, penguin_islands, by = "island")
head(penguins_left_join)
```

J√° o segundo tipo de jun√ß√£o, a jun√ß√£o de filtragem combina as observa√ß√µes da mesma maneira que as jun√ß√µes de modifica√ß√£o, mas afetam as observa√ß√µes (linhas), n√£o as vari√°veis (colunas). Existem dois tipos.

-   `semi_join(x, y)`: mant√©m todas as observa√ß√µes em `x` que t√™m uma correspond√™ncia em `y`
-   `anti_join(x, y)`: elimina todas as observa√ß√µes em `x` que t√™m uma correspond√™ncia em `y`

De forma geral, *semi-joins* s√£o √∫teis para corresponder tabelas de resumo filtradas de volta √†s linhas originais, removendo as linhas que n√£o estavam antes do join. J√° *anti-joins* s√£o √∫teis para diagnosticar incompatibilidades de jun√ß√£o, por exemplo, ao verificar os elementos que n√£o combinam entre duas tabelas de dados.

### Opera√ß√µes de conjuntos e compara√ß√£o de dados

Temos ainda opera√ß√µes de conjuntos e compara√ß√£o de dados.

-   `union(x, y)`: retorna todas as linhas que aparecem em `x`, `y` ou mais dos conjuntos de dados
-   `interesect(x, y)`: retorna apenas as linhas que aparecem em `x` e em `y`
-   `setdiff(x, y)`: retorna as linhas que aparecem `x`, mas n√£o em `y`
-   `setequal(x, y)`: retorna se `x` e `y` s√£o iguais e quais suas diferen√ßas

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [13 Relational data](https://r4ds.had.co.nz/relational-data.html) de Wickham & Grolemund [-@wickham2017].

## stringr

O pacote `stringr` fornece um conjunto de fun√ß√µes para a manipula√ß√£o de caracteres ou strings. O pacote concentra-se nas fun√ß√µes de manipula√ß√£o mais importantes e comumente usadas. Para fun√ß√µes mais espec√≠ficas, recomenda-se usar o pacote `stringi`, que fornece um conjunto mais abrangente de fun√ß√µes. As fun√ß√µes do `stringr` podem ser agrupadas em algumas opera√ß√µes para tarefas espec√≠ficas como i) correspond√™ncia de padr√µes, ii)retirar e acrescentar espa√ßos em branco, iii) mudar mai√∫sculas e min√∫sculas, al√©m de muitas outras opera√ß√µes com caracteres.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://stringr.tidyverse.org/reference/index.html) do pacote.

Demonstraremos algumas fun√ß√µes para algumas opera√ß√µes mais comuns, utilizando um vetor de um elemento, com o string "penguins".

Podemos explorar o comprimento de strings com a fun√ß√£o `stringr::str_length()`.

```{r}
## Comprimento
stringr::str_length(string = "penguins")
```

Extrair um string por sua posi√ß√£o usando a fun√ß√£o `stringr::str_sub()` ou por um padr√£o com `stringr::str_extract()`.

```{r}
## Extrair pela posi√ß√£o
stringr::str_sub(string = "penguins", end = 3)

## Extrair por padr√£o
stringr::str_extract(string = "penguins", pattern = "p")
```

Substituir strings por outros strings com `stringr::str_replace()`.

```{r}
## Substituir
stringr::str_replace(string = "penguins", pattern = "i", replacement = "y")
```

Separar strings por um padr√£o com a fun√ß√£o `stringr::str_split()`.

```{r}
## Separar
stringr::str_split(string = "p-e-n-g-u-i-n-s", pattern = "-", simplify = TRUE)
```

Inserir espa√ßos em brancos pela esquerda, direita ou ambos com a fun√ß√£o `stringr::str_pad()`.

```{r}
## Inserir espacos em branco
stringr::str_pad(string = "penguins", width = 10, side = "left")
stringr::str_pad(string = "penguins", width = 10, side = "right")
stringr::str_pad(string = "penguins", width = 10, side = "both")
```

Tamb√©m podemos remover espa√ßos em branco da esquerda, direita ou ambos, utilizando `stringr::str_trim()`.

```{r}
## Remover espacos em branco
stringr::str_trim(string = " penguins ", side = "left")
stringr::str_trim(string = " penguins ", side = "right")
stringr::str_trim(string = " penguins ", side = "both")
```

Podemos tamb√©m alterar min√∫sculas e mai√∫sculas em diferentes posi√ß√µes do string, com v√°rias fun√ß√µes.

```{r}
## Alterar min√∫sculas e mai√∫sculas
stringr::str_to_lower(string = "Penguins")
stringr::str_to_upper(string = "penguins")
stringr::str_to_sentence(string = "penGuins")
stringr::str_to_title(string = "penGuins")
```

Podemos ainda ordenar os elementos de um vetor por ordem alfab√©tica de forma crescente ou decrescente, usando `stringr::str_sort()`.

```{r}
## Ordenar
stringr::str_sort(x = letters)
stringr::str_sort(x = letters, dec = TRUE)
```

Podemos ainda utilizar essas fun√ß√µes em complemento com o pacote `dplyr`, para alterar os strings de colunas ou nome das colunas.

```{r}
## Alterar valores das colunas
penguins_stringr_valores <- penguins %>% 
    dplyr::mutate(species = stringr::str_to_lower(species))

## Alterar nome das colunas
penguins_stringr_nomes <- penguins %>% 
    dplyr::rename_with(stringr::str_to_title)
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [14 Strings](https://r4ds.had.co.nz/strings.html) de Wickham & Grolemund [-@wickham2017].

## forcats

O pacote `forcats` fornece um conjunto de ferramentas √∫teis para facilitar a manipula√ß√£o de fatores. Como dito no Cap√≠tulo \@ref(cap4), usamos fatores geralmente quando temos dados categ√≥ricos, que s√£o vari√°veis que possuem um conjunto de valores fixos e conhecidos. As fun√ß√µes s√£o utilizadas principalmente para: i) mudar a ordem dos n√≠veis, ii) mudar os valores dos n√≠veis, iii) adicionar e remover n√≠veis, iv) combinar m√∫ltiplos n√≠veis, al√©m de outras opera√ß√µes.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://forcats.tidyverse.org/reference/index.html) do pacote.

Vamos utilizar ainda os dados `penguins` e `penguins_raw` para exemplificar o uso do pacote `forcats`.

```{r}
## Carregar o pacote palmerpenguins
library(palmerpenguins)
```

Primeiramente, vamos converter dados de string para fator, utilizando a fun√ß√£o `forcats::as_factor()`.

```{r}
## String
forcats::as_factor(penguins_raw$Species) %>% head()
```

Podemos facilmente mudar o nome dos n√≠veis utilizando a fun√ß√£o `forcats::fct_recode()`.

```{r}
## Mudar o nome dos n√≠veis
forcats::fct_recode(penguins$species, a = "Adelie", c = "Chinstrap", g = "Gentoo") %>% head()
```

Para inverter os n√≠veis, usamos a fun√ß√£o `forcats::fct_rev()`.

```{r}
## Inverter os n√≠veis
forcats::fct_rev(penguins$species) %>% head()
```

Uma opera√ß√£o muito comum com fatores √© mudar a ordem dos n√≠veis. Quando precisamos especificar a ordem dos n√≠veis, podemos fazer essa opera√ß√£o manualmente com a fun√ß√£o `forcats::fct_relevel()`.

```{r}
## Especificar a ordem dos n√≠veis
forcats::fct_relevel(penguins$species, "Chinstrap", "Gentoo", "Adelie") %>% head()
```

Como vimos, a reordena√ß√£o dos n√≠veis pode ser feita manualmente. Mas existem outras formas autom√°ticas de reordena√ß√£o seguindo algumas regras, para as quais existem fun√ß√µes espec√≠ficas.

-   `forcats::fct_inorder()`: pela ordem em que aparecem pela primeira vez
-   `forcats::fct_infreq()`: por n√∫mero de observa√ß√µes com cada n√≠vel (decrescente, i.e., o maior primeiro)
-   `forcats::fct_inseq()`: pelo valor num√©rico do n√≠vel

```{r}
## N√≠veis pela ordem em que aparecem
forcats::fct_inorder(penguins$species) %>% head()

## Ordem (decrescente) de frequ√™ncia
forcats::fct_infreq(penguins$species) %>% head()
```

Por fim, podemos fazer a agrega√ß√£o de n√≠veis raros em um n√≠vel utilizando a fun√ß√£o `forcats::fct_lump()`.

```{r}
## Agrega√ß√£o de n√≠veis raros em um n√≠vel
forcats::fct_lump(penguins$species) %>% head()
```

Podemos ainda utilizar essas fun√ß√µes em complemento com o pacote `dplyr` para fazer manipula√ß√µes de fatores nas colunas de `tibbles`.

```{r}
## Transformar v√°rias colunas em fator
penguins_raw_multi_factor <- penguins_raw %>% 
    dplyr::mutate(across(where(is.character), forcats::as_factor))
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [15 Factors](https://r4ds.had.co.nz/factors.html) de Wickham & Grolemund [-@wickham2017].

## lubridate

O pacote `lubridate` fornece um conjunto de fun√ß√µes para a manipula√ß√£o de dados de data e hor√°rio. Dessa forma, esse pacote facilita a manipula√ß√£o dessa classe de dado no R, pois geralmente esses dados n√£o s√£o intuitivos e mudam dependendo do tipo de objeto de data e hor√°rio. Al√©m disso, os m√©todos que usam datas e hor√°rios devem levar em considera√ß√£o fusos hor√°rios, anos bissextos, hor√°rios de ver√£o, al√©m de outras particularidades. Existem diversas fun√ß√µes nesse pacote, sendo as mesmas focadas em: i) transforma√ß√µes de data/hor√°rio, ii) componentes, iii) arredondamentos, iv) dura√ß√µes, v) per√≠odos, vi) intervalos, al√©m de muitas outras fun√ß√µes espec√≠ficas.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://lubridate.tidyverse.org/reference/index.html) do pacote.

Apesar de estar inserido no escopo do *tidyverse*, este pacote n√£o √© carregado com os demais, requisitando seu carregamento solo.

```{r}
## Carregar
library(lubridate)
```

Existem tr√™s tipos de dados data/hor√°rio:

- **Data**: tempo em dias, meses e anos `<date>`
- **Hor√°rio**: tempo dentro de um dia `<time>`
- **Data-hor√°rio**: tempo em um instante (data mais tempo) `<dttm>`

Para trabalhar exclusivamente com hor√°rios, podemos utilizar o pacote `hms`.

√â fundamental tamb√©m destacar que algumas letras ter√£o um significado temporal, sendo abrevia√ß√µes de diferentes per√≠odos em ingl√™s: **y**ear (ano), **m**onth (m√™s), **w**eak (semana), **d**ay (dia), **h**our (hora), **m**inute (minuto), e **s**econd (segundo).

Para acessar a informa√ß√£o da data e hor√°rios atuais podemos utilizar as fun√ß√µes `lubridate::today()` e `lubridate::now()`.

```{r}
## Extrair a data nesse instante
lubridate::today()

## Extrair a data e tempo nesse instante
lubridate::now()
```

Al√©m dessas informa√ß√µes instant√¢neas, existem tr√™s maneiras de criar um dado de data/hor√°rio.

-   De um string
-   De componentes individuais de data e hor√°rio
-   De um objeto de data/hor√°rio existente

Os dados de data/hor√°rio geralmente est√£o no formato de strings. Podemos transformar os dados especificando a ordem dos seus componentes, ou seja, a ordem em que ano, m√™s e dia aparecem no string, usando as letras `y` (ano), `m` (m√™s) e `d` (dia) na mesma ordem, por exemplo, `lubridate::dmy()`.

```{r}
## Strings e n√∫meros para datas
lubridate::dmy("03-03-2021")
```

Essas fun√ß√µes tamb√©m aceitam n√∫meros sem aspas, al√©m de serem muito vers√°teis e funcionarem em outros diversos formatos.

```{r, eval=FALSE}
## Strings e n√∫meros para datas
lubridate::dmy("03-Mar-2021")
lubridate::dmy(03032021)
lubridate::dmy("03032021")
lubridate::dmy("03/03/2021")
lubridate::dmy("03.03.2021")
```

Al√©m da data, podemos especificar hor√°rios atrelados a essas datas. Para criar uma data com hor√°rio adicionamos um underscore (`_`) e `h` (hora), `m` (minuto) e `s` (segundo) ao nome da fun√ß√£o, al√©m do argumento `tz` para especificar o *fuso hor√°rio* (tema tratado mais adiante nessa se√ß√£o).

```{r}
## Especificar hor√°rios e fuso hor√°rio
lubridate::dmy_h("03-03-2021 13")
lubridate::dmy_hm("03-03-2021 13:32")
lubridate::dmy_hms("03-03-2021 13:32:01")
lubridate::dmy_hms("03-03-2021 13:32:01", tz = "America/Sao_Paulo")
```

Podemos ainda ter componentes individuais de data/hor√°rio em m√∫ltiplas colunas. Para realizar essa transforma√ß√£o, podemos usar as fun√ß√µes `lubridate::make_date()` e `lubridate::make_datetime()`.

```{r}
## Dados com componentes individuais
dados <- tibble::tibble(
    ano = c(2021, 2021, 2021),
    mes = c(1, 2, 3),
    dia = c(12, 20, 31),
    hora = c(2, 14, 18), 
    minuto = c(2, 44, 55))

## Data de componentes individuais
dados %>% 
    dplyr::mutate(data = lubridate::make_datetime(ano, mes, dia, hora, minuto))
```

Por fim, podemo criar datas modificando entre data/hor√°rio e data, utilizando as fun√ß√µes `lubridate::as_datetime()` e `lubridate::as_date()`.

```{r}
## Data para data-hor√°rio
lubridate::as_datetime(today())

## Data-hor√°rio para data
lubridate::as_date(now())
```

Uma vez que entendemos como podemos criar dados de data/hor√°rio, podemos explorar fun√ß√µes para acessar e definir componentes individuais. Para essa tarefa existe uma grande quantidade de fun√ß√µes para acessar de partes espec√≠ficas de datas e hor√°rios.

-   `year()`: acessa o ano
-   `month()`: acessa o m√™s
-   `month()`: acessa o dia
-   `yday()`: acessa o dia do ano
-   `mday()`: acessa o dia do m√™s
-   `wday()`: acessa o dia da semana
-   `hour()`: acessa as horas
-   `minute()`: acessa os minutos
-   `second()`: acessa os segundos

```{r}
## Extrair
lubridate::year(now())
lubridate::month(now())
lubridate::month(now(), label = TRUE)
lubridate::day(now())
lubridate::wday(now())
lubridate::wday(now(), label = TRUE)
lubridate::second(now())
```

Al√©m de acessar componentes de datas e hor√°rios, podemos usar essas fun√ß√µes para fazer a inclus√£o de informa√ß√µes de datas e hor√°rios.

```{r}
## Data
data <- dmy_hms("04-03-2021 01:04:56")

## Incluir
lubridate::year(data) <- 2020
lubridate::month(data) <- 01
lubridate::hour(data) <- 13
```

Mais convenientemente, podemos utilizar a fun√ß√£o `update()` para alterar v√°rios valores de uma vez.

```{r}
## Incluir v√°rios valores
update(data, year = 2020, month = 1, mday = 1, hour = 1)
```

Muitas vezes precisamos fazer opera√ß√µes com datas, como a aritm√©tica: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o. Para tanto, √© preciso entender tr√™s classes importantes que representam intervalos de tempo.

-   **Dura√ß√µes**: representam um n√∫mero exato de segundos
-   **Per√≠odos**: representam unidades humanas como semanas e meses
-   **Intervalos**: representam um ponto inicial e final

Quando fazemos uma subtra√ß√£o de datas, criamos um objeto da classe `difftime`. Essa classe pode ser um pouco complicada de trabalhar, ent√£o dentro do *lubridate* usamos fun√ß√µes que convertem essa classe em dura√ß√£o, da classe `Duration`. As dura√ß√µes sempre registram o intervalo de tempo em segundos, com alguma unidade de tempo maior entre par√™nteses. H√° uma s√©rie de fun√ß√µes para tratar dessa classe.

-   `duration()`: cria data em dura√ß√£o
-   `as.duration()`: converte datas em dura√ß√£o
-   `dyears()`: dura√ß√£o de anos
-   `dmonths()`: dura√ß√£o de meses
-   `dweeks()`: dura√ß√£o de semanas
-   `ddays()`: dura√ß√£o de dias
-   `dhours()`: dura√ß√£o de horas
-   `dminutes()`: dura√ß√£o de minutos
-   `dseconds()`: dura√ß√£o de segundos

```{r}
## Subtra√ß√£o de datas
tempo_estudando_r <- lubridate::today() - lubridate::dmy("30-11-2011")

## Convers√£o para dura√ß√£o
tempo_estudando_r_dur <- lubridate::as.duration(tempo_estudando_r)

## Criando dura√ß√µes
lubridate::duration(90, "seconds")
lubridate::duration(1.5, "minutes")
lubridate::duration(1, "days")

## Transforma√ß√£o da dura√ß√£o
lubridate::dseconds(100)
lubridate::dminutes(100)
lubridate::dhours(100)
lubridate::ddays(100)
lubridate::dweeks(100)
lubridate::dyears(100)
```

Podemos ainda utilizar as dura√ß√µes para fazer opera√ß√µes aritm√©ticas com datas como adi√ß√£o, subtra√ß√£o e multiplica√ß√£o.

```{r}
## Somando dura√ß√µes a datas
lubridate::today() + lubridate::ddays(1)

## Subtraindo dura√ß√µes de datas
lubridate::today() - lubridate::dyears(1)

## Multiplicando dura√ß√µes
2 * dyears(2)
```

Al√©m das dura√ß√µes, podemos usar per√≠odos, que s√£o extens√µes de tempo n√£o fixados em segundos como as dura√ß√µes, mas flex√≠veis, com o tempo em dias, semanas, meses ou anos, permitindo uma interpreta√ß√£o mais intuitiva das datas. Novamente, h√° uma s√©rie de fun√ß√µes para realizar essas opera√ß√µes.

-   `period()`: cria data em per√≠odo
-   `as.period()`: converte datas em per√≠odo
-   `seconds()`: per√≠odo em segundos
-   `minutes()`: per√≠odo em minutos
-   `hours()`: per√≠odo em horas
-   `days()`: per√≠odo em dias
-   `weeks()`: per√≠odo em semanas
-   `months()`: per√≠odo em meses
-   `years()`: per√≠odo em anos

```{r}
## Criando per√≠odos
period(c(90, 5), c("second", "minute"))
period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))

## Transforma√ß√£o de per√≠odos
lubridate::seconds(100)
lubridate::minutes(100)
lubridate::hours(100)
lubridate::days(100)
lubridate::weeks(100)
lubridate::years(100)
```

Al√©m disso, podemos fazer opera√ß√µes com os per√≠odos, somando e subtraindo.

```{r}
## Somando datas
lubridate::today() + lubridate::weeks(10)

## Subtraindo datas
lubridate::today() - lubridate::weeks(10)

## Criando datas recorrentes
lubridate::today() + lubridate::weeks(0:10)
```

Por fim, intervalos s√£o per√≠odos de tempo limitados por duas datas, possuindo uma dura√ß√£o com um ponto de partida, que o faz preciso para determinar uma dura√ß√£o. Intervalos s√£o objetos da classe `Interval`. Da mesma forma que para dura√ß√£o e per√≠odos, h√° uma s√©rie de fun√ß√µes para realizar essas opera√ß√µes.

-   `interval()`: cria data em intervalo
-   `%--%`: cria data em intervalo
-   `as.interval()`: converte datas em intervalo
-   `int_start()`: acessa ou atribui data inicial de um intervalo
-   `int_end()`: acessa ou atribui data final de um intervalo
-   `int_length()`: comprimento de um intervalo em segundos
-   `int_flip()`: inverte a ordem da data de in√≠cio e da data de t√©rmino em um intervalo
-   `int_shift()`: desloca as datas de in√≠cio e t√©rmino de um intervalo
-   `int_aligns()`: testa se dois intervalos compartilham um ponto final
-   `int_standardize()`: garante que todos os intervalos sejam positivos
-   `int_diff()`: retorna os intervalos que ocorrem entre os elementos de data/hor√°rio
-   `int_overlaps()`: testa se dois intervalos se sobrep√µem
-   `%within%`: testa se o primeiro intervalo est√° contido no segundo

```{r}
## Criando duas datas - in√≠cio de estudos do R e nascimento do meu filho
r_inicio <- lubridate::dmy("30-11-2011")
filho_nascimento <- lubridate::dmy("26-09-2013")
r_hoje <- lubridate::today()

## Criando intervalos - interval
r_intervalo <- lubridate::interval(r_inicio, r_hoje)

## Criando intervalos - interval %--%
filho_intervalo <- filho_nascimento %--% lubridate::today()

## Opera√ß√µes com intervalos
lubridate::int_start(r_intervalo)
lubridate::int_end(r_intervalo)
lubridate::int_length(r_intervalo)
lubridate::int_flip(r_intervalo)
lubridate::int_shift(r_intervalo, duration(days = 30))
```

Uma opera√ß√£o de destaque √© verificar a sobreposi√ß√£o entre dois intervalos.

```{r}
## Verificar sobreposi√ß√£o - int_overlaps
lubridate::int_overlaps(r_intervalo, filho_intervalo)

## Verificar se intervalo est√° contido
r_intervalo %within% filho_intervalo
filho_intervalo %within% r_intervalo
```

Podemos ainda calcular quantos per√≠odos existem dentro de um intervalo, utilizando as opera√ß√µes de `/` e `%/%`.

```{r}
## Per√≠odos dentro de um intervalo - anos
r_intervalo / lubridate::years()
r_intervalo %/% lubridate::years()

## Per√≠odos dentro de um intervalo - dias e semandas
filho_intervalo / lubridate::days()
filho_intervalo / lubridate::weeks()
```

Ainda podemos fazer transforma√ß√µes dos dados para per√≠odos e ter todas as unidades de data e tempo que o intervalo compreende.

```{r}
## Tempo total estudando R
lubridate::as.period(r_intervalo)

## Idade do meu filho
lubridate::as.period(filho_intervalo)
```

Por fim, fusos hor√°rios tendem a ser um fator complicador quando precisamos analisar informa√ß√µes instant√¢neas de tempo (hor√°rio) de outras partes do planeta, ou mesmo fazer convers√µes dos hor√°rios. No `lubridate` h√° fun√ß√µes para ajudar nesse sentido. Para isso, podemos utilizar a fun√ß√£o `lubridate::with_tz()` e no argumento `tzone` informar o fuso hor√°rio para a transforma√ß√£o do hor√°rio.

Podemos descobrir o fuso hor√°rio que o R est√° considerando com a fun√ß√£o `Sys.timezone()`.

```{r}
## Fuso hor√°rio no R
Sys.timezone()
```

No R h√° uma listagem dos nomes dos fusos hor√°rios que podemos utilizar no argumento `tzone` para diferentes fusos hor√°rios.

```{r}
## Verificar os fuso hor√°rios
length(OlsonNames())
head(OlsonNames())
```

Podemos nos perguntar que horas s√£o em outra parte do globo ou fazer as convers√µes facilmente no *lubridate*.

```{r}
## Que horas s√£o em...
lubridate::with_tz(lubridate::now(), tzone = "America/Sao_Paulo")
lubridate::with_tz(lubridate::now(), tzone = "GMT")
lubridate::with_tz(lubridate::now(), tzone = "Europe/Berlin")

## Altera o fuso sem mudar a hora
lubridate::force_tz(lubridate::now(), tzone = "GMT")
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [16 Dates and times](https://r4ds.had.co.nz/dates-and-times.html) de Wickham & Grolemund [-@wickham2017].

## purrr

O pacote `purrr` implementa a *Programa√ß√£o Funcional* no R, fornecendo um conjunto completo e consistente de ferramentas para trabalhar com fun√ß√µes e vetores. A programa√ß√£o funcional √© um assunto bastante extenso, sendo mais conhecido no R pela fam√≠lia de fun√ß√µes `purrr::map()`, que permite substituir muitos *loops for* por um c√≥digo mais sucinto e f√°cil de ler. N√£o focaremos aqui nas outras fun√ß√µes, pois esse √© um assunto extremamente extenso.

Todas as fun√ß√µes deste pacote s√£o listadas na [p√°gina de refer√™ncia](https://purrr.tidyverse.org/reference/index.html) do pacote.

Um *loop for* pode ser entendido como uma itera√ß√£o: um bloco de c√≥digos √© repetido mudando um contador de uma lista de possibilidades. Vamos exemplificar com uma itera√ß√£o bem simples, onde imprimiremos no console os valores de 1 a 10, utilizando a fun√ß√£o `for()`, um contador `i` em um vetor de dez n√∫meros `1:10` que ser√° iterado, no bloco de c√≥digos definido entre `{}`, usando a fun√ß√£o `print()` para imprimir os valores.

A ideia √© bastante simples: a fun√ß√£o `for()` vai atribuir o primeiro valor da lista ao contador `i`, esse contador ser√° utilizado em todo o bloco de c√≥digos. Quando o bloco terminar, o segundo valor √© atribu√≠do ao contador `i` e entra no bloco de c√≥digos, repetindo esse processo at√© que todos os elementos da lista tenham sido atribu√≠dos ao contador.

```{r}
## Loop for
for(i in 1:10){
    print(i)
}
```

Com essa ideia em mente, a programa√ß√£o funcional faz a mesma opera√ß√£o utilizando a fun√ß√£o `purrr::map()`. O mesmo *loop for* ficaria dessa forma.

```{r, cache=FALSE}
## Loop for com map
purrr::map(.x = 1:10, .f = print)
```

Nessa estrutura, temos:

`map(.x, .f)`

-   `.x`: um vetor, lista ou data frame
-   `.f`: uma fun√ß√£o

Num outro exemplo, aplicaremos a fun√ß√£o `sum()` para somar os valores de v√°rios elementos de uma lista.

```{r}
## Fun√ß√£o map
x <- list(1:5, c(4, 5, 7), c(1, 1, 1), c(2, 2, 2, 2, 2))
purrr::map(x, sum)
```

H√° diferente tipos de retornos da fam√≠lia `purrr::map()`.

-   `map()`: retorna uma lista
-   `map_chr()`: retorna um vetor de strings
-   `map_dbl()`: retorna um vetor num√©rico (double)
-   `map_int()`: retorna um vetor num√©rico (integer)
-   `map_lgl()`: retorna um vetor l√≥gico
-   `map_dfr()`: retorna um data frame (por linhas)
-   `map_dfc()`: retorna um data frame (por colunas)

```{r}
## Varia√ß√µes da fun√ß√£o map
purrr::map_dbl(x, sum)
purrr::map_chr(x, paste, collapse = " ")
```

Essas funcionalidades j√° eram conhecidas no Base R pelas fun√ß√µes da *fam√≠lia `apply()`*: `apply()`, `lapply()`, `sapply()`, `vapply()`, `mapply()`, `rapply()` e `tapply()`. Essas fun√ß√µes formam a base de combina√ß√µes mais complexas e ajudam a realizar opera√ß√µes com poucas linhas de c√≥digo, para diferentes retornos.

Temos ainda duas variantes da fun√ß√£o `map()`: `purrr::map2()` e `purrr::pmap()`, para duas ou mais listas, respectivamente. Como vimos para a primeira fun√ß√£o, existem v√°rias varia√ß√µes do sufixo para modificar o retorno da fun√ß√£o.

```{r}
## Listas
x <- list(3, 5, 0, 1)
y <- list(3, 5, 0, 1)
z <- list(3, 5, 0, 1)

## Fun√ß√£o map2
purrr::map2_dbl(x, y, prod)

## Fun√ß√£o pmap
purrr::pmap_dbl(list(x, y, z), prod)
```

Essas fun√ß√µes podem ser usadas em conjunto para implementar rotinas de manipula√ß√£o e an√°lise de dados com poucas linhas de c√≥digo, mas que n√£o exploraremos em sua completude aqui. Listamos dois exemplos simples.

```{r}
## Resumo dos dados
penguins %>% 
    dplyr::select(where(is.numeric)) %>% 
    tidyr::drop_na() %>% 
    purrr::map_dbl(mean)
```

```{r}
## An√°lise dos dados
penguins %>%
    dplyr::group_split(island, species) %>% 
    purrr::map(~ lm(bill_depth_mm ~ bill_length_mm, data = .x)) %>% 
    purrr::map(summary) %>% 
    purrr::map("r.squared")
```

Para se aprofundar no tema, recomendamos a leitura do Cap√≠tulo [21 Iteration](https://r4ds.had.co.nz/iteration.html) de Wickham & Grolemund [-@wickham2017].

## Para se aprofundar

Listamos a seguir livros que recomendamos para seguir com sua aprendizagem em R e tidyverse.

### Livros

Recomendamos aos interessados os livros: i) Oliveira e colaboradores [-@oliveira_ciencia_2018] Ci√™ncia de dados com R, ii) Grolemund [-@williams_essentials_2018] The Essentials of Data Science: Knowledge Discovery Using R, Holmes e Huber [-@holmes_modern_2019] Modern Statistics for Modern Biology, iii) Irizarry [-@irizarry_data_2017] Introduction to Data Science: Data Analysis and Prediction Algorithms with R, iv) Ismay e Kim [-@ismay_statistical_2020] Statistical Inference via Data Science: A ModernDive into R and the Tidyverse, v) Wickham e Grolemund [-@wickham2017] R for Data Science: Import, Tidy, Transform, Visualize, and Model Data, vi) Zumel e Mount [-@zumel_practical_2014] Practical Data Science with R Paperback.

## Exerc√≠cios

1.  Reescreva as opera√ß√µes abaixo utilizando pipes `%>%`.

-   `log10(cumsum(1:100))`
-   `sum(sqrt(abs(rnorm(100))))`
-   `sum(sort(sample(1:10, 10000, rep = TRUE)))`

2.  Use a fun√ß√£o `download.file()` e `unzip()` para baixar e extrair o arquivo do data paper de m√©dios e grandes mam√≠feros: [ATLANTIC MAMMALS](https://doi.org/10.1002/ecy.2785). Em seguinda, importe para o R, usando a fun√ß√£o `readr::read_csv()`.

3.  Use a fun√ß√£o `tibble::glimpse()` para ter uma no√ß√£o geral dos dados importados no item anterior.

4.  Compare os dados de penguins (*palmerpenguins::penguins_raw* e *palmerpenguins::penguins*). Monte uma s√©rie de fun√ß√µes dos pacotes *tidyr* e `dplyr` para limpar os dados e fazer com que o primeiro dado seja igual ao segundo.

5.  Usando os dados de penguins (*palmerpenguins::penguins*), calcule a correla√ß√£o de Pearson entre comprimento e profundidade do bico para cada esp√©cie e para todas as esp√©cies. Compare os √≠ndices de correla√ß√£o para exemplificar o Paradoxo de Simpsom.

6.  Oficialmente a pandemia de COVID-19 come√ßou no Brasil com o primeiro caso no dia 26 de fevereiro de 2020. Calcule quantos anos, meses e dias se passou desde ent√£o. Calcule tamb√©m quanto tempo se passou at√© voc√™ ser vacinado.
