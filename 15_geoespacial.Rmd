# Dados geoespaciais {#cap15}

## Pr√©-requisitos do cap√≠tulo {-}

Pacotes e dados que ser√£o utilizados nesse cap√≠tulo.

```{r}
## Pacotes
library(ecodados)
library(here)
library(tidyverse)
library(sf) 
library(raster) 
library(rgdal) 
library(spData)
library(rnaturalearth)
library(geobr)
library(ggplot2)
library(ggspatial)
library(tmap)
library(tmaptools)
library(grid)
library(mapview)
library(leaflet)
library(viridis)
library(knitr)
library(sidrar)
library(landscapetools)

## Dados
# world <- world
# volcano <- volcano
# geo_anfibios_locais <- ecodados::geo_anfibios_locais
# geo_anfibios_especies <- ecodados::geo_anfibios_especies
# geo_vetor_nascentes <- ecodados::geo_vetor_nascentes
# geo_vetor_hidrografia <- ecodados::geo_vetor_hidrografia
# geo_vetor_cobertura <- ecodados::geo_vetor_cobertura
# geo_vetor_rio_claro <- ecodados::geo_vetor_rio_claro
# geo_vetor_brasil <- ecodados::geo_vetor_brasil
# geo_vetor_brasil_anos <- ecodados::geo_vetor_brasil_anos
# geo_vetor_am_sul <- ecodados::geo_vetor_am_sul
# geo_vetor_biomas <- ecodados::geo_vetor_biomas
# geo_vetor_mata_atlantica <- ecodados::geo_vetor_mata_atlantica
# geo_raster_srtm <- ecodados::geo_raster_srtm
# geo_raster_bioclim <- ecodados::geo_raster_bioclim
# geo_raster_globcover_mata_atlantica <- ecodados::geo_raster_globcover_mata_atlantica
```

## Contextualiza√ß√£o

Nesta se√ß√£o, vamos fazer uma breve introdu√ß√£o aos principais conceitos sobre a manipula√ß√£o e visualiza√ß√£o de dados geoespaciais no R. Iremos abordar temas de forma te√≥rica e pr√°tica, utilizando a linguagem R, focando em: i) formatos de dados vetoriais e dados raster, ii) Sistemas de Refer√™ncias de Coordenadas e unidades (geogr√°ficas e projetadas), iii) fontes de dados, iv) importar e exportar dados, v) descri√ß√£o de objetos geoespaciais e vi) principais opera√ß√µes (atributos, espaciais e geom√©tricas). Num segundo momento, criaremos mapas com seus principais elementos como mapas principal e secund√°rio, t√≠tulo, legenda, barra de escala, indicador de orienta√ß√£o (Norte), gride de coordenadas, descri√ß√£o do Sistema de Refer√™ncia de Coordenadas e informa√ß√µes de origem dos dados. Por fim, apresentaremos exemplos de aplica√ß√µes de an√°lises geoespaciais para dados ecol√≥gicos, focadas em: i) agregar informa√ß√µes sobre a biodiversidade, ii) preparar dados para compor vari√°veis preditoras, e iii) como fazer predi√ß√µes espaciais de distribui√ß√£o de uma esp√©cie e riqueza de esp√©cies.

Esse cap√≠tulo segue parte da estrutura organizada por Lovelace et al. [-@lovelace2019], principalmente os Cap√≠tulos 2 a 8, sendo adaptado para atender aos principais requisitos que julgamos necess√°rios a estudos ecol√≥gicos. Entretanto, n√£o foi poss√≠vel cobrir todos os assuntos sobre o uso de dados geoespaciais no R, sendo um tema muito extenso que requer a leitura de livros especializados na √°rea como: i) Mas et al. [-@mas2019] [An√°lise espacial com R](https://bit.ly/2KpSI7C), ii) Wegmann, Leutner & Dech [-@wegmann2016] *Remote Sensing and GIS for Ecologists: Using Open Source Software*, iii) Wegmann, Schwalb-Willmann & Dech [-@wegmann2020] *An Introduction to Spatial Data Analysis Remote Sensing and GIS with Open Source Software*, e iv) Fletcher & Fortin [-@fletcher2018] *Spatial ecology and conservation modeling: Applications with R*. Outros livros sobre a an√°lise geoespacial no R podem ser consultados no Cap√≠tulo [11 - Geospatial](https://www.bigbookofr.com/geospatial.html) do [Big Book of R](https://www.bigbookofr.com/index.html).

## Vetor

Dados vetoriais s√£o usados para mapear fen√¥menos ou objetos espacialmente expl√≠citos que possuem localiza√ß√£o ou dimens√µes bem definidas, representado a partir de formas geom√©tricas (como pontos, linhas e pol√≠gonos) e possuem a possibilidade de ter associado a eles informa√ß√µes tabulares. A tabela de atributos √© uma tabela que inclui dados geoespaciais e dados alfanum√©ricos. Os dados geoespaciais s√£o representados por fei√ß√µes geolocalizada espacialmente (ponto, linha ou pol√≠gono), e os dados alfanum√©ricos (tabela de dados). Dessa forma, a tabela de atributos re√∫ne informa√ß√µes sobre cada fei√ß√£o e pode ser utilizada para realizar de filtros ou agrega√ß√µes dos dados de cada fei√ß√£o (Figura \@ref(fig:fig-vetor-tipos).

```{r fig-vetor-tipos, echo=FALSE, fig.cap="Representa√ß√£o das geometrias de ponto, linha e pol√≠gono e atributos. Adaptado de Olaya [-@olaya2020])."}
knitr::include_graphics("img/cap15_fig01.png")
```

### sf: principal pacote no R para dados vetoriais

Atualmente o principal pacote para trabalhar com dados vetoriais no R √© o [`sf`](https://r-spatial.github.io/sf/), que implementou o *Simple Feature* [@sf2018]. Entretanto, outro pacote pode ser t√£o vers√°til quanto o `sf`, no caso o [`terra`](https://rspatial.org/terra/index.html), com algumas mudan√ßas na sintaxe que n√£o abordaremos nesse livro por quest√µes de redu√ß√£o de espa√ßo.

Os tipos de geometrias apresentadas s√£o representados por diferentes classes: `POINT`, `LINESTRING` e `POLYGON` para apenas uma fei√ß√£o de cada tipo de geometria; `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON` para v√°rias fei√ß√µes de cada tipo de geometria e; `GEOMETRYCOLLECTION` para v√°rias fei√ß√µes e tipos de geometrias e classes.

Ao olharmos as informa√ß√µes de um objeto da classe `sf`, podemos notar diversas informa√ß√µes que descrevem o mesmo, numa esp√©cie de cabe√ßalho:

-   **resumo do vetor**: indica o n√∫mero de fei√ß√µes (linhas) e campos (colunas)
-   **tipo da geometria**: umas das sete classes (ou mais outras) listadas anteriormente
-   **dimens√£o**: n√∫mero de dimens√µes, geralmente duas (XY)
-   **bbox (bordas)**: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   **informa√ß√£o do CRS**: `epsg` ou `proj4string` indicando o CRS (*Coordinate Reference System*)
-   **tibble**: tabela de atributos, com destaque para a coluna `geom` ou `geometry` que representa cada fei√ß√£o ou geometria

```{r}
## Dados vetoriais de pol√≠gonos do mundo
data(world)
world
```

Podemos fazer um mapa simples utilizando a fun√ß√£o `plot()` desse objeto. Para facilitar, escolheremos apenas a primeira coluna `[1]` (Figura \@ref(fig:fig-vetor-mundo)). Caso n√£o escolhermos apenas uma coluna, um mapa para cada coluna ser√° plotado.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Faremos mapas mais elaborados na se√ß√£o de visualiza√ß√£o de dados geoespaciais deste cap√≠tulo.
:::

```{r fig-vetor-mundo, fig.cap="Mapa vetorial do mundo."}
## Plot dos pol√≠gonos do mundo
plot(world[1], col = viridis::viridis(100), main = "Mapa do mundo")
```

## Raster

Os dados no formato raster consistem em uma matriz (com linhas e colunas) em que os elementos representam c√©lulas, geralmente igualmente espa√ßadas (pixels; Figura \@ref(fig:fig-raster). As c√©lulas dos dados raster possuem duas informa√ß√µes: i) identifica√ß√£o das c√©lulas (IDs das c√©lulas) para especificar sua posi√ß√£o na matriz (Figura \@ref(fig:fig-raster) A) e; ii) valores das c√©lulas (Figura \@ref(fig:fig-raster) B), que geralmente s√£o coloridos para facilitar a interpreta√ß√£o da varia√ß√£o dos valores no espa√ßo (Figura \@ref(fig:fig-raster) C). Al√©m disso, valores ausentes ou n√£o amostrados s√£o representados por `NA`, ou seja, *not available* (Figura \@ref(fig:fig-raster) B e C).

```{r fig-raster, echo=FALSE, fig.cap="Raster: (A) IDs das c√©lulas, (B) valores das c√©lulas, (C) c√©lulas coloridas. Adaptado de Lovelace et al. [-@lovelace2019])."}
library(gridExtra)

# Dados
set.seed(42)
small_ras <- raster(matrix(1:16, 4, 4, byrow = TRUE))
small_ras_val <- raster(matrix(sample.int(100, 16), 4, 4, byrow = TRUE))
small_ras_val[c(10, 15)] <- NA
polys <- rasterToPolygons(small_ras, na.rm = FALSE)

# ids das c√©lulas
p_1 <- spplot(small_ras, colorkey = FALSE, col.regions = "white",
              main = "A. IDs das c√©lulas",
              sp.layout = list(
                  list("sp.polygons", polys, first = FALSE),
                  list("sp.text", xyFromCell(small_ras_val, 1:ncell(small_ras)),
                       1:ncell(small_ras))
              )
)

# valor das c√©lulas
p_2 <- spplot(small_ras_val, colorkey = FALSE, col.regions = "white",
              main = "B. Valores das c√©luas",
              sp.layout = list(
                  list("sp.polygons", polys, first = FALSE),
                  list("sp.text", xyFromCell(small_ras_val,
                                             1:ncell(small_ras_val)),
                       values(small_ras_val))
              )
)

# mapa colorido
p_3 <- spplot(small_ras_val, 
              col.regions = viridis::viridis(16),
              colorkey = FALSE,
              main = "C. Valores coloridos")

grid.arrange(p_1, p_2, p_3, ncol = 3)
```

Pode ainda fazer uma compara√ß√£o com as representa√ß√µes de dados vetoriais vistos na Figura \@ref(fig:fig-vetor-tipos), mas agora no formato raster (Figura \@ref(fig:fig-raster-tipos).

```{r fig-raster-tipos, echo=FALSE, fig.cap="Representa√ß√£o das geometrias de ponto, linha e pol√≠gono no formato raster. Adaptado de Olaya [-@olaya2020])."}
knitr::include_graphics("img/cap15_fig02.png")
```

### raster: principal pacote no R para dados raster

Atualmente, o principal pacote para trabalhar com dados raster √© o [*raster*](https://rspatial.org/raster/index.html), apesar de existir outros dois: [*terra*](https://rspatial.org/terra/index.html) e [*stars*](https://r-spatial.github.io/stars/), com algumas mudan√ßas na sintaxe que n√£o abordaremos neste livro.

O pacote `raster` fornece uma ampla gama de fun√ß√µes para criar, importar, exportar, manipular e processar dados raster no R. O objeto raster criado √† partir do pacote `raster` pode assumir tr√™s classes: `RasterLayer`, `RasterStack` e `RasterBrick`.

A classe `RasterLayer` representa apenas uma camada raster. Para criar ou importar um raster no R podemos utilizar a fun√ß√£o `raster::raster()`. Observando essa classe, podemos notar as seguintes informa√ß√µes:

-   **class**: classe raster do objeto raster
-   **dimensions**: n√∫mero de linhas, colunas e c√©lulas
-   **resolution**: largura e altura da c√©lula
-   **extent**: coordenadas m√≠nimas e m√°ximas da longitude e latitude
-   **crs**: Sistema de Refer√™ncia de Coordenadas (*CRS*)
-   **source**: fonte dos dados (mem√≥ria ou disco)
-   **names**: nome das camadas
-   **values**: valores m√°ximos e m√≠nimos das c√©lulas

Vamos utilizar os dados `volcano`, que possui informa√ß√µes topogr√°ficas (eleva√ß√£o) do vulc√£o Maunga Whau de Auckland na Nova Zel√¢ndia.

```{r}
## Dados de altitude de um vulc√£o
volcano[1:5, 1:5]
```

Vamos transformar essa matriz de dados em um raster com a fun√ß√£o `raster::raster()`.

```{r}
## Rasterlayer
raster_layer <- raster::raster(volcano)
raster_layer
```

Um mapa simples do objeto raster pode ser obtido utilizando a fun√ß√£o `plot()`, do pr√≥prio pacote `raster` (Figura \@ref(fig:fig-raster-layer)).

```{r fig-raster-layer, fig.cap="Mapa simples de um `RasterLayer`."}
## Plot raster layers
plot(raster_layer, col = viridis::viridis(n = 100))
```

Al√©m da classe `RasterLayer`, h√° mais duas classes que trabalham com m√∫ltiplas camadas: `RasterBrick` e `RasterStack`. Elas diferem em rela√ß√£o ao n√∫mero de formatos de arquivo suportados, tipo de representa√ß√£o interna e velocidade de processamento.

A classe `RasterBrick` geralmente corresponde √† importa√ß√£o de um √∫nico arquivo de imagem de sat√©lite multiespectral (multicamadas) ou a um √∫nico objeto com v√°rias camadas na mem√≥ria. A fun√ß√£o `raster::brick()` cria um objeto `RasterBrick`.

```{r}
## Raster layers
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

## Raster brick
raster_brick <- raster::brick(raster_layer1, raster_layer2, 
                              raster_layer3, raster_layer4)
raster_brick
```

Ao utilizarmos a fun√ß√£o `plot()` do pacote `raster`, podemos visualizar os raster contidos no objeto `RasterBrick` (Figura \@ref(fig:fig-raster-brick)).

```{r fig-raster-brick, fig.cap="Mapas simples de um raster `RasterBrick`."}
## Plot raster brick
plot(raster_brick, col = viridis::viridis(n = 25), main = "")
```

J√° a classe `RasterStack` permite conectar v√°rios objetos raster armazenados em arquivos diferentes ou v√°rios objetos no ambiente do R. Um `RasterStack` √© uma lista de objetos `RasterLayer` com a mesma extens√£o, resolu√ß√£o e CRS. Uma maneira de cri√°-lo √© com a jun√ß√£o de v√°rios objetos geoespaciais j√° existentes no ambiente do R ou listar v√°rios arquivos raster em um diret√≥rio armazenado no disco. A fun√ß√£o `raster::stack()` cria um objeto `RasterStack`.

Outra diferen√ßa √© que o tempo de processamento, para objetos `RasterBrick` geralmente √© menor do que para objetos `RasterStack`. A decis√£o sobre qual classe `Raster` deve ser usada depende principalmente do car√°ter dos dados de entrada.

```{r}
## Raster layers
raster_layer1 <- raster_layer
raster_layer2 <- raster_layer * raster_layer
raster_layer3 <- sqrt(raster_layer)
raster_layer4 <- log10(raster_layer)

## Raster stack
raster_stack <- raster::stack(raster_layer1, raster_layer2, 
                              raster_layer3, raster_layer4)
raster_stack
```

Da mesma forma, ao utilizar a fun√ß√£o `plot()` do pacote `raster`, podemos visualizar os raster contidos no objeto `RasterStack` (Figura \@ref(fig:fig-raster-stack)).

```{r fig-raster-stack, fig.cap="Mapas simples de um raster `RasterStack`."}
## Plot raster stack
plot(raster_stack, col = viridis::viridis(n = 25), main = "")
```

## Sistema de Refer√™ncia de Coordenadas e Unidades

Os dados geoespaciais (vetor e raster) possuem ainda um outro componente fundamental que √© o Sistema de Refer√™ncia de Coordenadas, ou do ingl√™s *Coordinate Reference System (CRS)*. Esse componente define a refer√™ncia espacial dos elementos geoespaciais (vetor e raster) na superf√≠cie da Terra. Esse componente √© composto por dois principais conceitos: primeiro, que tipo de unidades est√£o sendo utilizadas para a representa√ß√£o geogr√°fica, podendo assumir dois tipos - √¢ngulos ou metros, que definem o Sistema de Coordenadas Geogr√°ficas e o Sistema de Coordenadas Projetadas, respectivamente. O segundo componente √© o datum, que √© a rela√ß√£o do sistema de coordenadas (geogr√°fica ou projetada) com a superf√≠cie da Terra. Esse √∫ltimo componente faz parte de uma √°rea da Cartografia denominada Geod√©sia que estuda a forma e dimens√µes da Terra, campo gravitacional e a localiza√ß√£o de pontos fixos e sistemas de coordenadas. O livro de Lapaine & Usery [-@lapaine2017] √© um excelente material para se aprofundar nesse assunto.

### Sistema de Coordenadas Geogr√°ficas

O Sistema de Coordenadas Geogr√°ficas utiliza √¢ngulos (graus) para representar fei√ß√µes na superf√≠cie da Terra atrav√©s de dois valores: longitude e latitude. A longitude representa o eixo Leste-Oeste e a latitudeo eixo Norte-Sul. Nesse sistema, a superf√≠cie da Terra √© representada geralmente por uma superf√≠cie elipsoidal, pois a Terra √© ligeiramente achatada nos polos devido ao seu movimento no entorno do seu eixo.

### Sistema de Coordenadas Projetadas

O Sistema de Coordenadas Projetadas utiliza um Sistema Cartesiano de Coordenadas em uma superf√≠cie plana. Dessa forma, a partir de uma origem tra√ßam-se eixos X e Y e uma unidade linear √© utilizada, como o metro. Todos as proje√ß√µes feitas de sistemas geoespaciais convertem uma superf√≠cie tridimensional em uma superf√≠cie plana bidimensional. Sendo assim, essa convers√£o traz consigo algum tipo de distor√ß√£o em rela√ß√£o √† por√ß√£o real, podendo ser distor√ß√µes em: i) formas locais, ii) √°reas, iii) dist√¢ncias, iv) flex√£o ou curvatura, v) assimetria ou vi) lacunas de continuidade. Dessa forma, um sistema de coordenadas projetadas pode preservar somente uma ou duas dessas propriedades.

Existem tr√™s grandes grupos de proje√ß√µes: i) cil√≠ndricos, ii) c√¥nicos e iii) planares. Na proje√ß√£o cil√≠ndrica, a superf√≠cie da Terra √© mapeada em um cilindro, criada tocando a superf√≠cie da Terra ao longo de uma ou duas linhas de tang√™ncia, sendo utilizada com mais frequ√™ncia para mapear todo o globo tendo como exemplo mais conhecido a Proje√ß√£o Universal Transversa de Mercator (UTM). Na proje√ß√£o c√¥nica, a superf√≠cie da Terra √© projetada em um cone ao longo de uma linha ou duas linhas de tang√™ncia, de modo que as distor√ß√µes s√£o minimizadas ao longo das linhas e aumentam com a dist√¢ncia das mesmas, sendo portanto, mais adequada para mapear √°reas de latitudes m√©dias, tendo como exemplo mais conhecido a Proje√ß√£o C√¥nica Equivalente de Albers e a Proje√ß√£o C√¥nica Conforme de Lambert. E na proje√ß√£o plana, tamb√©m denominada Proje√ß√£o Azimutal, o mapeamento toca o globo em um ponto ou ao longo de uma linha de tang√™ncia, sendo normalmente utilizado no mapeamento de regi√µes polares, sendo a mais comum a Proje√ß√£o Azimutal Equidistante, a mesma utilizada na bandeira da ONU.

### Datum

Como dito anteriormente, o datum √© a rela√ß√£o do sistema de coordenadas com a superf√≠cie da Terra. Ele representa o ponto de intersec√ß√£o do elipsoide de refer√™ncia com a superf√≠cie da Terra (geoide, a forma verdadeira da Terra), compensando as diferen√ßas do campo gravitacional da Terra. Existem dois tipos de datum: i) local e ii) geoc√™ntrico. Em um datum local, como o SAD69 - *South American Datum 1969*, o elipsoide de refer√™ncia √© deslocado para se alinhar com a superf√≠cie em um determinado local, por exemplo, na Am√©rica do Sul. J√° em um datum geoc√™ntrico, como WGS84 - *World Geodetic System 1984*, o centro do elipsoide √© o centro de gravidade da Terra e a precis√£o das proje√ß√µes n√£o √© otimizada para um local espec√≠fico do globo.

No Brasil, desde 2015, o [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)](https://www.ibge.gov.br/) ajudou a desenvolver e reafirmou o uso do datum SIRGAS2000 - *Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000* para todos os mapeamentos realizados no Brasil, um esfor√ßo conjunto para adotar o mesmo datum em toda a Am√©rica. Mais sobre esse datum pode ser lido aqui: [SIRGAS2000](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/).

### Sistema de Refer√™ncia de Coordenadas (CRS) no R

No R, h√° duas formas principais de representar um Sistema de Refer√™ncia de Coordenadas: i) c√≥digo `epsg` e ii) `proj4string`. O c√≥digo EPSG (*European Petroleum Survey Group*) √© uma sequ√™ncia de n√∫meros curta, referindo-se apenas a um CRS. O site [epsg.io](http://epsg.io/) permite consultar diversas informa√ß√µes sobre um c√≥digo, como procurar por um c√≥digo, representa√ß√£o de mapas e fazer transforma√ß√µes de CRS.

J√° o `proj4string` permite mais flexibilidade para especificar diferentes par√¢metros, como o tipo de proje√ß√£o, datum e elipsoide. Dessa forma, √© poss√≠vel especificar muitas proje√ß√µes, ou mesmo modificar as proje√ß√µes existentes, tornando a representa√ß√£o `proj4string` mais complexa e flex√≠vel.

Al√©m disso, ainda √© poss√≠vel consultar uma extensa lista de CRSs no site [spatialreference.org](https://spatialreference.org/), que fornece descri√ß√µes em diversos formatos, baseados em GDAL e Proj.4. Essa abordagem permite consultar uma URL que pode produzir uma refer√™ncia espacial em um formato que seu software SIG ou o R pode utilizar como refer√™ncia.

Os pacotes (geo)espaciais no R suportam uma ampla variedade de CRSs e usam a biblioteca [PROJ](https://proj.org/index.html#). A fun√ß√£o `rgdal::make_EPSG()` retorna um `data frame` das proje√ß√µes dispon√≠veis, com informa√ß√µes dos c√≥digos `epsg` e `proj4string` numa mesma tabela, facilitando a busca e uso de CRSs (Tabela \@ref(tab:tab-epsg)).

```{r eval=FALSE}
## Listagem dos Sistemas de Refer√™ncias de Coordenadas no R
crs_data <- rgdal::make_EPSG()
head(crs_data)
```

```{r tab-epsg, echo=FALSE}
knitr::kable(
    head(rgdal::make_EPSG()),
    caption = "Listagem de Sistemas de Refer√™ncias de Coordenadas dispon√≠veis no R, com informa√ß√µes dos c√≥digos `epsg` e `proj4string`"
)
```

## Principais fontes de dados geoespaciais

Existem diversas fontes de dados geoespaciais em diferentes bases de dados dispon√≠veis gratuitamente. Geralmente essas bases de dados s√£o disponibilizadas separadamente em apenas dados vetoriais e dados raster. Para dados vetoriais, grande parte dos dados disponibilizados s√£o utilizados em mapas como limites pol√≠ticos, limites de biomas ou distribui√ß√£o de esp√©cies para pol√≠gonos; estradas e rios para dados lineares, ou ainda pontos de ocorr√™ncia de esp√©cies ou comunidades, ou medidas tomadas em campo sobre condi√ß√µes naturais como clima ou relevo, como pontos. Entretanto, √© sempre recomendado o uso de bases oficiais, principalmente em rela√ß√£o a dados vetoriais de limites pol√≠ticos. Para tanto, √© fundamental buscar as bases oficiais de cada pa√≠s, entretanto, h√° bases que podem ser utilizadas globalmente, como veremos.

Sobre as bases de dados raster, h√° uma infinidade de dados para diferentes objetivos, mas grande parte deles s√£o relativos a condi√ß√µes ambientais, representando uma vari√°vel de interesse de forma cont√≠nua no espa√ßo, como temperatura, precipita√ß√£o, eleva√ß√£o, etc.

H√° uma compila√ß√£o de dados geoespaciais vetoriais e raster feita por Marcus Vin√≠cius Alves de Carvalho e Angelica Carvalho Di Maio, chamada [GeoLISTA](http://www.clickgeo.com.br/wp-content/uploads/2018/05/GeoLISTA.pdf). Entretanto, como as bases de dados tendem a ser muito din√¢micas, √© poss√≠vel que muitas bases tenham surgido e desaparecido desde a listagem realizada.

Al√©m das bases de dados, h√° pacotes espec√≠ficos no R que fazem o download de dados vetoriais e rasters, facilitando a aquisi√ß√£o e reprodutibilidade. Para conferir uma listagem completa de pacotes para diversas an√°lises espaciais, veja [CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html).

### Vetor

Dentre as bases vetoriais, destacamos as seguintes na Tabela \@ref(tab:tab-vetor-bases).

```{r tab-vetor-bases, echo=FALSE}
knitr::kable(
    tibble(
        `Bases de dados` = c("[IBGE](https://www.ibge.gov.br/geociencias/downloads-geociencias.html)",
                             "[FBDS](http://geo.fbds.org.br/)",
                             "[GeoBank](http://geosgb.cprm.gov.br/)",
                             "[Pastagem.org](http://maps.lapig.iesa.ufg.br)",
                             "[CanaSat](http://www.dsr.inpe.br/laf/canasat/)",
                             "[CSR Maps](http://maps.csr.ufmg.br)",
                             "[Ecoregions](https://ecoregions2017.appspot.com/)",
                             "[UN Biodiversity Lab](https://www.unbiodiversitylab.org/)",
                             "[Biodiversity Hotspots](https://zenodo.org/record/3261807#.YA8lpPv0nOY)",
                             "[IUCN Red List of Threatened Species](https://www.iucnredlist.org/resources/spatial-data-download)",
                             "[Map of Life (MOL)](https://mol.org/)",
                             "[Key Biodiversity Areas](http://www.keybiodiversityareas.org/kba-data/request)",
                             "[HydroSHEDS](https://www.hydrosheds.org/)",
                             "[Global Roads Inventory Project (GRIP)](https://www.globio.info/download-grip-dataset)",
                             "[Database of Global Administrative Areas (GADM)](https://gadm.org/)",
                             "[Natural Earth](https://www.naturaleatoriorthdata.com/)",
                             "[Protected Planet](https://www.protectedplanet.net)", 
                             "[Global Biological Information Facility (GBIF)](http://www.gbif.org)",
                             "[Species Link](http://www.splink.cria.org.br)",
                             "[Global Invasive Species Information Network (GISIN)](http://www.gisin.org)"),
        Descri√ß√£o = c("Limites territoriais e censit√°rios do Brasil", 
                      "Uso da terra, APP e hidrografia - Mata Atl√¢ntica e Cerrado",
                      "Dados geol√≥gicos do Brasil",
                      "Dados de pastagens e gado para o Brasil",
                      "Dados de cana-de-a√ß√∫car para o Brasil",
                      "Diversos dados vetoriais e raster para o Brasil",
                      "Dados de biorregi√µes e geo_vetor_biomas do mundo",
                      "Diversas bases de dados para o mundo",
                      "Dados dos limites dos Hotspots de Biodiversidade",
                      "Dados dos limites das distribui√ß√µes das esp√©cies para o mundo",
                      "Dados da distribui√ß√£o de esp√©cies e outros dados para o mundo",
                      "Dados dos limites das Key Biodiversity Areas",
                      "Informa√ß√µes hidrol√≥gicas do mundo",
                      "Dados de estradas do mundo todo",
                      "Limites de √°reas administrativas do mundo",
                      "Diversos limites para o mundo",
                      "Limites de √°reas protegidas para o mundo",
                      "Dados de ocorr√™ncias de esp√©cies para o mundo",
                      "Dados de ocorr√™ncias de esp√©cies para o Brasil",
                      "Dados de ocorr√™ncias de esp√©cies invasoras para o Mundo")),
    caption = "Principais bases de dados vetoriais para o Brasil e o Mundo.",
    booktabs = TRUE
)
```

### Raster

Dentre as bases raster, destacamos as seguintes na Tabela \@ref(tab:tab-raster-bases).

```{r tab-raster-bases, echo=FALSE}
knitr::kable(tibble(
    `Bases de dados` = c("[Mapgeo_vetor_biomas](https://mapgeo_vetor_biomas.org/)",
                         "[Bahlu](ftp://madeira.dea.ufv.br/bdados/bhalu/)",
                         "[USGS](https://www.usgs.gov/)",
                         "[SRTM](http://srtm.csi.cgiar.org/)",
                         "[Geoservice Maps](https://geoservice.dlr.de/web/maps)",
                         "[Global Forest Watch](https://www.globalforestwatch.org/)",
                         "[GlobCover](http://due.esrin.esa.int/page_globcover.php)",
                         "[Landcover](https://www.earthenv.org/landcover)",
                         "[Global Human Footprint](https://wcshumanfootprint.org/)",
                         "[GHSL - Global Human Settlement Layer](https://ghsl.jrc.ec.europa.eu/download.php)",
                         "[Land-Use Harmonization (LUH2)](https://luh.umd.edu/)",
                         "[ESA Climate Change Initiative](https://climate.esa.int/en/odp/#/dashboard)",
                         "[WorldClim](https://www.worldclim.org/)",
                         "[CHELSA](https://chelsa-climate.org/)",
                         "[EarthEnv](https://www.earthenv.org/)",
                         "[SoilGrids](https://soilgrids.org/)",
                         "[Global Wetlands](https://www2.cifor.org/global-wetlands/)",
                         "[Global Surface Water Explorer](https://global-surface-water.appspot.com/#)",
                         "[MARSPEC](http://www.marspec.org/)",
                         "[Bio-ORACLE](http://www.oracle.ugent.be/)"), 
    Descri√ß√£o = c("Uso e cobertura da terra para o Brasil, Panamazonia Legal e Chaco, de 1985 a 2019", 
                  "Distribui√ß√µes hist√≥ricas de terras agr√≠colas e pastagens para todo o Brasil de 1940 a 2012", 
                  "Dados de diversos sat√©lites livres para o mundo",
                  "Dados de eleva√ß√£o para o mundo",
                  "Dados de eleva√ß√£o e florestas para o mundo",
                  "Dados de florestas para o mundo",
                  "Dados de uso e cobertura da terra para todo o planeta",
                  "Dados de uso e cobertura da terra para todo o planeta",
                  "Dados de pegada ecol√≥gica para o mundo",
                  "Dados e ferramentas abertos e gratuitos para avaliar a presen√ßa humana no planeta",
                  "Dados atuais e previs√µes de uso da terra",
                  "Arquivos globais de observa√ß√£o da Terra nos √∫ltimos 30 anos da Ag√™ncia Espacial Europeia (ESA)",
                  "Dados clim√°ticos para o mundo",
                  "Dados clim√°ticos para o mundo",
                  "Dados de cobertura da terra, nuvens, relevo e hidrografia",
                  "Dados de solo para o mundo",
                  "Dados de √°reas √∫midas para o mundo",
                  "Dados de √°guas superficiais para o mundo",
                  "Dados de condi√ß√µes do oceano para o mundo",
                  "Dados de condi√ß√µes do oceano para o mundo")), 
    caption = "Principais bases de dados raster para o Brasil e o Mundo.",
    booktabs = TRUE
)
```

### Pacotes do R

Dentre os pacotes no R para download de dados geoespaciais, destacamos os seguintes na Tabela \@ref(tab:tab-packages-bases).

```{r tab-packages-bases, echo=FALSE}
knitr::kable(
    tibble(
        Pacotes = c("[geobr](https://cran.r-project.org/web/packages/geobr/index.html)",
                    "[rnaturalearth](https://cran.r-project.org/web/packages/rnaturalearth/index.html)",
                    "[rworldmap](https://cran.r-project.org/web/packages/rworldmap/index.html)",
                    "[spData](https://cran.r-project.org/web/packages/spData/index.html)",
                    "[OpenStreetMap](https://cran.r-project.org/web/packages/OpenStreetMap/index.html)",
                    "[osmdata](https://cran.r-project.org/web/packages/osmdata/index.html)",
                    "[geonames](https://cran.r-project.org/web/packages/geonames/index.html)",
                    "[rgbif](https://cran.r-project.org/web/packages/rgbif/index.html)",
                    "[maptools](https://cran.r-project.org/web/packages/maptools/index.html)",
                    "[marmap](https://cran.r-project.org/web/packages/marmap/index.html)",
                    "[oce](https://cran.r-project.org/web/packages/oce/index.html)",
                    "[envirem](https://cran.r-project.org/web/packages/envirem/index.html)",
                    "[sdmpredictors](https://cran.r-project.org/web/packages/sdmpredictors/index.html)",
                    "[metScanR](https://cran.r-project.org/web/packages/metScanR/index.html)",
                    "[ClimDown](https://cran.r-project.org/web/packages/ClimDown/index.html)",
                    "[rWBclimate](https://cran.r-project.org/web/packages/rWBclimate/index.html)",
                    "[rnoaa](https://cran.r-project.org/web/packages/rnoaa/index.html)",
                    "[RNCEP](https://cran.r-project.org/web/packages/RNCEP/index.html)",
                    "[smapr](https://cran.r-project.org/web/packages/smapr/index.html)"), 
        Descri√ß√£o = c("Carrega Shapefiles de Conjuntos de Dados Espaciais Oficiais do Brasil", 
                      "Dados do mapa mundial da Natural Earth", 
                      "Mapeando Dados Globais",
                      "Conjuntos de dados para an√°lise espacial",
                      "Acesso para abrir imagens raster de mapas de ruas",
                      "Baixe e importe dados do OpenStreetMap",
                      "Interface para o servi√ßo da Web de consulta espacial 'Geonames'",
                      "Interface para o Global 'Biodiversity' Information Facility API",
                      "Ferramentas para lidar com objetos geoespaciais",
                      "Importar, tra√ßar e analisar dados batim√©tricos e topogr√°ficos",
                      "Fonte e processamento de dados oceanogr√°ficos",
                      "Gera√ß√£o de Vari√°veis ENVIREM",
                      "Conjuntos de dados preditor de modelagem de distribui√ß√£o de esp√©cies",
                      "Encontre, Mapeie e Colete Dados e Metadados Ambientais",
                      "Biblioteca de redu√ß√£o de escala do clima para a produ√ß√£o di√°ria do modelo clim√°tico",
                      "Acessa dados clim√°ticos do Banco Mundial",
                      "Dados meteorol√≥gicos 'NOAA' de R",
                      "Obtenha, organize e visualize dados meteorol√≥gicos NCEP",
                      "Aquisi√ß√£o e processamento de dados ativos-passivos (SMAP) de umidade do solo da NASA")),
    caption = "Principais pacotes no R para download de dados vetoriais e raster.",
    booktabs = TRUE
)
```

## Importar e exportar dados geoespaciais

Agora que sabemos o que s√£o dados geoespaciais e em quais bases de dados podemos buscar e baixar esses dados, veremos seus principais formatos e como import√°-los e export√°-los do R.

### Principais formatos de arquivos geoespaciais

H√° diversos formatos de arquivos geoespaciais, alguns espec√≠ficos para dados vetoriais e raster, e outros no formato de banco de dados geoespaciais, como [PostGIS](https://postgis.net/), que podem armazenar ambos os formatos.

Entretanto, todos os formatos para serem importados para o R usam o [GDAL (*Geospatial Data Abstraction Library*)](https://gdal.org/), uma interface unificada para leitura e escrita de diversos formatos de arquivos geoespaciais, sendo utilizado tamb√©m por uma s√©rie de softwares de GIS como QGIS, GRASS GIS e ArcGIS.

Dentre esses formatos, destacamos os seguintes na Tabela \@ref(tab:tab-formatos).

```{r tab-formatos, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Nome = c("ESRI Shapefile", "GeoJSON", "KML", "GPX", "GeoTIFF", "Arc ASCII", "NetCDF", "BIL", "R-raster", "SQLite/SpatiaLite", "ESRI FileGDB", "GeoPackage"), 
        extens√£o = c(".shp (arquivo principal)", ".geojson", ".kml", ".gpx", ".tif/.tiff", ".asc", ".nc", ".bil/.hdr", ".gri/ .grd", ".sqlite", ".gdb", ".gpkg"),
        Descri√ß√£o = c("Formato popular que consiste em pelo menos quatro arquivos: .shp (fei√ß√£o), .dbf (tabela de atributos), .shx (liga√ß√£o entre .shp e .dbf) e .prj (proje√ß√£o)", "Estende o formato de troca JSON incluindo um subconjunto da representa√ß√£o de recurso simples", "Formato baseado em XML para visualiza√ß√£o espacial, desenvolvido para uso com o Google Earth. O arquivo KML compactado forma o formato KMZ", "Esquema XML criado para troca de dados de GPS", "Formato raster popular. Um arquivo TIFF contendo metadados espaciais adicionais.", "Formato de texto em que as primeiras seis linhas representam o cabe√ßalho raster, seguido pelos valores das c√©lulas raster organizadas em linhas e colunas", "NetCDF (Network Common Data Form) √© um conjunto de bibliotecas de software e formatos de dados independentes que suportam a cria√ß√£o, acesso e compartilhamento de dados cient√≠ficos orientados a arrays", "BIL (Banda intercalada por linha) s√£o m√©todos comuns de organiza√ß√£o para imagens multibanda, geralmente acompanhados por um arquivo .hdr, descrevendo atributos espec√≠ficos da imagem", "Formato raster nativo do raster do pacote R", "Banco de dados relacional aut√¥nomo", "objetos geoespaciais e n√£o espaciais criados pelo ArcGIS. Permite: v√°rias classes de recursos; topologia", "Cont√™iner de banco de dados leve baseado em SQLite permitindo uma troca f√°cil e independente de plataforma de geodados"),
        Tipo = c("Vetor", "Vetor", "Vetor", "Vetor", "Raster", "Raster", "Raster", "Raster", "Raster", "Vetor e raster", "Vetor e raster", "Vetor e raster"),
        Modelo = c("Parcialmente aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Aberto", "Propriet√°rio", "Aberto")), 
    caption = "Principais formatos de arquivos geoespaciais. Adaptado de: Lovelace et al. [-@lovelace2019]."
)
```

O formato mais comum para arquivos vetoriais √© o [ESRI Shapefile](https://doc.arcgis.com/en/arcgis-online/reference/shapefiles.htm); para arquivos raster √© o [GeoTIFF](https://gdal.org/drivers/raster/gtiff.html); e para dados clim√°ticos em m√∫ltiplas camadas, geralmente h√° a disponibiliza√ß√£o de dados no formato [NetCDF](https://www.unidata.ucar.edu/software/netcdf/). Entretanto, recentemente tivemos o surgimento do [GeoPackage](https://www.geopackage.org/), que possui diversas vantagens em rela√ß√£o aos formatos anteriores, podendo armazenar em apenas um arquivo, dados no formato vetorial, raster e tamb√©m dados n√£o-espaciais (e.g., tabelas), al√©m de possuir uma grande integra√ß√£o com diversos softwares e bancos de dados.

### Importar dados

As principais fun√ß√µes para importar dados no R s√£o: i) para vetores a fun√ß√£o `sf::st_read()`, e ii) para raster a fun√ß√£o `raster::raster()` e suas varia√ß√µes `raster::brick()` e `raster::stack()` para m√∫ltiplas camadas. Essas fun√ß√µes atribuem objetos ao seu espa√ßo de trabalho, armazenando-os na mem√≥ria RAM dispon√≠vel em seu hardware, sendo essa a maior limita√ß√£o para trabalhar com dados geoespaciais no R. Por exemplo, se um arquivo raster possui mais de 8 Gb de tamanho, e seu computador possui exatamente 8 Gb de RAM, √© muito prov√°vel que ele n√£o seja importado ou mesmo criado como um objeto dentro do ambiente R. Existem solu√ß√µes para esses problemas, mas n√£o as abordaremos neste cap√≠tulo.

**Vetor**

Como vimos, os arquivos vetoriais s√£o disponibilizados em diversos formatos. Para sabermos se um determinado formato pode ser importado ou exportado utilizando o pacote `sf`, podemos utilizar a fun√ß√£o `sf::st_drivers()`. Uma amostra desses formatos √© apresentado na Tabela \@ref(tab:tab-vetor-formatos).

```{r eval=FALSE}
## Formatos vetoriais importados e exportados pelo pacote sf
head(sf::st_drivers())
```

```{r tab-vetor-formatos, echo=FALSE}
da <- head(st_drivers())
rownames(da) <- NULL
knitr::kable(
    da,
    caption = "Alguns formatos vetoriais importados e exportados pelo pacote `sf`."
)
```

**Importar dados vetoriais existentes**

Para importar vetores existentes para o R, utilizaremos a fun√ß√£o `sf::st_read()`. A estrutura √© semelhante para todos os formatos descritos na Tabela \@ref(tab:tab-vetor-formatos), de modo que sempre preencheremos o argumento `dsn` (*data source name*) com o nome do arquivo a ser importado. Entretanto, para banco de dados, como *GeoPackage*, pode ser necess√°rio especificar a camada que se tem interesse com um segundo argumento chamado `layer`, com o nome da camada.

Para quase todas as opera√ß√µes vetoriais nesse cap√≠tulo, usaremos os dados dispon√≠veis para o munic√≠pio de Rio Claro/SP. Primeiramente, baixaremos esses dados da [FBDS (Funda√ß√£o Brasileira para o Desenvolvimento Sustent√°vel)](https://www.fbds.org.br/), atrav√©s desse [reposit√≥rio de dados](http://geo.fbds.org.br/). Em 2013, a FBDS deu in√≠cio ao Projeto de Mapeamento em Alta Resolu√ß√£o dos Biomas Brasileiros, mapeando a cobertura da terra, hidrografia (nascentes, rios e lagos) e √Åreas de Preserva√ß√£o Permanente (APPs). O mapeamento foi conclu√≠do para os munic√≠pios dos Biomas Mata Atl√¢ntica e Cerrado, e mais recentemente para os outros biomas. Para fazer o download dos arquivos de interesse, utilizaremos o R, atrav√©s da fun√ß√£o `download.file()`.

Primeiramente, criaremos um diret√≥rio com a fun√ß√£o `create.dir()`, usando a fun√ß√£o `here::here()` para indicar o reposit√≥rio (ver o Cap√≠tulo \@ref(cap5)).

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados"))
dir.create(here::here("dados", "vetor"))
```

Em seguida, vamos fazer o download de pontos de nascentes, linhas de hidrografia e pol√≠gonos de cobertura da terra para o munic√≠pio de Rio Claro/SP.

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
for(i in c(".dbf", ".prj", ".shp", ".shx")){
    
    # Pontos de nascentes
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_NASCENTES", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_NASCENTES", i)), mode = "wb")
    
    # Linhas de hidrografia
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/HIDROGRAFIA/SP_3543907_RIOS_SIMPLES", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_RIOS_SIMPLES", i)), mode = "wb")
    
    # Pol√≠gonos de cobertura da terra
    download.file(
        url = paste0("http://geo.fbds.org.br/SP/RIO_CLARO/USO/SP_3543907_USO", i),
        destfile = here::here("dados", "vetor", paste0("SP_3543907_USO", i)), mode = "wb")
}
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_nascentes
ecodados::geo_vetor_hidrografia
ecodados::geo_vetor_cobertura
```

Agora podemos importar esses dados para o R. Primeiro vamos importar as nascentes (Figura \@ref(fig:fig-vetor-nascentes)).

```{r}
## Importar nascentes
geo_vetor_nascentes <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_NASCENTES.shp"), quiet = TRUE)
```

```{r fig-vetor-nascentes, fig.cap="Mapa de nascentes de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes[1], pch = 20, col = "blue", main = NA, 
     axes = TRUE, graticule = TRUE)
```

Agora vamos importar a hidrografia (Figura \@ref(fig:fig-vetor-hidrografia)).

```{r}
## Importar hidrografia
geo_vetor_hidrografia <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_RIOS_SIMPLES.shp"), quiet = TRUE)
```

```{r fig-vetor-hidrografia, fig.cap="Mapa da hidrografia de Rio Claro/SP."}
## Plot
plot(geo_vetor_hidrografia[1], col = "steelblue", main = NA, axes = TRUE, graticule = TRUE)
```

E por fim, vamos importar a cobertura da terra (Figura \@ref(fig:fig-vetor-cobertura)).

```{r}
## Importar cobertura da terra
geo_vetor_cobertura <- sf::st_read(
    here::here("dados", "vetor", "SP_3543907_USO.shp"), quiet = TRUE)
```

```{r fig-vetor-cobertura, fig.cap="Mapa de cobertura da terra de Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura[5], 
     col = c("blue", "orange", "gray30", "forestgreen", "green"), 
     main = NA, axes = TRUE, graticule = TRUE)
legend(x = .1, y = .3, pch = 15, cex = .7, pt.cex = 2.5, 
       legend = (geo_vetor_cobertura$CLASSE_USO), 
       col = c("blue", "orange", "gray30", "forestgreen", "green"))
```

**Importar utilizando pacotes**

Al√©m de dados existentes, podemos importar dados vetoriais de pacotes, como listado anteriormente na Tabela \@ref(tab:tab-packages-bases). Para o Brasil, o pacote mais interessante trata-se do [`geobr`](https://ipeagit.github.io/geobr/), do [Instituto de Pesquisa Econ√¥mica Aplicada (IPEA)](https://www.ipea.gov.br/portal/), que possui dados oficiais do [Instituto Brasileiro de Geografia e Estat√≠stica (IBGE)](https://www.ibge.gov.br/).

√â poss√≠vel listar todos os dados dispon√≠veis no pacote atrav√©s da fun√ß√£o `geobr::list_geobr()`. Na Tabela \@ref(tab:tab-vetor-dados-geobr) √© poss√≠vel ver alguns desses dados.

```{r eval=FALSE}
## Listar todos os dados do geobr
geobr::list_geobr()
```

```{r tab-vetor-dados-geobr, echo=FALSE}
knitr::kable(
    head(geobr::list_geobr()),
    caption = "Alguns dados dispon√≠veis no pacote `geobr`."
)
```

Como exemplo, vamos fazer o download o limite do munic√≠pio de Rio Claro/SP, utilizando o c√≥digo do munic√≠pio (3543907) (Figura \@ref(fig:fig-vetor-rio-claro)).

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para saber todos os c√≥digos dos munic√≠pios do Brasil, recomendamos a verifica√ß√£o no [site do IBGE](https://www.ibge.gov.br/explica/codigos-dos-municipios.php).
:::

```{r}
## Pol√≠gono do limite do munic√≠pio de Rio Claro
geo_vetor_rio_claro <- geobr::read_municipality(code_muni = 3543907, 
                                                year = 2020, showProgress = FALSE)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_rio_claro
```

```{r fig-vetor-rio-claro, fig.cap="Limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

J√° para o mundo, o pacote mais interessante trata-se do [`rnaturalearth`](https://docs.ropensci.org/rnaturalearth/), que faz o download de dados do [Natural Earth](https://www.naturaleatoriorthdata.com/). Vamos fazer o download do limite do Brasil (Figura \@ref(fig:fig-vetor-brasil)).

```{r}
## Pol√≠gono do limite do Brasil
geo_vetor_brasil <- rnaturalearth::ne_countries(scale = "large", 
                                                country = "Brazil", returnclass = "sf")
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_brasil
```

```{r fig-vetor-brasil, fig.cap="Limite do Brasil."}
## Plot
plot(geo_vetor_brasil[1], col = "gray", main = NA, axes = TRUE, graticule = TRUE)
```

**Criar um objeto espacial de uma tabela de coordenadas**

√â muito comum em coletas de campo ou bases de dados, ter coordenadas de locais de estudo ou de ocorr√™ncias de esp√©cies organizadas em tabelas. Essas tabelas devem possuir duas colunas: longitude e latitude, ou X e Y para dados UTM, por exemplo. Ao import√°-las para o R, o formato que assumem pode ser de uma das classes: `matrix`, `data frame` ou `tibble`, ou seja, ainda n√£o s√£o da classe vetorial `sf`. Nesta se√ß√£o iremos ver como fazer essa convers√£o.

Para tanto, vamos usar os dados de comunidades de anf√≠bios da Mata Atl√¢ntica (Atlantic Amphibians, Vancine et al. [-@vancine2018]). Faremos o download diretamente do site da fonte dos dados. Antes vamos criar um diret√≥rio.

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados", "tabelas"))
```

Em seguida, vamos fazer o download de um arquivo `.zip` e vamos extrair usando a fun√ß√£o `unzip()` nesse mesmo diret√≥rio.

```{r eval=FALSE}
## Download
download.file(url = "https://esajournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2Fecy.2392&file=ecy2392-sup-0001-DataS1.zip",
              destfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "tabelas", "atlantic_amphibians.zip"),
      exdir = here::here("dados", "tabelas"))
```

Agora podemos importar a tabela de dados com a fun√ß√£o `readr::read_csv()`.

```{r}
## Importar tabela de locais
geo_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    locale = readr::locale(encoding = "latin1")
)
geo_anfibios_locais
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_anfibios_locais
```

Por fim, podemos facilmente criar um objeto espacial do tipo `MULTIPOINT` utilizando a fun√ß√£o `sf::st_as_sf()`. Podemos ver essas coordenadas plotadas no mapa simples da Figura \@ref(fig:fig-vetor-pontos-atlantic-amphibians) [@vancine2018].

√â necess√°rio antes se ater ao argumento `coords` que deve indicar as colunas de longitude e latitude, nessa ordem; e tamb√©m ao argumento `crs` para indicar o CRS correspondente dessas coordenadas, que aqui sabemos se tratar de coordenadas geogr√°ficas e datum WGS84. Ent√£o podemos facilmente utilizar o c√≥digo EPSG 4326. Entretanto, se as coordenadas estiverem em metros, por exemplo, teremos de nos ater a qual CRS as mesmas foram coletadas, ou seja, se forem coordenadas de GPS, √© preciso saber como o GPS estava configurado (proje√ß√£o e datum).

```{r}
## Converter dados tabulares para sf
geo_anfibios_locais_vetor <- geo_anfibios_locais %>% 
    sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
geo_anfibios_locais_vetor
```

```{r fig-vetor-pontos-atlantic-amphibians, fig.cap="Coordenadas das comunidades do Atlantic Amphibians."}
## Plot
plot(geo_anfibios_locais_vetor[1], pch = 20, col = "black", 
     main = NA, axes = TRUE, graticule = TRUE)
```

**Converter dados espaciais sp para sf**

O pacote `sf` √© mais recente e mais f√°cil de manipular objetos vetoriais no R. Seu predecessor, o pacote `sp` possui uma classe pr√≥pria e hom√¥nima. Entretanto, muitos pacotes de an√°lises espaciais ainda utilizam essa classe em suas fun√ß√µes, apesar dessa migra√ß√£o ter ocorrido rapidamente recentemente. Dessa forma, a convers√£o entre essas classes pode ser necess√°ria em alguns momentos.

Abaixo, veremos como podemos fazer essa convers√£o facilmente. Primeiramente, vamos importar dados `sp`.

```{r}
## Pol√≠gonos pa√≠ses sp
co110_sp <- rnaturalearth::countries110
class(co110_sp)
```

Agora, podemos converter facilmente com a fun√ß√£o `sf::st_as_sf()`.

```{r}
## Pol√≠gonos pa√≠ses sf
co110_sf <- sf::st_as_sf(co110_sp)
class(co110_sf)
```

Podemos facilmente converter esse objeto novamente para a classe `sp` com a fun√ß√£o `sf::as_Spatial()`.

```{r}
## Pol√≠gonos pa√≠ses sp
co110_sp <- sf::as_Spatial(co110_sf)
class(co110_sp)
```

**Raster**

Para importar dados raster no R, utilizaremos a fun√ß√£o `raster::raster()`, `raster::brick()` ou `raster::stack()`. Para apenas uma camada raster, usaremos a fun√ß√£o `raster::raster()`, com o argumento `x` sendo o nome do arquivo. J√° para mais camadas, usaremos `raster::brick()` para um arquivo que possua m√∫ltiplas camadas, ou ainda a fun√ß√£o `raster::stack()` para v√°rios arquivos em diferentes camadas tamb√©m no argumento `x`, sendo necess√°rio listar os arquivos no diret√≥rio, geralmente utilizando a fun√ß√£o `dir()` ou `list.files()`. Entretanto, para especificar uma camada, podemos utilizar o argumento `band` ou `layer` e o nome dessa camada.

**Raster Layer**

Primeiramente, vamos criar um diret√≥rio para os dados raster que fazeremos o download.

```{r eval=TRUE}
## Criar diret√≥rio
dir.create(here::here("dados", "raster"))
```

Em seguida, vamos fazer o download de dados de eleva√ß√£o, na verdade dados de Modelo Digital de Eleva√ß√£o (*Digital Elevation Model* - DEM), localizados tamb√©m para o munic√≠pio de Rio Claro. Utilizaremos os dados do [*Shuttle Radar Topography Mission - SRTM*](https://srtm.csi.cgiar.org/). Para saber mais sobre esses dados, recomendamos a leitura do artigo de Farr et al. [-@farr_shuttle_2007].

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
download.file(url = "https://srtm.csi.cgiar.org/wp-content/uploads/files/srtm_5x5/TIFF/srtm_27_17.zip",
              destfile = here::here("dados", "raster", "srtm_27_17.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "raster", "srtm_27_17.zip"),
      exdir = here::here("dados", "raster"))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_srtm
```

Agora podemos importar essa camada para o R, e visualiz√°-la em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-dem)).

```{r}
## Importar raster de altitude
geo_raster_srtm <- raster::raster(here::here("dados", "raster", "srtm_27_17.tif"))
geo_raster_srtm
```

```{r fig-raster-dem, fig.cap="Camada raster do DEM em rela√ß√£o ao limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Raster Stack**

Al√©m dos dados de eleva√ß√£o, dados de temperatura e precipita√ß√£o podem ser obtidos do [WorldClim](https://www.worldclim.org/). Para saber mais sobre esses dados, recomendamos a leitura do artigo Fick & Hijmans [-@fick_worldclim_2017].

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e3)

## Download
download.file(url = "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_10m_bio.zip",
              destfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"), mode = "wb")

## Unzip
unzip(zipfile = here::here("dados", "raster", "wc2.0_10m_bio.zip"),
      exdir = here::here("dados", "raster"))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_bioclim
```

Para importar essa s√©rie de camadas, primeiramente listaremos os arquivos e depois importar no formato `RasterStack` (Figura \@ref(fig:fig-raster-wc)).

```{r}
## Listar arquivos
arquivos_raster <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
    grep(".tif", ., value = TRUE)
arquivos_raster

## Importar v√°rios rasters como stack
geo_raster_bioclim <- raster::stack(here::here("dados", "raster", arquivos_raster))
geo_raster_bioclim
```

```{r fig-raster-wc, fig.cap="Camadas rasters do WorldClim (BIO01 e BIO12) para o mundo."}
## Plot
plot(geo_raster_bioclim[[c(1, 4)]], col = viridis::viridis(10))
```

### Exportar dados

Saber a melhor forma de exportar dados geoespaciais de objetos rec√©m-criados no R √© fundamental, principalmente porque essa a√ß√£o depender√° do tipo de dado (vetor ou raster), classe do objeto (por exemplo, `MULTIPOINT` ou `RasterLayer`) e tipo e quantidade de informa√ß√µes armazenadas (por exemplo, tamanho do objeto, intervalo de valores, etc.).

**Vetor**

Para dados vetoriais, a principal fun√ß√£o utilizada √© a `sf::st_write()`. Essa fun√ß√£o permite gravar objetos `sf` em v√°rios formatos de arquivos vetoriais, como `.shp`, `.gpkg` ou `.geojson`. O formato a ser exportado vai influenciar na velocidade do processo de grava√ß√£o.

Os argumentos dessa fun√ß√£o ser√° o `obj` que √© o objeto `sf` criado no ambiente R, e o `dsn` (*data source name*), ou seja, o nome que o arquivo ter√° ao ser exportado do R, de modo que o complemento `.shp` no nome de sa√≠da, por exemplo, definir√° que o arquivo ter√° a extens√£o `ESRI Shapefile`. Entretanto, essa extens√£o pode ser definida tamb√©m utilizando o argumento `driver`, com as possibilidades listadas nesse [site](https://gdal.org/drivers/vector/index.html).

```{r eval=FALSE}
## Exportar o pol√≠gono de Rio Claro na extens√£o ESRI Shapefile
sf::st_write(obj = geo_vetor_rio_claro, 
             dsn = here::here("dados", "vetor", "geo_vetor_rio_claro.shp"))
```

Ou podemos ainda exportar o objeto vetorial na extens√£o `GeoPackage`. Entretanto, aqui √© interessante acrescentar um argumento chamado `layer` para definir o nome das camadas a serem exportadas no mesmo arquivo `GeoPackage`, por exemplo.

```{r eval=FALSE}
## Exportar o pol√≠gono de Rio Claro na extens√£o Geopackage
sf::st_write(obj = geo_vetor_rio_claro, 
             dsn = here::here("dados", "vetor", "vetores.gpkg"), 
             layer = "rio_claro")
```

Ainda sobre o formato `GeoPackage`, h√° algo muito interessante que podemos fazer: podemos acrescentar outros arquivos vetoriais ao mesmo arquivo j√° criado. Como exemplo, exportaremos o limite do Brasil para o mesmo arquivo.

```{r eval=FALSE}
## Exportar o pol√≠gono do Brasil na extens√£o Geopackage
sf::st_write(obj = geo_vetor_brasil, 
             dsn = here::here("dados", "vetor", "vetores.gpkg"), 
             layer = "brasil")
```

**Raster**

Para exportar dados raster utilizamos geralmente a fun√ß√£o `raster::writeRaster()`. Exportar dados raster √© um pouco mais complexo que exportar dados vetoriais. Teremos de definir se exportaremos arquivos em uma ou v√°rias camadas, quantidade de informa√ß√µes por pixel, e ainda diferentes extens√µes de sa√≠da. 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Arquivos raster escritos em discos geralmente ocupam bastante espa√ßo, e dessa forma, h√° par√¢metros espec√≠ficos para certos tipos de dados, que detalharemos a seguir para contornar esse problema e comprimir os arquivos.
:::

Na fun√ß√£o `raster::writeRaster()`, o argumento `x` diz respeito ao objeto raster no ambiente R. O argumento `filename` √© nome do arquivo que ser√° exportado do R, podendo ou n√£o possuir a extens√£o que se pretende que o arquivo tenha. O argumento `format` √© o formato do arquivo, sendo as principais possibilidades resumidas na Tabela \@ref(tab:tab-raster-formatos), e para saber das possibilidades suportadas, use a fun√ß√£o `raster::writeFormats()`. O argumento `bylayer` diz se m√∫ltiplas camadas ser√£o exportada em arquivos diferentes ou em apenas um arquivo.

```{r tab-raster-formatos, echo=FALSE}
knitr::kable(
    tibble(
        `Tipo de arquivo` = c("raster", "ascii", "SAGA", "IDRISI", "CDF", "GTiff", "ENVI", "EHdr", "HFA"), 
        `Nome longo` = c("Formato pacote raster", "ESRI Ascii", "SAGA GIS", "IDRISI", "netCDF (requer ncdf4)", "GeoTiff (requer rgdal)", "ENVI .hdr", "ESRI .hdr", "Erdas imagem (.img)"),
        Extens√£o = c(".grd", ".asc", ".sdat", ".rst", ".nc", ".tif", ".envi", ".bil", ".img"),
        `Suporte a m√∫ltiplas camadas` = c("Sim", "N√£o", "N√£o", "N√£o", "Sim", "Sim", "Sim", "Sim", "Sim")), 
    caption = "Principais formatos de arquivos raster exportados do R.")
```

Dentre os argumentos adicionais, temos ainda o `datatype`, que faz refer√™ncia a um dos nove tipos de formato de dados detalhados na Tabela \@ref(tab:tab-raster-tipos), sendo que o tipo de dado determina a representa√ß√£o em bits (quantidade de informa√ß√£o) na c√©lula do objeto raster exportado e depende da faixa de valores do objeto raster em cada pixel. Quanto mais valores um tipo de dado puder representar, maior ser√° o arquivo exportado no disco. Dessa forma, √© interessante utilizar um tipo de dado que diminua o tamanho do arquivo a ser exportado, dependendo do tipo de dado em cada pixel. Para a fun√ß√£o `raster::writeRaster()`, o default √© `FLT4S`, o que pode ocupar mais espa√ßo em disco do que o necess√°rio.

```{r tab-raster-tipos, echo=FALSE}
knitr::kable(
    tibble(
        `Tipo de dado` = c("LOG1S", "INT1S", "INT1U", "INT2S", "INT2U", "INT4S", "INT4U", "FLT4S", "FLT8S"), 
        `Valor m√≠nimo` = c("FALSE (0)",	"-127",	"0", "-32.767", "0", "-2.147.483.647", "0", "-3,4e+38", "-1,7e+308"),
        `Valor m√°ximo` = c("TRUE (1)",	"127",	"255", "32.767", "65534", "2.147.483.647", "42.94.967.296", "3,4e+38", "1,7e+308")), 
    caption = "Tipos de dados suportados pelo pacote `raster`."
)
```

Outros argumentos de suporte s√£o: `overwrite` para sobrescrever um arquivo que j√° exista, `progress` para mostrar uma barra de progresso da exporta√ß√£o como "text" ou "window", e `options` que permite op√ß√µes do GDAL. Para esse √∫ltimo , quando exportar especificamente na extens√£o `GeoTIFF`, podemos utilizar `options = c("COMPRESS=DEFLATE", "TFW=YES")` para que haja compress√£o do arquivo, diminuindo consideravelmente seu tamanho (cerca de um ter√ßo), aliado √† cria√ß√£o de um arquivo auxiliar `.tfw`, para ser carregado em softwares espec√≠ficos de SIG, como o ArcGIS.

Para exportar apenas uma camada `RasterLayer`, podemos utilizar a fun√ß√£o `raster::writeRaster()` em um formato mais simples.

```{r eval=FALSE}
## Criar diret√≥rio
dir.create(here::here("dados", "raster", "exportados"))

## Exportar raster layer
raster::writeRaster(geo_raster_srtm, 
                    filename = here::here("dados", "raster", "exportados", "elevation"),
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=DEFLATE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

Para mais de uma camada `RasterBrick` ou `RasterStack`, podemos utilizar a fun√ß√£o `raster::writeRaster()` com mais s, como o `bylayer = TRUE`.

```{r eval=FALSE}
## Exportar raster stack
raster::writeRaster(x = geo_raster_bioclim, 
                    filename = here::here("dados", "raster", "exportados", names(geo_raster_bioclim)),
                    bylayer = TRUE, 
                    format = "GTiff",
                    datatype = "INT2S",
                    options = c("COMPRESS=DEFLATE", "TFW=YES"),
                    progress = "text",
                    overwrite = TRUE)
```

## Descri√ß√£o de objetos geoespaciais

Muitas vezes precisaremos verificar as informa√ß√µes dos objetos geoespaciais importados para o R. Apesar de chamar o objeto trazer grande parte das informa√ß√µes que precisamos consultar, existem fun√ß√µes espec√≠ficas que nos auxiliam nesse processo de descri√ß√£o dos objetos.

### Vetor

Podemos acessar as informa√ß√µes geoespaciais e a tabela de atributos de um objeto importado como vetor simplesmente chamando o nome do objeto no R.

```{r}
## Munic√≠pio de Rio Claro
geo_vetor_rio_claro
```

Mas tamb√©m podemos acessar informa√ß√µes geoespaciais com fun√ß√µes espec√≠ficas, como tipo de geometria, limites geoespaciais do vetor (extens√£o), sistema de refer√™ncia de coordenadas (CRS), e a tabela de atributos.

```{r}
## Tipo de geometria
sf::st_geometry_type(geo_vetor_rio_claro)

## Extens√£o
sf::st_bbox(geo_vetor_rio_claro)

## CRS
sf::st_crs(geo_vetor_rio_claro)

## Acessar a tabela de atributos
geo_vetor_rio_claro_tab <- sf::st_drop_geometry(geo_vetor_rio_claro)
geo_vetor_rio_claro_tab
```

### Raster

Da mesma forma, podemos acessar as informa√ß√µes objetos raster chamando o nome do objeto.

```{r}
## Raster layer
geo_raster_srtm
```

Al√©m disso, podemos selecionar informa√ß√µes desse objeto com fun√ß√µes espec√≠ficas, tanto para `RasterLayer`, quanto para `RasterBrick` ou `RasterStack` como: classe, dimens√µes (n√∫mero de linhas, colunas e camadas), n√∫mero de camadas, n√∫mero de linhas, n√∫mero de colunas, n√∫mero de c√©lulas, resolu√ß√£o (largura e altura do tamanho do pixel), extens√£o (limites geoespaciais), sistema de refer√™ncia de coordenadas (CRS), nome das camadas e extrair os valores de todos os pixels.

```{r}
## Classe
class(geo_raster_srtm)

## Dimens√µes
dim(geo_raster_srtm)

## N√∫mero de camadas
nlayers(geo_raster_srtm)

## N√∫mero de linhas
nrow(geo_raster_srtm)

## N√∫mero de colunas
ncol(geo_raster_srtm)

## N√∫mero de c√©lulas
ncell(geo_raster_srtm)

## Resolu√ß√£o
res(geo_raster_srtm)

## Extens√£o
extent(geo_raster_srtm)

## Proje√ß√£o ou CRS
projection(geo_raster_srtm)

## Nomes
names(geo_raster_srtm)

## Valores
getValues(geo_raster_srtm) %>% head
values(geo_raster_srtm) %>% head
geo_raster_srtm[] %>% head
```

## Reproje√ß√£o de dados geoespaciais

Em algumas situa√ß√µes √© necess√°rio alterar o CRS de um objeto espacial para um novo CRS. A reproje√ß√£o √© justamente a transforma√ß√£o de coordenadas de um CRS para outro: geoespaciais ('lon/lat', com unidades em graus de longitude e latitude) e projetados (normalmente com unidades de metros a partir de um datum).

Geralmente precisaremos fazer essa opera√ß√£o para transformar camadas vetoriais ou rasters para o mesmo CRS, de modo que possam ser exibidas conjuntamente, ou ainda que as camadas possuem CRS projetado para realizar alguma opera√ß√£o espacial entre camadas, ou quando precisamos calcular √°reas, formatos ou dist√¢ncias, como m√©tricas de paisagem, por exemplo. Existe uma infinidade de proje√ß√µes e um excelente material de consulta √© o livro de Lapaine & Usery [-@lapaine2017].

Podemos verificar o CRS de uma camada atrav√©s da fun√ß√£o `sf::st_crs()` ou `raster::projection()` e `raster::crs()`, ou ainda, saber se a mesma possui um CRS geogr√°fico ou n√£o, com a fun√ß√£o `sf::st_is_longlat()`.

J√° para reprojetar um objeto `sf` usamos a fun√ß√£o `sf::st_transform()` e para um objeto `raster` usamos a fun√ß√£o `raster::projectRaster()`.

```{r}
## Proje√ß√£o de vetores
sf::st_crs(geo_vetor_rio_claro)

## Proje√ß√£o de raster
raster::projection(geo_raster_srtm)
raster::crs(geo_raster_srtm)

## Verificar se o CRS √© geogr√°fico
sf::st_is_longlat(geo_vetor_rio_claro)
```

As fun√ß√µes `sf::st_transform()` e `raster::projectRaster()` possuem dois argumentos importantes: `x` que √© o objeto a ser reprojetado e o `crs` que √© o CRS alvo. O argumento `crs` pode ser especificado de quatro maneiras: i) c√≥digo EPSG (por exemplo, 4326), ii) string PROJ4 (por exemplo, `+ proj = longlat + datum = WGS84 + no_defs`), iii) string WKT, ou iv) objeto `crs` de outra camada, conforme retornado por `sf::st_crs()` ou `raster::crs()`. Esas informa√ß√µes de EPSG, PROJ4 e WKT podem ser acessadas nas bases: [epsg.io](http://epsg.io/) e [spatialreference.org](https://spatialreference.org/).

Dentre os poss√≠veis CRSs a serem utilizados, alguns s√£o mais comuns para CRSs geoespaciais e projetados. Para CRSs geoespaciais, o mais comum para o mundo √© o World Geodetic System 1984 (WGS84), ou seja, geogr√°fico com datum WGS84. Para o Brasil, o CRS adotado √© o [Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)](http://www.sirgas.org/pt/sirgas-realizations/sirgas2000/), ou seja, geogr√°fico com datum SIRGAS2000.

Para CRSs projetados, essa escolha vai depender da extens√£o e localiza√ß√£o da √°rea de interesse no globo terrestre. Aqui destacaremos os principais, para tr√™s escalas: global, regional e local. Para a escala global, geralmente usa-se umas dessas proje√ß√µes, dependendo do objetivo: i) Proje√ß√£o de Mollweide, ii) Proje√ß√£o de Winkel Tripel, iii) Proje√ß√£o de Eckert IV, iv) Proje√ß√£o Azimutal de Lambert. Para a escala regional, como um hemisf√©rio, geralmente usa-se a Proje√ß√£o C√¥nica de Albers. Por fim, para a escala local, usa-se geralmente a Proje√ß√£o Universal Transverse Mercator (UTM), um conjunto de CRSs que divide a Terra em 60 cunhas longitudinais e 20 segmentos latitudinais, como pode ser visto neste [link](http://www.dmap.co.uk/utmworld.htm).

Os principais CRSs s√£o descritos na Tabela \@ref(tab:tab-crs).

```{r tab-crs, echo=FALSE}
knitr::kable(
    tibble(
        CRS = c("World Geodetic System 1984 (WGS84)", 
                "Sistema de Referencia Geoc√©ntrico para las Am√©ricas 2000 (SIRGAS 2000)",
                "Proje√ß√£o de Mollweide", 
                "Proje√ß√£o de Winkel Tripel", 
                "Proje√ß√£o de Eckert IV", 
                "Proje√ß√£o Azimutal de Lambert",
                "Proje√ß√£o C√¥nica de Albers",
                "Proje√ß√£o Universal Transverse Mercator (UTM)"),
        `Tipo de CRS` = c("Geogr√°fico", 
                          "Geogr√°fico", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado", 
                          "Projetado"),
        Descri√ß√£o = c("CRS geogr√°fico mais comum para o mundo", 
                      "CRS geogr√°fico oficial para o Brasil", 
                      "CRS projetado que  preserva as rela√ß√µes de √°rea", 
                      "CRS projetado com m√≠nimo de distor√ß√£o para √°rea, dire√ß√£o e dist√¢ncia", 
                      "CRS projetado que preserva a √°rea e com meridianos el√≠pticos", 
                      "CRS projetado que preserva os tamanhos relativos e senso de dire√ß√£o a partir do centro", 
                      "CRS projetado para escala regional, mantendo a √°rea constante em toda sua superf√≠cie", 
                      "CRS projetado para escala local, distorcendo √°reas e dist√¢ncias com gravidade crescente com a dist√¢ncia do centro da zona UTM"),
        epsg.io = c("[EPSG:4326](http://epsg.io/4326)", 
                    "[EPSG:4674](http://epsg.io/4674)",
                    "[ESRI:54009](https://epsg.io/54009)", 
                    NA, 
                    "[EPSG:54012](https://epsg.io/54012)", 
                    NA, 
                    NA, 
                    "[EPSG:31983](https://epsg.io/31983)"),
        spatialreference.org = c("[EPSG:4326](https://spatialreference.org/ref/epsg/4326/)",
                                 "[EPSG:4674](https://spatialreference.org/ref/epsg/4674/)",
                                 "[SR-ORG:7099](https://spatialreference.org/ref/sr-org/7099/)",
                                 "[SR-ORG:7291](https://spatialreference.org/ref/sr-org/7291/)",
                                 "[ESRI:54012](https://spatialreference.org/ref/esri/54012/)",                      
                                 NA,
                                 "[SR-ORG:7823](https://spatialreference.org/ref/sr-org/7823/)",
                                 "[EPSG:31983](https://spatialreference.org/ref/epsg/31983/)")), 
    caption = "Principais CRSs utilizados."
)
```

### Vetor

Como dissemos, para reprojetar um vetor, utilizamos a fun√ß√£o `sf::st_transform()`, observando os argumentos `x` que √© a camada a ser reprojetada, e o `crs` que √© o CRS alvo.

Vamos reprojetar o limite do munic√≠pio de Rio Claro/SP do CRS SIRGAS2000/geogr√°fico para o CRS projetado SIRGAS2000/UTM23S, com os efeitos da transforma√ß√£o podendo ser notados na Figura \@ref(fig:fig-vetor-crs-trans).

```{r}
## Converter CRS
geo_vetor_rio_claro_sirgas2000_utm23s <- sf::st_transform(x = geo_vetor_rio_claro, 
                                                          crs = 31983)
```

```{r fig-vetor-crs-trans, echo=FALSE, fig.cap="Limites do munic√≠pio de Rio Claro/SP com CRS SIRGAS2000/geogr√°fico e com CRS SIRGAS2000/UTM23S."}
p1 <- ggplot() +
    geom_sf(data = geo_vetor_rio_claro) +
    coord_sf(datum = sf::st_crs(4674)) +
    labs(x = "Longitude", y = "Latitude", title = "SIRGAS2000/Geogr√°fico") + 
    theme_bw() +
    theme(axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
          panel.grid = element_line(size = .3, color = "black", linetype = 2))

p2 <- ggplot() +
    geom_sf(data = geo_vetor_rio_claro) +
    coord_sf(datum = sf::st_crs(31983)) +
    labs(x = "X", y = "Y", title = "SIRGAS2000/UTM23S") + 
    theme_bw() +
    theme(axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7, angle = 90, hjust = .5),
          panel.grid = element_line(size = .3, color = "black", linetype = 2))

gridExtra::grid.arrange(p1, p2, nrow = 1)
```

Podemos ainda utilizar o formato `proj4string` no argumento `crs` para fazer a transforma√ß√£o. Vamos primeiramente plotar o mundo em WGS84/Geogr√°fico (Figura \@ref(fig:fig-vetor-mundo-wgs84)).

```{r fig-vetor-mundo-wgs84, fig.cap="Camada BIO01 para o mundo com CRS geogr√°fico e datum WGS84."}
## Plot
plot(co110_sf[1], col = "gray",  main = "WGS84/Geogr√°fio", graticule = TRUE)
```

Agora, reprojetaremos utilizando a Proje√ß√£o de Mollweide (Figura \@ref(fig:fig-vetor-mundo-moll)).

```{r}
## Proje√ß√£o de Mollweide 
co110_sf_moll <- sf::st_transform(x = co110_sf, crs = "+proj=moll")
```

```{r fig-vetor-mundo-moll, fig.cap="Camada BIO01 para o mundo com CRS Proje√ß√£o de Mollweide."}
## Plot
plot(co110_sf_moll[1], col = "gray", main = "Proje√ß√£o de Mollweide", graticule = TRUE)
```

Ou ainda podemos utilizar a Proje√ß√£o Azimutal de Lambert com alguns par√¢metros ajustados para centralizar a proje√ß√£o no Brasil (\@ref(fig:fig-vetor-mundo-laea)).

```{r}
## Proje√ß√£o Azimutal de Lambert
co110_sf_laea <- sf::st_transform(x = co110_sf, 
                                  crs = "+proj=laea +x_0=0 +y_0=0 +lon_0=-50 +lat_0=0")
```

```{r fig-vetor-mundo-laea, fig.cap="amada BIO01 para o mundo com CRS Proje√ß√£o Azimutal de Lambert centrado no Brasil."}
## Plot
plot(co110_sf_laea[1], col = "gray", main = "Proje√ß√£o Azimutal de Lambert", graticule = TRUE)
```

### Raster

A reproje√ß√£o de objetos raster n√£o √© uma tarefa t√£o simples quanto a reproje√ß√£o de vetores. Em vetores, a reproje√ß√£o altera as coordenadas de cada v√©rtice. Entretanto, como rasters s√£o compostos de c√©lulas retangulares do mesmo tamanho, a reproje√ß√£o do raster envolve a cria√ß√£o de um novo objeto raster, envolvendo duas opera√ß√µes espaciais separadas: i) reproje√ß√£o vetorial dos centroides celulares para outro CRS (i.e., muda a posi√ß√£o e tamanho do pixel) e, ii) c√°lculo de novos valores do pixel por meio de reamostragem (i.e., muda o valor do pixel).

A fun√ß√£o `raster::projectRaster()` possui alguns par√¢metros que necessitam de algumas especifica√ß√µes. O argumento `from` que √© o objeto raster de entrada que sofre a reproje√ß√£o. O argumento `to` √© um objeto raster do qual todas as propriedades dos CRSs, como extens√£o e resolu√ß√£o ser√£o associadas ao objeto raster indicado no argumento `from`. O argumento `res` permite ajustar a resolu√ß√£o do pixel de sa√≠da do objeto raster reprojetado.

O argumento `crs` aceita apenas as defini√ß√µes de `proj4string` extensas de um CRS em vez de c√≥digos EPSG concisos. Contudo, √© poss√≠vel usar um c√≥digo `EPSG` em uma defini√ß√£o de `proj4string` com `+init=epsg:EPSG`. Por exemplo, pode-se usar a defini√ß√£o `+init=epsg:4326` para definir CRS para WGS84 (c√≥digo EPSG de 4326). A biblioteca `PROJ` adiciona automaticamente o resto dos par√¢metros e os converte em `+init=epsg:4326 +proj=longlat +datum=WGS84 + no_defs + ellps=WGS84 + towgs84=0,0,0`.

O argumento `method` permite escolher entre os m√©todos `ngb` (vizinho mais pr√≥ximo) ou `biliniar` (interpola√ß√£o bilinear), sendo o primeiro mais indicado para reproje√ß√£o de rasters categ√≥ricos, pois os valores estimados devem ser iguais aos do raster original. O m√©todo `ngb` define cada novo valor de c√©lula para o valor da c√©lula mais pr√≥xima (centro) do raster de entrada. J√° o m√©todo `biliniar` √© indicado para raster cont√≠nuos e calcula o valor da c√©lula de sa√≠da com base nas quatro c√©lulas mais pr√≥ximas no raster original, sendo a m√©dia ponderada da dist√¢ncia dos valores dessas quatro c√©lulas. Existem outras formas de interpola√ß√£o, mas n√£o as abordaremos aqui.

Aqui, vamos reprojetar os dados de eleva√ß√£o para Rio Claro/SP. Para que esse processo seja mais r√°pido, iremos antes ajustar a extens√£o do raster para o limite do munic√≠pio usando a fun√ß√£o `raster::crop()` (Figura \@ref(fig:fig-raster-crop)). Essa fun√ß√£o √© melhor explicada na se√ß√£o de cortes e m√°scaras, mais adiante.

```{r}
## Ajuste do limite
geo_raster_srtm_rio_claro <- raster::crop(x = geo_raster_srtm, 
                                          y = geo_vetor_rio_claro)
geo_raster_srtm_rio_claro
```

```{r fig-raster-crop, fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Primeiramente, vamos reprojetar indicando uma proje√ß√£o e sem especificar o tamanho da c√©lula. Note que o tamanho da c√©lula vai se ajustar para valores diferentes, sendo portanto, pixels retangulares e n√£o quadrados.

```{r}
## Reproje√ß√£o
geo_raster_srtm_rio_claro_sirgas2000_utm23s <- raster::projectRaster(
    from = geo_raster_srtm_rio_claro, 
    crs = "+init=epsg:31983", 
    method = "bilinear")
geo_raster_srtm_rio_claro_sirgas2000_utm23s
```

Agora vamos reprojetar especificando o tamanho da c√©lula (Figura \@ref(fig:fig-raster-reproj)). Dessa forma, todas as c√©lulas ter√£o o mesmo, i.e., quadrados de 90 metros.

```{r}
## Reproje√ß√£o
geo_raster_srtm_rio_claro_sirgas2000_utm23s <- raster::projectRaster(
    from = geo_raster_srtm_rio_claro, 
    crs = "+init=epsg:31983", 
    method = "bilinear", 
    res = 90)
geo_raster_srtm_rio_claro_sirgas2000_utm23s
```

```{r fig-raster-reproj, fig.cap="Reproje√ß√£o do raster de eleva√ß√£o para SIRGAS2000/UTM23S especificado por um objeto e informando o tamanho da c√©lula."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s, 
     col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom,
     col = NA, border = "red", lwd = 2, add = TRUE)
```

Vamos tamb√©m reprojetar uma camada mundial da m√©dia de temperatura anual (BIO01), indicando o tamanho da c√©lula para 25.000 m (Figura \@ref(fig:fig-raster-reproj-celula-mundo)).

```{r}
## Reproje√ß√£o
geo_raster_bioclim_moll <- raster::projectRaster(
    from = geo_raster_bioclim[[1]], 
    crs = "+proj=moll",
    res = 25000, 
    method = "bilinear")
geo_raster_bioclim_moll
```

```{r fig-raster-reproj-celula-mundo, fig.cap="Reproje√ß√£o do raster de m√©dia de temperatura anual (BIO01) para Proje√ß√£o de Mollweide informando o tamanho da c√©lula."}
## Plot
plot(geo_raster_bioclim_moll, col = viridis::viridis(10))
plot(co110_sf_moll[1], col = NA, add = TRUE)
```

## Principais opera√ß√µes com dados geoespaciais

Nesta se√ß√£o veremos as principais fun√ß√µes para realizar opera√ß√µes com dados geoespaciais. Essas opera√ß√µes s√£o separadas conforme Lovelace et al. [-@lovelace2019] em: **Opera√ß√µes de atributos**, **Opera√ß√µes espaciais**, e **Opera√ß√µes geom√©tricas**.

### Opera√ß√µes de atributos

S√£o modifica√ß√£o de objetos geoespaciais baseado em informa√ß√µes n√£o espaciais associadas a dados geoespaciais, como a tabela de atributos ou valores das c√©lulas e nome das camadas dos rasters.

**Vetor**

As principais opera√ß√µes de atributos vetoriais s√£o com respeito √† tabela de atributos, sendo as principais: i) filtro, ii) jun√ß√£o, iii) agrega√ß√£o e iv) manipula√ß√£o da tabela de atributos. A lista de poss√≠veis opera√ß√µes √© longa, dessa forma, apresentaremos algumas opera√ß√µes utilizando as principais fun√ß√µes e listamos as demais fun√ß√µes e suas opera√ß√µes, que depender√£o de objetivos espec√≠ficos.

Quase todas as opera√ß√µes ser√£o as mesmas realizadas pelo pacote `dplyr` em uma tabela de dados (ver o Cap√≠tulo \@ref(cap5)), sendo algumas opera√ß√µes espec√≠ficas para alterar apenas campos da tabela de atributos e outras que refletem opera√ß√µes nas fei√ß√µes, ou seja, alterar√£o atrav√©s da tabela de atributos as caracter√≠sticas das fei√ß√µes. Essas fun√ß√µes e suas opera√ß√µes s√£o descritas com detalhes na Tabela (\@ref(tab:tab-vetor-operacoes-atributos)).

```{r tab-vetor-operacoes-atributos, echo=FALSE}
knitr::kable(
    tibble(
        Fun√ß√µes = c("`filter()`", 
                    "`slice()`", 
                    "`n_sample()`", 
                    "`group_by()`", 
                    "`summarise()`", 
                    "`select()`", 
                    "`pull()`", 
                    "`rename()`", 
                    "`mutate()`", 
                    "`*_join()`"),
        `Onde atua` = c("Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Fei√ß√µes", 
                        "Atributos",
                        "Atributos",
                        "Atributos",
                        "Atributos",
                        "Atributos"),
        Descri√ß√£o = c("Selecionar fei√ß√µes por valores",
                      "Selecionar fei√ß√µes pela posi√ß√£o na tabela de atributos",
                      "Amostrar fei√ß√µes na tabela de atributos",
                      "Agrupar fei√ß√µes por valores da tabela de atributos",
                      "Opera√ß√µes com valores das fei√ß√µes na tabela de atributos, que acabam por dissolver as fei√ß√µes",
                      "Selecionar colunas da tabela de atributos",
                      "Selecionar uma coluna da tabela de atributos como vetor",
                      "Renomear uma coluna da tabela de atributos",
                      "Criar uma coluna ou alterar os valores da tabela de atributos",
                      "Diversas fun√ß√µes para juntar dados de outras tabelas de dados √† tabela de atributos")), 
    caption = "Principais fun√ß√µes para realizar opera√ß√µes de atributos e suas descri√ß√µes."
)
```

Para exemplificar as opera√ß√µes de atributos, vamos utilizar os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Filtro**

Vamos iniciar as opera√ß√µes fazendo o filtro de fei√ß√µes pela tabela de atributos, que permite selecionar fei√ß√µes pelos seus valores atribu√≠dos, utilizando a fun√ß√£o `dplyr::filter()`. Aqui vamos selecionar as fei√ß√µes de floresta do mapa de cobertura da terra para Rio Claro/SP (Figura \@ref(fig:fig-vetor-opat-filtro)).

```{r}
## Filtro
geo_vetor_cobertura_floresta <- geo_vetor_cobertura %>% 
    dplyr::filter(CLASSE_USO == "forma√ß√£o florestal")
```

```{r fig-vetor-opat-filtro, fig.cap="Filtro da classe floresta para o mapeamento de cobertura da terra para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
```

**Jun√ß√£o**

Uma das fun√ß√µes mais √∫teis de opera√ß√µes de atributos √© a jun√ß√£o, referida em ingl√™s como *join*, realizada atrav√©s das fun√ß√µes `dplyr::*_join()` (ver detalhes do Cap√≠tulo \@ref(cap5)). Nela, usamos uma coluna identificadora para atribuir dados de outra tabela de dados. Como exemplo, vamos criar uma tabela de dados com novos nomes das classes de cobertura da terra e atribuir esses novos nomes √† tabela de atributos do objeto vetorial. √â fundamental destacar que para que essa fun√ß√£o funcione, precisamos de uma coluna identificadora dos valores para que a jun√ß√£o seja poss√≠vel.

```{r}
## Dados
dados_classes <- tibble::tibble(
    CLASSE_USO = geo_vetor_cobertura$CLASSE_USO, 
    classe = c("agua", "antropico", "edificado", "floresta", "silvicultura"))
dados_classes
```

```{r}
## Jun√ß√£o
geo_vetor_cobertura_classes <- dplyr::left_join(
    x = geo_vetor_cobertura, 
    y = dados_classes, 
    by = "CLASSE_USO") %>% 
    sf::st_drop_geometry()
geo_vetor_cobertura_classes
```

**Agrega√ß√£o**

Outra fun√ß√£o bastante √∫til √© a agrega√ß√£o de atributos. Apesar de existir uma fun√ß√£o que realiza a uni√£o de fei√ß√µes que veremos na pr√≥xima se√ß√£o, o uso conjunto das fun√ß√µes `dplyr::group_by()` e `dplyr::summarise()` realizam uma tarefa semelhante. Aqui vamos agregar as nascentes para Rio Claro/SP, i.e., juntar cada ponto que estava numa linha da tabela de atributos de modo que todos fiquem numa mesma linha, com o valor da quantidade de nascentes (Figura \@ref(fig:fig-vetor-opat-agregar)).

```{r}
## Agregar
geo_vetor_nascentes_n <- geo_vetor_nascentes %>% 
    dplyr::group_by(MUNICIPIO, HIDRO) %>% 
    dplyr::summarise(n = n())
geo_vetor_nascentes_n
```

```{r fig-vetor-opat-agregar, fig.cap="Agrega√ß√£o e contagem das nascentes para o munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_nascentes_n$geometry, pch = 20, 
     col = "blue", add = TRUE)
```

**Manipula√ß√£o da tabela de atributos**

Por fim, √© muito comum em an√°lises de softwares SIG a cria√ß√£o ou atualiza√ß√£o dos valores de colunas na tabela de atributos. Aqui, podemos utilizar a fun√ß√£o `dplyr::mutate()` para criar essas novas colunas, assim como atualizar os valores de colunas existentes. Em nosso exemplo, fazeremos uma composi√ß√£o das colunas `CLASSE_USO` e `AREA_HA` numa nova coluna chamada `classe_area`.

```{r}
## Criar coluna
geo_vetor_cobertura_cob_col_area <- geo_vetor_cobertura %>% 
    dplyr::mutate(classe_area = paste0(CLASSE_USO, " (", AREA_HA, " ha)")) %>% 
    sf::st_drop_geometry()
geo_vetor_cobertura_cob_col_area
```

Duas fun√ß√µes s√£o bastante interessantes de serem integradas junto √† manipula√ß√£o de tabelas de atributos. Elas calculam propriedades geom√©tricas num√©ricas dos vetores de linhas (comprimento) e pol√≠gonos (√°rea): `sf::st_length()` e `sf::st_area()`. Essas fun√ß√µes calculam essas propriedades em metros para comprimento e em metros quadrados para √°rea, independentemente do CRS. Para tanto, vamos utilizar as linhas de hidrografia e os pol√≠gonos de cobertura da terra para Rio Claro/SP, e atribuir esses valores √† tabela de atributos de ambos os objetos geoespaciais, utilizando em conjunto a fun√ß√£o `dplyr::mutate()`.

```{r}
## Comprimento das linhas
geo_vetor_hidrografia_comp <- geo_vetor_hidrografia %>% 
    dplyr::mutate(comprimento = sf::st_length(.))
geo_vetor_hidrografia_comp
```

```{r}
## √Årea dos pol√≠gonos
geo_vetor_cobertura_area <- geo_vetor_cobertura %>% 
    dplyr::mutate(area_m2 = sf::st_area(.))
geo_vetor_cobertura_area
```

**Raster**

Devido √† estrutura espacial do raster ser formada por uma ou mais superf√≠cies cont√≠nuas, as manipula√ß√µes como subconjunto e outras opera√ß√µes em objetos raster funcionam de uma maneira diferente do que em objetos vetoriais. Veremos aqui as tr√™s principais: i) subconjunto de c√©lulas usando o operador `[]` ou subconjunto de camadas `RasterStack` ou `RasterBrick` utilizando os operadores `[[]]` e `$`, ii) renomear nomes das camadas, e iii) resumir informa√ß√µes de todos os pixels.

**Subconjunto**

Podemos fazer um subconjunto de c√©lulas utilizando dentro dos operadores `[]` valores para indicar a posi√ß√£o da linha e da coluna de um raster, ou ainda a posi√ß√£o de uma c√©lula utilizando apenas um n√∫mero. Essas opera√ß√µes resultar√£o em valores diferentes para `RasterLayer` e `RasterBrick` ou `RasterStack`.

```{r}
## Raster - linha 1 e columna 1
geo_raster_srtm[1, 1]

## Raster - c√©lula 1
geo_raster_srtm[1]

## Stack - linha 1 e columna 1
geo_raster_bioclim[1, 1]

## Stack - c√©lula 1
geo_raster_bioclim[1]
```

Para selecionar uma camada de um `RasterBrick` ou `RasterStack`, podemos utilizar as fun√ß√µes `raster::subset()` ou `raster::raster()` com o argumento `layer` indicando a ordem ou o nome da camada, al√©m dos operadores `[[]]` e `$` (Figura \@ref(fig:fig-raster-stack-subset)).

```{r}
## Sele√ß√£o de camada num objeto stack utilizando a fun√ß√£o subset
geo_raster_bioclim_bio01 <- raster::subset(geo_raster_bioclim, "wc2.1_10m_bio_1")
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando a fun√ß√£o raster
geo_raster_bioclim_bio01 <- raster::raster(geo_raster_bioclim, layer = 1)
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando os operadores [[]] e o nome
geo_raster_bioclim_bio01 <- geo_raster_bioclim[["wc2.1_10m_bio_1"]]
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando os operadores [[]] e a posicao
geo_raster_bioclim_bio01 <- geo_raster_bioclim[[1]]
geo_raster_bioclim_bio01

## Sele√ß√£o de camada num objeto stack utilizando o operador $
geo_raster_bioclim_bio01 <- geo_raster_bioclim$wc2.1_10m_bio_1
geo_raster_bioclim_bio01
```

```{r fig-raster-stack-subset, fig.cap="Camada BIO01 selecionada pelas opera√ß√µes de subconjunto."}
# Plot
plot(geo_raster_bioclim_bio01, col = viridis::viridis(10))
```

**Renomear**

Podemos ainda renomear camadas dos raster `RasterLayer` utilizando a fun√ß√£o `names()`.

```{r}
## Raster - nomes
names(geo_raster_srtm_rio_claro)

## Raster - renomear
names(geo_raster_srtm_rio_claro) <- "elevacao"

## Raster - nomes
names(geo_raster_srtm_rio_claro)
```

E essa opera√ß√£o tamb√©m funciona para `RasterBrick` e `RasterStack`.

```{r}
## Stack - nomes
names(geo_raster_bioclim)

## Stack - renomear
names(geo_raster_bioclim) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))

## Stack - nomes
names(geo_raster_bioclim)
```

**Resumir**

Muitas vezes queremos fazer c√°lculos para todos as c√©lulas de um raster. Podemos resumir informa√ß√µes de todos os pixels fazendo c√°lculos simples com todos os pixels de cada camada com a fun√ß√£o `raster::cellStats()`, sendo `x` o argumento do objeto raster e `stat` o nome da fun√ß√£o resumo, como "mean" ou "sum".

```{r}
## Raster - m√©dia de todas as c√©lulas de altitude
raster::cellStats(x = geo_raster_srtm_rio_claro, stat = mean)

## Stack - m√©dia de todas as c√©lulas de cada camada bioclim√°tica
raster::cellStats(x = geo_raster_bioclim, stat = mean)
```

Ou ainda, podemos analisar a frequ√™ncia com que cada valor dos pixels ocorre, utilizando a fun√ß√£o `raster::freq()`.

```{r}
## Raster - frequ√™ncia das c√©lulas
raster::freq(x = geo_raster_srtm_rio_claro) %>% head()

## Stack - frequ√™ncia das c√©lulas
raster::freq(x = geo_raster_bioclim[[1]]) %>% head()
```

### Opera√ß√µes espaciais

As opera√ß√µes espaciais s√£o modifica√ß√µes de objetos geoespaciais baseado em informa√ß√µes espaciais, como localiza√ß√£o e formato. Seria quase imposs√≠vel abordar todas as opera√ß√µes realiz√°veis nesse cap√≠tulo, ent√£o demonstraremos as principais para dados vetoriais e raster.

**Vetor**

As principais opera√ß√µes espaciais para dados vetoriais s√£o: i) filtro espacial, ii) jun√ß√£o espacial, iii) agrega√ß√£o espacial e iv) dist√¢ncia espacial. Apresentaremos essas opera√ß√µes utilizando as principais fun√ß√µes utilizando os dados de nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Filtro espacial**

Filtros espaciais s√£o opera√ß√µes que realizam sele√ß√£o de fei√ß√µes espaciais entre dois objetos geoespaciais (x e y). Existe uma grande quantidade de fun√ß√µes para realizar filtros espaciais no R, como podemos ver na Tabela (\@ref(tab:tab-filtro-espacial)). Essas fun√ß√µes verificam se cada fei√ß√£o em x mant√©m sua rela√ß√£o em y. Ao especificar o par√¢metro `sparse = FALSE`, as fun√ß√µes retornam uma matriz l√≥gica (composta por `TRUE` e `FALSE`).

```{r tab-filtro-espacial, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Fun√ß√£o = c("`sf::st_contains()`", 
                   "`sf::st_contains_properly()`", 
                   "`sf::st_covers()`", 
                   "`sf::st_covered_by()`", 
                   "`sf::st_crosses()`", 
                   "`sf::st_disjoint()`", 
                   "`sf::st_equals()`", 
                   "`sf::st_equals_exact()`", 
                   "`sf::st_intersects()`", 
                   "`sf::st_is_within_distance()`", 
                   "`sf::st_within()`", 
                   "`sf::st_touches()`", 
                   "`sf::st_overlaps()`", 
                   "`sf::st_relate()`"), 
        Descri√ß√£o = c("Nenhum dos pontos de x est√° fora de y", 
                      "x cont√©m y, e y n√£o tem pontos em comum com a fronteira de x", 
                      "Nenhum ponto de y se encontra no exterior de x", 
                      "Inverso de `sf::st_covers()`", 
                      "x e y t√™m alguns, mas n√£o todos os pontos internos em comum", 
                      "x e y n√£o t√™m pontos em comum", 
                      "x e y s√£o geometricamente iguais; o n√∫mero de pedido dos n√≥s pode ser diferente", 
                      "x e y s√£o geometricamente iguais e t√™m ordem de n√≥ id√™ntica", 
                      "x e y n√£o s√£o separados", 
                      "x est√° mais perto de y do que uma determinada dist√¢ncia", 
                      "Nenhum dos pontos de y est√° fora de x", 
                      "x e y t√™m pelo menos um ponto limite em comum, mas nenhum ponto interno", 
                      "x e y t√™m alguns pontos em comum; a dimens√£o destes √© id√™ntica √† de x e y", 
                      "Dado um padr√£o, retorna se x e y aderem a este padr√£o"),
        `Fun√ß√£o inversa` = c("`st_within`", 
                             NA,
                             "`st_covered_by`", 
                             NA, 
                             NA, 
                             "`st_intersects`", 
                             NA, 
                             NA, 
                             "`st_disjoint`", 
                             NA, 
                             "`st_contains`", 
                             NA, 
                             NA, 
                             NA)),
    caption = "Principais pacotes para composi√ß√£o de mapas no R."
)
```

Em nosso exemplo, utilizaremos a fun√ß√£o `sf::intersects()` para filtrar as nascentes dentro de floresta para Rio Claro/SP. Essa fun√ß√£o vai retornar a resposta bin√°ria se as nascentes est√£o (1) ou n√£o (empty) dentro dos pol√≠gonos de floresta.

```{r}
## Filtro espacial
sf::st_intersects(x = geo_vetor_nascentes, y = geo_vetor_cobertura_floresta)
```

Podemos usar essa mesma fun√ß√£o em conjunto com a fun√ß√£o `dplyr::filter()` para filtrar as nascentes dentro de florestas, mas agora com o argumento `sparse = FALSE` para valores l√≥gicos funcionarem com o filtro.

```{r}
## Filtro espacial - interno
geo_vetor_nascentes_floresta_int <- geo_vetor_nascentes %>% 
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_cobertura_floresta, sparse = FALSE))
```

Ou ainda podemos utilizar o operador `[]` para realizar esse filtro, como podemos notar na Figura \@ref(fig:fig-vetor-filtro-espacial-interno).

```{r}
## Filtro espacial com [] - interno
geo_vetor_nascentes_floresta_int <- geo_vetor_nascentes[geo_vetor_cobertura_floresta, ]
```

```{r fig-vetor-filtro-espacial-interno, fig.cap="Nascentes dentro de florestas no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
plot(geo_vetor_nascentes_floresta_int$geometry, col = "blue", pch = 20, cex = 1, add = TRUE)
```

Entretanto, muitas vezes queremos fazer o filtro de fei√ß√µes que est√£o fora de fei√ß√µes de outro objeto espacial. Para isso, podemos usar a fun√ß√£o `sf::st_disjoint()` ou ainda utilizando o operador `[]`, mas com o argumento `op`, nesse caso utilizando a mesma fun√ß√£o `sf::st_disjoint()` como opera√ß√£o (Figura \@ref(fig:fig-vetor-filtro-espacial-externo)). Atentar o segundo vazio nesse filtro.

```{r}
## Filtro espacial - externo
geo_vetor_nascentes_floresta_ext <- geo_vetor_nascentes %>% 
    dplyr::filter(sf::st_disjoint(x = ., y = geo_vetor_cobertura_floresta, sparse = FALSE))

## Filtro espacial com [] - externo
geo_vetor_nascentes_floresta_ext <- geo_vetor_nascentes[geo_vetor_cobertura_floresta, , op = st_disjoint]
```

```{r fig-vetor-filtro-espacial-externo, fig.cap="Nascentes fora de florestas no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta$geometry, col = "forestgreen", add = TRUE)
plot(geo_vetor_nascentes_floresta_ext$geometry, col = "steelblue", pch = 20, cex = 1, add = TRUE)
```

**Jun√ß√£o espacial**

Outra opera√ß√£o muito usada dentro de an√°lises espaciais √© a jun√ß√£o espacial ou do ingl√™s *spatial join*. A ideia base √© muito semelhante com a jun√ß√£o baseada em atributos, mas aqui atribuiremos o valor da tabela de atributos das fei√ß√µes de um objeto espacial y √†s fei√ß√µes que fazem intersec√ß√£o com um objeto espacial x, de modo que esses valores sejam armazenados na tabela de atributos do primeiro objeto espacial.

Para exemplificar, vamos atribuir os valores dos pol√≠gonos de cobertura da terra aos pontos de nascentes para Rio Claro/SP, fazendo um agrupamento pela tabela de atributos para permitir criar o mapa da Figura \@ref(fig:fig-vetor-juncao-espacial).

```{r}
## Jun√ß√£o espacial
geo_vetor_nascentes_cob_jun <- geo_vetor_nascentes %>% 
    sf::st_join(x = ., y = geo_vetor_cobertura) %>% 
    dplyr::group_by(CLASSE_USO) %>% 
    dplyr::summarise(n = n())
```

```{r fig-vetor-juncao-espacial, fig.cap="Jun√ß√£o espacial da cobertura da terra para as nascentes no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_nascentes_cob_jun[1], col = c("blue", "orange", "gray30", "forestgreen", "green"),
     pch = 20, add = TRUE)
legend(x = 209000, y = 7520000, pch = 15, cex = .7, pt.cex = 2.5, 
       legend = (geo_vetor_nascentes_cob_jun$CLASSE_USO), 
       col = c("blue", "orange", "gray30", "forestgreen", "green"))
```

**Agrega√ß√£o espacial**

Muitas vezes queremos contabilizar quantas fei√ß√µes ou agregar valores de fei√ß√µes para pol√≠gonos. Podemos realizar essa opera√ß√£o usando as fun√ß√µes `dplyr::group_by()` e `dplyr::summarise`, ou utilizar a fun√ß√£o `aggregate()`. Nesse exemplo, vamos contabilizar quantas nascentes h√° por pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

```{r}
## Agrega√ß√£o espacial
geo_vetor_cobertura_nas_agre <- geo_vetor_nascentes %>% 
    aggregate(x = ., by = geo_vetor_cobertura, FUN = length)
```

```{r fig-vetor-agregacao-espacial, fig.cap="Agrega√ß√£o espacial contabilizando o n√∫mero de nascentes para cada classe de cobertura da terra no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura_nas_agre[1], axes = TRUE, graticule = TRUE, main = NA)
```

**Dist√¢ncia espacial**

A dist√¢ncia espacial √© a dist√¢ncia calculada em duas dimens√µes (2D) entre um objeto espacial x e y baseado no CRS e para cada fei√ß√£o dos objetos geoespaciais. Para realizar esse c√°lculo, utilizamos a fun√ß√£o `sf::st_distance()`. Em nosso exemplo, vamos calcular a dist√¢ncia das nascentes at√© a floresta mais pr√≥xima, e adicionando essa informa√ß√£o para cada ponto na tabela de atributos com a fun√ß√£o `dplyr::mutate()`, para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-distancia-espacial)).

```{r}
## Dist√¢ncia espacial
geo_vetor_nascentes_dist_flo <- geo_vetor_nascentes %>% 
    dplyr::mutate(dist_flo = sf::st_distance(geo_vetor_nascentes, geo_vetor_cobertura_floresta))
```

```{r fig-vetor-distancia-espacial, fig.cap="Dist√¢ncia espacial das nascentes at√© o fragmento de floresta mais pr√≥xima no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_dist_flo[7], pch = 20, axes = TRUE, graticule = TRUE, main = NA)
```

**Raster**

As principais opera√ß√µes espaciais para dados raster podem ser classificas, segundo Lovelace et al. [-@lovelace2019], em: i) opera√ß√µes locais (por c√©lula), ii) opera√ß√µes focais (por bloco de m√∫ltiplas c√©lulas regulares - e.g. 3x3), iii) opera√ß√µes zonais (por bloco de m√∫ltiplas c√©lulas irregulares) e iv) opera√ß√µes globais (por um ou v√°rios rasters inteiros). Cada uma delas √© aplicada para objetivos e escalas espaciais espec√≠ficas. Para os exemplos desta se√ß√£o, utilizaremos o dado raster de eleva√ß√£o para o munic√≠pio de Rio Claro/SP.

**Opera√ß√µes locais**

As opera√ß√µes locais contemplam todas as opera√ß√µes realizadas c√©lula a c√©lula em uma ou v√°rias camadas de um objeto raster. A √°lgebra de raster √© uma das mais comuns, simples e poderosas opera√ß√µes no R envolvendo rasters. Com ela podemos fazer opera√ß√µes simples atrav√©s de operadores aritm√©ticos (soma, subtra√ß√£o, multiplica√ß√£o, divis√£o ou potencia√ß√£o) entre dois ou mais objetos raster, ou utilizar fun√ß√µes para alterar todos os valores dos pixels como, por exemplo, as fun√ß√µes `lo10()` ou `sqrt()`, ou ainda a fun√ß√£o `raster::scale()` para padronizar ou centralizar os valores dos rasters (Figura \@ref(fig:fig-raster-local-aritmetico)).

```{r}
## Soma
geo_raster_srtm_rio_claro2 <- geo_raster_srtm_rio_claro + geo_raster_srtm_rio_claro

## Log10
geo_raster_srtm_rio_claro_log10 <- log10(geo_raster_srtm_rio_claro)
```

```{r fig-raster-local-aritmetico, fig.cap="Rasters de soma e log10 do mapa de eleva√ß√£o para Rio Claro/SP."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_raster_srtm_rio_claro2, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_raster_srtm_rio_claro_log10, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

Al√©m das opera√ß√µes aritm√©ticas, a √°lgebra de rasters tamb√©m permite opera√ß√µes l√≥gicas, como criar um raster (bin√°rio - composto por 1 quando a opera√ß√£o l√≥gica √© verdadeira, e 0 quanto √© falsa). Em nosso caso, buscamos todos os pixels acima de 600 metros para o raster de eleva√ß√£o de Rio Claro/SP (Figura \@ref(fig:fig-raster-local-logico)).

```{r}
## Acima de 600
geo_raster_srtm_rio_claro_acima_600 <- geo_raster_srtm_rio_claro > 600
```

```{r fig-raster-local-logico, fig.cap="Opera√ß√£o local l√≥gica mostrando todos os pixels acima de 600 metros de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_acima_600, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Al√©m dos operadores aritm√©ticos, tamb√©m podemos usar as fun√ß√µes `raster::calc()` (uma camada) e `raster::overlay()` (duas ou mais camadas) para realizar opera√ß√µes em todas as c√©lulas. Elas funcionam com a cria√ß√£o de uma fun√ß√£o espec√≠fica atrav√©s da fun√ß√£o `function()` (Cap√≠tulo \@ref(cap4)), para que esta seja aplicada em todas as c√©lulas do raster. Essas fun√ß√µes s√£o muito eficientes, portanto, s√£o prefer√≠veis para grandes conjuntos de dados raster. Exemplificaremos essa opera√ß√£o calculando o produto de todos os pixels por eles mesmos do raster de eleva√ß√£o de Rio Claro/SP (Figura \@ref(fig:fig-raster-local-calc)).

```{r}
## Produto dos pixel - calc
geo_raster_srtm_rio_claro_prod <- raster::calc(x = geo_raster_srtm_rio_claro, fun = function(x){x * x})
geo_raster_srtm_rio_claro_prod 
```

```{r fig-raster-local-calc, fig.cap="Opera√ß√£o local de multiplica√ß√£o de todos os pixels por eles mesmos do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_prod, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A predi√ß√£o de objetos raster (utilizando a fun√ß√£o `raster::predict()`) √© outra aplica√ß√£o extremamente √∫til em opera√ß√µes locais, n√≥s a veremos mais √† frente nesse cap√≠tulo. Essa fun√ß√£o possui basicamente dois argumentos: `object` que √© os rasters preditores e `model` com o modelo ajustado para o qual os valores ser√£o preditos com base nos valores dos rasters. A partir da rela√ß√£o entre vari√°veis respostas (e.g, pontos no espa√ßo, como ocorr√™ncia ou riqueza de esp√©cies), e vari√°veis preditoras (rasters cont√≠nuos de eleva√ß√£o, pH, precipita√ß√£o, temperatura, cobertura da terra ou classe de solo), criamos modelos usando fun√ß√µes como `lm()`, `glm()`, `gam()` ou uma t√©cnica de aprendizado de m√°quina, e fazemos predi√ß√µes espaciais aplicando os coeficientes estimados aos valores dos raster preditores (consulte od Cap√≠tulos \@ref(cap7) e \@ref(cap8)).

Por fim, a reclassifica√ß√£o de rasters √© outra opera√ß√£o muito comum quando trabalhamos com rasters. Nela √© realizada a classifica√ß√£o de intervalos de valores num√©ricos em grupos, e.g. agrupar um modelo digital de eleva√ß√£o em classes de valores. A fun√ß√£o que faz essa opera√ß√£o √© a `raster::reclassify()`. Ela possui dois argumentos: `x` que √© o raster a ser reclassificado, e o segundo `rcl` para o qual devemos construir uma matriz de reclassifica√ß√£o, onde a primeira coluna √© a extremidade inferior, a segunda coluna √© a extremidade superior, e a terceira coluna representa o novo valor para os intervalos das colunas um e dois. Vamos reclassificar o raster de eleva√ß√£o de Rio Claro/SP para os intervalos 400--600, 600--800 e 800--1000 que s√£o reclassificados para os valores 1, 2 e 3, respectivamente (Figura \@ref(fig:fig-raster-local-reclassificacao)).

```{r}
## Matriz de reclassifica√ß√£o
rcl  <- matrix(c(400,600,1, 
                 600,800,2, 
                 800,1000,3), 
               ncol = 3, byrow = TRUE)

## Reclassifi√ß√£o
geo_raster_srtm_rio_claro_rcl <- raster::reclassify(x = geo_raster_srtm_rio_claro, rcl = rcl)
```

```{r fig-raster-local-reclassificacao, fig.cap="Opera√ß√£o local de reclassifica√ß√£o para tr√™s classes de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_rcl, col = viridis::viridis(3))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Opera√ß√µes focais**

As opera√ß√µes focais levam em considera√ß√£o uma c√©lula central e seus vizinhos. A vizinhan√ßa (tamb√©m chamada de janela m√≥vel - *moving window*) tipicamente √© composta de c√©lulas de 3 por 3 (c√©lula central e seus oito vizinhos), mas pode assumir outra forma. A opera√ß√£o focal aplica uma fun√ß√£o de agrega√ß√£o a todas as c√©lulas dentro da vizinhan√ßa especificada, e usa a sa√≠da correspondente como o novo valor para a c√©lula central, e segue para a pr√≥xima c√©lula central e seus vizinhos. Essa opera√ß√£o √© realizada atrav√©s da fun√ß√£o `raster::focal()`. O par√¢metro `x` especifica o raster de entrada, o par√¢metro `w` define a janela m√≥vel por uma matriz cujos valores correspondem a pesos, e por fim, o par√¢metro `fun` especifica a fun√ß√£o que desejamos aplicar √†s c√©lulas, como `min()`, `max()`, `sum()`, `mean()`, `sd()` ou `var()`. Existem diversas aplica√ß√µes dessa opera√ß√£o para dados raster, como no processamento de imagens de sat√©lite (ver mais em Wegmann et al. [-@wegmann2016]). Outra utilidade √© para o c√°lculo de caracter√≠sticas topogr√°ficas, como declividade, aspecto e dire√ß√µes de fluxo. Para calcular essas m√©tricas espec√≠ficas, podemos utilizar a fun√ß√£o `raster::terrain()`.

Para nosso exemplo, vamos realizar o c√°lculo do desvio padr√£o da eleva√ß√£o e a m√©trica de aspecto (orienta√ß√£o da vertente) para o raster de eleva√ß√£o em Rio Claro/SP (Figura \@ref(fig:fig-raster-focal)).

```{r}
## Janela m√≥vel - moving window
geo_raster_srtm_rio_claro_focal_sd <- raster::focal(
    x = geo_raster_srtm_rio_claro, 
    w = matrix(data = 1, nrow = 3, ncol = 3), 
    fun = sd)

## Declividade
geo_raster_srtm_rio_claro_asp <- raster::terrain(x = geo_raster_srtm_rio_claro, opt = "aspect")
```

```{r fig-raster-focal, fig.cap="C√°lculo do desvio padr√£o da eleva√ß√£o para uma janela de 3x3 e do aspecto para Rio Claro/SP."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_raster_srtm_rio_claro_focal_sd, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_raster_srtm_rio_claro_asp, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

**Opera√ß√µes zonais**

As opera√ß√µes zonais aplicam uma fun√ß√£o de agrega√ß√£o para v√°rias c√©lulas de um raster. Geralmente usa-se um segundo raster categ√≥rico para definir as zonas, de modo que as c√©lulas raster que definem a zona n√£o precisam ser vizinhas, como na opera√ß√£o focal. O resultado de uma opera√ß√£o zonal √© uma tabela de resumo agrupada por zona, explicando porque essa opera√ß√£o tamb√©m √© conhecida como estat√≠stica zonal. Isso √© um contraste com as opera√ß√µes focais que retornam um objeto raster.

A opera√ß√£o zonal √© realizada atrav√©s da fun√ß√£o `raster::zonal()`, que recebe de entrada no `x` o raster cont√≠nuo, em `z` o raster categ√≥rico, e em `fun` a fun√ß√£o que resumir√° as c√©lulas. Em nosso exemplo, vamos calcular diversas medidas resumo da eleva√ß√£o com a fun√ß√£o `summary()` para cada classe de eleva√ß√£o que criamos anteriormente.

```{r}
## Estat√≠stica zonal
geo_raster_srtm_rio_claro_zonal <- data.frame(raster::zonal(geo_raster_srtm_rio_claro, geo_raster_srtm_rio_claro_rcl, fun = "summary"))
colnames(geo_raster_srtm_rio_claro_zonal) <- c("zona", "min", "1qt", "mediana", "media", "3qt", "max")
geo_raster_srtm_rio_claro_zonal
```

**Opera√ß√µes globais**

As opera√ß√µes globais usam todo o conjunto de dados raster representando uma √∫nica zona. As opera√ß√µes globais mais comuns s√£o estat√≠sticas descritivas para todos os pixels do raster, utilizando a fun√ß√£o `raster::cellStats()` ou `raster::freq()`, j√° vistas. Al√©m das estat√≠sticas descritivas, podemos gerar rasters de dist√¢ncia, que calcula a dist√¢ncia de cada c√©lula a uma ou um grupo c√©lulas-alvo espec√≠fica, utilizando a fun√ß√£o `raster::distance()`.

Em nosso exemplo, vamos selecionar os pixels abaixo de 500 m do raster de eleva√ß√£o e calcular a Dist√¢ncia Euclidiana (Figura \@ref(fig:fig-raster-global)).

```{r}
## Dist√¢ncia euclidiana
geo_raster_srtm_rio_claro_abaixo_500 <- raster::calc(
    x = geo_raster_srtm_rio_claro, 
    fun = function(x) ifelse(x < 500, 1, NA))
geo_raster_srtm_rio_claro_global_dist <- raster::distance(geo_raster_srtm_rio_claro_abaixo_500)
```

```{r fig-raster-global, fig.cap="Raster de dist√¢ncia Euclidiana dos pixels abaixo de 500 m de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_global_dist, col = viridis::viridis(10))
plot(geo_raster_srtm_rio_claro_abaixo_500, add = TRUE, col = "white", legend = FALSE)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

### Opera√ß√µes geom√©tricas

As opera√ß√µes geom√©tricas realizam modifica√ß√µes em objetos geoespaciais baseado na geometria do vetor ou do raster e na intera√ß√£o e convers√£o entre vetor-raster. As opera√ß√µes geom√©tricas vetoriais podem ser un√°rias (funcionam em uma √∫nica geometria) ou bin√°rias (modificam uma geometria com base na forma de outra geometria). Ainda podemos fazer transforma√ß√µes para alterar os tipos vetores, que refletir√° se as fei√ß√µes s√£o √∫nicas ou m√∫ltiplas, inclusive na tabela de atributos. As opera√ß√µes geom√©tricas em rasters envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels subjacentes e atribuir-lhes novos valores. Por fim, podemos ainda fazer opera√ß√µes de intera√ß√µes e convers√µes entre raster-vetor para ajustar rasters a vetores, assim como converter um objeto espacial vetorial para raster e vice-versa.

**Vetor**

Como dissemos, as opera√ß√µes geom√©tricas em vetores criar√£o ou alterar a geometria de objetos da classe `sf`, podendo fazer altera√ß√µes em √∫nica geometria (un√°rias): i) simplifica√ß√£o, ii) centroides, iii) pontos aleat√≥rios, iv) buffers, v) pol√≠gono convexo, vi) pol√≠gonos de Voronoi, vii) quadr√≠culas e hex√°gonos; ou modificar uma geometria com base na forma de outra geometria (bin√°rias), viii) uni√£o e ix) recortes; ou ainda fazer transforma√ß√µes de tipo de geometrias.

Para exemplificar as opera√ß√µes geom√©tricas com vetores, vamos utilizar os dados do limite, nascentes, hidrologia e cobertura da terra para o munic√≠pio de Rio Claro/SP.

**Simplifica√ß√£o**

A simplifica√ß√£o possui o intuito de generalizar linhas ou pol√≠gonos, diminuindo assim suas complexidades em rela√ß√£o ao n√∫mero de v√©rtices. √â utilizada para representa√ß√£o em mapas menores ou mapas interativos ou ainda quando um objeto vetorial √© muito grande. A fun√ß√£o utilizada √© a `sf::st_simplify()`, que usa o argumento `x` para uma geometria de entrada e `dTolerance` para controlar o n√≠vel de generaliza√ß√£o nas unidades do mapa. Em nosso exemplo, simplificaremos a hidrografia de Rio Claro/SP (Figura \@ref(fig:fig-vetor-simplificacao)).

```{r}
## Simplifica√ß√£o
geo_vetor_hidrografia_simplificado <- sf::st_simplify(x = geo_vetor_hidrografia, dTolerance = 1000)
```

```{r fig-vetor-simplificacao, fig.cap="Simplifica√ß√£o da hidrografia para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_hidrografia$geometry, col = "steelblue", lwd = 2, add = TRUE)
plot(geo_vetor_hidrografia_simplificado$geometry, col = adjustcolor("black", .7), add = TRUE)
```

**Centroides**

A opera√ß√£o de centroides identifica o centro de objetos geoespaciais, geralmente o centro de massa das fei√ß√µes. √â utilizado para gerar um ponto simples para representa√ß√µes complexas ou para estimar a dist√¢ncia entre pol√≠gonos utilizando esse centroide. Podemos calcul√°-los com a fun√ß√£o `sf::st_centroids()` ou com a fun√ß√£o `sf::st_point_on_surface()` para garantir que esses centroides caiam dentro das geometrias. Aqui calcularemos o centroide do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-centroide)).

```{r}
## Centroides
geo_vetor_rio_claro_sirgas2000_utm23s_cent <- sf::st_centroid(geo_vetor_rio_claro_sirgas2000_utm23s)
```

```{r fig-vetor-centroide, fig.cap="Centroide do limite do munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_cent$geom, cex = 3, pch = 20, add = TRUE)
```

**Pontos aleat√≥rios**

Por vezes precisamos criar algum padr√£o aleat√≥rio dentro de um contexto espacial. Isso pode ser realizado de diversas formas. Uma delas √© a cria√ß√£o de pontos aleat√≥rios dentro de um pol√≠gono. Podemos realizar essa opera√ß√£o com a fun√ß√£o `sf::st_sample()`. Para essa fun√ß√£o, dois argumentos s√£o utilizados: `x` uma geometria de entrada e o `size` indicando o n√∫mero de pontos √† seres criados. Outro argumento bastante interessante √© o `type`, indicando o tipo de amostragem espacial (aleat√≥rio, regular ou triangular). Para nosso exemplo, vamos fixar a amostragem utilizando a fun√ß√£o `set.seed()` e sortear 30 pontos para o limite do munic√≠pio de Rio Claro/SP (\@ref(fig:fig-vetor-pontos-aleatorios)). Para mais detalhes da fun√ß√£o `set.seed()`, consultar o Cap√≠tulo \@ref(cap4).

```{r}
## Fixar amostragem
set.seed(42)

## Pontos aleat√≥rios
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios <- sf::st_sample(geo_vetor_rio_claro_sirgas2000_utm23s, size = 30)
```

```{r fig-vetor-pontos-aleatorios, fig.cap="Sorteio de 30 pontos aleat√≥rio para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, add = TRUE)
```

**Buffer**

Buffers s√£o pol√≠gonos que representam a √°rea dentro de uma determinada dist√¢ncia de um elemento geom√©trico, independentemente de ser um ponto, linha ou pol√≠gono. O buffer √© comumente utilizado para an√°lise de dados geoespaciais, geralmente sendo entendio como uma unidade amostral, delimitando uma por√ß√£o no entorno de algum elemento ou evento, como as condi√ß√µes clim√°ticas ou da estrutura da paisagem para uma amostragem, ou as caracter√≠sticas de cobertura da terra ao longo de um corpo d'√°gua, e.g., √Åreas de Preserva√ß√£o Permanente (APPs).

A fun√ß√£o utilizada para criar buffers √© a `sf::st_buffer()`, que requer pelo menos dois argumentos: `x` uma geometria de entrada e o `dist` uma dist√¢ncia para o buffer, fornecido nas unidades do CRS da geometria de entrada. Em nosso exemplo, vamos criar buffers circulares de 1000 metros para os 30 pontos aleat√≥rios criados anteriormente para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-buffer)).

```{r}
## Buffer
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer <- sf::st_buffer(
    x = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, dist = 1000)
```

```{r fig-vetor-buffer, fig.cap="Buffers de 1000 metros para os 30 pontos aleat√≥rios no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

Podemos ainda criar buffers quadrados acrescentando o argumento `uendCapStyle = "SQUARE"` (Figura \@ref(fig:fig-vetor-buffer-quad)).

```{r}
## Buffer
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_quad <- sf::st_buffer(
    x = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, dist = 1000, endCapStyle = "SQUARE")
```

```{r fig-vetor-buffer-quad, fig.cap="Buffers quadrados de 1000 metros para os 30 pontos aleat√≥rios no munic√≠pio de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_quad, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```


**Pol√≠gono convexo**

Uma an√°lise bastante comum, principalmente realizada pela IUCN, √© a cria√ß√£o de pol√≠gonos convexos, para definir a extens√£o de ocorr√™ncia de uma esp√©cie (*Extent of occurrence* - EOO). Nesse sentido, essa opera√ß√£o ligar√° os pontos externos de um conjunto de pontos e cria um pol√≠gono a partir deles. Podemos criar esse pol√≠gono com a fun√ß√£o `sf::st_convex_hull()`. Um √∫nico passo que precisamos adiantar √© utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto `sf` `MULTIPOINT`, j√° iremos explicar com mais detalhes adiante. Vamos utilizar os pontos aleat√≥rios que criamos anteriormente para criar o pol√≠gono convexo (Figura \@ref(fig:fig-vetor-convexo)).

```{r}
## Pol√≠gono convexo
geo_vetor_rio_claro_sirgas2000_utm23s_convexo <- geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios %>% 
    sf::st_union() %>% 
    sf::st_convex_hull()
```

```{r fig-vetor-convexo, fig.cap="Pol√≠gono convexo para os 30 pontos criados aleatoriamente para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_convexo, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

**Pol√≠gonos de Voronoi**

Uma outra forma de criar pol√≠gonos para resumir dados espaciais √© atrav√©s dos Pol√≠gonos de Voronoi ou Diagrama de Voronoi. Nele, pol√≠gonos irregulares s√£o criados a partir da proximidade de pontos, de modo a estimar uma √°rea de abrang√™ncia no entorno dos mesmos [@okabe_spatial_2000]. Esses pol√≠gonos podem ser criados com a fun√ß√£o `sf::st_voronoi()`, mas precisamos novamente utilizar a fun√ß√£o `sf::st_union()` para unir todos os pontos e criar um objeto `sf` do tipo `MULTIPOINT`. Vamos utilizar os pontos aleat√≥rios que criamos anteriormente para criar o pol√≠gono de Voronoi (Figura \@ref(fig:fig-vetor-voronoi)).

```{r}
## Pol√≠gonos de Voronoi
geo_vetor_rio_claro_sirgas2000_utm23s_voronoi <- geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios %>% 
    sf::st_union() %>% 
    sf::st_voronoi()
```

```{r fig-vetor-voronoi, fig.cap="Pol√≠gonos de Voronoi para os 30 pontos criados aleatoriamente para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_voronoi, col = NA, lwd = 2, border = "red", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios, pch = 20, cex = 1, add = TRUE)
```

**Quadr√≠culas e hex√°gonos**

Muitas vezes precisamos criar unidades espaciais id√™nticas e igualmente espa√ßadas para resumir informa√ß√µes dispersas por toda a nossa √°rea de estudo. Uma pr√°tica muito comum √© a cria√ß√£o de um gride de pontos ou quadr√≠culas em toda a √°rea de estudo, e depois utilizar essas geometrias para associar ou resumir informa√ß√µes espacializadas, como a IUCN utiliza para a an√°lise de √°rea de ocupa√ß√£o (*Are of occupancy* - AOO). Al√©m das quadr√≠culas, uma outra geometria que se tornou bastante comum para as finalidades descritas, √© a cria√ß√£o de hex√°gonos, que al√©m de serem mais esteticamente atraentes, possuem uma explica√ß√£o matem√°tica de sua melhor funcionalidade para an√°lises espaciais em Ecologia [@birch_rectangular_2007].

A fun√ß√£o utilizada para criar esses grides √© a `sf::st_make_grid()`, que requer pelo menos dois argumentos: `x` uma geometria de entrada e o `cellsize` indicando o tamanho do gride a ser criado, fornecido nas unidades do CRS da geometria de entrada. H√° diversos outros argumentos, mas os mais importantes s√£o o `square` que definir√° se o gride ser√° de quadriculas ou de hex√°gonos, e o `what` que definir√° se geraremos pol√≠gonos, cantos ou centroides.

Em nosso exemplo, vamos criar quadr√≠culas e hex√°gonos de 2000 metros (i.e. 4000000 metros quadrados) para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-quad) e Figura \@ref(fig:fig-vetor-hex)). Podemos ainda utilizar as fun√ß√µes de filtros espaciais (Tabela \@ref(tab:tab-filtro-espacial)) para definir como selecionaremos esses elementos para a √°rea de estudo. Aqui utilizamos a fun√ß√£o `sf::st_intersects()`.

```{r}
## Quadr√≠culas
geo_vetor_rio_claro_sirgas2000_utm23s_grid <- sf::st_make_grid(
    x = geo_vetor_rio_claro_sirgas2000_utm23s, cellsize = 2000, what = "polygons") %>%
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_rio_claro_sirgas2000_utm23s, sparse = FALSE))

## Centroides das quadr√≠culas
geo_vetor_rio_claro_sirgas2000_utm23s_grid_cent <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, what = "centers") %>%
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., y = sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_grid), sparse = FALSE))
```

```{r fig-vetor-quad, fig.cap="Quadr√≠culas de 2000 metros de arestas e centroides para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_grid, col = NA, border = "red", lwd = 2, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_grid_cent, pch = 20, add = TRUE)
```

```{r}
## Hex√°gonos
geo_vetor_rio_claro_sirgas2000_utm23s_hex <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, square = FALSE) %>% 
    sf::st_as_sf() %>%
    dplyr::filter(sf::st_intersects(x = ., 
                                    y = geo_vetor_rio_claro_sirgas2000_utm23s, 
                                    sparse = FALSE))

## Centroides de hex√°gonos
geo_vetor_rio_claro_sirgas2000_utm23s_hex_cent <- geo_vetor_rio_claro_sirgas2000_utm23s %>% 
    sf::st_make_grid(cellsize = 2000, square = FALSE, what = "centers") %>% 
    sf::st_as_sf() %>% 
    dplyr::filter(sf::st_intersects(x = ., 
                                    y = sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_hex),
                                    sparse = FALSE))
```

```{r fig-vetor-hex, fig.cap="Hex√°gonos equivalentes a quadr√≠culas de 2000 metros de arestas e centroides para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex, col = NA, border = "red", lwd = 2, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex_cent, pch = 20, add = TRUE)
```

**Uni√£o ("dissolver")**

Como vimos, na agrega√ß√£o por atributos podemos dissolver as geometrias de pol√≠gonos do mesmo grupo pelos valores da tabela de atributos, onde, naquele exemplo, contabilizamos quantas nascentes haviam por pol√≠gono de cobertura da terra para o munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-vetor-agregacao-espacial)).

Nesta se√ß√£o, vamos utilizar a fun√ß√£o `sf::st_union()` para unir diversas fei√ß√µes em uma s√≥, dissolvendo os limites entre elas. Vamos utilizar de exemplo os buffers que criamos a partir dos 30 pontos aleat√≥rios (Figura \@ref(fig:fig-vetor-uniao)).

```{r}
## Uni√£o
geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao <- sf::st_union(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer)
```

```{r fig-vetor-uniao, fig.cap="Uni√£o - dissolu√ß√£o - dos buffers criados a partir de pontos aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
```

**Recorte e apagar ("clipar" e "erase")**

O recorte realiza um subconjunto espacial envolvendo dois objetos geoespaciais. O recorte √© aplicado somente a linhas e pol√≠gonos, ou seja, usaremos linhas e pol√≠gonos para recortar linhas ou pol√≠gonos. Esse recorte pode ser realizado de tr√™s formas: i) intersec√ß√£o (subconjunto das geometrias sobrepostas entre os dois objetos), ii) diferen√ßa (subconjunto das geometrias do primeiro objeto sem sobreposi√ß√£o com o segundo objeto), e iii) diferen√ßa sim√©trica (apenas as geometrias n√£o sobrepostas entre os dois objetos). Respectivamente para cada uma dessas opera√ß√µes temos fun√ß√µes espec√≠ficas: `sf::st_intersection()`, `sf::st_difference()` e `sf::st_sym_difference()`.

Para nosso exemplo, faremos o recorte da hidrografia em rela√ß√£o aos buffers criados e unidos para os 30 pontos aleat√≥rios em Rio Claro/SP. Primeiramente, fazeremos o recorte para dentro dos buffers com a fun√ß√£o `sf::st_intersection()` (Figura \@ref(fig:fig-vetor-interseccao)).

```{r}
## Recorte - intersec√ß√£o
geo_vetor_hidrografia_interseccao <- sf::st_intersection(x = geo_vetor_hidrografia, y = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig-vetor-interseccao, fig.cap="Recorte da hidrografia para dentro dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(geo_vetor_hidrografia_interseccao$geometry, col = "blue", add = TRUE)
```

Para nosso segundo exemplo, realizamos o recorte da hidrografia em rela√ß√£o aos buffers, mas agora para fora dos buffers utilizando a fun√ß√£o `sf::st_difference()` (Figura \@ref(fig:fig-vetor-difereca)), que seria semelhando a opera√ß√£o de apagar ("erase").

```{r}
## Recorte - diferen√ßa
geo_vetor_hidrografia_diferenca <- sf::st_difference(x = geo_vetor_hidrografia, y = geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao)
```

```{r fig-vetor-difereca, fig.cap="Recorte da hidrografia para fora dos buffers dos 30 aleat√≥rios para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s_pontos_aleatorios_buffer_uniao, col = adjustcolor("blue", .1), add = TRUE)
plot(geo_vetor_hidrografia_diferenca$geometry, col = "blue", add = TRUE)
```

**Transforma√ß√µes de tipo**

Esse t√≥pico possui muitas funcionalidades, que s√£o exploradas no t√≥pico "5.2.7 Type transformations" de Lovelace et al. [-@lovelace2019]. Aqui, nosso interesse principal √© em rela√ß√£o √† transforma√ß√£o dos tipos de objetos geoespaciais da classe `sf`: `MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`, para `POINT`, `LINESTRING` e `POLYGON`. Muitas vezes as fei√ß√µes de nossos objetos, i.e., as linhas da tabela de atributos est√£o agrupadas em apenas uma linha da tabela. Quando o objeto espacial est√° nesse formato, geralmente em alguma classe dessas (`MULTIPOINT`, `MULTILINESTRING` e `MULTIPOLYGON`), n√£o temos como realizar opera√ß√µes espaciais ou geom√©tricas para cada fei√ß√£o, e precisamos separ√°-las em linhas diferentes para que opera√ß√µes como o c√°lculo de comprimento ou √°rea seja poss√≠vel para cada fei√ß√£o.

Dessa forma, podemos utilizar a fun√ß√£o `sf::st_cast()` para fazer essas transforma√ß√µes e atribuir cada fei√ß√£o a uma linha da tabela de atributos. Como exemplo, vamos separar os fragmentos de floresta e calcular a √°rea para cada fei√ß√£o em hectares (Figura \@ref(fig:fig-vetor-tipo)).

```{r}
## Transforma√ß√£o de tipo
geo_vetor_cobertura_floresta_polygon <- geo_vetor_cobertura_floresta %>% 
    sf::st_cast("POLYGON") %>% 
    dplyr::mutate(area_ha = sf::st_area(.)/1e4 %>% round(2))
```

```{r fig-vetor-tipo, fig.cap="Transforma√ß√£o do vetor de florestas em `POLYGON` e c√°lculo da √°rea para cada fei√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = "gray", main = NA, axes = TRUE, graticule = TRUE)
plot(geo_vetor_cobertura_floresta_polygon["area_ha"], col = viridis::viridis(100),  add = TRUE)
```

**Raster**

As opera√ß√µes geom√©tricas em rasters envolvem mudar a posi√ß√£o, tamanho e n√∫mero dos pixels e atribuir novos valores, geralmente aumentando ou diminuindo o tamanho desses pixels. Essas opera√ß√µes permitem alinhar rasters de diversas fontes, fazendo com que compartilhem uma correspond√™ncia entre seus pixels, permitindo que eles sejam processados todos juntos, ou simplesmente permite a realiza√ß√£o de an√°lises que demorariam muito, caso os rasters possuam um tamanho de pixel muito pequeno.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essas opera√ß√µes funcionam para as tr√™s classes dos objetos raster: `RasterLayer`, `RasterBrick` e `RasterStack`.
:::

Para exemplificar as opera√ß√µes geom√©tricas com rasters, vamos utilizar os dados de eleva√ß√£o para o munic√≠pio de Rio Claro/SP e bioclim√°ticos para o mundo.

**Agrega√ß√£o**

Na agrega√ß√£o de rasters, aumentaremos o tamanho dos pixels (diminuindo a resolu√ß√£o), agregando os valores dos pixels em um pixel maior. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::aggregate()`, que possui tr√™s argumentos: `x` corresponde ao objeto raster de entrada, `fact` √© o fator de agrega√ß√£o e corresponde ao n√∫mero que definir√° o novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de agrega√ß√£o de 10 far√° com o novo raster tenha a resolu√ß√£o de 900 m), e `fun` √© a fun√ß√£o utilizada para realizar a agrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-agregacao)).

Em nosso exemplo, vamos aumentar o tamanho dos pixels para 900 metros do raster de eleva√ß√£o para Rio Claro/SP.

```{r}
## Agrega√ß√£o - aumentar o tamanho do pixel
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media <- raster::aggregate(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, fact = 10, fun = "mean")
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media
```

```{r fig-raster-agregacao, fig.cap="Agrega√ß√£o (aumento do pixel para 900 metros) utilizando a m√©dia para o raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Desagrega√ß√£o**

De modo contr√°rio, na desagrega√ß√£o de rasters, diminuiremos o tamanho dos pixels (aumentando a resolu√ß√£o), preenchendo com novos valores. Podemos realizar essa opera√ß√£o com a fun√ß√£o `raster::desaggregate()`, que assim como a fun√ß√£o anterior, possui tr√™s argumentos: `x` corresponde ao objeto raster de entrada, `fact` √© o fator de desagrega√ß√£o e corresponde ao n√∫mero que definir√° o novo tamanho do pixel (e.g. se um raster tem resolu√ß√£o de 90 m, um fator de desagrega√ß√£o de 2 far√° com que o novo raster tenha a resolu√ß√£o de 45 m), e `method` √© a fun√ß√£o utilizada para realizar a desagrega√ß√£o dos pixels (Figura \@ref(fig:fig-raster-desagregacao)).

Nesse exemplo, vamos diminuir o tamanho dos pixels para 45 metros do raster de eleva√ß√£o para Rio Claro/SP.

```{r}
## Desagrega√ß√£o - diminuir o tamanho do pixel
geo_raster_srtm_rio_claro_desg_bil <- raster::disaggregate(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, fact = 2, method = "bilinear")
geo_raster_srtm_rio_claro_desg_bil
```

```{r fig-raster-desagregacao, fig.cap="Desagrega√ß√£o (diminui√ß√£o do pixel para 45 metros) utilizando o m√©todo bilinear para o raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_desg_bil, col = viridis::viridis(10))
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Alinhamento de rasters**

Muitas vezes queremos ir al√©m de ajustar o tamanho do pixel, ajustando tamb√©m a extens√£o, n√∫mero e origem dos pixels para v√°rias camadas rasters, principalmente se precisamos criar objetos das classes `RasterBrick` ou `RasterStack`. Dessa forma, podemos utilizar a fun√ß√£o `raster::compareRaster()` para comparar os rasters em rela√ß√£o a extens√£o, n√∫mero de linhas e colunas, proje√ß√£o, resolu√ß√£o e origem (ou um subconjunto dessas compara√ß√µes).

Podemos utilizar a fun√ß√£o `raster::resample()` para fazer esse alinhamento, ou ainda a fun√ß√£o `gdalUtils::align_rasters()`. Para a primeira fun√ß√£o, os argumentos s√£o `x` para o raster de entrada, `y` para o raster de alinhamento e `method` para o m√©todo utilizado no alinhamento. Para nosso exemplo, vamos ajustar uma camada bioclim√°tica (BIO01) √† camada de eleva√ß√£o para Rio Claro/SP (Figura \@ref(fig:fig-raster-reamostragem)).

```{r}
## Reamostragem
geo_raster_bioclim_rc <- raster::resample(x = geo_raster_bioclim$bio01, 
                                          y = geo_raster_srtm_rio_claro, 
                                          method = "bilinear")
geo_raster_bioclim_rc
```

```{r fig-raster-reamostragem, fig.cap="Reamostragem (alinhamento dos rasters) utilizando o m√©todo bilinear para alinhar o raster bioclim√°tico (BIO01) ao de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_bioclim, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Intera√ß√µes raster-vetor**

Podemos fazer opera√ß√µes da intera√ß√£o entre objetos vetoriais e raster, como ajustes da extens√£o e limite do raster para vetores (corte e m√°scara), extra√ß√£o dos valores dos pixels para vetores (pontos, linhas e pol√≠gonos), e estat√≠sticas zonais dos valores dos pixels dos raster para um vetor (pol√≠gonos).

**Cortes e m√°scaras**

Muitas vezes precisamos ajustar o tamanho de um objeto raster a uma √°rea menor de interesse, geralmente definido por um objeto vetorial. Para realizar essa opera√ß√£o, dispomos de duas fun√ß√µes: `raster::crop()` e `raster::mask()`.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
√â fundamental que ambos os objetos raster a ser reduzido e o vetor como molde precisam estar no mesmo CRS.
:::

A fun√ß√£o `raster::crop()` ajusta o raster √† extens√£o do vetor. Como exemplo, vamos retomar o raster de eleva√ß√£o original baixado e importado anteriormente (Figura \@ref(fig:fig-raster-dem)). Primeiramente, vamos usar a fun√ß√£o `raster::crop()` para ajustar esse raster √† extens√£o do limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte)).

```{r}
## Crop - adjuste da extens√£o
geo_raster_srtm_rio_claro_crop <- raster::crop(geo_raster_srtm, geo_vetor_rio_claro)
```

```{r fig-raster-corte, fig.cap="Ajuste da extens√£o do raster de eleva√ß√£o para a extens√£o de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster ao limite do munic√≠pio de Rio Claro/SP, vamos usar a fun√ß√£o `raster::mask()`. √â importante notar que essa fun√ß√£o preenche com `NAs` os pixels que est√£o fora do limite do pol√≠gono e n√£o ajusta a extens√£o (Figura \@ref(fig:fig-raster-corte)).

```{r}
## Mask - adjuste ao limite
geo_raster_srtm_rio_claro_mask <- raster::mask(geo_raster_srtm, geo_vetor_rio_claro)
```

```{r fig-raster-mascara, fig.cap="Ajuste do raster de eleva√ß√£o para o limite de Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_mask, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Para ajustar o raster √† extens√£o e ao limite do munic√≠pio de Rio Claro/SP, precisamos utilizar conjuntamente as fun√ß√µes `raster::crop()` e `raster::mask()` (Figura \@ref(fig:fig-raster-corte-mascara)).

```{r}
## Crop e mask - ajuste da extens√£o e do limite
geo_raster_srtm_rio_claro_crop_mask <- geo_raster_srtm %>% 
    raster::crop(geo_vetor_rio_claro) %>% 
    raster::mask(geo_vetor_rio_claro)
```

```{r fig-raster-corte-mascara, fig.cap="Ajuste da extens√£o e do limite do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop_mask, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

A fun√ß√£o `raster::mask()` possui ainda um argumento chamado `inverse`, que cria uma m√°scara inversa ao limite, preenchendo com `NA` o pixels internos ao limite do pol√≠gono, como podemos ver para o raster de eleva√ß√£o e o limite de Rio Claro/SP (Figura \@ref(fig:fig-raster-corte-mascara-inverso)).

```{r}
## Crop e mask inversa - ajuste da extens√£o e do limite inverso
geo_raster_srtm_rio_claro_crop_mask_inv <- geo_raster_srtm %>% 
    raster::crop(geo_vetor_rio_claro) %>% 
    raster::mask(geo_vetor_rio_claro, inverse = TRUE)
```

```{r fig-raster-corte-mascara-inverso, fig.cap="Ajuste da extens√£o e do limite externo do raster de eleva√ß√£o para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_crop_mask_inv, col = viridis::viridis(10))
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Extra√ß√£o**

A intera√ß√£o entre raster-vetor de extra√ß√£o √© o processo que identifica e retorna valores associados de pixels de um raster com base em um objeto vetorial. √â uma opera√ß√£o extremamente comum em an√°lises espaciais, principalmente para associar valores de raster ambientais (cont√≠nuos ou categ√≥ricos) a pontos de ocorr√™ncia ou amostragem. Os valores retornados depender√£o do tipo vetor (pontos, linhas ou pol√≠gonos) e de argumentos da fun√ß√£o `raster::extract()` que alteram o funcionamento da extra√ß√£o.

Em nosso exemplo, vamos extrair os valores do raster de eleva√ß√£o para as nascentes do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-extracao)).

```{r}
## Extra√ß√£o
geo_vetor_nascentes_ele <- geo_vetor_nascentes %>% 
    dplyr::mutate(elev = raster::extract(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, y = .))
```

```{r fig-raster-extracao, fig.cap="Extra√ß√£o dos valores de eleva√ß√£o para as nascentes de Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_ele["elev"], 
     pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

Al√©m da extra√ß√£o dos valores totais, podemos resumir os valores dos pixels com a mesma opera√ß√£o de extra√ß√£o, utilizando ainda a fun√ß√£o `raster::extract()`, mas utilizando uma outra fun√ß√£o para resumir os valores dos pixels para um pol√≠gono, opera√ß√£o tamb√©m denominada de estat√≠stica zonal (agora para vetores). J√° vimos que ela pode ser realizada entre rasters na se√ß√£o de opera√ß√µes zonais, mas aqui a realizaremos para rasters e vetores.

Para o exemplo, vamos calcular a eleva√ß√£o m√©dia dos valores para os hex√°gonos que criamos para o limite de Rio Claro/SP( Figura \@ref(fig:fig-raster-zonas)).

```{r}
## Extra√ß√£o - estat√≠stica por zonas
geo_vetor_rio_claro_sirgas2000_utm23s_hex_alt <- geo_vetor_rio_claro_sirgas2000_utm23s_hex %>% 
    dplyr::mutate(elev_mean = raster::extract(x = geo_raster_srtm_rio_claro_sirgas2000_utm23s, 
                                              y = geo_vetor_rio_claro_sirgas2000_utm23s_hex, 
                                              fun = mean, 
                                              na.rm = TRUE))
```

```{r fig-raster-zonas, fig.cap="Extra√ß√£o dos valores de eleva√ß√£o e resumo pela m√©dia para os hex√°gonos de Rio Claro/SP."}
## Plot
plot(geo_vetor_rio_claro_sirgas2000_utm23s_hex_alt["elev_mean"], 
     pch = 20, main = NA, axes = TRUE, graticule = TRUE)
```

**Convers√µes raster-vetor**

Por fim, podemos ainda fazer opera√ß√µes de convers√£o entre objetos vetoriais para raster e vice-versa. Nessas opera√ß√µes, podemos resumir ou transformar objetos vetoriais (pontos, linhas ou pol√≠gonos) para rasters, escolhendo um raster previamente existente, processo denominado rasteriza√ß√£o. Tamb√©m podemos realizar o processo inverso, i.e., transformar o raster em um vetor, podendo esse vetor ser um gride pontos, linhas ou pol√≠gonos, opera√ß√£o chamada de vetoriza√ß√£o.

**Rasteriza√ß√£o**

A convers√£o de vetor para raster pode ser realizada de pontos, linhas ou pol√≠gonos para rasters. Nesse processo, podemos utilizar uma fun√ß√£o para resumir os dados pontuais para os pixels do raster que criaremos. Para essa opera√ß√£o, podemos utilizar a fun√ß√£o `raster::rasterize()`, com o argumento `x` sendo o vetor de pontos de entrada, `y` o raster base, `field` a coluna ou campo da tabela de atributos do objeto vetorial para os quais os valores ser√£o utilizados e `fun` a fun√ß√£o utilizada para agrega√ß√£o dos dados.

Aqui, vamos contabilizar a quantidade de nascentes por pixel, utilizando como base o raster para o qual mudamos a resolu√ß√£o para 900 metros (\@ref(fig:fig-raster-rasterizacao-pontos)).

```{r}
## Rasterizar pontos
geo_vetor_nascentes_rasterizacao <- raster::rasterize(x = geo_vetor_nascentes, y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-pontos, fig.cap="Rasteriza√ß√£o das nascentes, com a opera√ß√£o de contabiliza√ß√£o de pontos para Rio Claro/SP."}
## Plot
plot(geo_vetor_nascentes_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_nascentes$geometry, pch = 20, cex = .5, col = adjustcolor("gray", .5), add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Al√©m de pontos, podemos tamb√©m rasterizar linhas. Aqui vamos contabilizar as linhas da hidrografia simplificada para Rio Claro/SP (Figura \@ref(fig:fig-raster-rasterizacao-linhas)).

```{r}
## Rasterizar linhas
geo_vetor_hidrografia_rasterizacao <- raster::rasterize(
    x = geo_vetor_hidrografia_simplificado,
    y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media,
    field = 1, fun = "count")
```

```{r fig-raster-rasterizacao-linhas, fig.cap="Rasteriza√ß√£o da hidrografia, com a opera√ß√£o de contabiliza√ß√£o de linhas para Rio Claro/SP."}
## Plot
plot(geo_vetor_hidrografia_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_hidrografia_simplificado$geom, col = "gray", add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Podemos ainda rasterizar pol√≠gonos, de modo que cada pixel do raster a ser criado receber√°o valor da tabela de atributos, ou uma an√°lise pelo vizinho mais pr√≥ximo no caso de um campo categ√≥rico, como a cobertura da terra, que tamb√©m vai depender da resolu√ß√£o do raster base e do tamanho da fei√ß√£o do pol√≠gono. Para nosso exemplo, antes de criar o raster vamos transforma a coluna de classe de cobertura da terra em `factor` (Figura \@ref(fig:fig-raster-rasterizacao-poligonos)). Entretanto, essa opera√ß√£o de rasteriza√ß√£o tende a demorar muito no caso de pol√≠gonos muito detalhados ou um raster com pixels muito pequenos, sendo que dois pacotes aceleram esse processamento (`fasterize` e `gdalUtils`), com suas respectivas fun√ß√µes: `fasterize::fasterize()` e `gdalUtils::gdal_rasterize()`.

```{r}
## Rasterizar pol√≠gonos
geo_vetor_cobertura_rasterizacao <- geo_vetor_cobertura %>% 
    dplyr::mutate(classe = as.factor(CLASSE_USO)) %>% 
    raster::rasterize(x = ., y = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, field = "classe")
```

```{r fig-raster-rasterizacao-poligonos, fig.cap="Rasteriza√ß√£o da cobertura da terra para Rio Claro/SP."}
## Plot
plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura$geom, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

**Vetoriza√ß√£o**

A opera√ß√£o inversa √† rasteriza√ß√£o √© a vetoriza√ß√£o, na qual convertemos um raster em um vetor, sendo que esse vetor receber√° os valores dos pixels. O vetor em quest√£o pode ser pontos (geralmente um gride de pontos), linhas (geralmente isolinhas ou linhas de contorno), ou pol√≠gonos (podendo esses pol√≠gonos ser ou n√£o dissolvidos pelos valores dos pixels). Existem fun√ß√µes espec√≠ficas para cada uma dessas convers√µes, sendo elas: `raster::rasterToPoints()`, `raster::rasterToContour()` e `raster::rasterToPolygons()`, respectivamente. Para a √∫ltima fun√ß√£o, ainda dispomos de uma alternativa mais veloz `spex::polygonize()`.

Em nosso exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP, criando um gride de pontos, sendo os pontos os centroides de cada pixels (Figura \@ref(fig:fig-raster-vetorizacao-pontos)).

```{r}
## Vetoriza√ß√£o de pontos
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_pontos <- raster::rasterToPoints(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, spatial = TRUE) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-pontos, fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando um gride de pontos para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, 
     col = viridis::viridis(10, alpha = .8))
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_pontos, 
     pch = 20, cex = .7, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, col = NA, 
     border = "red", lwd = 2, add = TRUE)
```

Nesse outro exemplo, vamos vetorizar o raster de eleva√ß√£o para Rio Claro/SP novamente, mas agora criando isolinhas \@ref(fig:fig-raster-vetorizacao-linhas)).

```{r}
## Vetoriza√ß√£o de linhas
geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media_linhas <- raster::rasterToContour(
    x = geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-linhas, fig.cap="Vetoriza√ß√£o do raster de eleva√ß√£o criando isolinhas para Rio Claro/SP."}
## Plot
plot(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media,
     col = viridis::viridis(10, alpha = .8))
contour(geo_raster_srtm_rio_claro_sirgas2000_utm23s_agre_media, 
        labcex = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)
```

Por fim, vamos vetorizar o raster de cobertura da terra criado anteriormente para Rio Claro/SP, criando pol√≠gonos n√£o dissolvendo e dissolvidos \@ref(fig:fig-raster-vetorizacao-poligonos)).

```{r}
## Vetoriza√ß√£o de pol√≠gonos
geo_vetor_cobertura_rasterizacao_poligonos <- raster::rasterToPolygons(geo_vetor_cobertura_rasterizacao) %>%
    sf::st_as_sf()

## Vetoriza√ß√£o de pol√≠gonos dissolvendo
geo_vetor_cobertura_rasterizacao_poligonos_dissolvidos <- raster::rasterToPolygons(geo_vetor_cobertura_rasterizacao, dissolve = TRUE) %>% 
    sf::st_as_sf()
```

```{r fig-raster-vetorizacao-poligonos, fig.cap="Vetoriza√ß√£o do raster de cobertura da terra para Rio Claro/SP, n√£o dissolvendo e dissolvendos os pol√≠gonos gerados."}
## Plot
old_par <- par(mfrow = c(1, 2))
plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura_rasterizacao_poligonos$geometry, 
     col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)

plot(geo_vetor_cobertura_rasterizacao, col = viridis::viridis(10))
plot(geo_vetor_cobertura_rasterizacao_poligonos_dissolvidos$geometry, 
     col = NA, border = "gray", lwd = 1, main = FALSE, add = TRUE)
plot(geo_vetor_rio_claro_sirgas2000_utm23s$geom, 
     col = NA, border = "red", lwd = 2, add = TRUE)
par(old_par)
```

## Visualiza√ß√£o de dados geoespaciais

Um dos pontos finais de toda a an√°lise envolvendo a manipula√ß√£o de dados geoespaciais ser√° a apresenta√ß√£o de um mapa com as informa√ß√µes de interesse geoespacializadas. Mas antes, √© necess√°rio ter conhecimento de alguns dos elementos principais para a composi√ß√£o de um mapa relativamente bem informativo. Al√©m disso, o R nos permite criar tipos diferentes de mapas: est√°ticos, animados e interativos. Os mais comuns s√£o os est√°ticos, mas podemos por vezes melhorar a apresenta√ß√£o dos dados geoespaciais criando mapas animados e/ou interativos, com o aux√≠lio de p√°ginas web. Por fim, veremos as melhores formas de exportar mapas para diferentes formatos.

### Principais elementos de um mapa

Um mapa pode ser composto de v√°rios elementos, tendo estes o intuito de auxiliar a visualiza√ß√£o e entendimento de seu conte√∫do. Apesar disso, nem todos os elementos necessitam estar presentes em todos os *layouts* de mapas, sendo que os mesmos devem atendem √† necessidade das representa√ß√µes, podendo ser muitas vezes omitidos ou outros podem ser acrescentados.

Os principais elementos de um mapa geralmente s√£o compostos por:

1.  Mapa principal (ocupando quase toda a √°rea da figura)
2.  Mapa secund√°rio (geralmente muito menor que o mapa principal e com o intuito de mostrar a localiza√ß√£o do mapa principal num contexto mais amplo, como pa√≠s ou continente)
3.  T√≠tulo (para resumir o intuito do mapa)
4.  Legenda (apresentando as informa√ß√µes detalhadas das classes ou escala de valores, geralmente identificando as cores e/ou texturas),
5.  Barra de escala (representando quantas unidades do mapa representam do mundo real)
6.  Indicador de orienta√ß√£o (Norte) (indicando o norte geogr√°fico, podendo ser representado por uma flecha, b√∫ssola ou compasso)
7.  Gride de coordenadas (coordenadas presentes nas laterais)
8.  Descri√ß√£o do CRS (indicando qual o CRS)
9.  Informa√ß√µes de origem (informa√ß√µes sobre a fonte dos dados representados no mapa)
10. Al√©m de outros elementos auxiliares (como elementos textuais e figuras extras)

Podemos visualizar todos esses elementos resumidos na Figura \@ref(fig:fig-mapa-elementos).

```{r fig-mapa-elementos, echo=FALSE, fig.cap="Principais elementos de um mapa."}
tmap::tmap_mode(mode = "plot")

geo_vetor_am_sul <- rnaturalearth::ne_countries(continent = "South America")
geo_vetor_brasil <- rnaturalearth::ne_countries(country = "Brazil")
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro")

mapa_am_sul <- tm_shape(geo_vetor_am_sul) +
    tm_polygons() +
    tm_shape(geo_vetor_brasil) +
    tm_polygons(col = "gray50")

tm_shape(geo_vetor_biomas, bbox = c(-74, -35, -27, 10)) +
    tm_polygons(col = "name_biome",
                pal = c("darkgreen", "orange", "orange4", 
                        "forestgreen", "yellow", "yellow3"),
                border.col = "black",
                title = "Legenda") +
    tm_compass() +
    tm_scale_bar(text.size = .6) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
    tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
    tm_layout(title = "Biomas do Brasil",
              title.position = c(.25, .95),
              title.size = 1.8,
              title.fontface = "bold",
              legend.frame = TRUE,
              legend.position = c("left", "bottom"),
              legend.title.fontface = "bold")
print(mapa_am_sul, vp = grid::viewport(.815, .875, wi = .2, he = .2))
```

### Principais pacotes para a composi√ß√£o de mapas

H√° uma grande quantidade de pacotes para a composi√ß√£o de mapas no R. Aqui listamos os principais (Tabela \@ref(tab:tab-mapa-pacotes)).

```{r tab-mapa-pacotes, echo=FALSE}
knitr::kable(
    tibble::tibble(
        Pacote = c("[`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html)", 
                   "[`ggspatial`](https://cran.r-project.org/web/packages/ggspatial/index.html)", 
                   "[`ggmap`](https://cran.r-project.org/web/packages/ggmap/index.html)", 
                   "[`tmap`](https://cran.r-project.org/web/packages/tmap/index.html)", 
                   "[`leaflet`](https://cran.r-project.org/web/packages/leaflet/index.html)",
                   "[`plotly`](https://cran.r-project.org/web/packages/plotly/index.html)",
                   "[`cartography`](https://cran.r-project.org/web/packages/cartography/index.html)",
                   "[`googleway`](https://cran.r-project.org/web/packages/googleway/index.html)",
                   "[`mapview`](https://cran.r-project.org/web/packages/mapview/index.html)",
                   "[`rasterVis`](https://cran.r-project.org/web/packages/rasterVis/index.html)",
                   "[`cartogram`](https://cran.r-project.org/web/packages/cartogram/index.html)",
                   "[`mapsf`](https://cran.r-project.org/web/packages/mapsf/index.html)",
                   "[`geogrid`](https://cran.r-project.org/web/packages/geogrid/index.html)",
                   "[`geofacet`](https://cran.r-project.org/web/packages/geofacet/index.html)",
                   "[`globe`](https://cran.r-project.org/web/packages/globe/index.html)",
                   "[`linemap`](https://cran.r-project.org/web/packages/linemap/index.html)"), 
        Descri√ß√£o = c("Cria visualiza√ß√µes de dados elegantes usando a gram√°tica de gr√°ficos",
                      "Estrutura de dados espaciais para ggplot2",
                      "Visualiza√ß√£o espacial com ggplot2",
                      "Mapas tem√°ticos",
                      "Cria mapas da web interativos com a biblioteca JavaScript 'Leaflet'",
                      "Cria gr√°ficos interativos da Web por meio de 'plotly.js'",
                      "Cartografia tem√°tica",
                      "Cartografia tem√°tica",
                      "Acessa APIs do Google Maps para recuperar dados e mapas de plotagem",
                      "Visualiza√ß√£o interativa de dados espaciais em R",
                      "M√©todos de visualiza√ß√£o para dados raster",
                      "Crie cartogramas com R",
                      "Transforme pol√≠gonos geoespaciais em grades regulares ou hexagonais",
                      "'ggplot2' Utilit√°rios de faceta√ß√£o para dados geoespaciais",
                      "Plot 2D and 3D Views of the Earth, Including Major Coastline",
                      "Line Maps")),
    caption = "Principais pacotes para composi√ß√£o de mapas no R."
)
```

### Mapas est√°ticos

Mapas est√°ticos s√£o mapas simples e fixos para visualiza√ß√£o de dados, sendo o tipo mais comum de sa√≠da visual. No in√≠cio da composi√ß√£o de mapas no R, esse era o √∫nico tipo de mapa que a linguagem permitia produzir, principalmente utilizando o pacote `sp` [@pebesma_roger_2005]. No entanto, com o advento de ferramentas de visualiza√ß√£o din√¢micas no R, como componentes HTML, os mapas puderam ser compostos de forma din√¢mica (animados e interativos).

Neste t√≥pico abordaremos fun√ß√µes simples para composi√ß√£o de mapas est√°ticos, como o `plot()`, al√©m de pacotes para composi√ß√£o de mapas mais elaborados, como os pacotes `ggplot2` [@R-ggplot2] e `tmap` [@R-tmap].

**Fun√ß√£o `plot()`**

A fun√ß√£o gen√©rica `plot()` √© a maneira mais r√°pida de compor mapas est√°ticos utilizando objetos geoespaciais vetoriais e raster, funcionando para ambos os pacotes que apresentamos anteriormente (`sf` e `raster`). Apesar da simplicidade, essa fun√ß√£o geralmente tende a criar mapas com relativa velocidade, nos auxiliando principalmente em fases iniciais de desenvolvimento de um projeto. Essa fun√ß√£o oferece dezenas de argumentos em Base R, permitindo alguns ajustes limitados, com resultados bastante interessantes.

Como dito anteriormente, a fun√ß√£o `plot()` vai funcionar diferentemente dependendo da classe do objeto geoespacial. Para objetos geoespaciais `sf`, a fun√ß√£o vai plotar um mapa para cada coluna da tabela de atributos. Vamos usar de exemplo nosso mapa de biomas mostrado com os principais elementos de um mapa, podendo inclusive selecionar apenas a coluna de caracter√≠sticas geoespaciais (`geom`).

Primeiramente, vamos fazer o download dos dados de limites de biomas, retirando os sistemas costeiros, usando o pacote `geobr` [@R-geobr].

```{r}
## Download de pol√≠gonos dos geo_vetor_biomas Brasileiros
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro") %>% 
    dplyr::rename(nome_bioma = name_biome,
                  codigo_bioma = code_biome,
                  ano = year)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_biomas
```

Agora, quando utilizamos a fun√ß√£o `plot()` para um objeto da classe `sf`, temos os tr√™s mapas, cada um indicando uma coluna da tabela de atritos (Figura \@ref(fig:fig-vetor-map-plot)).

```{r fig-vetor-map-plot, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto `sf` para os Biomas do Brasil."}
## Plot
plot(geo_vetor_biomas)
```

Selecionando as colunas desse objeto, podemos escolher a informa√ß√£o que queremos plotar, por exemplo, apenas a geometria `geom`. Al√©m disso, podemos acrescentar os argumentos `col` para colorir e `main` para o t√≠tulo, al√©m dos argumentos `axes` e `graticule` para adicionar as coordenadas e quadr√≠culas, respectivamente. A legenda pode ser adicionada com a fun√ß√£o `legend()` (Figura \@ref(fig:fig-vetor-map-plot-selecao)).

```{r fig-vetor-map-plot-selecao, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto vetor."}
## Plot
plot(geo_vetor_biomas$geom, 
     col = c("darkgreen", "orange", "orange4", "forestgreen",
             "yellow", "yellow3"),
     main = "Biomas do Brasil", axes = TRUE, graticule = TRUE)
legend(x = -75, y = -20, pch = 15, cex = .7, pt.cex = 2.5,
       legend = geo_vetor_biomas$nome_bioma, 
       col = c("darkgreen", "orange", "orange4", "forestgreen", 
               "yellow", "yellow3"))
```

Para a classe dos objetos geoespaciais raster, a fun√ß√£o `plot()` vai plotar um mapa para o tipo `RasterLayer` e quantos mapas houverem no objeto e couberem no espa√ßo de plot para `RasterBrick` e `RasterStack`. Al√©m disso, para essas classes do objeto raster, essa fun√ß√£o prov√™ tamb√©m uma legenda e uma escala de cores autom√°tica (`terrain`). Vamos fazer o mapa da camada raster de eleva√ß√£o para o limite do munic√≠pio de Rio Claro/SP (Figura \@ref(fig:fig-raster-layer-mapa)).

```{r fig-raster-layer-mapa, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster com uma camada."}
## Plot
plot(geo_raster_srtm_rio_claro)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
```

Agora vamos plotar objetos da classe `RasterStack`, alterando a cor para `viridis`, usando a fun√ß√£o `viridis::viridis()` do pacote hom√¥nimo. Vamos fazer o mapa de duas camadas raster bioclim√°ticas para o mundo (Figura \@ref(fig:fig-raster-stack-mapa)).

```{r fig-raster-stack-mapa, fig.cap="Mapa feito com a fun√ß√£o `plot()` de um objeto raster com v√°rias camadas."}
## Plot
plot(geo_raster_bioclim[[1:2]], col = viridis::viridis(10))
```

Para exportar esses mapas podemos utilizar as fun√ß√µes `png()` ou `pdf()`, indicando os argumentos para ter as configura√ß√µes que desejamos, e finalizando com a fun√ß√£o `dev.off()`. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura (mais detalhes no Cap√≠tulo \@ref(cap6)).

```{r eval=FALSE}
## Criar diret√≥rio
dir.create(here::here("dados", "mapas"))

## Exportar mapa
png(filename = here::here("dados", "mapas", "elev_rc.png"), 
    width = 20, height = 20, units = "cm", res = 300)
plot(geo_raster_srtm_rio_claro)
plot(geo_vetor_rio_claro$geom, col = NA, border = "red", lwd = 2, add = TRUE)
dev.off()
```

**Pacotes ggplot2 e ggspatial**

Como discutimos no Cap√≠tulo \@ref(cap6) sobre gr√°ficos, o pacote `ggplot2` utiliza a gram√°tica de gr√°ficos para composi√ß√£o de figuras no R [@wilkinson2005; @wickham2016]. Para cada classe de objeto geogr√°fico h√° fun√ß√µes espec√≠ficas para os dados: para objetos sf `geom_sf()` e para objetos raster `geom_raster()` e `geom_tile()`.

Al√©m do pacote `ggplot2`, podemos utilizar o pacote `ggspatial` para acrescentar elementos geoespaciais como a barra de escala e o indicador de orienta√ß√£o (Norte), atrav√©s das fun√ß√µes `annotation_scale()` e `annotation_north_arrow()`, respectivamente, al√©m de outras fun√ß√µes espec√≠ficas que n√£o abordaremos nesta se√ß√£o.

A estrutura de composi√ß√£o das fun√ß√µes do pacote `ggplot2` vai funcionar parecido com a estrutura√ß√£o de gr√°ficos j√° vista no Cap√≠tulo \@ref(cap6), de modo que a cada fun√ß√£o iremos utilizando o sinal de `+` para acrescentar outra camada. Indicaremos os dados com a fun√ß√£o `ggplot()` e a coluna da tabela de atributos que queremos representar com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_sf()` para indicar que trata-se de um objeto `sf`.

Al√©m dessas fun√ß√µes, podemos ainda fazer altera√ß√µes nos mapas atrav√©s das fun√ß√µes: `scale_*()` que vai alterar as caracter√≠sticas indicadas em `aes()`, `coord_*()` que vai alterar constru√ß√£o do mapa em rela√ß√£o √†s coordenadas, `facet_*()` que altera a disposi√ß√£o de v√°rios mapas, e `theme_*()` e `theme()` que alterar√£o caracter√≠sticas relacionadas ao tema, como cores de fundo, fontes e legenda. Podemos ainda utilizar as fun√ß√µes `annotate()` para adicionar textos e `labs()` para alterar o texto do t√≠tulo, legenda e eixos.

Vamos demonstrar esse funcionamento para compor o mapa de geo_vetor_biomas, apresentado no in√≠cio desta se√ß√£o (Figura \@ref(fig:fig-vetor-mapa-ggplot2)).

```{r fig-vetor-mapa-ggplot2, fig.cap="Mapa de Biomas do Brasil com o pacote `ggplot2`."}
## Plot
mapa_vetor_biomas_ggplot2 <- ggplot(data = geo_vetor_biomas) +
    aes(fill = nome_bioma) +
    geom_sf(color = "black") +
    scale_fill_manual(values = c("darkgreen", "orange", "orange4", 
                                 "forestgreen", "yellow", "yellow3")) +
    annotation_scale(location = "br") +
    annotation_north_arrow(location = "br", which_north = "true",
                           pad_x = unit(0, "cm"), pad_y = unit(.5, "cm"),
                           style = north_arrow_fancy_orienteering) +
    annotate(geom = "text", label = "CRS: SIRGAS2000/Geo", x = -38, y = -31, size = 2.5) +
    annotate(geom = "text", label = "Fonte: IBGE (2019)", x = -39, y = -32.5, size = 2.5) +
    labs(title = "Biomas do Brasil", fill = "Legenda", x = "Longitude", y = "Latitude") +
    theme_bw() +
    theme(title = element_text(size = 15, face = "bold"),
          legend.title = element_text(size = 10, face = "bold"),
          legend.position = c(.15, .25),
          legend.background = element_rect(colour = "black"),
          axis.title = element_text(size = 10, face = "plain"))
mapa_vetor_biomas_ggplot2
```

Para objetos raster, o uso do pacote `ggplot2` para compor mapas requer um passo preliminar. Primeiramente, vamos criar um `data frame` com os dados do raster, com as linhas sendo os pixels e as colunas sendo as coordenadas centrais da longitude e latitude, al√©m dos valores de cada camada em cada coluna. Esse passo pode ser realizado com a fun√ß√£o `raster::rasterToPoints()`.

Uma vez que temos esses dados organizados, podemos utilizar as fun√ß√µes `ggplot()` para indicar o `data frame`, e as colunas com a fun√ß√£o `aes()`. Em seguida, utilizamos a fun√ß√£o `geom_raster()` para indicar que trata-se de um objeto raster. Al√©m dessas fun√ß√µes, podemos ainda utilizar as demais fun√ß√µes para alterar as caracter√≠sticas do mapa, como comentamos acima. Entretanto, devemos nos atentar para a fun√ß√£o `coord_*()` e escolher aquela que vai fazer a constru√ß√£o do mapa em rela√ß√£o √† coordenadas e resolu√ß√£o das c√©lulas.

Como exemplo, vamos compor o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-ggplot2)).

```{r fig-raster-mapa-ggplot2, fig.cap="Mapa raster com o pacote `ggplot2`."}
## Dados
geo_raster_srtm_rio_claro_dados <- raster::rasterToPoints(geo_raster_srtm_rio_claro) %>% 
    tibble::as_tibble()
head(geo_raster_srtm_rio_claro_dados)

## Mapa
mapa_srtm_rio_claro_ggplot2 <- ggplot() +
    geom_raster(data = geo_raster_srtm_rio_claro_dados, aes(x = x, y = y, fill = elevacao)) +
    geom_sf(data = geo_vetor_rio_claro, color = "red", fill = NA, size = 1.3) +
    scale_fill_viridis_c() +
    coord_sf() +
    annotation_scale(location = "br",
                     pad_x = unit(.5, "cm"), pad_y = unit(.7, "cm"),) +
    annotation_north_arrow(location = "br", which_north = "true",
                           pad_x = unit(.4, "cm"), pad_y = unit(1.3, "cm"),
                           style = north_arrow_fancy_orienteering) +
    annotate(geom = "text", label = "CRS: WGS84/Geo", 
             x = -47.51, y = -22.53, size = 3) +
    labs(title = "Eleva√ß√£o de Rio Claro/SP", fill = "Eleva√ß√£o (m)", 
         x = "Longitude", y = "Latitude") +
    theme_bw() +
    theme(title = element_text(size = 15, face = "bold"),
          legend.title = element_text(size = 10, face = "bold"),
          legend.position = c(.2, .25),
          legend.background = element_rect(colour = "black"),
          axis.title = element_text(size = 10, face = "plain"),
          axis.text.y = element_text(angle = 90, hjust = .4))
mapa_srtm_rio_claro_ggplot2
```

Para exportar mapas criados com o pacote `ggplot2`, podemos utilizar a fun√ß√£o `ggplot2::ggsave()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura.

```{r eval=FALSE}
## Exportar mapa ggplot2
ggsave(filename = here::here("dados", "mapas", "srtm_rio_claro_ggplot2.png"),
       plot = mapa_srtm_rio_claro_ggplot2, width = 20, height = 20, units = "cm", dpi = 300)
```

**Pacote tmap**

O pacote `tmap` √© um pacote direcionado √† cria√ß√£o de mapas tem√°ticos, com uma sintaxe concisa que permite a cria√ß√£o de mapas com o m√≠nimo de c√≥digos, mas muito similar √† sintaxe do pacote `ggplot2` [@tmap2018]. Ele tamb√©m pode gerar mapas est√°ticos ou interativos usando o mesmo c√≥digo, apenas mudando a forma de visualiza√ß√£o com a fun√ß√£o `tmap_mode()`, com o argumento `mode` igual a "plot" para est√°tico e "view" para interativo. Por fim, o pacote `tmap` aceita diversas classes espaciais, incluindo objetos raster, de forma bastante simples. Mais sobre o pacote pode ser lido [aqui](https://mtennekes.github.io/tmap/). 

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Atentar para a instala√ß√£o extra em Sistemas Operacionais [GNU/Linux](https://geocompr.github.io/post/2020/installing-r-spatial-ubuntu/) e [MacOS](http://www.kyngchaos.com).
:::

Todas as fun√ß√µes do pacote `tmap` iniciam-se com `tm_*`, facilitando seu uso. A cada fun√ß√£o iremos utilizar o sinal de `+` para acrescentar outra camada, da mesma forma que o pacote `ggplot2`. A principal fun√ß√£o, em que todos os objetos geoespaciais s√£o dados de entrada, √© `tm_shape()`. A partir dela, podemos seguir com fun√ß√µes espec√≠ficas para vizualiza√ß√£o de objetos `sf`, como `tm_polygons()`, `tm_borders()`, `tm_fill()`, `tm_lines()`, `tm_dots()` ou `tm_bubbles()`, ou com fun√ß√µes para objetos raster como `tm_raster()`. Ainda h√° fun√ß√µes como `tm_text()` para representa√ß√£o de textos das colunas da tabela de atributos, e `tm_scale_bar()`, `tm_compass()` e `tm_graticules()`, para adicionar barra de escala, indicador de orienta√ß√£o (Norte) e gride de coordenadas, respectivamente. Por fim, a fun√ß√£o `tm_credits()` adiciona um texto descritivo e a fun√ß√£o `tm_layout()` faz diversas mudan√ßas nos detalhes e apresenta√ß√£o do mapa.

Uma funcionalidade muito interessante do pacote `tmap` √© o uso da fun√ß√£o `tmaptools::palette_explorer()` para escolher as paletas de cores dispon√≠veis. Essa fun√ß√£o requer que os pacotes `shiny` e `shinyjs` estejam instalados, e quando executada, retorna uma aba onde √© poss√≠vel editar e escolher algumas paletas de cores nativas do `tmap`.

Diversos par√¢metros podem ser acrescentados √†s fun√ß√µes de composi√ß√£o do tmap, mas n√£o as detalharemos aqui, pois todas s√£o descritas nos vignettes do pacote: [tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) e [tmap: version changes](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes.html).

Vamos seguir com a composi√ß√£o do mapa de biomas para o Brasil apresentado no in√≠cio dessa se√ß√£o (Figura \@ref(fig:fig-vetor-mapa-tmap)).

```{r fig-vetor-mapa-tmap, fig.cap="Mapa de Biomas do Brasil com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
mapa_vetor_biomas_tmap <- tm_shape(geo_vetor_biomas, bbox = c(-74, -35, -27, 10)) +
    tm_polygons(col = "nome_bioma",
                pal = c("darkgreen", "orange", "orange4", "forestgreen", "yellow", "yellow3"),
                border.col = "black",
                title = "Legenda") +
    tm_compass() +
    tm_scale_bar(text.size = .6) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: SIRGAS2000/Geo", position = c(.63, .13)) +
    tm_credits("Fonte: IBGE (2019)", position = c(.63, .09)) +
    tm_layout(title = "Biomas do Brasil",
              title.position = c(.25, .95),
              title.size = 1.8,
              title.fontface = "bold",
              legend.frame = TRUE,
              legend.position = c("left", "bottom"),
              legend.title.fontface = "bold")
mapa_vetor_biomas_tmap
```

Al√©m disso, o pacote `tmap` nos permite adicionar de forma simples um mapa secund√°rio, provendo uma localiza√ß√£o regional de interesse (Figura \@ref(fig:fig-vetor-mapa-sec-tmap)).

```{r}
## Dados
geo_vetor_am_sul <- rnaturalearth::ne_countries(continent = "South America")
geo_vetor_brasil <- rnaturalearth::ne_countries(country = "Brazil")
geo_vetor_biomas <- geobr::read_biomes(showProgress = FALSE) %>%
    dplyr::filter(name_biome != "Sistema Costeiro")
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_am_sul
ecodados::geo_vetor_brasil
ecodados::geo_vetor_biomas
```

```{r fig-vetor-mapa-sec-tmap, fig.cap="Mapa vetorial prim√°rio e secund√°rio com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa secund√°rio
mapa_am_sul <- tm_shape(geo_vetor_am_sul) +
    tm_polygons() +
    tm_shape(geo_vetor_brasil) +
    tm_polygons(col = "gray50")

## Juntando os mapas
mapa_vetor_biomas_tmap
print(mapa_am_sul, vp = grid::viewport(.815, .875, wi = .2, he = .2))
```

Como exemplo de mapa raster, vamos compor novamente o mapa de eleva√ß√£o para Rio Claro/SP, adicionando tamb√©m o limite do munic√≠pio (Figura \@ref(fig:fig-raster-mapa-tmap)).

```{r fig-raster-mapa-tmap, fig.cap="Mapa raster de eleva√ß√£o com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
mapa_srtm_rio_claro_tmap <- tm_shape(geo_raster_srtm_rio_claro) +
    tm_raster(pal = "viridis", title = "Eleva√ß√£o (m)") +
    tm_shape(geo_vetor_rio_claro) +
    tm_borders(col = "red", lwd = 2) +
    tm_compass(position = c(.9, .08)) +
    tm_scale_bar(text.size = .6, position = c(.67, 0)) +
    tm_graticules(lines = FALSE) +
    tm_credits("CRS: WGS84/Geo", position = c(.67, .06)) +
    tm_layout(title = "Eleva√ß√£o Rio Claro/SP",
              title.size = 1,
              title.fontface = "bold",
              legend.title.size = .7,
              legend.text.size = .6,
              legend.frame = TRUE,
              legend.position = c(.01, .01),
              legend.title.fontface = "bold")
mapa_srtm_rio_claro_tmap
```

Para exportar mapas criados com o pacote `tmap` podemos utilizar a fun√ß√£o `tmap::tmap_save()`, indicando os argumentos para ter as configura√ß√µes que desejamos. Vamos exportar, a t√≠tulo de exemplo, a √∫ltima figura.

```{r eval=FALSE}
## Exportar mapa tmap
tmap::tmap_save(tm = mapa_srtm_rio_claro_tmap, 
                filename = here::here("dados", "mapas", "srtm_rio_claro_tmap.png"),
                width = 20, height = 20, units = "cm", dpi = 300)
```

### Mapas animados

Podemos montar mapas facetados para mostrar como padr√µes espaciais variam ao longo do tempo, como por exemplo, os limites do Brasil ao longo dos anos (Figura \@ref(fig:fig-vetor-brasil-tmap-facted)). Entretanto, essa abordagem possui algumas desvantagens, de modo que as facetas podem ficar muito pequenas quando h√° muitas delas.

```{r}
## Dados
geo_vetor_brasil_anos <- NULL
for(i in c(1872, 1900, 1911, 1920, 1933, 1940, 1950, 1960, 1970,
           1980, 1991, 2001, 2010, 2019)){
    geo_vetor_brasil_anos <- geobr::read_state(code_state = "all",
                                               year = i, showProgress = FALSE) %>% 
        sf::st_geometry() %>% 
        sf::st_as_sf() %>%
        dplyr::mutate(year = i) %>% 
        dplyr::bind_rows(geo_vetor_brasil_anos, .)
}
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_brasil_anos
```

```{r fig-vetor-brasil-tmap-facted, fig.cap="Mapa vetor facetado dos estados brasileiros ao longo do tempo com o pacote `tmap`."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa facetado
mapa_brasil_tmap <- tm_shape(geo_vetor_brasil_anos) + 
    tm_polygons() + 
    tm_facets(by = "year", nrow = 4)
mapa_brasil_tmap
```

Uma solu√ß√£o √© a composi√ß√£o de mapas animados. Apesar de dependerem da publica√ß√£o digital, os mapas animados podem aprimorar relat√≥rios f√≠sicos √† medida que o v√≠nculo a uma p√°gina da web contendo a vers√£o animada torna-se simples. Existem v√°rias maneiras de gerar anima√ß√µes em R, e uma forma √© com o pacote `gganimate` e `ggplot2`. Entretanto, aqui veremos a cria√ß√£o de mapas animados com `tmap`.

Podemos criar mapas animados alterando dois argumentos da fun√ß√£o `tm_facets()`:

-   trocando o `by = year` por `along = year`
-   indicando o `free.coords = FALSE`

Por fim, podemos exportar o mapa animado no formato de `.gif` utilizando a fun√ß√£o `tmap::tmap_animation()`, indicando a taxa de atualiza√ß√£o com o argumento `delay` (Figura \@ref(fig:fig-vetor-brasil-tmap-animated)). Alguns pacotes extras s√£o requeridos dependendo do sistema operacional utilizado.

```{r eval=FALSE}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa animado
mapa_brasil_tmap_ani <- tm_shape(geo_vetor_brasil_anos) + 
    tm_polygons() + 
    tm_facets(along = "year", free.coords = FALSE)

## Exportar mapa tmap animado
tmap::tmap_animation(tm = mapa_brasil_tmap_ani, 
                     filename = here::here("dados", "mapas",
                                           "srtm_rio_claro_tmap_ani.gif"), 
                     delay = 30)
```

```{r fig-vetor-brasil-tmap-animated, echo=FALSE, fig.cap="Mapa vetorial animado mostrando os estados brasileiros ao longo do tempo com o pacote `tmap`."}
knitr::include_graphics("img/cap15_fig75.gif")
```

### Mapas interativos

Mapas interativos podem assumir muitas formas, sendo que a mais comum e √∫til √© a capacidade de deslocar e ampliar qualquer parte de um conjunto de dados geoespaciais sobreposto em um "mapa da web". Diversos pacotes nos permitem criar esse tipo de mapa, sendo os mais comuns o `tmap`, `mapview` e `leaflet`.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Destacamos que esses mapas ir√£o ser compostos numa janela especial de "Viewer".
:::

**pacote tmap**

Um recurso exclusivo do `tmap` √© sua capacidade de criar mapas est√°ticos e interativos usando o mesmo c√≥digo. Os mapas podem ser visualizados interativamente em qualquer ponto mudando para o modo de visualiza√ß√£o, usando a fun√ß√£o `tmap::tmap_mode(mode = "view")` (Figura \@ref(fig:fig-raster-mapa-tmap-int)).

```{r}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "view")

## Atribuir novo mapa interativo
mapa_srtm_rio_claro_tmap_int <- mapa_srtm_rio_claro_tmap
```

```{r fig-raster-mapa-tmap-int, echo=FALSE, fig.cap="Mapa vetorial interativo com o pacote `tmap`."}
knitr::include_url("img/cap15_fig76.png")
```

Para exportar mapas interativos criados com o pacote `tmap`, podemos utilizar novamente a fun√ß√£o `tmap::tmap_save()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa tmap interativo
tmap::tmap_save(tm = mapa_srtm_rio_claro_tmap_int, 
                filename = here::here("dados", "mapas", "srtm_rio_claro_tmap_int.html"))
```

**Pacote mapview**

O pacote `mapview` cria rapidamente mapas interativos simples com a fun√ß√£o `mapvew::mapview()` (Figura \@ref(fig:fig-raster-mapa-mapview-int)). Entretanto, outras caracter√≠sticas podem ser mudadas para criar mapas mais elaborados, como pode ser visto atrav√©s do [site do pacote](https://r-spatial.github.io/mapview).

```{r}
## Mapa
mapa_srtm_rio_claro_mapview_int <- mapview::mapview(
    geo_raster_srtm_rio_claro, col.regions = viridis::viridis(100))
```

```{r fig-raster-mapa-mapview-int, echo=FALSE, fig.cap="Mapa vetorial interativo com o pacote `mapview`."}
knitr::include_url("img/cap15_fig77.png")
```

Para exportar mapas interativos criados com o pacote `mapview`, podemos utilizar a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa mapview interativo
mapview::mapshot(x = mapa_srtm_rio_claro_mapview_int, 
                 url = here::here("dados", "mapas", "srtm_rio_claro_mapview_int.html"))
```

**Pacote leaflet**

O `leaflet` √© um dos pacotes de mapeamento interativo mais utilizados e completos em R. Esse pacote fornece uma interface utilizando a biblioteca JavaScript e muitos argumentos podem ser compreendidos lendo a documenta√ß√£o da [biblioteca original](leafletjs.com).

Mapas interativos usando esse pacote s√£o criados utilizando a fun√ß√£o `leaflet::leaflet()`. O resultado dessa fun√ß√£o √© um objeto da classe leaflet, que pode ser alterado por outras fun√ß√µes deste mesmo pacote, permitindo que v√°rias camadas e configura√ß√µes de controle sejam adicionadas interativamente (Figura \@ref(fig:fig-raster-mapa-leaflet-int)).

Mais sobre o pacote `leaflet` pode ser consultado em seu [site](https://rstudio.github.io/leaflet/) e [CheatSheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/leaflet.pdf).

```{r}
## Paleta de cores
pal <- colorNumeric(viridis::viridis(10), raster::values(geo_raster_srtm_rio_claro))

## Mapa
mapa_srtm_rio_claro_leaflet_int <- leaflet() %>%
    addProviderTiles("CartoDB.Positron") %>% 
    addRasterImage(geo_raster_srtm_rio_claro, colors = pal, opacity = .8) %>%
    addLegend(pal = pal, values = raster::values(geo_raster_srtm_rio_claro), 
              title = "Eleva√ß√£o (m)") %>% 
    addPolygons(data = geo_vetor_rio_claro, col = "red", fill = NA)
```

```{r fig-raster-mapa-leaflet-int, fig.cap="Mapa vetorial interativo com o pacote `leaflet`."}
knitr::include_url("img/cap15_fig78.png")
```

Para exportar mapas interativos criados com o pacote `leaflet`, podemos utilizar novamente a fun√ß√£o `mapivew::mapshot()`, indicando a extens√£o como `.html`.

```{r eval=FALSE}
## Exportar mapa leaflet interativo
mapview::mapshot(x = mapa_srtm_rio_claro_leaflet_int, 
                 url = here::here("dados", "mapas", "srtm_rio_claro_leaflet_int.html"))
```

## Exemplos de aplica√ß√µes de an√°lises geoespaciais para dados ecol√≥gicos

Agora que vimos os principais conceitos e aplica√ß√µes do manejo e visualiza√ß√£o de dados geoespaciais, podemos avan√ßar para realizar quatro exemplos de aplica√ß√µes para dados ecol√≥gicos. Para isso, usaremos novamente os dados de comunidades de anf√≠bios da Mata Atl√¢ntica [@vancine2018]. Primeiramente, veremos como resumir informa√ß√µes de biodiversidade (n√∫mero de ocorr√™ncias e riqueza) para hex√°gonos. Num segundo momento, veremos como associar dados ambientais a coordenadas de esp√©cies ou comunidades. Depois, como resumir dados de rasters para buffers. Por fim, realizaremos predi√ß√µes espaciais cont√≠nuas de adequabilidade de habitat para uma esp√©cie e do n√∫mero de esp√©cies.

### Resumir informa√ß√µes de biodiversidade para unidades espaciais

Resumir informa√ß√µes para unidades espaciais √© um passo muito frequente em an√°lises de Macroecologia, Biogeografia ou Ecologia da Paisagem. Nesta se√ß√£o, contabilizaremos o n√∫mero de ocorr√™ncias e riqueza de anf√≠bios para hex√°gonos na Mata Atl√¢ntica.

Primeiramente, vamos importar e preparar os dados de biodiversidade que usaremos nesses exemplos. Vamos come√ßar importando os locais de amostragens de anf√≠bios na Mata Atl√¢ntica e selecionando apenas as colunas de interesse.

```{r}
## Importar locais
geo_anfibios_locais <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_sites.csv"),
    col_types = cols()) %>%
    dplyr::select(id, longitude, latitude, species_number)
```

Agora vamos importar as esp√©cies das comunidades, selecionando apenas as esp√©cies com nomes v√°lidos e transformando a coluna de indiv√≠duos para 1, para compor posteriormente uma matriz de comunidade de esp√©cies.

```{r}
## Importar esp√©cies
geo_anfibios_especies <- readr::read_csv(
    here::here("dados", "tabelas", "ATLANTIC_AMPHIBIANS_species.csv"), 
    col_types = cols()) %>%
    tidyr::drop_na(valid_name) %>% 
    dplyr::select(id, valid_name, individuals) %>% 
    dplyr::distinct(id, valid_name, .keep_all = TRUE) %>% 
    dplyr::mutate(individuals = tidyr::replace_na(individuals, 1),
                  individuals = ifelse(individuals > 0, 1, 1))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_anfibios_locais
ecodados::geo_anfibios_especies
```

Podemos agora juntar a tabela de locais, que possui as coordenadas √† tabela de esp√©cies. Em seguida convertemos essa √∫nica tabela na classe vetor `sf`.

```{r}
## Jun√ß√£o das coordenadas e convers√£o para classe sf
geo_anfibios_especies_locais_vetor <- geo_anfibios_especies %>% 
    dplyr::left_join(geo_anfibios_locais, by = "id") %>% 
    dplyr::relocate(longitude, latitude, .after = 1) %>% 
    dplyr::mutate(lon = longitude, lat = latitude) %>% 
    sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Agora vamos baixar o limite do Bioma da Mata Atl√¢ntica para o Brasil, converter o GCS para WGS84/Geo e ajustar sua extens√£o para remover as ilhas no Oceano Atl√¢ntico.

```{r warning=FALSE, message=FALSE}
## Download do Bioma da Mata Atl√¢ntica
geo_vetor_mata_atlantica <- geobr::read_biomes(year = 2019, showProgress = FALSE) %>% 
    dplyr::filter(name_biome == "Mata Atl√¢ntica") %>% 
    sf::st_transform(crs = 4326) %>% 
    sf::st_crop(xmin = -55, ymin = -30, xmax = -34, ymax = -5)
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_vetor_mata_atlantica
```

Podemos verificar se as coordenadas e o limite do bioma est√£o todos corretos compondo um mapa preliminar, usando o pacote `tmap` (Figura \@ref(fig:fig-vetor-aa-ma)).

```{r fig-vetor-aa-ma, fig.cap="Mapa dos locais do Atlantic Amphibians e do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_anfibios_especies_locais_vetor) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor) +
    tm_dots(size = .1, col = "forestgreen")
```

Como o limite utilizado para reunir informa√ß√µes das comunidades de anf√≠bios foi o mais abrangente poss√≠vel [@muylaert2018; @vancine2018], selecionaremos apenas os locais que caem dentro do limite da Mata Atl√¢ntica que estamos utilizando aqui.

```{r}
## Selecionar os locais dentro do limite
geo_anfibios_especies_locais_vetor_mata_atlantica <- geo_anfibios_especies_locais_vetor[geo_vetor_mata_atlantica, ]
```

Podemos refazer o mapa mostrando as coordenadas retiradas em vermelho e as que ficaram em verde (Figura \@ref(fig:fig-vetor-aa-ma-sel)).

```{r fig-vetor-aa-ma-sel, fig.cap="Mapa dos locais do Atlantic Amphibians que caem dentro do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica,
         bbox = geo_anfibios_especies_locais_vetor) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor) +
    tm_bubbles(size = .1, col = "red") +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica) +
    tm_bubbles(size = .1, col = "forestgreen")
```

O pr√≥ximo passo √© criar um gride de hex√°gonos para o Bioma da Mata Atl√¢ntica. Usaremos a fun√ß√£o `sf::st_make_grid()` que pode criar quadr√≠culas ou hex√°gonos. Esses hex√°gonos ter√£o a √°rea equivalente √† quadr√≠culas de 1¬∫ de tamanho (aproximadamente 10000 km¬≤). Usaremos a fun√ß√£o `sf::st_area()` para calcular as √°reas dos hex√°gonos e a fun√ß√£o `tibble::rowid_to_column()` para criar uma identifica√ß√£o para cada fei√ß√£o.

```{r}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Criar hex√°gonos de ~110 km
geo_vetor_mata_atlantica_hex <- sf::st_make_grid(
    x = geo_vetor_mata_atlantica, cellsize = 1, square = FALSE) %>% 
    sf::st_as_sf() %>% 
    dplyr::mutate(areakm2 = sf::st_area(.)/1e6) %>% 
    tibble::rowid_to_column("id_hex")

## Selecionar os hex√°gonos dentro do limite da Mata Atl√¢ntica
geo_vetor_mata_atlantica_hex <- geo_vetor_mata_atlantica_hex[geo_vetor_mata_atlantica, ]
```

Podemos conferir os hex√°gonos criados fazendo um mapa preliminar (Figura \@ref(fig:fig-vetor-aa-ma-sel-hex)).

```{r fig-vetor-aa-ma-sel-hex, fig.cap="Mapa dos hex√°gonos para o limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_vetor_mata_atlantica_hex) +
    tm_polygons() +
    tm_shape(geo_vetor_mata_atlantica_hex) +
    tm_borders()
```

Podemos ser mais restritos e selecionar apenas os hex√°gonos dentro do limite do Bioma da Mata Atl√¢ntica utilizando o operador `st_within()` (Figura \@ref(fig:fig-vetor-aa-ma-sel-hex-total).

```{r}
## Selecionar os hex√°gonos totalmente dentro do limite da Mata Atl√¢ntica
geo_vetor_mata_atlantica_hex_total <- geo_vetor_mata_atlantica_hex[geo_vetor_mata_atlantica, , op = st_within]
```

```{r fig-vetor-aa-ma-sel-hex-total, fig.cap="Mapa dos hex√°gonos totalmente dentro do limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica, 
         bbox = geo_vetor_mata_atlantica_hex) +
    tm_polygons() +
    tm_shape(geo_vetor_mata_atlantica_hex_total) +
    tm_borders()
```

Podemos agora associar as esp√©cies aos hex√°gonos fazendo um "join" espacial, utilizando a fun√ß√£o `sf::st_join()`.

```{r}
## Jun√ß√£o espacial dos locais com os hex√°gonos
geo_vetor_mata_atlantica_hex_especies <- sf::st_join(
    x = geo_vetor_mata_atlantica_hex, 
    y = geo_anfibios_especies_locais_vetor_mata_atlantica,
    left = TRUE)
```

Por fim, podemos agregar os dados para ter o n√∫mero de ocorr√™ncias e de esp√©cies por hex√°gono.

```{r}
## Agregar dados de ocorr√™ncias e n√∫mero de esp√©cies por hex√°gono
geo_vetor_mata_atlantica_hex_especies_oco_riq <- geo_vetor_mata_atlantica_hex_especies %>% 
    dplyr::group_by(id_hex) %>% 
    dplyr::summarise(ocorrencias = length(valid_name[!is.na(valid_name)]),
                     riqueza = n_distinct(valid_name, na.rm = TRUE))
```

Finalmente podemos compor os mapas finais, mostrando os hex√°gonos com cores e valores do n√∫mero de ocorr√™ncias e de esp√©cies \@ref(fig:fig-vetor-aa-ma-sel-hex-oco-riq)).

```{r eval=FALSE}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa de ocorr√™ncias
mapa_oco <- tm_shape(geo_vetor_mata_atlantica_hex_especies_oco_riq) +
    tm_polygons(title = "Ocorr√™ncia de anf√≠bios", col = "ocorrencias", 
                pal = "viridis", style = "pretty") +
    tm_text("ocorrencias", size = .4) +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Mapa de riqueza
mapa_riq <- tm_shape(geo_vetor_mata_atlantica_hex_especies_oco_riq) +
    tm_polygons(title = "Riqueza de anf√≠bios", col = "riqueza", 
                pal = "viridis", style = "pretty") +
    tm_text("riqueza", size = .4) +
    tm_graticules(lines = FALSE) +
    tm_compass() +
    tm_scale_bar() +
    tm_layout(legend.title.size = 2,
              legend.title.fontface = "bold",
              legend.position = c("left", "top"))

## Uni√£o dos mapas
tmap_arrange(mapa_oco, mapa_riq)
```

```{r fig-vetor-aa-ma-sel-hex-oco-riq, echo=FALSE, fig.cap="Mapa com o n√∫mero de ocorr√™ncias e riqueza de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica."}
knitr::include_graphics("img/cap15_fig81.png")
```

### Extrair dados raster para pontos

Atribuir informa√ß√µes ambientais a ocorr√™ncias √© um passo fundamental para diversas an√°lises. Nesta se√ß√£o, atribuiremos os valores das vari√°veis bioclim√°ticas aos locais de amostragem de anf√≠bios na Mata Atl√¢ntica.

J√° realizamos o download das vari√°veis bioclim√°ticas na se√ß√£o de raster. Vamos importar novamente esses dados, primeiramente listando as camadas e depois importando com a fun√ß√£o `raster:stack()`.

```{r}
## Listar arquivos
arquivos_raster <- dir(path = here::here("dados", "raster"), pattern = "wc") %>% 
    grep(".tif", ., value = TRUE)

## Importar rasters
geo_raster_bioclim <- raster::stack(here::here("dados", "raster", arquivos_raster))

## Renomear rasters
names(geo_raster_bioclim) <- c("bio01", paste0("bio", 10:19), paste0("bio0", 2:9))
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_bioclim
```

Da se√ß√£o anterior, j√° temos o objeto com a tabela de coordenadas dos locais de amostragem das comunidades de anf√≠bios. Vamos agora criar um objeto vetorial das coordenadas e em seguida selecionar os locais dentro do limite do bioma da Mata Atl√¢ntica.

```{r}
## Importar locais e converter em sf
geo_anfibios_locais_vetor <- geo_anfibios_locais %>% 
    dplyr::mutate(lon = longitude, lat = latitude) %>% 
    sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
geo_anfibios_locais_vetor
```

Usaremos agora a fun√ß√£o `raster::extract()` para extrair e associar os valores das vari√°veis bioclim√°ticas para os locais de amostragem.

```{r}
## Extrair valores das vari√°veis para os locais
geo_anfibios_locais_vetor_bioclim <- geo_anfibios_locais_vetor %>% 
    dplyr::mutate(raster::extract(geo_raster_bioclim, ., df = TRUE)) %>% 
    dplyr::select(-ID) %>% 
    dplyr::relocate(bio02:bio09, .after = bio01)
```

Podemos ver esses dados na Tabela \@ref(tab:tab-aa-var).

```{r tab-aa-var, echo=FALSE}
## Visualizar os dados
geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(id:bio05) %>% 
    dplyr::slice(1:6) %>% 
    knitr::kable(caption = "Dados extra√≠dos e atribu√≠dos aos locais
               de amostragens de comunidades de anf√≠bios na Mata Atl√¢ntica")
```

Podemos ainda fazer alguns mapas para espacializar essas vari√°veis (Figura \@ref(fig:fig-vetor-aa-var)).

```{r fig-vetor-aa-var, fig.cap="Mapa mostrando os valores das vari√°veis bioclim√°ticas (BIO01:BIO06) para os locais amostrados de comunidades de anf√≠bios para hex√°gonos no limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
geo_anfibios_locais_vetor_bioclim %>% 
    dplyr::select(bio01:bio06) %>% 
    tidyr::gather(var, val, -geometry) %>% 
    tm_shape() +
    tm_bubbles(size = .1, col = "val", pal = "viridis") +
    tm_facets("var", free.scales = TRUE) +
    tm_layout(legend.outside = FALSE)
```

### Resumir dados de rasters para buffers

Muitas an√°lises requerem que fa√ßamos um resumo da composi√ß√£o da paisagem para buffers, sendo o buffer uma unidade de an√°lise espacial no entorno de um ponto de amostragem.

Aqui, usaremos os dados do [GlobCover v.2.3](http://due.esrin.esa.int/page_globcover.php) de 2009 [@arino2012] como raster de cobertura da terra. O arquivo √© grande (\~400 Mb) e pode demorar muito, dependendo da velocidade da sua internet.

```{r eval=FALSE}
## Aumentar o tempo de download
options(timeout = 1e5)

## Download dos dados do GlobCover
download.file(url = "http://due.esrin.esa.int/files/Globcover2009_V2.3_Global_.zip",
              destfile = here::here("dados", "raster", "Globcover2009_V2.3_Global.zip"), 
              mode = "wb", extra = "c")

## Unzip
unzip(zipfile = here::here("dados", "raster", "Globcover2009_V2.3_Global.zip"),
      exdir = here::here("dados", "raster"))
```

Depois de fazer o download, vamos importar e ajustar esse raster para o limite da Mata Atl√¢ntica (Figura \@ref(fig:fig-raster-globcover)).

```{r}
## Importar raster do GlobCover
geo_raster_globcover <- raster::raster(
    here::here("dados", "raster", "GLOBCOVER_L4_200901_200912_V2.3.tif"))

## Ajustar para o limite do bioma da Mata Atl√¢ntica
geo_raster_globcover_mata_atlantica <- geo_raster_globcover %>% 
    raster::crop(geo_vetor_mata_atlantica) %>% 
    raster::mask(geo_vetor_mata_atlantica)
geo_raster_globcover_mata_atlantica
```

Caso o download n√£o funcione ou haja problemas com a importa√ß√£o, disponibilizamos os dados tamb√©m no pacote `ecodados`.

```{r eval=FALSE}
## Importar os dados pelo pacote ecodados
ecodados::geo_raster_globcover_mata_atlantica
```

```{r fig-raster-globcover, fig.cap="Camada raster do GlobCover 2.3 para o Bioma da Mata Atl√¢ntica."}
# Plot
plot(geo_raster_globcover_mata_atlantica, col = viridis::viridis(n = 200))
```

Vamos agora transformar a tabela de locais em vetor, selecionar aleatoriamente 50 amostragens das comunidades de anf√≠bios e criar buffers de \~10 km.

```{r}
## Fixar a amostragem
set.seed(42)

## Pontos
geo_anfibios_especies_locais_vetor_mata_atlantica <- geo_anfibios_locais %>% 
    sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
    dplyr::filter(sf::st_intersects(x = ., y = geo_vetor_mata_atlantica, sparse = FALSE)) %>% 
    dplyr::slice_sample(n = 50)

## Buffers de ~1 km
geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km <-
    sf::st_buffer(geo_anfibios_especies_locais_vetor_mata_atlantica,
                  dist = 1000)
```

Podemos conferir no mapa da Figura \@ref(fig:fig-vetor-aa-ma-buffer).

```{r fig-vetor-aa-ma-buffer, fig.cap="Distribui√ß√£o de 50 localidades aleat√≥rios e buffers de ~1 km (fora de escala)."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_vetor_mata_atlantica) +
    tm_polygons() +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km) +
    tm_bubbles(size = .3, border.col = "red", alpha = 0) +
    tm_shape(geo_anfibios_especies_locais_vetor_mata_atlantica) +
    tm_dots(size = .01, col = "forestgreen")
```

Agora podemos utilizar a fun√ß√£o `raster::extract()` para fazer a contabiliza√ß√£o, j√° em porcentagem, de pixels de cada classe para cada buffer.

```{r}
## Estat√≠stica zonal 
geo_anfibios_locais_vetor_ma_buffer10km_ext <- raster::extract(
    x = geo_raster_globcover_mata_atlantica,
    y = geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km,
    df = TRUE, na.rm = TRUE) %>% 
    dplyr::rename(id = ID, classe = 2) %>% 
    tidyr::drop_na(classe) %>% 
    dplyr::mutate(classe = paste0("classe_", classe)) %>%
    dplyr::group_by(id, classe) %>% 
    dplyr::summarise(n = n()) %>% 
    tidyr::pivot_wider(id_cols = id, names_from = classe, values_from = n) %>% 
    dplyr::mutate(across(everything(), ~replace_na(.x, 0))) %>% 
    janitor::adorn_totals("col") %>% 
    janitor::adorn_percentages("row") %>% 
    janitor::adorn_pct_formatting(rounding = "half up", digits = 1)
head(geo_anfibios_locais_vetor_ma_buffer10km_ext)
```

Agora podemos combinar esses dados aos dados dos buffers.

```{r}
## Combina√ß√£o
geo_anfibios_locais_vetor_ma_buffer10km_ext_bind  <- dplyr::bind_cols(
    x = geo_anfibios_especies_locais_vetor_mata_atlantica_buffer10km,
    y = geo_anfibios_locais_vetor_ma_buffer10km_ext[, -1]) %>% 
    sf::st_drop_geometry()
geo_anfibios_locais_vetor_ma_buffer10km_ext_bind
```

### Predi√ß√µes espaciais de objetos raster

O pacote `raster` al√©m de permitir realizar a manipula√ß√£o e visualiza√ß√£o de dados raster no R, tamb√©m permite a extrapola√ß√£o do ajuste de an√°lises, como `LMs`, `GLMs`, `GAMs` dentre outras (Cap√≠tulos \@ref(cap7) e \@ref(cap8)). Aqui, faremos uma pequena demostra√ß√£o utilizando a fun√ß√£o `raster::predict()`, predizendo o resultado de dois ajustes de GLMs para a presen√ßa/aus√™ncia de uma esp√©cie de anuro e a extrapola√ß√£o do n√∫mero de esp√©cies de anf√≠bios para o Bioma da Mata Atl√¢ntica.

Para ajustar um GLM para dados de presen√ßa/aus√™ncia, podemos usar a tabela j√° criada anteriormente, com as esp√©cies e as coordenadas, e fazer uma jun√ß√£o com a √∫ltima tabela que criamos com os dados bioclim√°ticos.

```{r}
## Jun√ß√£o dos dados ambientais aos dados de esp√©cies
geo_anfibios_locais_especies_vetor_bioclim <- geo_anfibios_especies %>% 
    dplyr::left_join(., sf::st_drop_geometry(geo_anfibios_locais_vetor_bioclim), by = "id")
```

Agora, vamos selecionar ocorr√™ncias da esp√©cie *Haddadus binotatus*, atribuindo **1** quando ela ocorre e **0** quando ela n√£o ocorre. Essa esp√©cie √© relativamente comum na serrapilheira de fragmentos florestais da Mata Atl√¢ntica, e recebe esse nome em homenagem a um grande pesquisador de anf√≠bios da Mata Atl√¢ntica, o **Prof. C√©lio Fernando Baptista Haddad**.

```{r}
## Sele√ß√£o da esp√©cie Haddadus binotatus
geo_anfibios_locais_especies_vetor_bioclim_hb <- geo_anfibios_locais_especies_vetor_bioclim %>% 
    dplyr::mutate(pa = ifelse(valid_name == "Haddadus binotatus", 1, 0), .after = individuals) %>% 
    dplyr::distinct(id, .keep_all = TRUE)
```

Vamos utilizar apenas as vari√°veis n√£o correlacionadas para o √≠ndice de correla√ß√£o de Pearson para r \< 0,7 (Cap√≠tulo \@ref(cap7)).

```{r message=FALSE, warning=FALSE}
## Correla√ß√£o entre as vari√°veis
corr <- geo_anfibios_locais_especies_vetor_bioclim_hb %>% 
    dplyr::select(bio01:bio19) %>% 
    cor() %>% 
    caret::findCorrelation(.7, names = TRUE)

## Sele√ß√£o das vari√°veis n√£o correlacionadas
geo_anfibios_locais_especies_vetor_bioclim_hb_cor <- geo_anfibios_locais_especies_vetor_bioclim_hb %>% 
    dplyr::select(pa, bio01:bio19) %>% 
    dplyr::select(-c(corr))
```

Agora sim, podemos ajustar um modelo simples da presen√ßa e aus√™ncia dessa esp√©cie, utilizando as vari√°veis n√£o correlacionadas, atrav√©s de um GLM para a fam√≠lia binomial. Nosso intuito n√£o analisar se o modelo atende √† todos os pressupostos, e sim exemplificar a predi√ß√£o espacial, para esses detalhes, consulte o Cap√≠tulo \@ref(cap8).

```{r}
## Ajustar um modelo GLM binomial
modelo_pa <- glm(formula = pa ~ ., 
                 data = geo_anfibios_locais_especies_vetor_bioclim_hb_cor, 
                 family = binomial("logit"))
```

Antes de fazermos a predi√ß√£o da distribui√ß√£o potencial da esp√©cie √© fundamental que o objeto raster esteja ajustado para o limite da Mata Atl√¢ntica. Para isso vamos utilizar as fun√ß√µes `raster::crop()` e `raster::mask()` para fazer esse ajuste \@ref(fig:fig-raster-bio-ajuste)).

```{r}
## Ajuste da extens√£o e limite
geo_raster_bioclim_mata_atlantica <- geo_raster_bioclim %>% 
    raster::crop(geo_vetor_mata_atlantica) %>% 
    raster::mask(geo_vetor_mata_atlantica)
```

```{r fig-raster-bio-ajuste, fig.cap="Mapa de dois rasters (BIO01 e BIO12) ajustados ao limite da Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Mapa
tm_shape(geo_raster_bioclim_mata_atlantica[[c(1, 4)]]) +
    tm_raster(pal = "viridis", title = c("bio01", "bio12")) +
    tm_facets(free.scales.raster = TRUE)
```

Agora podemos fazer a predi√ß√£o desse modelo para todo o Bioma da Mata Atl√¢ntica. Essa fun√ß√£o vai utilizar os coeficientes do modelo ajustado para gerar um raster de predi√ß√£o para todos os pixels da Mata Atl√¢ntica. Vamos usar o argumento `type = "response"` para que os valores da predi√ß√£o sejam ajustados a 0 a 1.

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Para que a predi√ß√£o funcione, os nomes das camadas raster `geo_raster_bioclim_mata_atlantica` devem possuir o mesmo nome das colunas das vari√°veis preditoras ajustadas no modelo `modelo_pa`.
:::

```{r}
## Predi√ß√µes
modelo_pa_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica, 
    model = modelo_pa,
    type = "response")
modelo_pa_pred
```

Por fim, no √∫ltimo passo podemos tornar esse modelo bin√°rio, ou seja, apenas com valores 0 ou 1. Para isso vamos adotar arbitrariamente o valor de 0,01 como ponto de corte. A partir desse valor consideraremos o pixels acima como 1 e abaixo como 0.

```{r}
## Sele√ß√£o dos pixels de presen√ßa/aus√™ncia potencial
modelo_pa_pred_corte <- modelo_pa_pred >= .01
```

Por fim, vamos produzir dois mapas mostrando os valores das predi√ß√µes, o mapa bin√°rio e as ocorr√™ncias da esp√©cie \@ref(fig:fig-raster-pred-modelo-bin)).

```{r fig-raster-pred-modelo-bin, fig.cap="Mapa da predi√ß√£o cont√≠nua e bin√°ria do modelo ajustado para a presen√ßa/aus√™ncia da esp√©cie *Haddadus binotatus* na Mata Atl√¢ntica e suas ocorr√™ncias."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Combinar os dois raster
modelo_pa_pred <- raster::stack(modelo_pa_pred, modelo_pa_pred_corte)
names(modelo_pa_pred) <- c("Cont√≠nuo", "Bin√°rio")

## Mapas de predi√ß√£o cont√≠nua e bin√°ria
tm_shape(modelo_pa_pred) +
    tm_raster(pal = "viridis", title = c("Predi√ß√£o", "Predi√ß√£o"),
              style = "fisher") +
    tm_facets(free.scales.raster = TRUE)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essa an√°lise foi realizada com o intuito de exemplificar o funcionamento da fun√ß√£o `raster::predict()`, para mais detalhes, consultar livros espec√≠ficos da √°rea de Modelagem de Distribui√ß√£o de Esp√©cies ou Modelagem de Nicho Ecol√≥gico [@franklin_mapping_2009; @peterson_ecological_2011; @guisan_habitat_2017 e @fletcher2018].
:::

Em nossa segunda an√°lise, vamos predizer os dados de riqueza para todo o bioma da Mata Atl√¢ntica. Para isso, temos de retirar novamente as vari√°veis correlacionadas.

```{r}
## Correla√ß√£o
corr <- geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(bio01:bio19) %>% 
    cor() %>% 
    caret::findCorrelation(.7, names = TRUE)

## Sele√ß√£o das vari√°veis n√£o correlacionadas
geo_anfibios_locais_bioclim_cor <- geo_anfibios_locais_vetor_bioclim %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(species_number, bio01:bio19) %>% 
    dplyr::select(-c(corr))
```

Agora sim, podemos criar os GLMs com fam√≠lias de distribui√ß√£o apropriadas para dados de contagem como Poisson e Binomial Negativa. Nosso intuito n√£o analisar se o modelo atende √† todos os pressupostos, e sim exemplificar a predi√ß√£o espacial, para esses detalhes, consulte o Cap√≠tulo \@ref(cap8).

```{r}
## Modelo Poisson
modelo_riq_pois <- glm(
    formula = species_number ~ ., 
    data = geo_anfibios_locais_bioclim_cor, 
    family = poisson)

## Modelo Binomial Negativo
modelo_riq_nb <- MASS::glm.nb(
    formula = species_number ~ .,
    data = geo_anfibios_locais_bioclim_cor)
```

Com os modelos ajustados, podemos fazer as predi√ß√µes utilizando os objetos raster com as vari√°veis ambientais.

```{r}
## Predi√ß√£o do modelo Poisson
modelo_riq_pois_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica,
    model = modelo_riq_pois,
    type = "response")
modelo_riq_pois_pred

## Predi√ß√£o do modelo Binomial Negativo
modelo_riq_nb_pred <- raster::predict(
    object = geo_raster_bioclim_mata_atlantica,
    model = modelo_riq_nb,
    type = "response")
modelo_riq_nb_pred
```

Por fim, podemos compor os dois mapas de predi√ß√µes (Figura \@ref(fig:fig-raster-pred-modelo-riq)).

```{r fig-raster-pred-modelo-riq, fig.cap="Mapa da predi√ß√£o de riqueza utilizando o modelo Poisson e Binomial Negativa para a Mata Atl√¢ntica."}
## Mudar o modo de exibi√ß√£o do tmap
tmap::tmap_mode(mode = "plot")

## Combinar os dois raster
modelo_riq_pred <- raster::stack(modelo_riq_pois_pred, modelo_riq_nb_pred)
names(modelo_riq_pred) <- c("Poisson", "Binomial Negativa")

## Mapas da predi√ß√£o Poisson e Binomial Negativa
tm_shape(modelo_riq_pred) +
    tm_raster(pal = "viridis", title = c("N√∫mero de esp√©cies", "N√∫mero de esp√©cies"),
              style = "fisher") +
    tm_facets(free.scales.raster = TRUE)
```

::: {.alert .alert-info}
<strong> üìù Importante </strong>\
Essa an√°lise foi realizada com o intuito de exemplificar o funcionamento da fun√ß√£o `raster::predict()`, para mais detalhes, consultar livros espec√≠ficos da √°rea de Ecologia Espacial [@fletcher2018].
:::

## Para se aprofundar

### Livros

Listamos aqui as principais refer√™ncias sobre manipula√ß√£o, visualiza√ß√£o de dados geoespaciais e an√°lises geoespaciais no R. Recomendamos aos interessados os livros: i) Lovelace, Nowosad & Muenchow [-@lovelace2019] [Geocomputation with R](https://geocompr.robinlovelace.net/), ii) Mas et al. [-@mas2019] [An√°lise espacial com R](https://bit.ly/2KpSI7C), iii) Olaya [-@olaya2020] [Sistemas de Informaci√≥n Geogr√°fica](http://volaya.github.io/libro-sig/), iv) Moraga [-@moraga_geospatial_2019] [Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/), v) Brunsdon & Comber [-@brunsdon_introduction_2015] [An Introduction to Spatial Analysis and Mapping in R](https://bookdown.org/lexcomber/brunsdoncomber2e/), vi) Wegmann, Leutner & Dech [-@wegmann2016] Remote Sensing and GIS for Ecologists: Using Open Source Software, vii)  Wegmann, Schwalb-Willmann & Dech [-@wegmann2020] An Introduction to Spatial Data Analysis Remote Sensing and GIS with Open Source Software, viii) Fletcher & Fortin [-@fletcher2018] Spatial ecology and conservation modeling: Applications with R, ix) Lapaine, Miljenko, Usery, E. Lynn [-@lapaine2017] Choosing a Map Projection.

### Links

[Awesome Geospatial](https://github.com/sacridini/Awesome-Geospatial#r)

[Spatial Data Science](https://keen-swartz-3146c4.netlify.app/)

[Intro to GIS and Spatial Analysis](https://mgimond.github.io/Spatial/index.html)

[Introduction to Spatial Data Programming with R](https://geobgu.xyz/r/)

[R for Geographic Data Science](https://sdesabbata.github.io/r-for-geographic-data-science)

[Spatial Data Science with R](https://rspatial.org/#)

[Spatial Modelling for Data Scientists](https://gdsl-ul.github.io/san/)

[Predictive Soil Mapping with R](https://soilmapper.org/)

## Exerc√≠cios

**15.1**
Importe o limite dos estados brasileiros no formato `sf` com o nome `br`. Para isso, use a fun√ß√£o `ne_states` do pacote `rnaturalearth`. Crie um mapa simples cinza utilizando a fun√ß√£o `plot()`, selecionando a coluna  `geometry` com o operador `$` e com os argumentos `axes` e `graticule` verdadeiros.

**15.2**
Dados vetoriais podem ser criados com diversos erros de topologia, e.g., sobreposi√ß√£o de linhas ou pol√≠gonos ou buracos. Algumas fun√ß√µes exigem que os objetos vetoriais aos quais s√£o atribu√≠dos esses dados n√£o possuam esses wrros para que o algoritmo funcione. Para verificar se h√° erros, podemos usar a fun√ß√£o `st_is_valid()` do pacote `sf`. H√° diversas forma de corre√ß√µes desses erros, mas vamos usar uma corre√ß√£o simples do R, com a fun√ß√£o `st_make_valid()`. Vamos fazer essa corre√ß√£o para o `br` importado anteriormente e atribuindo ao objeto `br_valid`. Podemos conferir para saber se h√° erros e fazer um plot.

**15.3**
Crie um objeto RasterLayer vazio chamado `ra` com resolu√ß√£o de 5¬∫ (~600 km). Atribua um sistema de refer√™ncia de coordendas com o c√≥digo `4326`. Atribua valores aleat√≥rios de uma distribui√ß√£o normal e plote o mesmo.

**15.4**
Reprojete o limite dos estados brasileiros do exerc√≠cio anterior para o CRS SIRGAS 2000/Brazil Polyconic, utilizando o c√≥digo EPSG:5880 e chamando de `br_poly`. Fa√ßa um mapa simples como no exerc√≠cio 1. Atente para as curvaturas das linhas.

**15.5**
Utilizando a fun√ß√£o `st_centroid` do pacote `sf`, crie um vetor chamado  `br_valid_cen` que armazenar√° o centroide de cada estado brasileiro do objeto `br_valid` do exerc√≠cio 2 e plot o resultado.

**15.6**
Ajuste o limite e m√°scara do objeto raster criado no exerc√≠cio 3 para o  limite do Brasil, atribuindo ao objeto `ra_br`. Depois reprojete esse raster para a mesma proje√ß√£o utilizada no exerc√≠cio 4 com o nome `ra_br_poly` e plote o mapa resultante.

**15.7**
Extraia os valores de cada pixel do raster criado no exerc√≠cio 6 para os centroides dos estados do Brasil criado no exerc√≠cio 5, atribuindo √† coluna `val` do objeto espacial chamado `br_valid_poly_cent_ra`. 

**15.8**
Crie um mapa final usando os resultados dos exerc√≠cios 4, 5 e 6. Utilize o pacote `tmap` e inclua todos os principais elementos de um mapa.

[Solu√ß√µes dos exerc√≠cios](https://exercicios-livro-aer.netlify.app/cap.-15---dados-geoespaciais.html).
